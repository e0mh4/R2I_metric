{
    "funcCount": 93,
    "funcInfo": [
        {
            "funcStartAddr": "0x401775",
            "funcEndAddr": "0x40177a",
            "decompiledFuncCode": "\nvoid FUN_00401775(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401775"
        },
        {
            "funcStartAddr": "0x40177a",
            "funcEndAddr": "0x40177f",
            "decompiledFuncCode": "\nvoid FUN_0040177a(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040177a"
        },
        {
            "funcStartAddr": "0x40177f",
            "funcEndAddr": "0x401784",
            "decompiledFuncCode": "\nvoid FUN_0040177f(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040177f"
        },
        {
            "funcStartAddr": "0x401784",
            "funcEndAddr": "0x401789",
            "decompiledFuncCode": "\nvoid FUN_00401784(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401784"
        },
        {
            "funcStartAddr": "0x401790",
            "funcEndAddr": "0x401d91",
            "decompiledFuncCode": "\nundefined8 FUN_00401790(int param_1,undefined **param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  __mode_t __mask;\n  undefined8 uVar3;\n  void *__ptr;\n  long lVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  undefined **ppuVar8;\n  long extraout_RDX;\n  long lVar9;\n  ulong extraout_RDX_00;\n  uint uVar10;\n  undefined **ppuVar11;\n  char *pcVar12;\n  undefined *puVar13;\n  long lVar14;\n  uint unaff_R13D;\n  ulong local_50;\n  ulong local_48;\n  ulong local_40 [2];\n  \n  ppuVar11 = (undefined **)(long)param_1;\n  FUN_00402860(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\n                 \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\"\n                );\n  textdomain(\"coreutils\");\n  FUN_00406720(FUN_00402270);\n  lVar4 = 0;\nLAB_004017e1:\n  do {\n    lVar14 = lVar4;\n    ppuVar8 = &PTR_s_context_00407000;\n    iVar2 = FUN_00405e60(param_1,param_2,&DAT_00406822,&PTR_s_context_00407000,0);\n    if (iVar2 == -1) {\n      if (lVar14 == 0) {\n        unaff_R13D = 0x1b6;\n      }\n      else {\n        __ptr = (void *)FUN_00402310();\n        if (__ptr == (void *)0x0) goto LAB_00401bc9;\n        __mask = umask(0);\n        umask(__mask);\n        unaff_R13D = FUN_004026e0(0x1b6,0,__mask,__ptr,0);\n        free(__ptr);\n        if ((unaff_R13D & 0xfffffe00) != 0) goto LAB_00401ba7;\n      }\n      ppuVar8 = (undefined **)(long)DAT_0060a258._4_4_;\n      uVar5 = (ulong)(param_1 - DAT_0060a258._4_4_);\n      if (param_1 <= DAT_0060a258._4_4_) goto LAB_00401b03;\n      if ((DAT_0060a258._4_4_ + 1 < param_1) &&\n         (lVar4 = (long)DAT_0060a258._4_4_, *param_2[lVar4 + 1] == 'p')) {\n        if (uVar5 < 2) goto LAB_00401d7d;\n        if (uVar5 < 3) goto LAB_00401935;\n        puVar13 = param_2[lVar4 + 2];\n        goto LAB_00401b1c;\n      }\n      if (3 < uVar5) {\n        if (uVar5 < 5) goto LAB_00401932;\n        param_2 = (undefined **)FUN_00404480(param_2[(long)ppuVar8 + 4]);\n        pcVar12 = \"extra operand %s\";\n        goto LAB_00401ae1;\n      }\n      param_2 = (undefined **)FUN_00404480(param_2[(long)param_1 + -1]);\n      uVar3 = dcgettext(0,\"missing operand after %s\",5);\n      ppuVar8 = param_2;\n      error(0,0,uVar3);\n      ppuVar11 = (undefined **)(ulong)(uint)(param_1 - DAT_0060a258._4_4_);\n      if (param_1 - DAT_0060a258._4_4_ == 2) {\n        pcVar12 = \"Special files require major and minor device numbers.\";\n        goto LAB_00401b5b;\n      }\n      break;\n    }\n    if (iVar2 == -0x82) {\n      FUN_00401e80(0);\nLAB_00401ba7:\n      uVar3 = dcgettext(0,\"mode must specify only file permission bits\",5);\n      error(1,0,uVar3);\nLAB_00401bc9:\n      uVar3 = dcgettext(0,\"invalid mode\",5);\n      error(1,0,uVar3);\n      goto LAB_00401beb;\n    }\n    if (iVar2 < -0x81) {\n      if (iVar2 == -0x83) {\n        FUN_00404900(stdout,\"mknod\",\"GNU coreutils\",PTR_DAT_0060a1f0,\"David MacKenzie\",0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      break;\n    }\n    if (iVar2 == 0x5a) {\n      lVar4 = lVar14;\n      if (DAT_0060a440 != 0) {\n        uVar3 = dcgettext(0,\n                          \"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel\"\n                          ,5);\n        error(0,0,uVar3);\n      }\n      goto LAB_004017e1;\n    }\n    lVar4 = DAT_0060a440;\n  } while (iVar2 == 0x6d);\nLAB_00401af9:\n  do {\n    FUN_00401e80(1);\n    uVar5 = extraout_RDX_00;\nLAB_00401b03:\n    if (uVar5 < 2) {\nLAB_00401c30:\n      uVar3 = dcgettext(0,\"missing operand\",5);\n      error(0,0,uVar3);\n      goto LAB_00401af9;\n    }\n    if (uVar5 == 2) {\nLAB_00401932:\n      lVar4 = (long)(int)ppuVar8;\nLAB_00401935:\n      lVar9 = (lVar4 + 1) * 8;\n      cVar1 = *param_2[lVar4 + 1];\n      if (cVar1 == 'c') {\nLAB_004019af:\n        uVar10 = 0x2000;\n        do {\n          ppuVar11 = *(undefined ***)((long)param_2 + lVar9 + 8);\n          uVar3 = *(undefined8 *)((long)param_2 + lVar9 + 0x10);\n          iVar2 = FUN_00404cd0(ppuVar11,0,0,&local_50,0);\n          if ((iVar2 != 0) || (local_50 != (local_50 & 0xffffffff))) {\nLAB_00401cf0:\n            param_2 = (undefined **)FUN_00404480(ppuVar11);\n            uVar3 = dcgettext(0,\"invalid major device number %s\",5);\n            error(1,0,uVar3,param_2);\nLAB_00401d20:\n            uVar3 = dcgettext(0,\"invalid device %s %s\",5);\n            error(1,0,uVar3,ppuVar11);\n            goto LAB_00401d48;\n          }\n          iVar2 = FUN_00404cd0(uVar3,0,0,&local_48,0);\n          if ((iVar2 != 0) || (local_48 != (local_48 & 0xffffffff))) {\n            uVar3 = FUN_00404480(uVar3);\n            uVar7 = dcgettext(0,\"invalid minor device number %s\",5);\n            error(1,0,uVar7,uVar3);\n            goto LAB_00401cf0;\n          }\n          uVar5 = (local_50 & 0xfffff000) << 0x20 | (ulong)((uint)(local_50 << 8) & 0xfff00) |\n                  (local_48 & 0xffffff00) << 0xc | local_48 & 0xff;\n          if (uVar5 == 0xffffffffffffffff) goto LAB_00401d20;\n          local_40[0] = uVar5;\n          iVar2 = __xmknod(0,param_2[DAT_0060a258._4_4_],uVar10 | unaff_R13D,local_40);\n          if (iVar2 == 0) goto LAB_0040196b;\n          param_2 = (undefined **)FUN_00404300(0,3,param_2[DAT_0060a258._4_4_]);\n          piVar6 = __errno_location();\n          cVar1 = error(1,*piVar6,\"%s\",param_2);\n          lVar9 = extraout_RDX;\nLAB_00401ac1:\n          uVar10 = 0x6000;\n        } while (cVar1 == 'b');\nLAB_00401acf:\n        param_2 = (undefined **)FUN_00404480();\n        pcVar12 = \"invalid device type %s\";\n      }\n      else {\n        if (cVar1 < 'd') goto LAB_00401ac1;\n        if (cVar1 != 'p') {\n          if (cVar1 == 'u') goto LAB_004019af;\n          goto LAB_00401acf;\n        }\n        iVar2 = mkfifo(param_2[lVar4],unaff_R13D);\n        if (iVar2 == 0) {\nLAB_0040196b:\n          if ((lVar14 == 0) || (iVar2 = chmod(param_2[DAT_0060a258._4_4_],unaff_R13D), iVar2 == 0))\n          {\n            return 0;\n          }\nLAB_00401beb:\n          ppuVar11 = (undefined **)FUN_00404230(4,param_2[DAT_0060a258._4_4_]);\n          param_2 = (undefined **)dcgettext(0,\"cannot set permissions of %s\",5);\n          piVar6 = __errno_location();\n          ppuVar8 = ppuVar11;\n          error(1,*piVar6,param_2);\n          goto LAB_00401c30;\n        }\nLAB_00401d48:\n        param_2 = (undefined **)FUN_00404300(0,3,param_2[DAT_0060a258._4_4_]);\n        piVar6 = __errno_location();\n        error(1,*piVar6,\"%s\",param_2);\nLAB_00401d7d:\n        param_2 = (undefined **)FUN_00404480(param_2[(long)ppuVar11 + -1]);\n        pcVar12 = \"missing operand after %s\";\n      }\nLAB_00401ae1:\n      uVar3 = dcgettext(0,pcVar12,5);\n      ppuVar8 = param_2;\n      error(0,0,uVar3);\n    }\n    else {\n      puVar13 = param_2[(long)ppuVar8 + 2];\nLAB_00401b1c:\n      param_2 = (undefined **)FUN_00404480(puVar13);\n      uVar3 = dcgettext(0,\"extra operand %s\",5);\n      ppuVar8 = param_2;\n      error(0,0,uVar3);\n      uVar10 = (int)ppuVar11 - DAT_0060a258._4_4_;\n      ppuVar11 = (undefined **)(ulong)uVar10;\n      if (uVar10 == 4) {\n        pcVar12 = \"Fifos do not have major and minor device numbers.\";\nLAB_00401b5b:\n        ppuVar8 = (undefined **)dcgettext(0,pcVar12,5);\n        __fprintf_chk(stderr,1,\"%s\\n\");\n      }\n    }\n  } while( true );\n}\n\n",
            "funcName": "FUN_00401790"
        },
        {
            "funcStartAddr": "0x401da0",
            "funcEndAddr": "0x401dcb",
            "decompiledFuncCode": "\nvoid FUN_00401da0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00609ff0)\n            (FUN_00401790,unaff_retaddr,&stack0x00000008,FUN_004066b0,FUN_00406710,param_3,auStack_8\n            );\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "FUN_00401da0"
        },
        {
            "funcStartAddr": "0x401dcb",
            "funcEndAddr": "0x401dea",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00401dd8) */\n/* WARNING: Removing unreachable block (ram,0x00401de2) */\n\nvoid FUN_00401dcb(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_00401dcb"
        },
        {
            "funcStartAddr": "0x401dea",
            "funcEndAddr": "0x401e21",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00401e19) */\n\nvoid FUN_00401dea(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_00401dea"
        },
        {
            "funcStartAddr": "0x401e21",
            "funcEndAddr": "0x401e78",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00401e56) */\n\nvoid FUN_00401e21(void)\n\n{\n  if (DAT_0060a288 != '\\0') {\n    return;\n  }\n  FUN_00401dcb();\n  DAT_0060a288 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_00401e21"
        },
        {
            "funcStartAddr": "0x401e78",
            "funcEndAddr": "0x401e7d",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00401e19) */\n\nvoid thunk_FUN_00401dea(void)\n\n{\n  return;\n}\n\n",
            "funcName": "thunk_401e78"
        },
        {
            "funcStartAddr": "0x401e80",
            "funcEndAddr": "0x402245",
            "decompiledFuncCode": "\nvoid FUN_00401e80(int param_1)\n\n{\n  FILE *pFVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  byte **ppbVar6;\n  char *pcVar8;\n  long lVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  byte *local_88;\n  char *local_80;\n  byte *local_78 [5];\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char *local_38;\n  char *local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  byte **ppbVar7;\n  \n  uVar5 = DAT_0060a2a8;\n  bVar14 = 0;\n  if (param_1 != 0) {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar5);\n    goto LAB_00401ebf;\n  }\n  uVar3 = dcgettext(0,\"Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\\n\",5);\n  __printf_chk(1,uVar3,uVar5);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"Create the special file NAME of the given TYPE.\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -Z                   set the SELinux security context to default type\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n                         or SMACK security context to CTX\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nBoth MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\\nmust be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\\nit is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\\notherwise, as decimal.  TYPE may be:\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\n  b      create a block (buffered) special file\\n  c, u   create a character (unbuffered) special file\\n  p      create a FIFO\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  uVar5 = dcgettext(0,\n                    \"\\nNOTE: your shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                    ,5);\n  __printf_chk(1,uVar5,\"mknod\");\n  local_88 = &DAT_0040678a;\n  local_80 = \"test invocation\";\n  local_78[0] = (byte *)0x406804;\n  local_78[1] = (byte *)0x40679c;\n  local_78[2] = (byte *)0x4067b2;\n  local_78[3] = (byte *)0x4067bc;\n  local_78[4] = (byte *)0x4067cb;\n  local_50 = \"sha2 utilities\";\n  local_48 = \"sha384sum\";\n  local_40 = \"sha2 utilities\";\n  local_38 = \"sha512sum\";\n  local_30 = \"sha2 utilities\";\n  local_28 = 0;\n  local_20 = 0;\n  ppbVar6 = &local_88;\n  do {\n    ppbVar7 = ppbVar6;\n    ppbVar6 = ppbVar7 + 2;\n    pbVar11 = *ppbVar6;\n    bVar12 = false;\n    bVar13 = pbVar11 == (byte *)0x0;\n    if (bVar13) break;\n    lVar9 = 6;\n    pbVar10 = (byte *)\"mknod\";\n    do {\n      if (lVar9 == 0) break;\n      lVar9 = lVar9 + -1;\n      bVar12 = *pbVar10 < *pbVar11;\n      bVar13 = *pbVar10 == *pbVar11;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n      pbVar11 = pbVar11 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n  } while ((!bVar12 && !bVar13) != bVar12);\n  pcVar4 = (char *)ppbVar7[3];\n  if ((byte *)pcVar4 == (byte *)0x0) {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar2 = strncmp(pcVar4,\"en_\",3);\n      if (iVar2 != 0) {\n        pcVar4 = \"mknod\";\n        goto LAB_0040221b;\n      }\n    }\n    pcVar4 = \"mknod\";\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar8 = \" invocation\";\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"mknod\");\n  }\n  else {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar8 = setlocale(5,(char *)0x0);\n    if (pcVar8 != (char *)0x0) {\n      iVar2 = strncmp(pcVar8,\"en_\",3);\n      if (iVar2 != 0) {\nLAB_0040221b:\n        uVar5 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar5,\"mknod\");\n      }\n    }\n    pcVar8 = \" invocation\";\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"mknod\");\n    if (pcVar4 != \"mknod\") {\n      pcVar8 = \"\";\n    }\n  }\n  uVar5 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  __printf_chk(1,uVar5,pcVar4,pcVar8);\nLAB_00401ebf:\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
            "funcName": "FUN_00401e80"
        },
        {
            "funcStartAddr": "0x402250",
            "funcEndAddr": "0x402258",
            "decompiledFuncCode": "\nvoid FUN_00402250(undefined8 param_1)\n\n{\n  DAT_0060a2a0 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00402250"
        },
        {
            "funcStartAddr": "0x402260",
            "funcEndAddr": "0x402268",
            "decompiledFuncCode": "\nvoid FUN_00402260(undefined param_1)\n\n{\n  DAT_0060a298 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00402260"
        },
        {
            "funcStartAddr": "0x402270",
            "funcEndAddr": "0x40230e",
            "decompiledFuncCode": "\nvoid FUN_00402270(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = FUN_00405f60(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((DAT_0060a298 == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (DAT_0060a2a0 == 0) {\n        error(0,*piVar2,\"%s\",uVar3);\n      }\n      else {\n        uVar4 = FUN_004042d0();\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n      goto LAB_004022ee;\n    }\n  }\n  iVar1 = FUN_00405f60(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_004022ee:\n                    /* WARNING: Subroutine does not return */\n  _exit(DAT_0060a1f8);\n}\n\n",
            "funcName": "FUN_00402270"
        },
        {
            "funcStartAddr": "0x402310",
            "funcEndAddr": "0x40261d",
            "decompiledFuncCode": "\nundefined2 * FUN_00402310(byte *param_1)\n\n{\n  byte bVar1;\n  undefined2 *puVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  undefined uVar8;\n  byte bVar9;\n  ulong uVar10;\n  undefined uVar11;\n  undefined2 *puVar12;\n  long lVar13;\n  \n  bVar9 = *param_1;\n  uVar5 = (uint)(char)bVar9;\n  if ((byte)(bVar9 - 0x30) < 8) {\n    uVar7 = 0;\n    pbVar4 = param_1;\n    do {\n      uVar7 = (uVar5 - 0x30) + uVar7 * 8;\n      pbVar4 = pbVar4 + 1;\n      if (0xfff < uVar7) {\n        return (undefined2 *)0x0;\n      }\n      bVar9 = *pbVar4;\n      uVar5 = (uint)(char)bVar9;\n    } while ((byte)(bVar9 - 0x30) < 8);\n    if (bVar9 != 0) {\n      return (undefined2 *)0x0;\n    }\n    uVar5 = uVar7 & 0xc00 | 0x3ff;\n    if (4 < (long)pbVar4 - (long)param_1) {\n      uVar5 = 0xfff;\n    }\n    puVar2 = (undefined2 *)FUN_00404a40(0x20);\n    *puVar2 = 0x13d;\n    *(undefined4 *)(puVar2 + 2) = 0xfff;\n    *(uint *)(puVar2 + 4) = uVar7;\n    *(uint *)(puVar2 + 6) = uVar5;\n    *(undefined *)((long)puVar2 + 0x11) = 0;\n    return puVar2;\n  }\n  uVar10 = 1;\n  pbVar4 = param_1;\n  if (bVar9 != 0) {\n    do {\n      bVar1 = (byte)uVar5;\n      bVar9 = pbVar4[1];\n      uVar5 = (uint)bVar9;\n      uVar10 = uVar10 + ((bVar1 & 0xef) == 0x2d || bVar1 == 0x2b);\n      pbVar4 = pbVar4 + 1;\n    } while (bVar9 != 0);\n    if (((long)(uVar10 * 0x10) < 0) || (uVar10 >> 0x3c != 0)) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00404c90();\n    }\n  }\n  puVar2 = (undefined2 *)FUN_00404a40();\n  lVar13 = 0;\nLAB_0040238b:\n  uVar5 = 0;\n  do {\n    bVar9 = *param_1;\n    uVar7 = (uint)bVar9;\n    if (bVar9 == 0x61) {\n      uVar5 = 0xfff;\n    }\n    else {\n      if ((char)bVar9 < 'b') break;\n      if (bVar9 == 0x6f) {\n        uVar5 = uVar5 | 0x207;\n      }\n      else if (bVar9 == 0x75) {\n        uVar5 = uVar5 | 0x9c0;\n      }\n      else {\n        if (bVar9 != 0x67) goto LAB_004023bb;\n        uVar5 = uVar5 | 0x438;\n      }\n    }\n    param_1 = param_1 + 1;\n  } while( true );\n  if (((bVar9 != 0x2d) && (bVar9 != 0x3d)) && (bVar9 != 0x2b)) goto LAB_004023bb;\n  puVar12 = puVar2 + lVar13 * 8;\n  do {\n    lVar13 = lVar13 + 1;\n    bVar9 = param_1[1];\n    uVar6 = (uint)(char)bVar9;\n    uVar11 = (undefined)uVar7;\n    if (bVar9 == 0x67) {\n      uVar3 = 0x38;\nLAB_0040242e:\n      *(undefined *)((long)puVar12 + 1) = 3;\n      *(uint *)(puVar12 + 2) = uVar5;\n      *(uint *)(puVar12 + 4) = uVar3;\n      *(undefined *)puVar12 = uVar11;\n      param_1 = param_1 + 2;\n      uVar7 = (uint)*param_1;\nLAB_00402446:\n      if (uVar5 != 0) {\n        uVar3 = uVar3 & uVar5;\n      }\n    }\n    else {\n      uVar7 = uVar6;\n      if ('g' < (char)bVar9) {\n        if (bVar9 == 0x6f) {\n          uVar3 = 7;\n        }\n        else {\n          uVar3 = 0x1c0;\n          if (bVar9 != 0x75) goto LAB_00402510;\n        }\n        goto LAB_0040242e;\n      }\n      if (7 < (byte)(bVar9 - 0x30)) {\nLAB_00402510:\n        uVar6 = uVar6 - 0x58;\n        uVar8 = 1;\n        uVar3 = 0;\n        bVar9 = (byte)uVar6;\n        param_1 = param_1 + 1;\n        while (bVar9 < 0x21) {\n                    /* WARNING: Could not find normalized switch variable to match jumptable */\n          switch(uVar6 & 0xff) {\n          case 0:\n            uVar8 = 2;\n            break;\n          default:\n            goto switchD_00402524_caseD_1;\n          case 0x1a:\n            uVar3 = uVar3 | 0x124;\n            break;\n          case 0x1b:\n            uVar3 = uVar3 | 0xc00;\n            break;\n          case 0x1c:\n            uVar3 = uVar3 | 0x200;\n            break;\n          case 0x1f:\n            uVar3 = uVar3 | 0x92;\n            break;\n          case 0x20:\n            uVar3 = uVar3 | 0x49;\n          }\n          param_1 = param_1 + 1;\n          uVar7 = (uint)*param_1;\n          uVar6 = uVar7 - 0x58;\n          bVar9 = (byte)uVar6;\n        }\nswitchD_00402524_caseD_1:\n        *(undefined *)puVar12 = uVar11;\n        *(undefined *)((long)puVar12 + 1) = uVar8;\n        *(uint *)(puVar12 + 2) = uVar5;\n        *(uint *)(puVar12 + 4) = uVar3;\n        goto LAB_00402446;\n      }\n      uVar6 = 0;\n      param_1 = param_1 + 1;\n      do {\n        uVar6 = (uVar7 - 0x30) + uVar6 * 8;\n        param_1 = param_1 + 1;\n        if (0xfff < uVar6) goto LAB_004023bb;\n        bVar9 = *param_1;\n        uVar7 = (uint)(char)bVar9;\n      } while ((byte)(bVar9 - 0x30) < 8);\n      if ((uVar5 != 0) || ((bVar9 != 0 && (bVar9 != 0x2c)))) goto LAB_004023bb;\n      *(undefined *)puVar12 = uVar11;\n      uVar5 = 0xfff;\n      *(uint *)(puVar12 + 4) = uVar6;\n      uVar3 = 0xfff;\n      *(undefined *)((long)puVar12 + 1) = 1;\n      *(undefined4 *)(puVar12 + 2) = 0xfff;\n    }\n    *(uint *)(puVar12 + 6) = uVar3;\n    puVar12 = puVar12 + 8;\n    bVar9 = (byte)uVar7;\n  } while (((bVar9 & 0xef) == 0x2d) || (bVar9 == 0x2b));\n  if (bVar9 != 0x2c) {\n    if (bVar9 == 0) {\n      *(undefined *)((long)puVar2 + lVar13 * 0x10 + 1) = 0;\n      return puVar2;\n    }\nLAB_004023bb:\n    free(puVar2);\n    return (undefined2 *)0x0;\n  }\n  param_1 = param_1 + 1;\n  goto LAB_0040238b;\n}\n\n",
            "funcName": "FUN_00402310"
        },
        {
            "funcStartAddr": "0x402680",
            "funcEndAddr": "0x4026d4",
            "decompiledFuncCode": "\nundefined2 * FUN_00402680(char *param_1)\n\n{\n  int iVar1;\n  undefined2 *puVar2;\n  stat sStack_98;\n  \n  iVar1 = __xstat(1,param_1,&sStack_98);\n  puVar2 = (undefined2 *)0x0;\n  if (iVar1 == 0) {\n    puVar2 = (undefined2 *)FUN_00404a40(0x20);\n    *puVar2 = 0x13d;\n    *(undefined4 *)(puVar2 + 2) = 0xfff;\n    *(__mode_t *)(puVar2 + 4) = sStack_98.st_mode;\n    *(undefined4 *)(puVar2 + 6) = 0xfff;\n    *(undefined *)((long)puVar2 + 0x11) = 0;\n  }\n  return puVar2;\n}\n\n",
            "funcName": "FUN_00402680"
        },
        {
            "funcStartAddr": "0x4026e0",
            "funcEndAddr": "0x402846",
            "decompiledFuncCode": "\nvoid FUN_004026e0(uint param_1,char param_2,uint param_3,char *param_4,uint *param_5)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  cVar7 = param_4[1];\n  param_1 = param_1 & 0xfff;\n  uVar2 = 0;\n  if (cVar7 != '\\0') {\n    do {\n      while( true ) {\n        uVar1 = *(uint *)(param_4 + 4);\n        uVar4 = *(uint *)(param_4 + 8);\n        if (param_2 != '\\0') break;\n        uVar6 = 0xffffffff;\n        uVar5 = 0xffffffff;\n        uVar3 = 0;\n        uVar8 = 0;\n        if (cVar7 != '\\x02') goto LAB_0040271f;\n        if ((param_1 & 0x49) != 0) goto LAB_004027cc;\nLAB_00402764:\n        cVar7 = *param_4;\n        uVar4 = uVar4 & uVar6;\n        if (uVar1 != 0) goto LAB_004027e0;\nLAB_00402770:\n        uVar4 = uVar4 & ~param_3;\n        if (cVar7 != '-') {\n          if (cVar7 == '=') goto LAB_004027fb;\n          goto LAB_00402783;\n        }\nLAB_00402830:\n        uVar2 = uVar2 | uVar4;\n        param_1 = param_1 & ~uVar4;\nLAB_0040278d:\n        cVar7 = param_4[0x11];\n        param_4 = param_4 + 0x10;\n        if (cVar7 == '\\0') goto LAB_00402818;\n      }\n      uVar5 = *(uint *)(param_4 + 0xc) | 0xfffff3ff;\n      uVar3 = ~*(uint *)(param_4 + 0xc) & 0xc00;\n      uVar8 = uVar3;\n      if (cVar7 != '\\x02') {\nLAB_0040271f:\n        uVar3 = uVar8;\n        uVar6 = uVar5;\n        if (cVar7 == '\\x03') {\n          uVar4 = uVar4 & param_1;\n          uVar8 = ~-(uint)((uVar4 & 0x124) == 0) & 0x124;\n          if ((uVar4 & 0x92) != 0) {\n            uVar8 = uVar8 | 0x92;\n          }\n          if ((uVar4 & 0x49) != 0) {\n            uVar8 = uVar8 | 0x49;\n          }\n          uVar4 = uVar4 | uVar8;\n        }\n        goto LAB_00402764;\n      }\nLAB_004027cc:\n      cVar7 = *param_4;\n      uVar4 = (uVar4 | 0x49) & uVar5;\n      uVar6 = uVar5;\n      if (uVar1 == 0) goto LAB_00402770;\nLAB_004027e0:\n      uVar4 = uVar4 & uVar1;\n      if (cVar7 == '-') goto LAB_00402830;\n      if (cVar7 != '=') {\nLAB_00402783:\n        if (cVar7 == '+') {\n          uVar2 = uVar2 | uVar4;\n          param_1 = param_1 | uVar4;\n        }\n        goto LAB_0040278d;\n      }\n      uVar3 = uVar3 | ~uVar1;\n      uVar6 = ~uVar3;\nLAB_004027fb:\n      cVar7 = param_4[0x11];\n      uVar2 = uVar2 | uVar6 & 0xfff;\n      param_1 = param_1 & uVar3 | uVar4;\n      param_4 = param_4 + 0x10;\n    } while (cVar7 != '\\0');\n  }\nLAB_00402818:\n  if (param_5 != (uint *)0x0) {\n    *param_5 = uVar2;\n  }\n  return;\n}\n\n",
            "funcName": "FUN_004026e0"
        },
        {
            "funcStartAddr": "0x402860",
            "funcEndAddr": "0x4028f9",
            "decompiledFuncCode": "\nvoid FUN_00402860(byte *param_1)\n\n{\n  byte *pbVar1;\n  char *pcVar2;\n  long lVar3;\n  ulong uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  \n  bVar10 = 0;\n  if (param_1 == (byte *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr((char *)param_1,0x2f);\n  if (pcVar2 != (char *)0x0) {\n    pbVar1 = (byte *)(pcVar2 + 1);\n    uVar4 = (long)pbVar1 - (long)param_1;\n    bVar7 = uVar4 < 6;\n    bVar9 = uVar4 == 6;\n    if (6 < (long)uVar4) {\n      lVar3 = 7;\n      pbVar5 = (byte *)(pcVar2 + -6);\n      pbVar6 = (byte *)\"/.libs/\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar9 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      bVar8 = false;\n      bVar7 = (!bVar7 && !bVar9) == bVar7;\n      if (bVar7) {\n        lVar3 = 3;\n        pbVar5 = pbVar1;\n        pbVar6 = &DAT_00407200;\n        do {\n          if (lVar3 == 0) break;\n          lVar3 = lVar3 + -1;\n          bVar8 = *pbVar5 < *pbVar6;\n          bVar7 = *pbVar5 == *pbVar6;\n          pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n          pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        } while (bVar7);\n        param_1 = pbVar1;\n        if ((!bVar8 && !bVar7) == bVar8) {\n          param_1 = (byte *)(pcVar2 + 4);\n          program_invocation_short_name = param_1;\n        }\n      }\n    }\n  }\n  DAT_0060a2a8 = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00402860"
        },
        {
            "funcStartAddr": "0x402900",
            "funcEndAddr": "0x4029df",
            "decompiledFuncCode": "\nchar * FUN_00402900(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte *pbVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    pbVar3 = (byte *)FUN_00406020();\n    if ((*pbVar3 & 0xdf) == 0x55) {\n      if (((((pbVar3[1] & 0xdf) != 0x54) || ((pbVar3[2] & 0xdf) != 0x46)) || (pbVar3[3] != 0x2d)) ||\n         ((pbVar3[4] != 0x38 || (pbVar3[5] != 0)))) {\nLAB_004029d8:\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_00407211;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_00407206;\n      }\n    }\n    else {\n      if (((((*pbVar3 & 0xdf) != 0x47) || ((pbVar3[1] & 0xdf) != 0x42)) || (pbVar3[2] != 0x31)) ||\n         (((pbVar3[3] != 0x38 || (pbVar3[4] != 0x30)) ||\n          ((pbVar3[5] != 0x33 || ((pbVar3[6] != 0x30 || (pbVar3[7] != 0)))))))) goto LAB_004029d8;\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_0040720d;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_0040720a;\n      }\n    }\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_00402900"
        },
        {
            "funcStartAddr": "0x402a00",
            "funcEndAddr": "0x403b33",
            "decompiledFuncCode": "\nulong FUN_00402a00(undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                  uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  ulong uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ulong uVar9;\n  ushort **ppuVar10;\n  long lVar11;\n  char *pcVar12;\n  byte bVar13;\n  char cVar14;\n  ulong uVar15;\n  ulong uVar16;\n  byte bVar17;\n  uint uVar18;\n  ulong uVar19;\n  bool bVar20;\n  ulong uVar21;\n  ulong uVar22;\n  bool bVar23;\n  bool bVar24;\n  bool bVar25;\n  bool bVar26;\n  size_t local_a0;\n  char *local_78;\n  ulong local_70;\n  bool local_5c;\n  bool local_5b;\n  wint_t local_44;\n  mbstate_t local_40 [2];\n  \n  sVar8 = __ctype_get_mb_cur_max();\n  uVar18 = param_6 & 2;\n  local_5c = uVar18 != 0;\n  uVar9 = param_2;\n  switch(param_5) {\n  case 0:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = false;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar18 != 0) {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = false;\n      local_a0 = 1;\n      local_78 = \"\\'\";\n      break;\n    }\n    bVar6 = false;\nLAB_00403651:\n    if (param_2 != 0) {\n      bVar3 = false;\n      local_5b = false;\n      bVar2 = true;\n      local_70 = 0;\n      goto LAB_00403286;\n    }\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 1;\n    param_5 = 2;\n    local_70 = 0;\n    local_5b = false;\n    local_5c = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 3:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 4:\n    if (uVar18 == 0) {\n      bVar6 = true;\n      goto LAB_00403651;\n    }\n  case 1:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 5:\n    if (uVar18 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      local_5b = false;\n      local_70 = 0;\n      bVar2 = true;\n      bVar3 = false;\n      local_5c = false;\n      uVar15 = 1;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    else {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 5;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\\"\";\n    break;\n  case 7:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = true;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      param_8 = (char *)FUN_00402900(&DAT_00407215,param_5);\n      param_9 = (char *)FUN_00402900(&DAT_0040876f);\n    }\n    uVar15 = 0;\n    if (uVar18 == 0) {\n      cVar14 = *param_8;\n      while (cVar14 != '\\0') {\n        if (uVar15 < param_2) {\n          param_1[uVar15] = cVar14;\n        }\n        uVar15 = uVar15 + 1;\n        cVar14 = param_8[uVar15];\n      }\n    }\n    local_a0 = strlen(param_9);\n    bVar2 = true;\n    bVar3 = false;\n    local_78 = param_9;\n    local_5b = false;\n    local_70 = 0;\n    bVar6 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\nLAB_00402a98:\n  uVar22 = 0;\n  bVar5 = local_5b;\nLAB_00402aa8:\n  bVar23 = param_4 != uVar22;\n  if (param_4 == 0xffffffffffffffff) {\n    bVar23 = param_3[uVar22] != '\\0';\n  }\n  bVar26 = bVar6;\n  if (!bVar23) goto LAB_00403228;\n  bVar20 = (bool)(param_5 != 2 & bVar6);\n  __s1 = (byte *)(param_3 + uVar22);\n  uVar16 = uVar15;\n  bVar4 = bVar3;\n  if (bVar20) {\n    if (local_a0 == 0) {\nLAB_004031a0:\n      uVar19 = (ulong)*__s1;\n      switch(uVar19) {\n      case 0:\n        goto switchD_004031b2_caseD_0;\n      default:\n        bVar20 = false;\n        goto switchD_0040301e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_00402eb5;\n      case 8:\n        bVar17 = 0x62;\n        break;\n      case 9:\nswitchD_004031b2_caseD_9:\n        bVar17 = 0x74;\n        break;\n      case 10:\nswitchD_004031b2_caseD_a:\n        bVar17 = 0x6e;\n        break;\n      case 0xb:\nswitchD_004031b2_caseD_b:\n        bVar17 = 0x76;\n        goto LAB_00402eb5;\n      case 0xc:\nswitchD_004031b2_caseD_c:\n        bVar17 = 0x66;\nLAB_00402eb5:\n        if (local_5c) {\n          bVar25 = false;\n          goto LAB_00402e08;\n        }\nLAB_00402ec0:\n        bVar23 = false;\n        goto LAB_00402c7b;\n      case 0xd:\n        bVar20 = false;\nswitchD_00402b98_caseD_d:\n        bVar25 = param_5 == 2;\n        uVar19 = 0xd;\n        bVar13 = 0x72;\n        goto LAB_00402dd0;\n      case 0x20:\n        bVar25 = false;\nLAB_004031fa:\n        uVar19 = 0x20;\n        goto LAB_004031c2;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar20 = false;\nswitchD_00402b98_caseD_21:\n        bVar25 = false;\n        goto LAB_00402ddb;\n      case 0x23:\n      case 0x7e:\n        bVar26 = false;\nLAB_004031da:\n        if (uVar22 == 0) {\n          bVar25 = false;\n          bVar23 = bVar20;\n          bVar20 = bVar26;\n          goto LAB_00402be8;\n        }\n        bVar23 = false;\n        goto LAB_00402bff;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar25 = false;\nLAB_004031c2:\n        bVar24 = false;\n        bVar23 = bVar20;\n        bVar20 = bVar25;\n        goto LAB_00402c01;\n      case 0x27:\n        bVar20 = false;\n        goto switchD_0040301e_caseD_27;\n      case 0x3f:\n        bVar20 = false;\n        goto switchD_0040301e_caseD_3f;\n      case 0x5c:\n        bVar20 = false;\n        goto switchD_00402b98_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        bVar20 = false;\n        goto switchD_0040301e_caseD_7b;\n      }\n      bVar25 = false;\n      bVar23 = false;\n      goto joined_r0x00402df7;\n    }\n    if ((param_4 == 0xffffffffffffffff) && (1 < local_a0)) {\n      param_4 = strlen(param_3);\n    }\n    if ((param_4 < uVar22 + local_a0) || (iVar7 = memcmp(__s1,local_78,local_a0), iVar7 != 0))\n    goto LAB_004031a0;\n    if (!local_5c) {\n      uVar19 = (ulong)*__s1;\n      bVar25 = bVar20;\n      switch(uVar19) {\n      case 0:\n        goto switchD_00402b98_caseD_0;\n      default:\n        goto switchD_0040301e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_00402ec0;\n      case 8:\n        bVar25 = false;\n        bVar23 = false;\n        bVar17 = 0x62;\n        break;\n      case 9:\n        goto switchD_004031b2_caseD_9;\n      case 10:\n        goto switchD_004031b2_caseD_a;\n      case 0xb:\n        goto switchD_004031b2_caseD_b;\n      case 0xc:\n        goto switchD_004031b2_caseD_c;\n      case 0xd:\n        goto switchD_00402b98_caseD_d;\n      case 0x20:\n        goto LAB_004031fa;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        goto switchD_00402b98_caseD_21;\n      case 0x23:\n      case 0x7e:\n        bVar26 = bVar20;\n        goto LAB_004031da;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto LAB_004031c2;\n      case 0x27:\n        goto switchD_0040301e_caseD_27;\n      case 0x3f:\n        goto switchD_0040301e_caseD_3f;\n      case 0x5c:\n        goto switchD_00402b98_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        goto switchD_0040301e_caseD_7b;\n      }\n      goto LAB_00402c42;\n    }\n    goto LAB_00402e1a;\n  }\n  uVar19 = (ulong)*__s1;\n  switch(uVar19) {\n  case 0:\n    if (bVar6) {\nswitchD_004031b2_caseD_0:\n      if (!local_5c) {\n        bVar20 = false;\nswitchD_00402b98_caseD_0:\n        bVar26 = param_5 == 2;\n        bVar24 = (bool)((bVar3 ^ 1U) & bVar26);\n        if (bVar24) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar16 = uVar15 + 3;\n          bVar3 = bVar24;\n          if (uVar9 <= uVar15 + 3) {\n            uVar16 = uVar15 + 4;\n            bVar23 = false;\n            bVar17 = 0x30;\n            bVar4 = bVar24;\n            goto LAB_00402cf8;\n          }\nLAB_00402f3a:\n          param_1[uVar16] = 0x5c;\n          uVar15 = uVar16;\n        }\n        else if (uVar15 < uVar9) goto LAB_00402f3a;\n        uVar16 = uVar15 + 1;\n        bVar24 = bVar23;\n        if (param_5 == 2) {\n          bVar17 = 0x30;\n          bVar23 = false;\n          bVar4 = bVar3;\n          goto LAB_00402cf8;\n        }\n        uVar19 = 0x30;\n        if ((uVar22 + 1 < param_4) && ((byte)(param_3[uVar22 + 1] - 0x30U) < 10)) {\n          if (uVar16 < uVar9) {\n            param_1[uVar16] = 0x30;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x30;\n          }\n          uVar16 = uVar15 + 3;\n          uVar19 = 0x30;\n        }\nLAB_00402f79:\n        bVar17 = (byte)uVar19;\n        bVar23 = false;\n        uVar15 = uVar16;\n        bVar4 = bVar3;\n        if ((bool)(bVar6 ^ 1U | bVar26)) goto LAB_00402cf8;\n        goto LAB_00402c01;\n      }\n      bVar26 = param_5 == 2;\n      goto LAB_00402e0c;\n    }\n    if ((param_6 & 1) == 0) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0;\n      bVar23 = false;\n      bVar20 = false;\n      goto LAB_00402be8;\n    }\n    uVar22 = uVar22 + 1;\n    goto LAB_00402aa8;\n  default:\nswitchD_0040301e_caseD_1:\n    bVar25 = bVar6;\n    if (sVar8 != 1) {\n      local_40[0] = (mbstate_t)0x0;\n      if (param_4 == 0xffffffffffffffff) {\n        param_4 = strlen(param_3);\n      }\n      uVar21 = 0;\n      do {\n        uVar1 = uVar22 + uVar21;\n        lVar11 = FUN_00405ee0(&local_44,param_3 + uVar1,param_4 - uVar1,local_40);\n        if (lVar11 == 0) break;\n        if (lVar11 == -1) {\n          bVar23 = false;\n          goto LAB_0040392a;\n        }\n        if (lVar11 == -2) {\n          if ((param_4 <= uVar1) || (param_3[uVar1] == '\\0')) goto LAB_00403a67;\n          goto LAB_00403a57;\n        }\n        if (((param_5 == 2) && (local_5c)) && (lVar11 != 1)) {\n          pcVar12 = param_3 + uVar1 + 1;\n          do {\n            if (((byte)(*pcVar12 + 0xa5U) < 0x22) &&\n               ((1L << (*pcVar12 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n              param_5 = 2;\n              goto LAB_00402e0c;\n            }\n            pcVar12 = pcVar12 + 1;\n          } while (param_3 + uVar1 + lVar11 != pcVar12);\n        }\n        iVar7 = iswprint(local_44);\n        if (iVar7 == 0) {\n          bVar23 = false;\n        }\n        uVar21 = uVar21 + lVar11;\n        iVar7 = mbsinit(local_40);\n      } while (iVar7 == 0);\n      bVar25 = (bool)((bVar23 ^ 1U) & bVar6);\n      goto LAB_0040392a;\n    }\n    ppuVar10 = __ctype_b_loc();\n    uVar21 = 1;\n    bVar25 = ((*ppuVar10)[uVar19] & 0x4000) == 0;\n    bVar23 = !bVar25;\n    bVar25 = (bool)(bVar25 & bVar6);\n    goto LAB_00402ff4;\n  case 7:\n    bVar25 = param_5 == 2;\n    uVar19 = 7;\n    bVar13 = 0x61;\n    break;\n  case 8:\n    bVar25 = param_5 == 2;\n    uVar19 = 8;\n    bVar13 = 0x62;\n    break;\n  case 9:\n    uVar19 = 9;\n    bVar13 = 0x74;\n    goto LAB_00403032;\n  case 10:\n    uVar19 = 10;\n    bVar13 = 0x6e;\n    goto LAB_00403032;\n  case 0xb:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xb;\n    bVar13 = 0x76;\n    break;\n  case 0xc:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xc;\n    bVar13 = 0x66;\n    break;\n  case 0xd:\n    uVar19 = 0xd;\n    bVar13 = 0x72;\nLAB_00403032:\n    bVar25 = param_5 == 2;\n    bVar20 = (bool)(local_5c & bVar25);\n    if (bVar20) {\nLAB_0040304a:\n      param_5 = 2;\n      goto LAB_00402e0c;\n    }\n    break;\n  case 0x20:\n    uVar19 = 0x20;\n    goto LAB_00402bd6;\n  case 0x21:\n  case 0x22:\n  case 0x24:\n  case 0x26:\n  case 0x28:\n  case 0x29:\n  case 0x2a:\n  case 0x3b:\n  case 0x3c:\n  case 0x3d:\n  case 0x3e:\n  case 0x5b:\n  case 0x5e:\n  case 0x60:\n  case 0x7c:\n    bVar23 = false;\nLAB_00402bd6:\n    bVar25 = param_5 == 2;\n    if ((local_5c) && (bVar25)) goto LAB_0040304a;\n    goto LAB_00402be8;\n  case 0x23:\n  case 0x7e:\nLAB_00402bcd:\n    bVar25 = param_5 == 2;\n    if (uVar22 == 0) goto LAB_00402bd6;\n    goto LAB_00402ddb;\n  case 0x25:\n  case 0x2b:\n  case 0x2c:\n  case 0x2d:\n  case 0x2e:\n  case 0x2f:\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x3a:\n  case 0x41:\n  case 0x42:\n  case 0x43:\n  case 0x44:\n  case 0x45:\n  case 0x46:\n  case 0x47:\n  case 0x48:\n  case 0x49:\n  case 0x4a:\n  case 0x4b:\n  case 0x4c:\n  case 0x4d:\n  case 0x4e:\n  case 0x4f:\n  case 0x50:\n  case 0x51:\n  case 0x52:\n  case 0x53:\n  case 0x54:\n  case 0x55:\n  case 0x56:\n  case 0x57:\n  case 0x58:\n  case 0x59:\n  case 0x5a:\n  case 0x5d:\n  case 0x5f:\n  case 0x61:\n  case 0x62:\n  case 99:\n  case 100:\n  case 0x65:\n  case 0x66:\n  case 0x67:\n  case 0x68:\n  case 0x69:\n  case 0x6a:\n  case 0x6b:\n  case 0x6c:\n  case 0x6d:\n  case 0x6e:\n  case 0x6f:\n  case 0x70:\n  case 0x71:\n  case 0x72:\n  case 0x73:\n  case 0x74:\n  case 0x75:\n  case 0x76:\n  case 0x77:\n  case 0x78:\n  case 0x79:\n  case 0x7a:\n    goto switchD_0040301e_caseD_25;\n  case 0x27:\nswitchD_0040301e_caseD_27:\n    bVar5 = bVar23;\n    if (param_5 != 2) {\n      bVar25 = false;\n      uVar19 = 0x27;\n      goto LAB_00402be8;\n    }\n    if (!local_5c) {\n      if ((uVar9 == 0) || (uVar19 = 0, uVar21 = uVar9, local_70 != 0)) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x5c;\n        }\n        uVar19 = uVar9;\n        uVar21 = local_70;\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x27;\n        }\n      }\n      uVar16 = uVar15 + 3;\n      bVar17 = 0x27;\n      uVar9 = uVar19;\n      local_70 = uVar21;\n      bVar24 = false;\n      bVar4 = false;\n      goto LAB_00402cf8;\n    }\n    goto LAB_00402e0c;\n  case 0x3f:\nswitchD_0040301e_caseD_3f:\n    if (param_5 == 2) {\n      if (!local_5c) {\n        bVar17 = 0x3f;\n        bVar24 = false;\n        bVar23 = false;\n        goto LAB_00402cf8;\n      }\n      goto LAB_00402e0c;\n    }\n    if (param_5 != 5) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0x3f;\n      bVar23 = false;\n      goto LAB_00402be8;\n    }\n    if (((((param_6 & 4) != 0) && (uVar21 = uVar22 + 2, uVar21 < param_4)) &&\n        (param_3[uVar22 + 1] == '?')) &&\n       ((uVar19 = (ulong)(byte)param_3[uVar21], (byte)param_3[uVar21] < 0x3f &&\n        ((0x7000a38200000000U >> (uVar19 & 0x3f) & 1) != 0)))) {\n      if (!local_5c) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x3f;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x22;\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x22;\n        }\n        if (uVar15 + 3 < uVar9) {\n          param_1[uVar15 + 3] = 0x3f;\n        }\n        uVar16 = uVar15 + 4;\n        bVar26 = false;\n        uVar22 = uVar21;\n        bVar24 = false;\n        goto LAB_00402f79;\n      }\n      goto LAB_00402e1a;\n    }\n    bVar25 = false;\n    uVar19 = 0x3f;\n    bVar23 = false;\n    goto LAB_00402be8;\n  case 0x5c:\n    if (param_5 != 2) {\nswitchD_00402b98_caseD_5c:\n      uVar19 = 0x5c;\n      bVar17 = 0x5c;\n      bVar13 = 0x5c;\n      bVar25 = (bool)(bVar6 & local_5c & local_a0 != 0);\n      if (!bVar25) break;\n      uVar22 = uVar22 + 1;\n      bVar23 = false;\n      goto LAB_00402d14;\n    }\n    if (local_5c) goto LAB_00402e0c;\n    uVar22 = uVar22 + 1;\n    bVar23 = false;\n    bVar17 = 0x5c;\n    goto LAB_00402d14;\n  case 0x7b:\n  case 0x7d:\nswitchD_0040301e_caseD_7b:\n    bVar24 = param_4 != 1;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar24 = param_3[1] != '\\0';\n    }\n    bVar25 = param_5 == 2;\n    if (!bVar24) goto LAB_00402bcd;\n    goto LAB_00402ddb;\n  }\nLAB_00402dd0:\n  if (!bVar6) {\nLAB_00402ddb:\n    bVar23 = false;\n    goto LAB_00402be8;\n  }\n  bVar23 = false;\n  bVar17 = bVar13;\n  goto joined_r0x00402df7;\nLAB_00403228:\n  if ((uVar15 == 0) && ((bool)(local_5c & param_5 == 2))) {\n    param_5 = 2;\nLAB_00402e0c:\n    if (bVar26) {\n      param_5 = 4;\n    }\nLAB_00402e1a:\n    uVar9 = FUN_00402a00(param_1,uVar9,param_3,param_4,param_5,param_6 & 0xfffffffd,0,param_8,\n                         param_9);\n    return uVar9;\n  }\n  bVar26 = (bool)(param_5 == 2 & (local_5c ^ 1U));\n  bVar23 = (bool)(local_5c ^ 1U);\n  if ((!bVar26) || (bVar23 = bVar26, !bVar5)) {\nLAB_00403afd:\n    uVar22 = uVar15;\n    if (((local_78 != (char *)0x0) && (bVar23)) && (cVar14 = *local_78, cVar14 != '\\0')) {\n      do {\n        if (uVar22 < uVar9) {\n          param_1[uVar22] = cVar14;\n        }\n        uVar22 = uVar22 + 1;\n        cVar14 = local_78[uVar22 - uVar15];\n      } while (cVar14 != '\\0');\n    }\n    if (uVar22 < uVar9) {\n      param_1[uVar22] = 0;\n    }\n    return uVar22;\n  }\n  if (bVar2) {\n    uVar9 = FUN_00402a00(param_1,local_70,param_3,param_4,5,param_6,param_7,param_8,param_9);\n    return uVar9;\n  }\n  local_5b = uVar9 == 0 && local_70 != 0;\n  param_2 = local_70;\n  bVar23 = bVar5;\n  if (uVar9 != 0 || local_70 == 0) goto LAB_00403afd;\nLAB_00403286:\n  *param_1 = 0x27;\n  param_5 = 2;\n  uVar15 = 1;\n  local_78 = \"\\'\";\n  local_a0 = 1;\n  local_5c = false;\n  uVar9 = param_2;\n  goto LAB_00402a98;\n  while (__s1[uVar21] != 0) {\nLAB_00403a57:\n    uVar21 = uVar21 + 1;\n    if (param_4 <= uVar22 + uVar21) break;\n  }\nLAB_00403a67:\n  bVar23 = false;\nLAB_0040392a:\n  if (1 < uVar21) {\nLAB_004034ee:\n    bVar26 = false;\n    uVar21 = uVar21 + uVar22;\n    uVar16 = uVar22;\n    do {\n      bVar17 = (byte)uVar19;\n      if (bVar25) {\n        bVar26 = param_5 == 2;\n        if (local_5c) goto LAB_00402e0c;\n        bVar26 = (bool)(bVar26 & (bVar4 ^ 1U));\n        if (bVar26) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar15 = uVar15 + 3;\n          bVar4 = bVar26;\n        }\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x5c;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = (char)(uVar19 >> 6) + '0';\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = ((byte)(uVar19 >> 3) & 7) + 0x30;\n        }\n        uVar22 = uVar16 + 1;\n        uVar15 = uVar15 + 3;\n        bVar17 = (bVar17 & 7) + 0x30;\n        bVar26 = bVar25;\n        if (uVar21 <= uVar22) goto LAB_00402c8d;\n      }\n      else {\n        bVar3 = (bool)((bVar26 ^ 1U) & bVar4);\n        if (bVar20) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x5c;\n          }\n          uVar15 = uVar15 + 1;\n        }\n        uVar22 = uVar16 + 1;\n        if (uVar21 <= uVar22) goto LAB_00402d14;\n        if (bVar3) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x27;\n          }\n          uVar15 = uVar15 + 2;\n          bVar20 = false;\n          bVar4 = false;\n        }\n        else {\n          bVar20 = false;\n        }\n      }\n      uVar16 = uVar16 + 1;\n      if (uVar15 < uVar9) {\n        param_1[uVar15] = bVar17;\n      }\n      uVar19 = (ulong)(byte)param_3[uVar16];\n      uVar15 = uVar15 + 1;\n    } while( true );\n  }\nLAB_00402ff4:\n  if (bVar25) {\n    bVar23 = false;\n    bVar25 = bVar6;\n    goto LAB_004034ee;\n  }\nswitchD_0040301e_caseD_25:\n  bVar25 = param_5 == 2;\nLAB_00402be8:\n  bVar17 = (byte)uVar19;\n  bVar24 = (bool)((bVar6 ^ 1U | bVar25) ^ 1 | local_5c);\n  bVar26 = bVar20;\n  if (bVar24) {\nLAB_00402bff:\n    bVar24 = false;\n    bVar20 = bVar26;\nLAB_00402c01:\n    bVar17 = (byte)uVar19;\n    uVar16 = uVar15;\n    bVar4 = bVar3;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar19 >> 5) * 4) >> (bVar17 & 0x1f) & 1) == 0))\n    goto LAB_00402cf8;\n    bVar25 = param_5 == 2;\n  }\n  else {\nLAB_00402cf8:\n    bVar25 = param_5 == 2;\n    uVar15 = uVar16;\n    bVar3 = bVar4;\n    if (!bVar20) {\n      uVar22 = uVar22 + 1;\n      bVar3 = (bool)((bVar24 ^ 1U) & bVar4);\nLAB_00402d14:\n      if (bVar3) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x27;\n        }\n        uVar15 = uVar15 + 2;\n        bVar4 = false;\n      }\n      goto LAB_00402c8d;\n    }\n  }\njoined_r0x00402df7:\n  if (local_5c) {\nLAB_00402e08:\n    bVar26 = (bool)(bVar6 & bVar25);\n    goto LAB_00402e0c;\n  }\nLAB_00402c42:\n  bVar25 = (bool)((bVar3 ^ 1U) & bVar25);\n  if (bVar25) {\n    if (uVar15 < uVar9) {\n      param_1[uVar15] = 0x27;\n    }\n    if (uVar15 + 1 < uVar9) {\n      param_1[uVar15 + 1] = 0x24;\n    }\n    if (uVar15 + 2 < uVar9) {\n      param_1[uVar15 + 2] = 0x27;\n    }\n    uVar15 = uVar15 + 3;\n    bVar3 = bVar25;\n  }\nLAB_00402c7b:\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = 0x5c;\n  }\n  uVar15 = uVar15 + 1;\n  uVar22 = uVar22 + 1;\n  bVar4 = bVar3;\nLAB_00402c8d:\n  bVar3 = bVar4;\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = bVar17;\n  }\n  uVar15 = uVar15 + 1;\n  if (!bVar23) {\n    bVar2 = false;\n  }\n  goto LAB_00402aa8;\n}\n\n",
            "funcName": "FUN_00402a00"
        },
        {
            "funcStartAddr": "0x403c30",
            "funcEndAddr": "0x403dcb",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_00403c30(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  ulong uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  undefined4 *puVar8;\n  ulong uVar9;\n  undefined *__ptr;\n  ulong *puVar10;\n  \n  piVar7 = __errno_location();\n  iVar1 = *piVar7;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  puVar8 = (undefined4 *)PTR_DAT_0060a238;\n  if (DAT_0060a250 <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00404c90();\n    }\n    if (PTR_DAT_0060a238 == &DAT_0060a240) {\n      puVar8 = (undefined4 *)FUN_00404aa0(0);\n      uVar6 = PTR_DAT_0060a248._4_4_;\n      uVar5 = PTR_DAT_0060a248._0_4_;\n      uVar3 = _UNK_0060a244;\n      PTR_DAT_0060a238 = (undefined *)puVar8;\n      *puVar8 = _DAT_0060a240;\n      puVar8[1] = uVar3;\n      puVar8[2] = uVar5;\n      puVar8[3] = uVar6;\n    }\n    else {\n      puVar8 = (undefined4 *)FUN_00404aa0(PTR_DAT_0060a238);\n      PTR_DAT_0060a238 = (undefined *)puVar8;\n    }\n    memset(puVar8 + (long)DAT_0060a250 * 4,0,(long)((param_1 + 1) - DAT_0060a250) << 4);\n    DAT_0060a250 = param_1 + 1;\n  }\n  uVar2 = param_4[1];\n  puVar10 = (ulong *)(puVar8 + (long)param_1 * 4);\n  uVar4 = *puVar10;\n  __ptr = (undefined *)puVar10[1];\n  uVar9 = FUN_00402a00(__ptr,uVar4,param_2,param_3,*param_4,uVar2 | 1,param_4 + 2,\n                       *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar4 <= uVar9) {\n    uVar9 = uVar9 + 1;\n    *puVar10 = uVar9;\n    if (__ptr != &DAT_0060a2c0) {\n      free(__ptr);\n    }\n    __ptr = (undefined *)FUN_00404a40(uVar9);\n    uVar3 = *param_4;\n    puVar10[1] = (ulong)__ptr;\n    FUN_00402a00(__ptr,uVar9,param_2,param_3,uVar3,uVar2 | 1,param_4 + 2,\n                 *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar7 = iVar1;\n  return __ptr;\n}\n\n",
            "funcName": "FUN_00403c30"
        },
        {
            "funcStartAddr": "0x403dd0",
            "funcEndAddr": "0x403e04",
            "decompiledFuncCode": "\nvoid FUN_00403dd0(undefined *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060a3c0;\n  }\n  FUN_00404c40(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_00403dd0"
        },
        {
            "funcStartAddr": "0x403e10",
            "funcEndAddr": "0x403e1f",
            "decompiledFuncCode": "\nundefined4 FUN_00403e10(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060a3c0;\n  }\n  return *param_1;\n}\n\n",
            "funcName": "FUN_00403e10"
        },
        {
            "funcStartAddr": "0x403e20",
            "funcEndAddr": "0x403e2f",
            "decompiledFuncCode": "\nvoid FUN_00403e20(undefined4 *param_1,undefined4 param_2)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060a3c0;\n  }\n  *param_1 = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_00403e20"
        },
        {
            "funcStartAddr": "0x403e30",
            "funcEndAddr": "0x403e63",
            "decompiledFuncCode": "\nuint FUN_00403e30(undefined *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060a3c0;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n",
            "funcName": "FUN_00403e30"
        },
        {
            "funcStartAddr": "0x403e70",
            "funcEndAddr": "0x403e83",
            "decompiledFuncCode": "\nundefined4 FUN_00403e70(undefined *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060a3c0;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00403e70"
        },
        {
            "funcStartAddr": "0x403e90",
            "funcEndAddr": "0x403ebb",
            "decompiledFuncCode": "\nvoid FUN_00403e90(undefined4 *param_1,long param_2,long param_3)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060a3c0;\n  }\n  *param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)(param_1 + 10) = param_2;\n    *(long *)(param_1 + 0xc) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00403e90"
        },
        {
            "funcStartAddr": "0x403ec0",
            "funcEndAddr": "0x403f32",
            "decompiledFuncCode": "\nvoid FUN_00403ec0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined4 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (param_5 == (undefined4 *)0x0) {\n    param_5 = (undefined4 *)&DAT_0060a3c0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  FUN_00402a00(param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5 + 2,\n               *(undefined8 *)(param_5 + 10),*(undefined8 *)(param_5 + 0xc));\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_00403ec0"
        },
        {
            "funcStartAddr": "0x403f40",
            "funcEndAddr": "0x404021",
            "decompiledFuncCode": "\nundefined8 FUN_00403f40(undefined8 param_1,undefined8 param_2,long *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if (param_4 == (undefined4 *)0x0) {\n    param_4 = (undefined4 *)&DAT_0060a3c0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | param_4[1];\n  lVar3 = FUN_00402a00(0,0,param_1,param_2,*param_4,uVar5,param_4 + 2,*(undefined8 *)(param_4 + 10),\n                       *(undefined8 *)(param_4 + 0xc));\n  uVar4 = FUN_00404a40(lVar3 + 1);\n  FUN_00402a00(uVar4,lVar3 + 1,param_1,param_2,*param_4,uVar5,param_4 + 2,\n               *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n",
            "funcName": "FUN_00403f40"
        },
        {
            "funcStartAddr": "0x404030",
            "funcEndAddr": "0x40403a",
            "decompiledFuncCode": "\nvoid FUN_00404030(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00403f40(param_1,param_2,0,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00404030"
        },
        {
            "funcStartAddr": "0x404040",
            "funcEndAddr": "0x4040d5",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404040(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = PTR_DAT_0060a238;\n  if (1 < DAT_0060a250) {\n    ppvVar2 = (void **)(PTR_DAT_0060a238 + 0x18);\n    ppvVar1 = (void **)(PTR_DAT_0060a238 + (ulong)(DAT_0060a250 - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined **)(__ptr_00 + 8) != &DAT_0060a2c0) {\n    free(*(undefined **)(__ptr_00 + 8));\n    _DAT_0060a240 = 0x100;\n    PTR_DAT_0060a248 = &DAT_0060a2c0;\n  }\n  if (__ptr_00 != &DAT_0060a240) {\n    free(__ptr_00);\n    PTR_DAT_0060a238 = &DAT_0060a240;\n  }\n  DAT_0060a250 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_00404040"
        },
        {
            "funcStartAddr": "0x4040e0",
            "funcEndAddr": "0x4040f1",
            "decompiledFuncCode": "\nvoid FUN_004040e0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00403c30(param_1,param_2,0xffffffffffffffff,&DAT_0060a3c0);\n  return;\n}\n\n",
            "funcName": "FUN_004040e0"
        },
        {
            "funcStartAddr": "0x404100",
            "funcEndAddr": "0x40410a",
            "decompiledFuncCode": "\nvoid FUN_00404100(void)\n\n{\n  FUN_00403c30();\n  return;\n}\n\n",
            "funcName": "FUN_00404100"
        },
        {
            "funcStartAddr": "0x404110",
            "funcEndAddr": "0x404126",
            "decompiledFuncCode": "\nvoid FUN_00404110(undefined8 param_1)\n\n{\n  FUN_00403c30(0,param_1,0xffffffffffffffff,&DAT_0060a3c0);\n  return;\n}\n\n",
            "funcName": "FUN_00404110"
        },
        {
            "funcStartAddr": "0x404130",
            "funcEndAddr": "0x404142",
            "decompiledFuncCode": "\nvoid FUN_00404130(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00403c30(0,param_1,param_2,&DAT_0060a3c0);\n  return;\n}\n\n",
            "funcName": "FUN_00404130"
        },
        {
            "funcStartAddr": "0x404150",
            "funcEndAddr": "0x4041b8",
            "decompiledFuncCode": "\nvoid FUN_00404150(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00403c30(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404150"
        },
        {
            "funcStartAddr": "0x4041c0",
            "funcEndAddr": "0x404224",
            "decompiledFuncCode": "\nvoid FUN_004041c0(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00403c30(param_1,param_3,param_4,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_004041c0"
        },
        {
            "funcStartAddr": "0x404230",
            "funcEndAddr": "0x40423c",
            "decompiledFuncCode": "\nvoid FUN_00404230(undefined4 param_1,undefined8 param_2)\n\n{\n  FUN_00404150(0,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00404230"
        },
        {
            "funcStartAddr": "0x404240",
            "funcEndAddr": "0x40424f",
            "decompiledFuncCode": "\nvoid FUN_00404240(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_004041c0(0,param_1,param_2,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00404240"
        },
        {
            "funcStartAddr": "0x404250",
            "funcEndAddr": "0x4042c0",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404250(undefined8 param_1,undefined8 param_2,byte param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  \n  local_18 = DAT_0060a3f0;\n  local_48 = _DAT_0060a3c0;\n  uStack_40 = uRam000000000060a3c8;\n  local_38 = _DAT_0060a3d0;\n  uStack_30 = uRam000000000060a3d8;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_3 >> 5) * 4);\n  local_28 = _DAT_0060a3e0;\n  uStack_20 = uRam000000000060a3e8;\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_3 & 0x1f)) & 1) << (param_3 & 0x1f) ^ uVar2;\n  FUN_00403c30(0,param_1,param_2,&local_48);\n  return;\n}\n\n",
            "funcName": "FUN_00404250"
        },
        {
            "funcStartAddr": "0x4042c0",
            "funcEndAddr": "0x4042cd",
            "decompiledFuncCode": "\nvoid FUN_004042c0(undefined8 param_1,char param_2)\n\n{\n  FUN_00404250(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n",
            "funcName": "FUN_004042c0"
        },
        {
            "funcStartAddr": "0x4042d0",
            "funcEndAddr": "0x4042e1",
            "decompiledFuncCode": "\nvoid FUN_004042d0(undefined8 param_1)\n\n{\n  FUN_00404250(param_1,0xffffffffffffffff,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_004042d0"
        },
        {
            "funcStartAddr": "0x4042f0",
            "funcEndAddr": "0x4042fa",
            "decompiledFuncCode": "\nvoid FUN_004042f0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404250(param_1,param_2,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_004042f0"
        },
        {
            "funcStartAddr": "0x404300",
            "funcEndAddr": "0x40436e",
            "decompiledFuncCode": "\nvoid FUN_00404300(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_40 = 0x400000000000000;\n    local_44 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00403c30(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404300"
        },
        {
            "funcStartAddr": "0x404370",
            "funcEndAddr": "0x4043dc",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404370(undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5\n                 )\n\n{\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  \n  uStack_40 = uRam000000000060a3c8;\n  local_38 = _DAT_0060a3d0;\n  uStack_30 = uRam000000000060a3d8;\n  local_28 = _DAT_0060a3e0;\n  lStack_20 = uRam000000000060a3e8;\n  local_18 = DAT_0060a3f0;\n  local_48 = CONCAT44((int)((ulong)_DAT_0060a3c0 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_00403c30(param_1,param_4,param_5,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404370"
        },
        {
            "funcStartAddr": "0x4043e0",
            "funcEndAddr": "0x4043e9",
            "decompiledFuncCode": "\nvoid FUN_004043e0(void)\n\n{\n  FUN_00404370();\n  return;\n}\n\n",
            "funcName": "FUN_004043e0"
        },
        {
            "funcStartAddr": "0x4043f0",
            "funcEndAddr": "0x404407",
            "decompiledFuncCode": "\nvoid FUN_004043f0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00404370(0,param_1,param_2,param_3,0xffffffffffffffff);\n  return;\n}\n\n",
            "funcName": "FUN_004043f0"
        },
        {
            "funcStartAddr": "0x404410",
            "funcEndAddr": "0x404423",
            "decompiledFuncCode": "\nvoid FUN_00404410(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_00404370(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
            "funcName": "FUN_00404410"
        },
        {
            "funcStartAddr": "0x404430",
            "funcEndAddr": "0x40443a",
            "decompiledFuncCode": "\nvoid FUN_00404430(void)\n\n{\n  FUN_00403c30();\n  return;\n}\n\n",
            "funcName": "FUN_00404430"
        },
        {
            "funcStartAddr": "0x404440",
            "funcEndAddr": "0x404452",
            "decompiledFuncCode": "\nvoid FUN_00404440(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00403c30(0,param_1,param_2,&DAT_0060a200);\n  return;\n}\n\n",
            "funcName": "FUN_00404440"
        },
        {
            "funcStartAddr": "0x404460",
            "funcEndAddr": "0x404471",
            "decompiledFuncCode": "\nvoid FUN_00404460(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00403c30(param_1,param_2,0xffffffffffffffff,&DAT_0060a200);\n  return;\n}\n\n",
            "funcName": "FUN_00404460"
        },
        {
            "funcStartAddr": "0x404480",
            "funcEndAddr": "0x404496",
            "decompiledFuncCode": "\nvoid FUN_00404480(undefined8 param_1)\n\n{\n  FUN_00403c30(0,param_1,0xffffffffffffffff,&DAT_0060a200);\n  return;\n}\n\n",
            "funcName": "FUN_00404480"
        },
        {
            "funcStartAddr": "0x4044a0",
            "funcEndAddr": "0x404844",
            "decompiledFuncCode": "\nundefined8\nFUN_004044a0(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5,\n            undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_00407f6b,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e1);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0040471c;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_0040471c:\n    __fprintf_chk(param_1,1,uVar7,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[1];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar1 = param_5[2];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_004047b9;\n  case 7:\n    uVar1 = param_5[2];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    local_58 = param_5[1];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_004047b9:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_58,uVar1,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0040459a;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_0040459a:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_50,local_58,uVar6,uVar5,uVar4,uVar1,local_48);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_004044a0"
        },
        {
            "funcStartAddr": "0x404880",
            "funcEndAddr": "0x4048a0",
            "decompiledFuncCode": "\nvoid FUN_00404880(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  FUN_004044a0();\n  return;\n}\n\n",
            "funcName": "FUN_00404880"
        },
        {
            "funcStartAddr": "0x4048a0",
            "funcEndAddr": "0x4048f9",
            "decompiledFuncCode": "\nvoid FUN_004048a0(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long local_58 [11];\n  \n  lVar4 = 0;\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_58[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_58[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_004044a0();\n  return;\n}\n\n",
            "funcName": "FUN_004048a0"
        },
        {
            "funcStartAddr": "0x404900",
            "funcEndAddr": "0x4049b8",
            "decompiledFuncCode": "\nvoid FUN_00404900(void)\n\n{\n  long lVar1;\n  undefined8 in_R8;\n  ulong uVar2;\n  undefined8 in_R9;\n  long lVar3;\n  long *plVar4;\n  long local_88 [10];\n  long local_38 [4];\n  long local_18 [3];\n  \n  local_18[0] = in_R8;\n  plVar4 = (long *)&stack0x00000008;\n  uVar2 = 0x20;\n  local_18[1] = in_R9;\n  lVar3 = 0;\n  do {\n    if ((uint)uVar2 < 0x30) {\n      lVar1 = *(long *)((long)local_38 + uVar2);\n      local_88[lVar3] = lVar1;\n      uVar2 = (ulong)((uint)uVar2 + 8);\n    }\n    else {\n      lVar1 = *plVar4;\n      local_88[lVar3] = lVar1;\n      plVar4 = plVar4 + 1;\n    }\n  } while ((lVar1 != 0) && (lVar3 = lVar3 + 1, lVar3 != 10));\n  FUN_004044a0();\n  return;\n}\n\n",
            "funcName": "FUN_00404900"
        },
        {
            "funcStartAddr": "0x4049c0",
            "funcEndAddr": "0x404a34",
            "decompiledFuncCode": "\nvoid FUN_004049c0(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n",
            "funcName": "FUN_004049c0"
        },
        {
            "funcStartAddr": "0x404a40",
            "funcEndAddr": "0x404a5a",
            "decompiledFuncCode": "\nvoid FUN_00404a40(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00404c90();\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00404a40"
        },
        {
            "funcStartAddr": "0x404a60",
            "funcEndAddr": "0x404a81",
            "decompiledFuncCode": "\nvoid FUN_00404a60(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    FUN_00404a40();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00404c90();\n}\n\n",
            "funcName": "FUN_00404a60"
        },
        {
            "funcStartAddr": "0x404a90",
            "funcEndAddr": "0x404a92",
            "decompiledFuncCode": "\nvoid thunk_FUN_00404a40(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00404c90();\n  }\n  return;\n}\n\n",
            "funcName": "thunk_404a90"
        },
        {
            "funcStartAddr": "0x404aa0",
            "funcEndAddr": "0x404ad0",
            "decompiledFuncCode": "\nvoid * FUN_00404aa0(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00404c90();\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "FUN_00404aa0"
        },
        {
            "funcStartAddr": "0x404ae0",
            "funcEndAddr": "0x404b01",
            "decompiledFuncCode": "\nvoid FUN_00404ae0(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    FUN_00404aa0();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00404c90();\n}\n\n",
            "funcName": "FUN_00404ae0"
        },
        {
            "funcStartAddr": "0x404b10",
            "funcEndAddr": "0x404b88",
            "decompiledFuncCode": "\nvoid FUN_00404b10(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar2 = *param_2;\n  if (param_1 == 0) {\n    if (uVar2 == 0) {\n      uVar2 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar3 = (ulong)(SUB168(ZEXT816(uVar2) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar2) * ZEXT816(param_3),0) < 0) || (uVar3 != 0)) goto LAB_00404b6b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar3 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar2) {\nLAB_00404b6b:\n                    /* WARNING: Subroutine does not return */\n      FUN_00404c90(param_1,param_2,uVar3);\n    }\n    uVar2 = (uVar2 >> 1) + 1 + uVar2;\n  }\n  *param_2 = uVar2;\n  FUN_00404aa0(param_1,uVar2 * param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00404b10"
        },
        {
            "funcStartAddr": "0x404ba0",
            "funcEndAddr": "0x404bea",
            "decompiledFuncCode": "\nvoid FUN_00404ba0(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = *param_2;\n  if (param_1 == 0) {\n    if (uVar1 == 0) {\n      *param_2 = 0x80;\n      FUN_00404aa0(0,0x80);\n      return;\n    }\n    if ((long)uVar1 < 0) goto LAB_00404bea;\n  }\n  else {\n    if (0x5555555555555553 < uVar1) {\nLAB_00404bea:\n                    /* WARNING: Subroutine does not return */\n      FUN_00404c90();\n    }\n    uVar1 = (uVar1 >> 1) + 1 + uVar1;\n  }\n  *param_2 = uVar1;\n  FUN_00404aa0(param_1,uVar1);\n  return;\n}\n\n",
            "funcName": "FUN_00404ba0"
        },
        {
            "funcStartAddr": "0x404bf0",
            "funcEndAddr": "0x404c07",
            "decompiledFuncCode": "\nvoid FUN_00404bf0(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_00404a40();\n  memset(__s,0,param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00404bf0"
        },
        {
            "funcStartAddr": "0x404c10",
            "funcEndAddr": "0x404c3e",
            "decompiledFuncCode": "\nvoid FUN_00404c10(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00404c90();\n}\n\n",
            "funcName": "FUN_00404c10"
        },
        {
            "funcStartAddr": "0x404c40",
            "funcEndAddr": "0x404c68",
            "decompiledFuncCode": "\nvoid FUN_00404c40(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)FUN_00404a40(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00404c40"
        },
        {
            "funcStartAddr": "0x404c70",
            "funcEndAddr": "0x404c83",
            "decompiledFuncCode": "\nvoid FUN_00404c70(char *param_1)\n\n{\n  void *__dest;\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  __dest = (void *)FUN_00404a40(sVar1 + 1);\n  memcpy(__dest,param_1,sVar1 + 1);\n  return;\n}\n\n",
            "funcName": "FUN_00404c70"
        },
        {
            "funcStartAddr": "0x404c90",
            "funcEndAddr": "0x404cc1",
            "decompiledFuncCode": "\nvoid FUN_00404c90(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  error(DAT_0060a1f8,0,\"%s\",uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404c90"
        },
        {
            "funcStartAddr": "0x404cd0",
            "funcEndAddr": "0x40507e",
            "decompiledFuncCode": "\nulong FUN_00404cd0(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint uVar9;\n  int iVar10;\n  ulong uVar11;\n  byte bVar12;\n  uint uVar13;\n  ulong uVar14;\n  int iVar15;\n  int iVar16;\n  byte *local_40 [2];\n  \n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = local_40;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar12 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar12 * 2 + 1) & 0x20) != 0) {\n    pbVar5 = pbVar5 + 1;\n    bVar12 = *pbVar5;\n  }\n  if (bVar12 == 0x2d) {\n    return 4;\n  }\n  uVar6 = __strtoul_internal(param_1,param_2,param_3,0);\n  pbVar5 = *param_2;\n  if (pbVar5 == param_1) {\n    if ((param_5 == (char *)0x0) || (bVar12 = *param_1, bVar12 == 0)) {\n      return 4;\n    }\n    uVar14 = 0;\n    uVar6 = 1;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) {\n      return 4;\n    }\n  }\n  else {\n    if (*piVar3 == 0) {\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = 1;\n      if (*piVar3 != 0x22) {\n        return 4;\n      }\n    }\n    uVar13 = (uint)uVar14;\n    if ((param_5 == (char *)0x0) || (bVar12 = *pbVar5, bVar12 == 0)) goto LAB_00404d72;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) goto switchD_00404e5c_caseD_1;\n  }\n  uVar13 = (uint)uVar14;\n  uVar9 = bVar12 - 0x45;\n  bVar8 = (byte)uVar9;\n  if (((bVar8 < 0x30) && ((0x814400308945U >> ((ulong)uVar9 & 0x3f) & 1) != 0)) &&\n     (pcVar7 = strchr(param_5,0x30), pcVar7 != (char *)0x0)) {\n    bVar1 = pbVar5[1];\n    if (bVar1 != 0x44) {\n      if (bVar1 == 0x69) {\n        uVar11 = 0x400;\n        iVar15 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n        goto LAB_00404e4a;\n      }\n      if (bVar1 != 0x42) {\n                    /* WARNING: Could not recover jumptable at 0x00404e31. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar6 = (*(code *)(&PTR_LAB_00408338)[bVar8])();\n        return uVar6;\n      }\n    }\n    iVar15 = 2;\n    uVar11 = 1000;\n  }\n  else {\n    iVar15 = 1;\n    uVar11 = 0x400;\n  }\nLAB_00404e4a:\n  iVar10 = (int)uVar11;\n  switch(bVar12 - 0x42 & 0xff) {\n  case 0:\n    if (uVar6 >> 0x36 == 0) {\n      uVar6 = uVar6 << 10;\n      break;\n    }\n    goto LAB_00404eb7;\n  default:\nswitchD_00404e5c_caseD_1:\n    *param_4 = uVar6;\n    return (ulong)(uVar13 | 2);\n  case 3:\n    iVar16 = 6;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00404f44;\n  case 5:\n  case 0x25:\n    uVar11 = (ulong)iVar10;\n    if (((SUB168(ZEXT816(uVar6) * ZEXT816(uVar11) >> 0x40,0) != 0) ||\n        (auVar2 = (ZEXT816(uVar6) * ZEXT816(uVar11) & (undefined  [16])0xffffffffffffffff) *\n                  ZEXT816(uVar11), SUB168(auVar2 >> 0x40,0) != 0)) ||\n       (auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816(uVar11),\n       uVar6 = SUB168(auVar2,0), SUB168(auVar2 >> 0x40,0) != 0)) {\n      uVar6 = 0xffffffffffffffff;\n      uVar14 = 1;\n    }\n    break;\n  case 9:\n  case 0x29:\n    auVar2 = ZEXT816(uVar6) * ZEXT816(uVar11);\n    goto joined_r0x00404e7c;\n  case 0xb:\n  case 0x2b:\n    auVar2 = ZEXT816(uVar6) * ZEXT816((ulong)(long)iVar10);\n    if (SUB168(auVar2 >> 0x40,0) != 0) goto LAB_00404eb7;\n    auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816((ulong)(long)iVar10);\njoined_r0x00404e7c:\n    uVar6 = SUB168(auVar2,0);\n    if (SUB168(auVar2 >> 0x40,0) != 0) {\nLAB_00404eb7:\n      uVar14 = 1;\n      uVar6 = 0xffffffffffffffff;\n    }\n    break;\n  case 0xe:\n    iVar16 = 5;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00404f44;\n  case 0x12:\n  case 0x32:\n    iVar16 = 4;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00404f44;\n  case 0x17:\n    iVar16 = 8;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00404f44;\n  case 0x18:\n    iVar16 = 7;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\nLAB_00404f44:\n    uVar14 = (ulong)(uVar13 | uVar9);\n    break;\n  case 0x20:\n    if (uVar6 >> 0x37 != 0) goto LAB_00404eb7;\n    uVar6 = uVar6 << 9;\n    break;\n  case 0x21:\n    break;\n  case 0x35:\n    if ((long)uVar6 < 0) goto LAB_00404eb7;\n    uVar6 = uVar6 * 2;\n  }\n  *param_2 = pbVar5 + iVar15;\n  if (pbVar5[iVar15] != 0) {\n    uVar14 = (ulong)((uint)uVar14 | 2);\n  }\nLAB_00404d72:\n  *param_4 = uVar6;\n  return uVar14;\n}\n\n",
            "funcName": "FUN_00404cd0"
        },
        {
            "funcStartAddr": "0x405110",
            "funcEndAddr": "0x4051e5",
            "decompiledFuncCode": "\nvoid FUN_00405110(long param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  iVar1 = param_2[0xb];\n  iVar2 = *param_2;\n  iVar3 = param_2[0xc];\n  iVar8 = iVar1;\n  iVar9 = iVar2;\n  while (iVar3 < iVar9) {\n    while( true ) {\n      if (iVar3 <= iVar8) goto LAB_0040518c;\n      iVar10 = iVar9 - iVar3;\n      iVar7 = iVar3 - iVar8;\n      if (iVar10 <= iVar7) break;\n      lVar6 = (long)iVar8;\n      iVar9 = iVar9 - iVar7;\n      puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n      do {\n        uVar4 = *puVar5;\n        *puVar5 = puVar5[iVar9 - lVar6];\n        puVar5[iVar9 - lVar6] = uVar4;\n        puVar5 = puVar5 + 1;\n      } while ((undefined8 *)(param_1 + 8 + ((ulong)(iVar7 - 1) + lVar6) * 8) != puVar5);\n      if (iVar9 <= iVar3) goto LAB_0040518c;\n    }\n    lVar6 = (long)iVar8;\n    puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n    do {\n      uVar4 = *puVar5;\n      *puVar5 = puVar5[iVar3 - lVar6];\n      puVar5[iVar3 - lVar6] = uVar4;\n      puVar5 = puVar5 + 1;\n    } while (puVar5 != (undefined8 *)(param_1 + 8 + ((ulong)(iVar10 - 1) + lVar6) * 8));\n    iVar8 = iVar8 + iVar10;\n  }\nLAB_0040518c:\n  param_2[0xc] = iVar2;\n  param_2[0xb] = iVar1 + (iVar2 - iVar3);\n  return;\n}\n\n",
            "funcName": "FUN_00405110"
        },
        {
            "funcStartAddr": "0x4051f0",
            "funcEndAddr": "0x4057ee",
            "decompiledFuncCode": "\nint FUN_004051f0(int param_1,undefined8 *param_2,char *param_3,char **param_4,undefined4 *param_5,\n                int param_6,int *param_7,int param_8,undefined8 param_9)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  char **ppcVar12;\n  char *pcVar13;\n  char *__s1;\n  FILE *__stream;\n  ulong uVar14;\n  size_t sVar15;\n  char *__s1_00;\n  long lVar16;\n  char *local_70;\n  uint local_44;\n  \n  pcVar13 = *(char **)(param_7 + 8);\n  cVar1 = *pcVar13;\n  pcVar11 = pcVar13;\n  if ((cVar1 == '=') || (cVar1 == '\\0')) {\n    sVar15 = 0;\n  }\n  else {\n    do {\n      pcVar11 = pcVar11 + 1;\n      if (*pcVar11 == '\\0') break;\n    } while (*pcVar11 != '=');\n    sVar15 = (long)pcVar11 - (long)pcVar13;\n  }\n  uVar14 = 0;\n  __s1 = *param_4;\n  ppcVar10 = param_4;\n  __s1_00 = __s1;\n  if (__s1 != (char *)0x0) {\n    while( true ) {\n      iVar5 = strncmp(__s1_00,pcVar13,sVar15);\n      if ((iVar5 == 0) && (sVar7 = strlen(__s1_00), sVar7 == sVar15)) goto LAB_00405410;\n      ppcVar10 = ppcVar10 + 4;\n      __s1_00 = *ppcVar10;\n      iVar5 = (int)uVar14 + 1;\n      if (__s1_00 == (char *)0x0) break;\n      uVar14 = (ulong)iVar5;\n    }\n    lVar16 = 0;\n    ppcVar10 = (char **)0x0;\n    local_44 = 0xffffffff;\n    bVar3 = false;\n    bVar4 = false;\n    local_70 = (char *)0x0;\n    ppcVar12 = param_4;\n    do {\n      iVar6 = strncmp(__s1,pcVar13,sVar15);\n      if (iVar6 == 0) {\n        if (ppcVar10 == (char **)0x0) {\n          local_44 = (uint)lVar16;\n          ppcVar10 = ppcVar12;\n        }\n        else if (((((param_6 != 0) || (*(int *)(ppcVar10 + 1) != *(int *)(ppcVar12 + 1))) ||\n                  (ppcVar10[2] != ppcVar12[2])) ||\n                 (*(int *)(ppcVar10 + 3) != *(int *)(ppcVar12 + 3))) && (!bVar3)) {\n          if (param_8 == 0) {\n            bVar3 = true;\n            if (local_70 == (char *)0x0) goto LAB_00405350;\n          }\n          else if (local_70 == (char *)0x0) {\n            local_70 = (char *)calloc((long)iVar5,1);\n            if (local_70 == (char *)0x0) {\n              bVar3 = true;\n              goto LAB_00405350;\n            }\n            bVar4 = true;\n            local_70[(int)local_44] = '\\x01';\n          }\n          local_70[lVar16] = '\\x01';\n        }\n      }\nLAB_00405350:\n      ppcVar12 = ppcVar12 + 4;\n      __s1 = *ppcVar12;\n      lVar16 = lVar16 + 1;\n    } while (__s1 != (char *)0x0);\n    if ((local_70 != (char *)0x0) || (bVar3)) {\n      if (param_8 != 0) {\n        if (bVar3) {\n          uVar2 = *param_2;\n          uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous\\n\",5);\n          __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n        else {\n          flockfile(stderr);\n          uVar2 = *(undefined8 *)(param_7 + 8);\n          uVar8 = *param_2;\n          uVar9 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous; possibilities:\",5);\n          __fprintf_chk(stderr,1,uVar9,uVar8,param_9,uVar2);\n          pcVar13 = local_70;\n          __stream = stderr;\n          do {\n            if (*pcVar13 != '\\0') {\n              __fprintf_chk(__stream,1,&DAT_00408769,param_9,*param_4);\n              __stream = stderr;\n            }\n            pcVar13 = pcVar13 + 1;\n            param_4 = param_4 + 4;\n          } while (local_70 + uVar14 + 1 != pcVar13);\n          fputc(10,__stream);\n          funlockfile(stderr);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n      }\n      if (bVar4) {\n        free(local_70);\n      }\n      sVar15 = strlen(pcVar13);\n      *(char **)(param_7 + 8) = pcVar13 + sVar15;\n      *param_7 = *param_7 + 1;\n      param_7[2] = 0;\n      return 0x3f;\n    }\n    if (ppcVar10 != (char **)0x0) {\n      uVar14 = (ulong)local_44;\nLAB_00405410:\n      iVar6 = *param_7;\n      *(undefined8 *)(param_7 + 8) = 0;\n      iVar5 = iVar6 + 1;\n      *param_7 = iVar5;\n      if (*pcVar11 == '\\0') {\n        if (*(int *)(ppcVar10 + 1) == 1) {\n          if (param_1 <= iVar5) {\n            if (param_8 != 0) {\n              pcVar13 = *ppcVar10;\n              uVar2 = *param_2;\n              uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' requires an argument\\n\",5);\n              __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n            }\n            param_7[2] = *(int *)(ppcVar10 + 3);\n            return (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          *param_7 = iVar6 + 2;\n          *(undefined8 *)(param_7 + 4) = param_2[iVar5];\n        }\n      }\n      else {\n        if (*(int *)(ppcVar10 + 1) == 0) {\n          if (param_8 != 0) {\n            pcVar13 = *ppcVar10;\n            uVar2 = *param_2;\n            uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' doesn\\'t allow an argument\\n\",5);\n            __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          }\n          param_7[2] = *(int *)(ppcVar10 + 3);\n          return 0x3f;\n        }\n        *(char **)(param_7 + 4) = pcVar11 + 1;\n      }\n      if (param_5 != (undefined4 *)0x0) {\n        *param_5 = (int)uVar14;\n      }\n      if ((int *)ppcVar10[2] == (int *)0x0) {\n        return *(int *)(ppcVar10 + 3);\n      }\n      *(int *)ppcVar10[2] = *(int *)(ppcVar10 + 3);\n      return 0;\n    }\n  }\n  if (((param_6 != 0) && (*(char *)(param_2[*param_7] + 1) != '-')) &&\n     (pcVar11 = strchr(param_3,(int)cVar1), pcVar11 != (char *)0x0)) {\n    return -1;\n  }\n  if (param_8 != 0) {\n    uVar2 = *param_2;\n    uVar8 = dcgettext(0,\"%s: unrecognized option \\'%s%s\\'\\n\",5);\n    __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n  }\n  *(undefined8 *)(param_7 + 8) = 0;\n  *param_7 = *param_7 + 1;\n  param_7[2] = 0;\n  return 0x3f;\n}\n\n",
            "funcName": "FUN_004051f0"
        },
        {
            "funcStartAddr": "0x405810",
            "funcEndAddr": "0x405d77",
            "decompiledFuncCode": "\nuint FUN_00405810(uint param_1,undefined8 *param_2,char *param_3,long param_4,undefined8 param_5,\n                 ulong param_6,uint *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long lVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  uint uVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  undefined1 *puVar15;\n  \n  bVar14 = 0;\n  uVar3 = param_7[1];\n  if ((int)param_1 < 1) {\n    return 0xffffffff;\n  }\n  uVar11 = *param_7;\n  *(undefined8 *)(param_7 + 4) = 0;\n  if (uVar11 == 0) {\n    *param_7 = 1;\n    uVar11 = 1;\nLAB_0040585a:\n    param_7[0xc] = uVar11;\n    param_7[0xb] = uVar11;\n    *(undefined8 *)(param_7 + 8) = 0;\n    if (*param_3 == '-') {\n      param_7[10] = 2;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else if (*param_3 == '+') {\n      param_7[10] = 0;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else {\n      pbVar8 = (byte *)0x0;\n      if (param_8 == 0) {\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        param_6 = param_6 & 0xffffffff;\n        if (pcVar4 == (char *)0x0) {\n          param_7[10] = 1;\n          pbVar8 = *(byte **)(param_7 + 8);\n          goto LAB_0040595d;\n        }\n        pbVar8 = *(byte **)(param_7 + 8);\n      }\n      param_7[10] = 0;\n    }\nLAB_0040595d:\n    param_7[6] = 1;\n    cVar2 = *param_3;\nLAB_00405968:\n    if (cVar2 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 == (byte *)0x0) goto LAB_004058d8;\nLAB_0040597c:\n    if (*pbVar8 == 0) goto LAB_004058d8;\n  }\n  else {\n    if (param_7[6] == 0) goto LAB_0040585a;\n    cVar2 = *param_3;\n    pbVar8 = *(byte **)(param_7 + 8);\n    if ((cVar2 - 0x2bU & 0xfd) != 0) goto LAB_00405968;\n    pcVar4 = param_3 + 1;\n    param_3 = param_3 + 1;\n    if (*pcVar4 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 != (byte *)0x0) goto LAB_0040597c;\nLAB_004058d8:\n    uVar11 = *param_7;\n    if (param_7[0xc] != uVar11 && (int)uVar11 <= (int)param_7[0xc]) {\n      param_7[0xc] = uVar11;\n    }\n    if ((int)uVar11 < (int)param_7[0xb]) {\n      param_7[0xb] = uVar11;\n    }\n    if (param_7[10] == 1) {\n      uVar7 = param_7[0xc];\n      if (param_7[0xb] == uVar7) {\n        if (uVar11 != uVar7) {\n          param_7[0xb] = uVar11;\n          uVar7 = uVar11;\n        }\n      }\n      else if (uVar11 != uVar7) {\n        FUN_00405110(param_2,param_7);\n        param_6 = param_6 & 0xffffffff;\n        uVar7 = *param_7;\n      }\n      uVar11 = uVar7;\n      uVar7 = uVar11;\n      if ((int)uVar11 < (int)param_1) {\n        lVar6 = (long)(int)uVar11;\n        do {\n          if ((*(char *)param_2[lVar6] == '-') && (((char *)param_2[lVar6])[1] != '\\0')) {\n            uVar11 = *param_7;\n            uVar7 = (uint)lVar6;\n            break;\n          }\n          uVar11 = (uint)lVar6 + 1;\n          lVar6 = lVar6 + 1;\n          *param_7 = uVar11;\n          uVar7 = uVar11;\n        } while ((int)lVar6 < (int)param_1);\n      }\n      param_7[0xc] = uVar7;\n    }\n    bVar12 = param_1 < uVar11;\n    bVar13 = param_1 == uVar11;\n    if (bVar13) {\n      param_1 = param_7[0xc];\n      uVar11 = param_7[0xb];\nLAB_00405a46:\n      if (uVar11 != param_1) {\n        *param_7 = uVar11;\n      }\n      return 0xffffffff;\n    }\n    lVar6 = 3;\n    pbVar8 = (byte *)param_2[(int)uVar11];\n    pbVar9 = pbVar8;\n    pbVar10 = &DAT_00408781;\n    do {\n      if (lVar6 == 0) break;\n      lVar6 = lVar6 + -1;\n      bVar12 = *pbVar9 < *pbVar10;\n      bVar13 = *pbVar9 == *pbVar10;\n      pbVar9 = pbVar9 + (ulong)bVar14 * -2 + 1;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n    if ((!bVar12 && !bVar13) == bVar12) {\n      uVar11 = uVar11 + 1;\n      *param_7 = uVar11;\n      if (param_7[0xb] == param_7[0xc]) {\n        param_7[0xb] = uVar11;\n      }\n      else {\n        bVar12 = uVar11 != param_7[0xc];\n        uVar11 = param_7[0xb];\n        if (bVar12) {\n          FUN_00405110(param_2,param_7);\n          uVar11 = param_7[0xb];\n        }\n      }\n      param_7[0xc] = param_1;\n      *param_7 = param_1;\n      goto LAB_00405a46;\n    }\n    if ((*pbVar8 != 0x2d) || (bVar14 = pbVar8[1], bVar14 == 0)) {\n      if (param_7[10] == 0) {\n        return 0xffffffff;\n      }\n      *(byte **)(param_7 + 4) = pbVar8;\n      *param_7 = uVar11 + 1;\n      return 1;\n    }\n    if (param_4 != 0) {\n      if (bVar14 == 0x2d) {\n        *(byte **)(param_7 + 8) = pbVar8 + 2;\n        puVar15 = &DAT_00408781;\n        goto LAB_00405ba5;\n      }\n      if ((int)param_6 != 0) {\n        if (pbVar8[2] == 0) {\n          pcVar4 = strchr(param_3,(int)(char)bVar14);\n          param_6 = param_6 & 0xffffffff;\n          if (pcVar4 != (char *)0x0) goto LAB_00405b50;\n        }\n        *(byte **)(param_7 + 8) = pbVar8 + 1;\n        uVar11 = FUN_004051f0(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,\n                              &DAT_00408782);\n        if (uVar11 != 0xffffffff) {\n          return uVar11;\n        }\n        pbVar8 = (byte *)param_2[(int)*param_7];\n      }\n    }\nLAB_00405b50:\n    pbVar8 = pbVar8 + 1;\n  }\n  pbVar9 = pbVar8 + 1;\n  *(byte **)(param_7 + 8) = pbVar9;\n  bVar14 = *pbVar8;\n  uVar11 = (uint)(char)bVar14;\n  pcVar4 = strchr(param_3,uVar11);\n  if (pbVar8[1] == 0) {\n    *param_7 = *param_7 + 1;\n  }\n  if (((byte)(bVar14 - 0x3a) < 2) || (pcVar4 == (char *)0x0)) {\n    if (uVar3 != 0) {\n      uVar1 = *param_2;\n      uVar5 = dcgettext(0,\"%s: invalid option -- \\'%c\\'\\n\",5);\n      __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n    }\n    param_7[2] = uVar11;\n    return 0x3f;\n  }\n  if (((*pcVar4 != 'W') || (param_4 == 0)) || (pcVar4[1] != ';')) {\n    if (pcVar4[1] == ':') {\n      if (pcVar4[2] == ':') {\n        if (pbVar8[1] == 0) {\n          *(undefined8 *)(param_7 + 4) = 0;\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = *param_7 + 1;\n        }\n      }\n      else {\n        uVar7 = *param_7;\n        if (pbVar8[1] == 0) {\n          if (param_1 == uVar7) {\n            if (uVar3 != 0) {\n              uVar1 = *param_2;\n              uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n              __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n            }\n            param_7[2] = uVar11;\n            uVar11 = (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          else {\n            uVar1 = param_2[(int)uVar7];\n            *param_7 = uVar7 + 1;\n            *(undefined8 *)(param_7 + 4) = uVar1;\n          }\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = uVar7 + 1;\n        }\n      }\n      *(undefined8 *)(param_7 + 8) = 0;\n      return uVar11;\n    }\n    return uVar11;\n  }\n  if (pbVar8[1] == 0) {\n    if (*param_7 == param_1) {\n      if (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n        __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n      }\n      param_7[2] = uVar11;\n      return (uint)(*param_3 != ':') * 5 + 0x3a;\n    }\n    pbVar9 = (byte *)param_2[(int)*param_7];\n  }\n  *(byte **)(param_7 + 8) = pbVar9;\n  param_6 = 0;\n  *(undefined8 *)(param_7 + 4) = 0;\n  puVar15 = &DAT_004087a0;\nLAB_00405ba5:\n  uVar3 = FUN_004051f0(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,puVar15);\n  return uVar3;\n}\n\n",
            "funcName": "FUN_00405810"
        },
        {
            "funcStartAddr": "0x405de0",
            "funcEndAddr": "0x405e36",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00405de0(void)\n\n{\n  DAT_0060a400 = DAT_0060a258._4_4_;\n  _DAT_0060a404 = (undefined4)DAT_0060a258;\n  FUN_00405810();\n  DAT_0060a258._4_4_ = DAT_0060a400;\n  DAT_0060a440 = DAT_0060a410;\n  _DAT_0060a254 = DAT_0060a408;\n  return;\n}\n\n",
            "funcName": "FUN_00405de0"
        },
        {
            "funcStartAddr": "0x405e40",
            "funcEndAddr": "0x405e58",
            "decompiledFuncCode": "\nvoid FUN_00405e40(void)\n\n{\n  FUN_00405de0();\n  return;\n}\n\n",
            "funcName": "FUN_00405e40"
        },
        {
            "funcStartAddr": "0x405e60",
            "funcEndAddr": "0x405e73",
            "decompiledFuncCode": "\nvoid FUN_00405e60(void)\n\n{\n  FUN_00405de0();\n  return;\n}\n\n",
            "funcName": "FUN_00405e60"
        },
        {
            "funcStartAddr": "0x405e80",
            "funcEndAddr": "0x405e95",
            "decompiledFuncCode": "\nvoid FUN_00405e80(void)\n\n{\n  FUN_00405810();\n  return;\n}\n\n",
            "funcName": "FUN_00405e80"
        },
        {
            "funcStartAddr": "0x405ea0",
            "funcEndAddr": "0x405eb6",
            "decompiledFuncCode": "\nvoid FUN_00405ea0(void)\n\n{\n  FUN_00405de0();\n  return;\n}\n\n",
            "funcName": "FUN_00405ea0"
        },
        {
            "funcStartAddr": "0x405ec0",
            "funcEndAddr": "0x405ed8",
            "decompiledFuncCode": "\nvoid FUN_00405ec0(void)\n\n{\n  FUN_00405810();\n  return;\n}\n\n",
            "funcName": "FUN_00405ec0"
        },
        {
            "funcStartAddr": "0x405ee0",
            "funcEndAddr": "0x405f4f",
            "decompiledFuncCode": "\nsize_t FUN_00405ee0(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  wchar_t local_1c;\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = 1;\n    param_2 = (byte *)0x40879f;\n  }\n  else {\n    if (param_3 == 0) {\n      return 0xfffffffffffffffe;\n    }\n    if (param_1 != (wchar_t *)0x0) goto LAB_00405f04;\n  }\n  param_1 = &local_1c;\nLAB_00405f04:\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (cVar1 = FUN_00405fc0(0), cVar1 == '\\0')) {\n    sVar2 = 1;\n    *param_1 = (uint)*param_2;\n  }\n  return sVar2;\n}\n\n",
            "funcName": "FUN_00405ee0"
        },
        {
            "funcStartAddr": "0x405f60",
            "funcEndAddr": "0x405fbc",
            "decompiledFuncCode": "\nulong FUN_00405f60(uint *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  uVar1 = *param_1;\n  uVar3 = FUN_00406590(param_1);\n  if ((uVar1 & 0x20) == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_00405f60"
        },
        {
            "funcStartAddr": "0x405fc0",
            "funcEndAddr": "0x406016",
            "decompiledFuncCode": "\nbool FUN_00405fc0(int param_1)\n\n{\n  bool bVar1;\n  byte *pbVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  pbVar2 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar1 = true;\n  bVar6 = false;\n  bVar8 = pbVar2 == (byte *)0x0;\n  if (!bVar8) {\n    lVar3 = 2;\n    pbVar4 = pbVar2;\n    pbVar5 = &DAT_004087a4;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar8 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n    } while (bVar8);\n    bVar1 = false;\n    bVar7 = false;\n    bVar6 = (!bVar6 && !bVar8) == bVar6;\n    if (!bVar6) {\n      lVar3 = 6;\n      pbVar4 = (byte *)\"POSIX\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar2 < *pbVar4;\n        bVar6 = *pbVar2 == *pbVar4;\n        pbVar2 = pbVar2 + (ulong)bVar9 * -2 + 1;\n        pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      } while (bVar6);\n      return (!bVar7 && !bVar6) != bVar7;\n    }\n  }\n  return bVar1;\n}\n\n",
            "funcName": "FUN_00405fc0"
        },
        {
            "funcStartAddr": "0x406020",
            "funcEndAddr": "0x406574",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * FUN_00406020(void)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  char *__s1;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  size_t __n;\n  char *__file;\n  FILE *__stream;\n  byte *pbVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  ulong uVar12;\n  undefined8 *puVar13;\n  char *__ptr;\n  bool bVar14;\n  long local_d0;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined auStack_80 [8];\n  undefined8 local_78;\n  \n  __s1 = nl_langinfo(0xe);\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  if (DAT_0060a438 != (char *)0x0) goto LAB_0040605a;\n  pcVar7 = getenv(\"CHARSETALIASDIR\");\n  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\\0')) {\n    sVar6 = 0x73;\n    sVar5 = 0x65;\n    __n = 100;\n    pcVar7 = \n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\"\n    ;\nLAB_00406145:\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      __file[__n] = '/';\n      goto LAB_00406166;\n    }\n  }\n  else {\n    __n = strlen(pcVar7);\n    if (__n == 0) {\n      sVar6 = 0xe;\n    }\n    else {\n      if (pcVar7[__n - 1] != '/') {\n        sVar6 = __n + 0xf;\n        sVar5 = __n + 1;\n        goto LAB_00406145;\n      }\n      sVar6 = __n + 0xe;\n    }\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      sVar5 = __n;\nLAB_00406166:\n      puVar13 = (undefined8 *)(__file + sVar5);\n      *puVar13 = 0x2e74657372616863;\n      *(undefined2 *)((long)puVar13 + 0xc) = 0x73;\n      *(undefined4 *)(puVar13 + 1) = 0x61696c61;\n      iVar2 = open(__file,0);\n      if (-1 < iVar2) {\n        __stream = fdopen(iVar2,\"r\");\n        local_d0 = 0;\n        if (__stream != (FILE *)0x0) {\n          pcVar7 = (char *)0x0;\nLAB_00406200:\n          pbVar8 = (byte *)__stream->_IO_read_ptr;\n          if (__stream->_IO_read_end <= pbVar8) goto LAB_0040638c;\n          do {\n            __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n            uVar4 = (uint)*pbVar8;\n            __ptr = pcVar7;\n            while( true ) {\n              pcVar7 = __ptr;\n              if ((uVar4 - 9 < 2) || (uVar4 == 0x20)) goto LAB_00406200;\n              if (uVar4 == 0x23) goto LAB_004063f1;\n              ungetc(uVar4,__stream);\n              iVar2 = fscanf(__stream,\"%50s %50s\",&local_b8,&local_78);\n              puVar13 = &local_b8;\n              if (iVar2 < 2) goto LAB_0040639f;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              lVar11 = (long)puVar13 +\n                       ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_b8);\n              puVar13 = &local_78;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              local_c0 = (long)puVar13 +\n                         ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_78);\n              lVar9 = lVar11 + local_c0;\n              if (local_d0 == 0) {\n                pcVar7 = (char *)malloc(lVar9 + 3);\n              }\n              else {\n                lVar9 = lVar9 + local_d0;\n                pcVar7 = (char *)realloc(__ptr,lVar9 + 3);\n              }\n              local_d0 = lVar9 + 2;\n              if (pcVar7 == (char *)0x0) {\n                pcVar7 = \"\";\n                free(__ptr);\n                FUN_00406590(__stream);\n                goto LAB_004061a4;\n              }\n              uVar12 = lVar11 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (-2 - lVar11) + (local_d0 - local_c0));\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_b8;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 2));\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_b8;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 4));\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_b8._4_4_,(undefined4)local_b8);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 8));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_b8 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              uVar12 = local_c0 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (local_d0 - local_c0) + -1);\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_78;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 6);\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_78;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 4);\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_78._4_4_,(undefined4)local_78);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)auStack_80 + (uVar12 & 0xffffffff));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_78 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              pbVar8 = (byte *)__stream->_IO_read_ptr;\n              if (pbVar8 < __stream->_IO_read_end) break;\nLAB_0040638c:\n              uVar4 = __uflow(__stream);\n              __ptr = pcVar7;\n              if (uVar4 == 0xffffffff) goto LAB_0040639f;\n            }\n          } while( true );\n        }\n        close(iVar2);\n      }\n      goto LAB_0040619e;\n    }\n  }\n  DAT_0060a438 = \"\";\nLAB_0040605a:\n  cVar1 = *DAT_0060a438;\n  pcVar7 = DAT_0060a438;\n  do {\n    if (cVar1 == '\\0') {\nLAB_004060b4:\n      if (*__s1 == '\\0') {\n        __s1 = \"ASCII\";\n      }\n      return __s1;\n    }\n    iVar2 = strcmp(__s1,pcVar7);\n    if ((iVar2 == 0) || ((cVar1 == '*' && (pcVar7[1] == '\\0')))) {\n      sVar6 = strlen(pcVar7);\n      __s1 = pcVar7 + sVar6 + 1;\n      goto LAB_004060b4;\n    }\n    sVar6 = strlen(pcVar7);\n    sVar5 = strlen(pcVar7 + sVar6 + 1);\n    pcVar7 = pcVar7 + sVar6 + 1 + sVar5 + 1;\n    cVar1 = *pcVar7;\n  } while( true );\nLAB_004063f1:\n  do {\n    pbVar8 = (byte *)__stream->_IO_read_ptr;\n    if (pbVar8 < __stream->_IO_read_end) {\n      __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n      uVar4 = (uint)*pbVar8;\n      bVar14 = true;\n    }\n    else {\n      uVar4 = __uflow(__stream);\n      bVar14 = uVar4 != 0xffffffff;\n    }\n  } while ((uVar4 != 10) && (bVar14));\n  if (uVar4 == 0xffffffff) goto LAB_0040639f;\n  goto LAB_00406200;\nLAB_0040639f:\n  FUN_00406590(__stream);\n  if (local_d0 == 0) {\nLAB_0040619e:\n    pcVar7 = \"\";\n  }\n  else {\n    pcVar7[local_d0] = '\\0';\n  }\nLAB_004061a4:\n  free(__file);\n  DAT_0060a438 = pcVar7;\n  goto LAB_0040605a;\n}\n\n",
            "funcName": "FUN_00406020"
        },
        {
            "funcStartAddr": "0x406590",
            "funcEndAddr": "0x406608",
            "decompiledFuncCode": "\nint FUN_00406590(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_004065f7;\n    }\n    iVar1 = FUN_00406610(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_004065f7:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_00406590"
        },
        {
            "funcStartAddr": "0x406610",
            "funcEndAddr": "0x40664b",
            "decompiledFuncCode": "\nvoid FUN_00406610(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if ((iVar1 != 0) && ((param_1->_flags & 0x100U) != 0)) {\n      FUN_00406650(param_1,0,1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00406610"
        },
        {
            "funcStartAddr": "0x406650",
            "funcEndAddr": "0x4066a6",
            "decompiledFuncCode": "\nulong FUN_00406650(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  uint uVar1;\n  int __fd;\n  ulong uVar2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    __fd = fileno(param_1);\n    uVar2 = lseek(__fd,param_2,param_3);\n    if (uVar2 != 0xffffffffffffffff) {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = uVar2;\n      uVar2 = 0;\n    }\n    return uVar2;\n  }\n  uVar1 = fseeko(param_1,param_2,param_3);\n  return (ulong)uVar1;\n}\n\n",
            "funcName": "FUN_00406650"
        },
        {
            "funcStartAddr": "0x4066b0",
            "funcEndAddr": "0x40670d",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004066e3) */\n/* WARNING: Removing unreachable block (ram,0x004066e8) */\n\nvoid FUN_004066b0(void)\n\n{\n  __DT_INIT();\n  return;\n}\n\n",
            "funcName": "FUN_004066b0"
        },
        {
            "funcStartAddr": "0x406710",
            "funcEndAddr": "0x406711",
            "decompiledFuncCode": "\nvoid FUN_00406710(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_00406710"
        },
        {
            "funcStartAddr": "0x406720",
            "funcEndAddr": "0x406738",
            "decompiledFuncCode": "\nvoid FUN_00406720(undefined8 param_1)\n\n{\n  __cxa_atexit(param_1,0,DAT_0060a1e8);\n  return;\n}\n\n",
            "funcName": "FUN_00406720"
        },
        {
            "funcStartAddr": "0x406738",
            "funcEndAddr": "0x406758",
            "decompiledFuncCode": "\nundefined8 FUN_00406738(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  code **ppcVar1;\n  \n  for (ppcVar1 = (code **)&DAT_00609e30; *ppcVar1 != (code *)0xffffffffffffffff;\n      ppcVar1 = ppcVar1 + -1) {\n    (**ppcVar1)();\n  }\n  return param_3;\n}\n\n",
            "funcName": "FUN_00406738"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_mknod.elf",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}