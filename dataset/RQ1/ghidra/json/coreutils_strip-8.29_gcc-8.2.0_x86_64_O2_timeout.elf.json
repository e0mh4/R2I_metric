{
    "funcCount": 100,
    "funcInfo": [
        {
            "funcStartAddr": "0x401df5",
            "funcEndAddr": "0x401dfa",
            "decompiledFuncCode": "\nvoid FUN_00401df5(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401df5"
        },
        {
            "funcStartAddr": "0x401dfa",
            "funcEndAddr": "0x401dff",
            "decompiledFuncCode": "\nvoid FUN_00401dfa(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401dfa"
        },
        {
            "funcStartAddr": "0x401dff",
            "funcEndAddr": "0x401e04",
            "decompiledFuncCode": "\nvoid FUN_00401dff(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401dff"
        },
        {
            "funcStartAddr": "0x401e04",
            "funcEndAddr": "0x401e09",
            "decompiledFuncCode": "\nvoid FUN_00401e04(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00401e04"
        },
        {
            "funcStartAddr": "0x401e10",
            "funcEndAddr": "0x4023da",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_00401e10(uint param_1,undefined8 *param_2)\n\n{\n  char **__argv;\n  _union_1454 _Var1;\n  int iVar2;\n  __pid_t _Var3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  undefined local_158 [32];\n  sigset_t local_138;\n  sigaction local_b8;\n  \n  FUN_00403060(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\n                 \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\"\n                );\n  textdomain(\"coreutils\");\n  DAT_0060b2a0 = 0x7d;\n  FUN_00406db0(FUN_00402f00);\nLAB_00401e68:\n  do {\n    iVar2 = FUN_004062c0(param_1,param_2,\"+k:s:v\",&PTR_s_kill_after_00407820,0);\n    if (iVar2 == -1) {\n      if (1 < (int)(param_1 - DAT_0060b318._4_4_)) {\n        DAT_0060b318._4_4_ = DAT_0060b318._4_4_ + 1;\n        uVar5 = FUN_00402bf0();\n        __argv = (char **)(param_2 + DAT_0060b318._4_4_);\n        DAT_0060b518 = *__argv;\n        if (DAT_0060b522 == '\\0') {\n          setpgid(0,0);\n        }\n        iVar2 = DAT_0060b290;\n        sigemptyset(&local_b8.sa_mask);\n        local_b8.__sigaction_handler.sa_handler = FUN_00402680;\n        local_b8.sa_flags = 0x10000000;\n        sigaction(0xe,&local_b8,(sigaction *)0x0);\n        sigaction(2,&local_b8,(sigaction *)0x0);\n        sigaction(3,&local_b8,(sigaction *)0x0);\n        sigaction(1,&local_b8,(sigaction *)0x0);\n        sigaction(0xf,&local_b8,(sigaction *)0x0);\n        sigaction(iVar2,&local_b8,(sigaction *)0x0);\n        signal(0x15,(__sighandler_t)0x1);\n        signal(0x16,(__sighandler_t)0x1);\n        sigemptyset(&local_b8.sa_mask);\n        local_b8.__sigaction_handler.sa_handler = FUN_004024e0;\n        local_b8.sa_flags = 0x10000000;\n        sigaction(0x11,&local_b8,(sigaction *)0x0);\n        FUN_00402620(0x11);\n        DAT_0060b530 = fork();\n        if (DAT_0060b530 == -1) {\n          uVar5 = dcgettext(0,\"fork system call failed\",5);\n          piVar6 = __errno_location();\n          param_1 = 0x7d;\n          error(0,*piVar6,uVar5);\n        }\n        else if (DAT_0060b530 == 0) {\n          signal(0x15,(__sighandler_t)0x0);\n          signal(0x16,(__sighandler_t)0x0);\n          execvp(*__argv,__argv);\n          piVar6 = __errno_location();\n          iVar2 = *piVar6;\n          uVar5 = FUN_00404c80(DAT_0060b518);\n          param_1 = (iVar2 == 2) + 0x7e;\n          uVar4 = dcgettext(0,\"failed to run command %s\",5);\n          error(0,*piVar6,uVar4,uVar5);\n        }\n        else {\n          FUN_00402620(0xe);\n          FUN_004024f0(uVar5,1);\n          iVar2 = DAT_0060b290;\n          sigemptyset((sigset_t *)&local_b8);\n          sigaddset((sigset_t *)&local_b8,0xe);\n          sigaddset((sigset_t *)&local_b8,2);\n          sigaddset((sigset_t *)&local_b8,3);\n          sigaddset((sigset_t *)&local_b8,1);\n          sigaddset((sigset_t *)&local_b8,0xf);\n          sigaddset((sigset_t *)&local_b8,iVar2);\n          sigaddset((sigset_t *)&local_b8,0x11);\n          iVar2 = sigprocmask(0,(sigset_t *)&local_b8,&local_138);\n          if (iVar2 != 0) {\n            uVar5 = dcgettext(0,\"warning: sigprocmask\",5);\n            piVar6 = __errno_location();\n            error(0,*piVar6,uVar5);\n          }\n          while( true ) {\n            _Var3 = waitpid(DAT_0060b530,(int *)&local_b8,1);\n            _Var1 = local_b8.__sigaction_handler;\n            if (_Var3 != 0) break;\n            sigsuspend(&local_138);\n          }\n          if (_Var3 < 0) {\n            uVar5 = dcgettext(0,\"error waiting for command\",5);\n            piVar6 = __errno_location();\n            error(0,*piVar6,uVar5);\n            param_1 = 0x7d;\n          }\n          else {\n            param_1 = local_b8.__sigaction_handler._0_4_ & 0x7f;\n            if (((ulong)local_b8.__sigaction_handler.sa_handler & 0x7f) == 0) {\n              param_1 = local_b8.__sigaction_handler._0_4_ >> 8 & 0xff;\n            }\n            else if ((char)param_1 == '\\0' || (char)((char)param_1 + '\\x01') < '\\x01') {\n              uVar5 = dcgettext(0,\"unknown status from command (%d)\",5);\n              error(0,0,uVar5,(ulong)_Var1.sa_handler & 0xffffffff);\n              param_1 = 1;\n            }\n            else {\n              if (((ulong)local_b8.__sigaction_handler.sa_handler & 0x80) != 0) {\n                uVar5 = dcgettext(0,\"the monitored command dumped core\",5);\n                error(0,0,uVar5);\n              }\n              if (_DAT_0060b534 == 0) {\n                iVar2 = prctl(4);\n                if (iVar2 == 0) {\n                  signal(param_1,(__sighandler_t)0x0);\n                  FUN_00402620(param_1);\n                  raise(param_1);\n                }\n                else {\nLAB_004023c6:\n                  uVar5 = dcgettext(0,\"warning: disabling core dumps failed\",5);\n                  piVar6 = __errno_location();\n                  error(0,*piVar6,uVar5);\n                }\n              }\n              param_1 = param_1 + 0x80;\n            }\n          }\n          if ((_DAT_0060b534 != 0) && (DAT_0060b521 == '\\0')) {\n            param_1 = 0x7c;\n          }\n        }\n        return param_1;\n      }\n      goto LAB_00401ee9;\n    }\n    if (iVar2 != 0x73) {\n      if (iVar2 < 0x74) {\n        if (iVar2 == -0x82) {\n          FUN_00402850(0);\n          goto LAB_004023c6;\n        }\n        if (iVar2 != 0x6b) goto LAB_00401ef8;\n        DAT_0060b528 = FUN_00402bf0(DAT_0060b6e0);\n      }\n      else if (iVar2 == 0x80) {\n        DAT_0060b522 = '\\x01';\n      }\n      else if (iVar2 == 0x81) {\n        DAT_0060b521 = '\\x01';\n      }\n      else {\n        if (iVar2 != 0x76) goto LAB_00401ee9;\n        DAT_0060b520 = 1;\n      }\n      goto LAB_00401e68;\n    }\n    DAT_0060b290 = FUN_00402cc0(DAT_0060b6e0,local_158);\n    if (DAT_0060b290 == -1) {\nLAB_00401ee9:\n      do {\n        iVar2 = FUN_00402850(0x7d);\nLAB_00401ef8:\n      } while (iVar2 != -0x83);\n      FUN_00405100(stdout,\"timeout\",\"GNU coreutils\",PTR_DAT_0060b298,\"Padraig Brady\",0);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  } while( true );\n}\n\n",
            "funcName": "FUN_00401e10"
        },
        {
            "funcStartAddr": "0x402400",
            "funcEndAddr": "0x40242b",
            "decompiledFuncCode": "\nvoid FUN_00402400(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_0060aff0)\n            (FUN_00401e10,unaff_retaddr,&stack0x00000008,FUN_00406d40,FUN_00406da0,param_3,auStack_8\n            );\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "FUN_00402400"
        },
        {
            "funcStartAddr": "0x40242b",
            "funcEndAddr": "0x40244a",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402438) */\n/* WARNING: Removing unreachable block (ram,0x00402442) */\n\nvoid FUN_0040242b(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040242b"
        },
        {
            "funcStartAddr": "0x40244a",
            "funcEndAddr": "0x402481",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402479) */\n\nvoid FUN_0040244a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040244a"
        },
        {
            "funcStartAddr": "0x402481",
            "funcEndAddr": "0x4024d8",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004024b6) */\n\nvoid FUN_00402481(void)\n\n{\n  if (DAT_0060b508 != '\\0') {\n    return;\n  }\n  FUN_0040242b();\n  DAT_0060b508 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_00402481"
        },
        {
            "funcStartAddr": "0x4024d8",
            "funcEndAddr": "0x4024dd",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402479) */\n\nvoid thunk_FUN_0040244a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "thunk_4024d8"
        },
        {
            "funcStartAddr": "0x4024e0",
            "funcEndAddr": "0x4024e1",
            "decompiledFuncCode": "\nvoid FUN_004024e0(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_004024e0"
        },
        {
            "funcStartAddr": "0x4024f0",
            "funcEndAddr": "0x4025fa",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_004024f0(double param_1,char param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  uint __seconds;\n  timer_t local_30;\n  itimerspec local_28;\n  \n  local_28.it_value = (timespec)FUN_00402fa0();\n  local_28.it_interval.tv_sec = 0;\n  local_28.it_interval.tv_nsec = 0;\n  iVar1 = timer_create(0,(sigevent *)0x0,&local_30);\n  if (iVar1 == 0) {\n    iVar1 = timer_settime(local_30,0,&local_28,(itimerspec *)0x0);\n    if (iVar1 == 0) {\n      return;\n    }\n    if (param_2 != '\\0') {\n      uVar3 = dcgettext(0,\"warning: timer_settime\",5);\n      piVar2 = __errno_location();\n      error(0,*piVar2,uVar3);\n    }\n    timer_delete(local_30);\n  }\n  else if (param_2 != '\\0') {\n    piVar2 = __errno_location();\n    if (*piVar2 != 0x26) {\n      uVar3 = dcgettext(0,\"warning: timer_create\",5);\n      error(0,*piVar2,uVar3);\n    }\n  }\n  __seconds = 0xffffffff;\n  if (param_1 < _DAT_00407920) {\n    __seconds = (uint)((double)((long)param_1 & 0xffffffff) < param_1) + (int)(long)param_1;\n  }\n  alarm(__seconds);\n  return;\n}\n\n",
            "funcName": "FUN_004024f0"
        },
        {
            "funcStartAddr": "0x402620",
            "funcEndAddr": "0x40267b",
            "decompiledFuncCode": "\nvoid FUN_00402620(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  sigset_t sStack_88;\n  \n  sigemptyset(&sStack_88);\n  sigaddset(&sStack_88,param_1);\n  iVar1 = sigprocmask(1,&sStack_88,(sigset_t *)0x0);\n  if (iVar1 != 0) {\n    uVar2 = dcgettext(0,\"warning: sigprocmask\",5);\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar2);\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00402620"
        },
        {
            "funcStartAddr": "0x402680",
            "funcEndAddr": "0x402832",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00402680(int param_1)\n\n{\n  double dVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  bool bVar6;\n  undefined local_38 [32];\n  \n  dVar1 = DAT_0060b528;\n  if (param_1 == 0xe) {\n    _DAT_0060b534 = 1;\n    param_1 = DAT_0060b290;\n  }\n  if (DAT_0060b530 == 0) {\n                    /* WARNING: Subroutine does not return */\n    _exit(param_1 + 0x80);\n  }\n  if (DAT_0060b528 == _DAT_00407928) {\n    iVar2 = DAT_0060b530;\n    if (DAT_0060b520 == '\\0') goto LAB_004026ca;\nLAB_00402730:\n    iVar2 = FUN_00406520(param_1,local_38);\n    if (iVar2 != 0) {\n      __snprintf_chk(local_38,0x13,1,0x13,&DAT_00406e46,param_1);\n    }\n    uVar4 = FUN_00404c80(DAT_0060b518);\n    uVar5 = dcgettext(0,\"sending signal %s to command %s\",5);\n    error(0,0,uVar5,local_38,uVar4);\n  }\n  else {\n    piVar3 = __errno_location();\n    DAT_0060b290 = 9;\n    iVar2 = *piVar3;\n    FUN_004024f0(dVar1,0);\n    bVar6 = DAT_0060b520 != '\\0';\n    DAT_0060b528 = 0.0;\n    *piVar3 = iVar2;\n    if (bVar6) goto LAB_00402730;\n  }\n  iVar2 = DAT_0060b530;\n  if (DAT_0060b530 == 0) {\n    signal(param_1,(__sighandler_t)0x1);\n  }\nLAB_004026ca:\n  kill(iVar2,param_1);\n  if (DAT_0060b522 == '\\0') {\n    signal(param_1,(__sighandler_t)0x1);\n    kill(0,param_1);\n    if ((param_1 != 9) && (param_1 != 0x12)) {\n      if (iVar2 == 0) {\n        signal(0x12,(__sighandler_t)0x1);\n      }\n      kill(iVar2,0x12);\n      signal(0x12,(__sighandler_t)0x1);\n      kill(0,0x12);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00402680"
        },
        {
            "funcStartAddr": "0x402850",
            "funcEndAddr": "0x402bed",
            "decompiledFuncCode": "\nvoid FUN_00402850(int param_1)\n\n{\n  FILE *pFVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  byte **ppbVar5;\n  undefined8 uVar7;\n  char *pcVar8;\n  long lVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  byte *local_88;\n  char *local_80;\n  byte *local_78 [5];\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char *local_38;\n  char *local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  byte **ppbVar6;\n  \n  uVar7 = DAT_0060b550;\n  bVar14 = 0;\n  if (param_1 != 0) {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar7);\n    goto LAB_0040288f;\n  }\n  uVar3 = dcgettext(0,\"Usage: %s [OPTION] DURATION COMMAND [ARG]...\\n  or:  %s [OPTION]\\n\",5);\n  __printf_chk(1,uVar3,uVar7,uVar7);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"Start COMMAND, and kill it if still running after DURATION.\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"      --preserve-status\\n                 exit with the same status as COMMAND, even when the\\n                   command times out\\n      --foreground\\n                 when not running timeout directly from a shell prompt,\\n                   allow COMMAND to read from the TTY and get TTY signals;\\n                   in this mode, children of COMMAND will not be timed out\\n  -k, --kill-after=DURATION\\n                 also send a KILL signal if COMMAND is still running\\n                   this long after the initial signal was sent\\n  -s, --signal=SIGNAL\\n                 specify the signal to be sent on timeout;\\n                   SIGNAL may be a name like \\'HUP\\' or a number;\\n                   see \\'kill -l\\' for a list of signals\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"  -v, --verbose  diagnose to stderr any signal sent upon timeout\\n\",\n                             5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nDURATION is a floating point number with an optional suffix:\\n\\'s\\' for seconds (the default), \\'m\\' for minutes, \\'h\\' for hours or \\'d\\' for days.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nIf the command times out, and --preserve-status is not set, then exit with\\nstatus 124.  Otherwise, exit with the status of COMMAND.  If no signal\\nis specified, send the TERM signal upon timeout.  The TERM signal kills\\nany process that does not block or catch that signal.  It may be necessary\\nto use the KILL (9) signal, since this signal cannot be caught, in which\\ncase the exit status is 128+9 rather than 124.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  local_88 = &DAT_00406e51;\n  local_80 = \"test invocation\";\n  local_78[0] = (byte *)0x406ecb;\n  local_78[1] = (byte *)0x406e63;\n  local_78[2] = (byte *)0x406e79;\n  local_78[3] = (byte *)0x406e83;\n  local_78[4] = (byte *)0x406e92;\n  local_50 = \"sha2 utilities\";\n  local_48 = \"sha384sum\";\n  local_40 = \"sha2 utilities\";\n  local_38 = \"sha512sum\";\n  local_30 = \"sha2 utilities\";\n  local_28 = 0;\n  local_20 = 0;\n  ppbVar5 = &local_88;\n  do {\n    ppbVar6 = ppbVar5;\n    ppbVar5 = ppbVar6 + 2;\n    pbVar11 = *ppbVar5;\n    bVar12 = false;\n    bVar13 = pbVar11 == (byte *)0x0;\n    if (bVar13) break;\n    lVar9 = 8;\n    pbVar10 = (byte *)\"timeout\";\n    do {\n      if (lVar9 == 0) break;\n      lVar9 = lVar9 + -1;\n      bVar12 = *pbVar10 < *pbVar11;\n      bVar13 = *pbVar10 == *pbVar11;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n      pbVar11 = pbVar11 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n  } while ((!bVar12 && !bVar13) != bVar12);\n  pcVar4 = (char *)ppbVar6[3];\n  if ((byte *)pcVar4 == (byte *)0x0) {\n    uVar7 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar7,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar2 = strncmp(pcVar4,\"en_\",3);\n      if (iVar2 != 0) {\n        pcVar4 = \"timeout\";\n        goto LAB_00402bc3;\n      }\n    }\n    pcVar4 = \"timeout\";\n    uVar7 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar8 = \" invocation\";\n    __printf_chk(1,uVar7,\"https://www.gnu.org/software/coreutils/\",\"timeout\");\n  }\n  else {\n    uVar7 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar7,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar8 = setlocale(5,(char *)0x0);\n    if (pcVar8 != (char *)0x0) {\n      iVar2 = strncmp(pcVar8,\"en_\",3);\n      if (iVar2 != 0) {\nLAB_00402bc3:\n        uVar7 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar7,\"timeout\");\n      }\n    }\n    pcVar8 = \" invocation\";\n    uVar7 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    __printf_chk(1,uVar7,\"https://www.gnu.org/software/coreutils/\",\"timeout\");\n    if (pcVar4 != \"timeout\") {\n      pcVar8 = \"\";\n    }\n  }\n  uVar7 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  __printf_chk(1,uVar7,pcVar4,pcVar8);\nLAB_0040288f:\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
            "funcName": "FUN_00402850"
        },
        {
            "funcStartAddr": "0x402bf0",
            "funcEndAddr": "0x402cb1",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\ndouble FUN_00402bf0(undefined8 param_1)\n\n{\n  char cVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  double extraout_XMM0_Qa;\n  double local_18;\n  char *local_10;\n  \n  cVar1 = FUN_004054d0(param_1,&local_10,&local_18,FUN_00402e70);\n  if (((cVar1 != '\\0') || (piVar2 = __errno_location(), *piVar2 == 0x22)) &&\n     (_DAT_00407928 <= local_18)) {\n    cVar1 = *local_10;\n    if (cVar1 == '\\0') {\n      return local_18;\n    }\n    if (local_10[1] == '\\0') {\n      if (cVar1 == 'h') {\n        return local_18 * _DAT_00407938;\n      }\n      if ('h' < cVar1) goto LAB_00402c98;\n      if (cVar1 == 'd') {\n        return local_18 * _DAT_00407940;\n      }\n    }\n  }\n  while( true ) {\n    param_1 = FUN_00404c80(param_1);\n    uVar3 = dcgettext(0,\"invalid time interval %s\",5);\n    error(0,0,uVar3,param_1);\n    cVar1 = FUN_00402850(0x7d);\n    local_18 = extraout_XMM0_Qa;\nLAB_00402c98:\n    if (cVar1 == 'm') break;\n    if (cVar1 == 's') {\n      return local_18;\n    }\n  }\n  return local_18 * _DAT_00407930;\n}\n\n",
            "funcName": "FUN_00402bf0"
        },
        {
            "funcStartAddr": "0x402cc0",
            "funcEndAddr": "0x402e52",
            "decompiledFuncCode": "\nuint FUN_00402cc0(char *param_1,undefined8 param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  char *__ptr;\n  char *pcVar7;\n  uint uVar8;\n  char *pcVar9;\n  uint local_34;\n  char *local_30;\n  \n  if ((int)*param_1 - 0x30U < 10) {\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n    lVar4 = strtol(param_1,&local_30,10);\n    if (((local_30 == param_1) || (*local_30 != '\\0')) ||\n       ((*piVar3 != 0 || (local_34 = (uint)lVar4, (int)local_34 != lVar4)))) {\n      local_34 = 0xffffffff;\n      goto LAB_00402d30;\n    }\n    if (local_34 == 0xffffffff) goto LAB_00402d30;\n    uVar8 = 0x7f;\n    if (0xfe < (int)local_34) {\n      uVar8 = 0xff;\n    }\n    uVar8 = uVar8 & local_34;\n    local_34 = uVar8;\n  }\n  else {\n    __ptr = (char *)FUN_00405470();\n    cVar1 = *__ptr;\n    pcVar9 = __ptr;\n    while (cVar1 != '\\0') {\n      pcVar7 = strchr(\"abcdefghijklmnopqrstuvwxyz\",(int)cVar1);\n      if (pcVar7 != (char *)0x0) {\n        *pcVar9 = cVar1 + -0x20;\n      }\n      pcVar9 = pcVar9 + 1;\n      cVar1 = *pcVar9;\n    }\n    iVar2 = FUN_004063c0(__ptr,&local_34);\n    if ((iVar2 != 0) &&\n       ((((*__ptr != 'S' || (__ptr[1] != 'I')) || (__ptr[2] != 'G')) ||\n        (iVar2 = FUN_004063c0(__ptr + 3,&local_34), iVar2 != 0)))) {\n      local_34 = 0xffffffff;\n      free(__ptr);\n      goto LAB_00402d30;\n    }\n    uVar8 = local_34;\n    free(__ptr);\n    if ((int)uVar8 < 0) goto LAB_00402d30;\n  }\n  iVar2 = FUN_00406520(uVar8,param_2);\n  if (iVar2 == 0) {\n    return local_34;\n  }\nLAB_00402d30:\n  uVar5 = FUN_00404c80(param_1);\n  uVar6 = dcgettext(0,\"%s: invalid signal\",5);\n  error(0,0,uVar6,uVar5);\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_00402cc0"
        },
        {
            "funcStartAddr": "0x402e70",
            "funcEndAddr": "0x402ed2",
            "decompiledFuncCode": "\ndouble FUN_00402e70(char *param_1,char **param_2)\n\n{\n  double dVar1;\n  \n  if (DAT_0060b538 == (__locale_t)0x0) {\n    DAT_0060b538 = newlocale(0x1fbf,\"C\",(__locale_t)0x0);\n  }\n  if (DAT_0060b538 != (__locale_t)0x0) {\n    dVar1 = strtod_l(param_1,param_2,DAT_0060b538);\n    return dVar1;\n  }\n  if (param_2 != (char **)0x0) {\n    *param_2 = param_1;\n  }\n  return 0.0;\n}\n\n",
            "funcName": "FUN_00402e70"
        },
        {
            "funcStartAddr": "0x402ee0",
            "funcEndAddr": "0x402ee8",
            "decompiledFuncCode": "\nvoid FUN_00402ee0(undefined8 param_1)\n\n{\n  DAT_0060b548 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00402ee0"
        },
        {
            "funcStartAddr": "0x402ef0",
            "funcEndAddr": "0x402ef8",
            "decompiledFuncCode": "\nvoid FUN_00402ef0(undefined param_1)\n\n{\n  DAT_0060b540 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00402ef0"
        },
        {
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f9e",
            "decompiledFuncCode": "\nvoid FUN_00402f00(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = FUN_004065f0(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((DAT_0060b540 == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (DAT_0060b548 == 0) {\n        error(0,*piVar2,\"%s\",uVar3);\n      }\n      else {\n        uVar4 = FUN_00404ad0();\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n      goto LAB_00402f7e;\n    }\n  }\n  iVar1 = FUN_004065f0(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_00402f7e:\n                    /* WARNING: Subroutine does not return */\n  _exit(DAT_0060b2a0);\n}\n\n",
            "funcName": "FUN_00402f00"
        },
        {
            "funcStartAddr": "0x402fa0",
            "funcEndAddr": "0x40304b",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined  [16] FUN_00402fa0(double param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  double dVar3;\n  \n  if (param_1 <= _DAT_00407990) {\n    return ZEXT816(0x8000000000000000);\n  }\n  if (DAT_00407998 <= param_1) {\n    return CONCAT88(999999999,0x7fffffffffffffff);\n  }\n  dVar3 = (param_1 - (double)(long)param_1) * _DAT_004079a0;\n  lVar2 = (long)dVar3;\n  lVar2 = (ulong)((double)lVar2 < dVar3) + lVar2;\n  lVar1 = lVar2 / 1000000000 + (long)param_1;\n  lVar2 = lVar2 % 1000000000;\n  if (-1 < lVar2) {\n    return CONCAT88(lVar2,lVar1);\n  }\n  return CONCAT88(lVar2 + 1000000000,lVar1 + -1);\n}\n\n",
            "funcName": "FUN_00402fa0"
        },
        {
            "funcStartAddr": "0x403060",
            "funcEndAddr": "0x4030f9",
            "decompiledFuncCode": "\nvoid FUN_00403060(byte *param_1)\n\n{\n  byte *pbVar1;\n  char *pcVar2;\n  long lVar3;\n  ulong uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  \n  bVar10 = 0;\n  if (param_1 == (byte *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr((char *)param_1,0x2f);\n  if (pcVar2 != (char *)0x0) {\n    pbVar1 = (byte *)(pcVar2 + 1);\n    uVar4 = (long)pbVar1 - (long)param_1;\n    bVar7 = uVar4 < 6;\n    bVar9 = uVar4 == 6;\n    if (6 < (long)uVar4) {\n      lVar3 = 7;\n      pbVar5 = (byte *)(pcVar2 + -6);\n      pbVar6 = (byte *)\"/.libs/\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar9 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      bVar8 = false;\n      bVar7 = (!bVar7 && !bVar9) == bVar7;\n      if (bVar7) {\n        lVar3 = 3;\n        pbVar5 = pbVar1;\n        pbVar6 = &DAT_004079e8;\n        do {\n          if (lVar3 == 0) break;\n          lVar3 = lVar3 + -1;\n          bVar8 = *pbVar5 < *pbVar6;\n          bVar7 = *pbVar5 == *pbVar6;\n          pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n          pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        } while (bVar7);\n        param_1 = pbVar1;\n        if ((!bVar8 && !bVar7) == bVar8) {\n          param_1 = (byte *)(pcVar2 + 4);\n          program_invocation_short_name = param_1;\n        }\n      }\n    }\n  }\n  DAT_0060b550 = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_00403060"
        },
        {
            "funcStartAddr": "0x403100",
            "funcEndAddr": "0x4031df",
            "decompiledFuncCode": "\nchar * FUN_00403100(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte *pbVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    pbVar3 = (byte *)FUN_004066b0();\n    if ((*pbVar3 & 0xdf) == 0x55) {\n      if (((((pbVar3[1] & 0xdf) != 0x54) || ((pbVar3[2] & 0xdf) != 0x46)) || (pbVar3[3] != 0x2d)) ||\n         ((pbVar3[4] != 0x38 || (pbVar3[5] != 0)))) {\nLAB_004031d8:\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_004079f9;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_004079ee;\n      }\n    }\n    else {\n      if (((((*pbVar3 & 0xdf) != 0x47) || ((pbVar3[1] & 0xdf) != 0x42)) || (pbVar3[2] != 0x31)) ||\n         (((pbVar3[3] != 0x38 || (pbVar3[4] != 0x30)) ||\n          ((pbVar3[5] != 0x33 || ((pbVar3[6] != 0x30 || (pbVar3[7] != 0)))))))) goto LAB_004031d8;\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_004079f5;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_004079f2;\n      }\n    }\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_00403100"
        },
        {
            "funcStartAddr": "0x403200",
            "funcEndAddr": "0x404333",
            "decompiledFuncCode": "\nulong FUN_00403200(undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                  uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  ulong uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ulong uVar9;\n  ushort **ppuVar10;\n  long lVar11;\n  char *pcVar12;\n  byte bVar13;\n  char cVar14;\n  ulong uVar15;\n  ulong uVar16;\n  byte bVar17;\n  uint uVar18;\n  ulong uVar19;\n  bool bVar20;\n  ulong uVar21;\n  ulong uVar22;\n  bool bVar23;\n  bool bVar24;\n  bool bVar25;\n  bool bVar26;\n  size_t local_a0;\n  char *local_78;\n  ulong local_70;\n  bool local_5c;\n  bool local_5b;\n  wint_t local_44;\n  mbstate_t local_40 [2];\n  \n  sVar8 = __ctype_get_mb_cur_max();\n  uVar18 = param_6 & 2;\n  local_5c = uVar18 != 0;\n  uVar9 = param_2;\n  switch(param_5) {\n  case 0:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = false;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar18 != 0) {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = false;\n      local_a0 = 1;\n      local_78 = \"\\'\";\n      break;\n    }\n    bVar6 = false;\nLAB_00403e51:\n    if (param_2 != 0) {\n      bVar3 = false;\n      local_5b = false;\n      bVar2 = true;\n      local_70 = 0;\n      goto LAB_00403a86;\n    }\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 1;\n    param_5 = 2;\n    local_70 = 0;\n    local_5b = false;\n    local_5c = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 3:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 4:\n    if (uVar18 == 0) {\n      bVar6 = true;\n      goto LAB_00403e51;\n    }\n  case 1:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 5:\n    if (uVar18 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      local_5b = false;\n      local_70 = 0;\n      bVar2 = true;\n      bVar3 = false;\n      local_5c = false;\n      uVar15 = 1;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    else {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 5;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\\"\";\n    break;\n  case 7:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = true;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      param_8 = (char *)FUN_00403100(&DAT_004079fd,param_5);\n      param_9 = (char *)FUN_00403100(&DAT_00408bd7);\n    }\n    uVar15 = 0;\n    if (uVar18 == 0) {\n      cVar14 = *param_8;\n      while (cVar14 != '\\0') {\n        if (uVar15 < param_2) {\n          param_1[uVar15] = cVar14;\n        }\n        uVar15 = uVar15 + 1;\n        cVar14 = param_8[uVar15];\n      }\n    }\n    local_a0 = strlen(param_9);\n    bVar2 = true;\n    bVar3 = false;\n    local_78 = param_9;\n    local_5b = false;\n    local_70 = 0;\n    bVar6 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\nLAB_00403298:\n  uVar22 = 0;\n  bVar5 = local_5b;\nLAB_004032a8:\n  bVar23 = param_4 != uVar22;\n  if (param_4 == 0xffffffffffffffff) {\n    bVar23 = param_3[uVar22] != '\\0';\n  }\n  bVar26 = bVar6;\n  if (!bVar23) goto LAB_00403a28;\n  bVar20 = (bool)(param_5 != 2 & bVar6);\n  __s1 = (byte *)(param_3 + uVar22);\n  uVar16 = uVar15;\n  bVar4 = bVar3;\n  if (bVar20) {\n    if (local_a0 == 0) {\nLAB_004039a0:\n      uVar19 = (ulong)*__s1;\n      switch(uVar19) {\n      case 0:\n        goto switchD_004039b2_caseD_0;\n      default:\n        bVar20 = false;\n        goto switchD_0040381e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_004036b5;\n      case 8:\n        bVar17 = 0x62;\n        break;\n      case 9:\nswitchD_004039b2_caseD_9:\n        bVar17 = 0x74;\n        break;\n      case 10:\nswitchD_004039b2_caseD_a:\n        bVar17 = 0x6e;\n        break;\n      case 0xb:\nswitchD_004039b2_caseD_b:\n        bVar17 = 0x76;\n        goto LAB_004036b5;\n      case 0xc:\nswitchD_004039b2_caseD_c:\n        bVar17 = 0x66;\nLAB_004036b5:\n        if (local_5c) {\n          bVar25 = false;\n          goto LAB_00403608;\n        }\nLAB_004036c0:\n        bVar23 = false;\n        goto LAB_0040347b;\n      case 0xd:\n        bVar20 = false;\nswitchD_00403398_caseD_d:\n        bVar25 = param_5 == 2;\n        uVar19 = 0xd;\n        bVar13 = 0x72;\n        goto LAB_004035d0;\n      case 0x20:\n        bVar25 = false;\nLAB_004039fa:\n        uVar19 = 0x20;\n        goto LAB_004039c2;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar20 = false;\nswitchD_00403398_caseD_21:\n        bVar25 = false;\n        goto LAB_004035db;\n      case 0x23:\n      case 0x7e:\n        bVar26 = false;\nLAB_004039da:\n        if (uVar22 == 0) {\n          bVar25 = false;\n          bVar23 = bVar20;\n          bVar20 = bVar26;\n          goto LAB_004033e8;\n        }\n        bVar23 = false;\n        goto LAB_004033ff;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar25 = false;\nLAB_004039c2:\n        bVar24 = false;\n        bVar23 = bVar20;\n        bVar20 = bVar25;\n        goto LAB_00403401;\n      case 0x27:\n        bVar20 = false;\n        goto switchD_0040381e_caseD_27;\n      case 0x3f:\n        bVar20 = false;\n        goto switchD_0040381e_caseD_3f;\n      case 0x5c:\n        bVar20 = false;\n        goto switchD_00403398_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        bVar20 = false;\n        goto switchD_0040381e_caseD_7b;\n      }\n      bVar25 = false;\n      bVar23 = false;\n      goto joined_r0x004035f7;\n    }\n    if ((param_4 == 0xffffffffffffffff) && (1 < local_a0)) {\n      param_4 = strlen(param_3);\n    }\n    if ((param_4 < uVar22 + local_a0) || (iVar7 = memcmp(__s1,local_78,local_a0), iVar7 != 0))\n    goto LAB_004039a0;\n    if (!local_5c) {\n      uVar19 = (ulong)*__s1;\n      bVar25 = bVar20;\n      switch(uVar19) {\n      case 0:\n        goto switchD_00403398_caseD_0;\n      default:\n        goto switchD_0040381e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_004036c0;\n      case 8:\n        bVar25 = false;\n        bVar23 = false;\n        bVar17 = 0x62;\n        break;\n      case 9:\n        goto switchD_004039b2_caseD_9;\n      case 10:\n        goto switchD_004039b2_caseD_a;\n      case 0xb:\n        goto switchD_004039b2_caseD_b;\n      case 0xc:\n        goto switchD_004039b2_caseD_c;\n      case 0xd:\n        goto switchD_00403398_caseD_d;\n      case 0x20:\n        goto LAB_004039fa;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        goto switchD_00403398_caseD_21;\n      case 0x23:\n      case 0x7e:\n        bVar26 = bVar20;\n        goto LAB_004039da;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto LAB_004039c2;\n      case 0x27:\n        goto switchD_0040381e_caseD_27;\n      case 0x3f:\n        goto switchD_0040381e_caseD_3f;\n      case 0x5c:\n        goto switchD_00403398_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        goto switchD_0040381e_caseD_7b;\n      }\n      goto LAB_00403442;\n    }\n    goto LAB_0040361a;\n  }\n  uVar19 = (ulong)*__s1;\n  switch(uVar19) {\n  case 0:\n    if (bVar6) {\nswitchD_004039b2_caseD_0:\n      if (!local_5c) {\n        bVar20 = false;\nswitchD_00403398_caseD_0:\n        bVar26 = param_5 == 2;\n        bVar24 = (bool)((bVar3 ^ 1U) & bVar26);\n        if (bVar24) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar16 = uVar15 + 3;\n          bVar3 = bVar24;\n          if (uVar9 <= uVar15 + 3) {\n            uVar16 = uVar15 + 4;\n            bVar23 = false;\n            bVar17 = 0x30;\n            bVar4 = bVar24;\n            goto LAB_004034f8;\n          }\nLAB_0040373a:\n          param_1[uVar16] = 0x5c;\n          uVar15 = uVar16;\n        }\n        else if (uVar15 < uVar9) goto LAB_0040373a;\n        uVar16 = uVar15 + 1;\n        bVar24 = bVar23;\n        if (param_5 == 2) {\n          bVar17 = 0x30;\n          bVar23 = false;\n          bVar4 = bVar3;\n          goto LAB_004034f8;\n        }\n        uVar19 = 0x30;\n        if ((uVar22 + 1 < param_4) && ((byte)(param_3[uVar22 + 1] - 0x30U) < 10)) {\n          if (uVar16 < uVar9) {\n            param_1[uVar16] = 0x30;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x30;\n          }\n          uVar16 = uVar15 + 3;\n          uVar19 = 0x30;\n        }\nLAB_00403779:\n        bVar17 = (byte)uVar19;\n        bVar23 = false;\n        uVar15 = uVar16;\n        bVar4 = bVar3;\n        if ((bool)(bVar6 ^ 1U | bVar26)) goto LAB_004034f8;\n        goto LAB_00403401;\n      }\n      bVar26 = param_5 == 2;\n      goto LAB_0040360c;\n    }\n    if ((param_6 & 1) == 0) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0;\n      bVar23 = false;\n      bVar20 = false;\n      goto LAB_004033e8;\n    }\n    uVar22 = uVar22 + 1;\n    goto LAB_004032a8;\n  default:\nswitchD_0040381e_caseD_1:\n    bVar25 = bVar6;\n    if (sVar8 != 1) {\n      local_40[0] = (mbstate_t)0x0;\n      if (param_4 == 0xffffffffffffffff) {\n        param_4 = strlen(param_3);\n      }\n      uVar21 = 0;\n      do {\n        uVar1 = uVar22 + uVar21;\n        lVar11 = FUN_00406340(&local_44,param_3 + uVar1,param_4 - uVar1,local_40);\n        if (lVar11 == 0) break;\n        if (lVar11 == -1) {\n          bVar23 = false;\n          goto LAB_0040412a;\n        }\n        if (lVar11 == -2) {\n          if ((param_4 <= uVar1) || (param_3[uVar1] == '\\0')) goto LAB_00404267;\n          goto LAB_00404257;\n        }\n        if (((param_5 == 2) && (local_5c)) && (lVar11 != 1)) {\n          pcVar12 = param_3 + uVar1 + 1;\n          do {\n            if (((byte)(*pcVar12 + 0xa5U) < 0x22) &&\n               ((1L << (*pcVar12 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n              param_5 = 2;\n              goto LAB_0040360c;\n            }\n            pcVar12 = pcVar12 + 1;\n          } while (param_3 + uVar1 + lVar11 != pcVar12);\n        }\n        iVar7 = iswprint(local_44);\n        if (iVar7 == 0) {\n          bVar23 = false;\n        }\n        uVar21 = uVar21 + lVar11;\n        iVar7 = mbsinit(local_40);\n      } while (iVar7 == 0);\n      bVar25 = (bool)((bVar23 ^ 1U) & bVar6);\n      goto LAB_0040412a;\n    }\n    ppuVar10 = __ctype_b_loc();\n    uVar21 = 1;\n    bVar25 = ((*ppuVar10)[uVar19] & 0x4000) == 0;\n    bVar23 = !bVar25;\n    bVar25 = (bool)(bVar25 & bVar6);\n    goto LAB_004037f4;\n  case 7:\n    bVar25 = param_5 == 2;\n    uVar19 = 7;\n    bVar13 = 0x61;\n    break;\n  case 8:\n    bVar25 = param_5 == 2;\n    uVar19 = 8;\n    bVar13 = 0x62;\n    break;\n  case 9:\n    uVar19 = 9;\n    bVar13 = 0x74;\n    goto LAB_00403832;\n  case 10:\n    uVar19 = 10;\n    bVar13 = 0x6e;\n    goto LAB_00403832;\n  case 0xb:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xb;\n    bVar13 = 0x76;\n    break;\n  case 0xc:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xc;\n    bVar13 = 0x66;\n    break;\n  case 0xd:\n    uVar19 = 0xd;\n    bVar13 = 0x72;\nLAB_00403832:\n    bVar25 = param_5 == 2;\n    bVar20 = (bool)(local_5c & bVar25);\n    if (bVar20) {\nLAB_0040384a:\n      param_5 = 2;\n      goto LAB_0040360c;\n    }\n    break;\n  case 0x20:\n    uVar19 = 0x20;\n    goto LAB_004033d6;\n  case 0x21:\n  case 0x22:\n  case 0x24:\n  case 0x26:\n  case 0x28:\n  case 0x29:\n  case 0x2a:\n  case 0x3b:\n  case 0x3c:\n  case 0x3d:\n  case 0x3e:\n  case 0x5b:\n  case 0x5e:\n  case 0x60:\n  case 0x7c:\n    bVar23 = false;\nLAB_004033d6:\n    bVar25 = param_5 == 2;\n    if ((local_5c) && (bVar25)) goto LAB_0040384a;\n    goto LAB_004033e8;\n  case 0x23:\n  case 0x7e:\nLAB_004033cd:\n    bVar25 = param_5 == 2;\n    if (uVar22 == 0) goto LAB_004033d6;\n    goto LAB_004035db;\n  case 0x25:\n  case 0x2b:\n  case 0x2c:\n  case 0x2d:\n  case 0x2e:\n  case 0x2f:\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x3a:\n  case 0x41:\n  case 0x42:\n  case 0x43:\n  case 0x44:\n  case 0x45:\n  case 0x46:\n  case 0x47:\n  case 0x48:\n  case 0x49:\n  case 0x4a:\n  case 0x4b:\n  case 0x4c:\n  case 0x4d:\n  case 0x4e:\n  case 0x4f:\n  case 0x50:\n  case 0x51:\n  case 0x52:\n  case 0x53:\n  case 0x54:\n  case 0x55:\n  case 0x56:\n  case 0x57:\n  case 0x58:\n  case 0x59:\n  case 0x5a:\n  case 0x5d:\n  case 0x5f:\n  case 0x61:\n  case 0x62:\n  case 99:\n  case 100:\n  case 0x65:\n  case 0x66:\n  case 0x67:\n  case 0x68:\n  case 0x69:\n  case 0x6a:\n  case 0x6b:\n  case 0x6c:\n  case 0x6d:\n  case 0x6e:\n  case 0x6f:\n  case 0x70:\n  case 0x71:\n  case 0x72:\n  case 0x73:\n  case 0x74:\n  case 0x75:\n  case 0x76:\n  case 0x77:\n  case 0x78:\n  case 0x79:\n  case 0x7a:\n    goto switchD_0040381e_caseD_25;\n  case 0x27:\nswitchD_0040381e_caseD_27:\n    bVar5 = bVar23;\n    if (param_5 != 2) {\n      bVar25 = false;\n      uVar19 = 0x27;\n      goto LAB_004033e8;\n    }\n    if (!local_5c) {\n      if ((uVar9 == 0) || (uVar19 = 0, uVar21 = uVar9, local_70 != 0)) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x5c;\n        }\n        uVar19 = uVar9;\n        uVar21 = local_70;\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x27;\n        }\n      }\n      uVar16 = uVar15 + 3;\n      bVar17 = 0x27;\n      uVar9 = uVar19;\n      local_70 = uVar21;\n      bVar24 = false;\n      bVar4 = false;\n      goto LAB_004034f8;\n    }\n    goto LAB_0040360c;\n  case 0x3f:\nswitchD_0040381e_caseD_3f:\n    if (param_5 == 2) {\n      if (!local_5c) {\n        bVar17 = 0x3f;\n        bVar24 = false;\n        bVar23 = false;\n        goto LAB_004034f8;\n      }\n      goto LAB_0040360c;\n    }\n    if (param_5 != 5) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0x3f;\n      bVar23 = false;\n      goto LAB_004033e8;\n    }\n    if (((((param_6 & 4) != 0) && (uVar21 = uVar22 + 2, uVar21 < param_4)) &&\n        (param_3[uVar22 + 1] == '?')) &&\n       ((uVar19 = (ulong)(byte)param_3[uVar21], (byte)param_3[uVar21] < 0x3f &&\n        ((0x7000a38200000000U >> (uVar19 & 0x3f) & 1) != 0)))) {\n      if (!local_5c) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x3f;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x22;\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x22;\n        }\n        if (uVar15 + 3 < uVar9) {\n          param_1[uVar15 + 3] = 0x3f;\n        }\n        uVar16 = uVar15 + 4;\n        bVar26 = false;\n        uVar22 = uVar21;\n        bVar24 = false;\n        goto LAB_00403779;\n      }\n      goto LAB_0040361a;\n    }\n    bVar25 = false;\n    uVar19 = 0x3f;\n    bVar23 = false;\n    goto LAB_004033e8;\n  case 0x5c:\n    if (param_5 != 2) {\nswitchD_00403398_caseD_5c:\n      uVar19 = 0x5c;\n      bVar17 = 0x5c;\n      bVar13 = 0x5c;\n      bVar25 = (bool)(bVar6 & local_5c & local_a0 != 0);\n      if (!bVar25) break;\n      uVar22 = uVar22 + 1;\n      bVar23 = false;\n      goto LAB_00403514;\n    }\n    if (local_5c) goto LAB_0040360c;\n    uVar22 = uVar22 + 1;\n    bVar23 = false;\n    bVar17 = 0x5c;\n    goto LAB_00403514;\n  case 0x7b:\n  case 0x7d:\nswitchD_0040381e_caseD_7b:\n    bVar24 = param_4 != 1;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar24 = param_3[1] != '\\0';\n    }\n    bVar25 = param_5 == 2;\n    if (!bVar24) goto LAB_004033cd;\n    goto LAB_004035db;\n  }\nLAB_004035d0:\n  if (!bVar6) {\nLAB_004035db:\n    bVar23 = false;\n    goto LAB_004033e8;\n  }\n  bVar23 = false;\n  bVar17 = bVar13;\n  goto joined_r0x004035f7;\nLAB_00403a28:\n  if ((uVar15 == 0) && ((bool)(local_5c & param_5 == 2))) {\n    param_5 = 2;\nLAB_0040360c:\n    if (bVar26) {\n      param_5 = 4;\n    }\nLAB_0040361a:\n    uVar9 = FUN_00403200(param_1,uVar9,param_3,param_4,param_5,param_6 & 0xfffffffd,0,param_8,\n                         param_9);\n    return uVar9;\n  }\n  bVar26 = (bool)(param_5 == 2 & (local_5c ^ 1U));\n  bVar23 = (bool)(local_5c ^ 1U);\n  if ((!bVar26) || (bVar23 = bVar26, !bVar5)) {\nLAB_004042fd:\n    uVar22 = uVar15;\n    if (((local_78 != (char *)0x0) && (bVar23)) && (cVar14 = *local_78, cVar14 != '\\0')) {\n      do {\n        if (uVar22 < uVar9) {\n          param_1[uVar22] = cVar14;\n        }\n        uVar22 = uVar22 + 1;\n        cVar14 = local_78[uVar22 - uVar15];\n      } while (cVar14 != '\\0');\n    }\n    if (uVar22 < uVar9) {\n      param_1[uVar22] = 0;\n    }\n    return uVar22;\n  }\n  if (bVar2) {\n    uVar9 = FUN_00403200(param_1,local_70,param_3,param_4,5,param_6,param_7,param_8,param_9);\n    return uVar9;\n  }\n  local_5b = uVar9 == 0 && local_70 != 0;\n  param_2 = local_70;\n  bVar23 = bVar5;\n  if (uVar9 != 0 || local_70 == 0) goto LAB_004042fd;\nLAB_00403a86:\n  *param_1 = 0x27;\n  param_5 = 2;\n  uVar15 = 1;\n  local_78 = \"\\'\";\n  local_a0 = 1;\n  local_5c = false;\n  uVar9 = param_2;\n  goto LAB_00403298;\n  while (__s1[uVar21] != 0) {\nLAB_00404257:\n    uVar21 = uVar21 + 1;\n    if (param_4 <= uVar22 + uVar21) break;\n  }\nLAB_00404267:\n  bVar23 = false;\nLAB_0040412a:\n  if (1 < uVar21) {\nLAB_00403cee:\n    bVar26 = false;\n    uVar21 = uVar21 + uVar22;\n    uVar16 = uVar22;\n    do {\n      bVar17 = (byte)uVar19;\n      if (bVar25) {\n        bVar26 = param_5 == 2;\n        if (local_5c) goto LAB_0040360c;\n        bVar26 = (bool)(bVar26 & (bVar4 ^ 1U));\n        if (bVar26) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar15 = uVar15 + 3;\n          bVar4 = bVar26;\n        }\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x5c;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = (char)(uVar19 >> 6) + '0';\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = ((byte)(uVar19 >> 3) & 7) + 0x30;\n        }\n        uVar22 = uVar16 + 1;\n        uVar15 = uVar15 + 3;\n        bVar17 = (bVar17 & 7) + 0x30;\n        bVar26 = bVar25;\n        if (uVar21 <= uVar22) goto LAB_0040348d;\n      }\n      else {\n        bVar3 = (bool)((bVar26 ^ 1U) & bVar4);\n        if (bVar20) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x5c;\n          }\n          uVar15 = uVar15 + 1;\n        }\n        uVar22 = uVar16 + 1;\n        if (uVar21 <= uVar22) goto LAB_00403514;\n        if (bVar3) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x27;\n          }\n          uVar15 = uVar15 + 2;\n          bVar20 = false;\n          bVar4 = false;\n        }\n        else {\n          bVar20 = false;\n        }\n      }\n      uVar16 = uVar16 + 1;\n      if (uVar15 < uVar9) {\n        param_1[uVar15] = bVar17;\n      }\n      uVar19 = (ulong)(byte)param_3[uVar16];\n      uVar15 = uVar15 + 1;\n    } while( true );\n  }\nLAB_004037f4:\n  if (bVar25) {\n    bVar23 = false;\n    bVar25 = bVar6;\n    goto LAB_00403cee;\n  }\nswitchD_0040381e_caseD_25:\n  bVar25 = param_5 == 2;\nLAB_004033e8:\n  bVar17 = (byte)uVar19;\n  bVar24 = (bool)((bVar6 ^ 1U | bVar25) ^ 1 | local_5c);\n  bVar26 = bVar20;\n  if (bVar24) {\nLAB_004033ff:\n    bVar24 = false;\n    bVar20 = bVar26;\nLAB_00403401:\n    bVar17 = (byte)uVar19;\n    uVar16 = uVar15;\n    bVar4 = bVar3;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar19 >> 5) * 4) >> (bVar17 & 0x1f) & 1) == 0))\n    goto LAB_004034f8;\n    bVar25 = param_5 == 2;\n  }\n  else {\nLAB_004034f8:\n    bVar25 = param_5 == 2;\n    uVar15 = uVar16;\n    bVar3 = bVar4;\n    if (!bVar20) {\n      uVar22 = uVar22 + 1;\n      bVar3 = (bool)((bVar24 ^ 1U) & bVar4);\nLAB_00403514:\n      if (bVar3) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x27;\n        }\n        uVar15 = uVar15 + 2;\n        bVar4 = false;\n      }\n      goto LAB_0040348d;\n    }\n  }\njoined_r0x004035f7:\n  if (local_5c) {\nLAB_00403608:\n    bVar26 = (bool)(bVar6 & bVar25);\n    goto LAB_0040360c;\n  }\nLAB_00403442:\n  bVar25 = (bool)((bVar3 ^ 1U) & bVar25);\n  if (bVar25) {\n    if (uVar15 < uVar9) {\n      param_1[uVar15] = 0x27;\n    }\n    if (uVar15 + 1 < uVar9) {\n      param_1[uVar15 + 1] = 0x24;\n    }\n    if (uVar15 + 2 < uVar9) {\n      param_1[uVar15 + 2] = 0x27;\n    }\n    uVar15 = uVar15 + 3;\n    bVar3 = bVar25;\n  }\nLAB_0040347b:\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = 0x5c;\n  }\n  uVar15 = uVar15 + 1;\n  uVar22 = uVar22 + 1;\n  bVar4 = bVar3;\nLAB_0040348d:\n  bVar3 = bVar4;\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = bVar17;\n  }\n  uVar15 = uVar15 + 1;\n  if (!bVar23) {\n    bVar2 = false;\n  }\n  goto LAB_004032a8;\n}\n\n",
            "funcName": "FUN_00403200"
        },
        {
            "funcStartAddr": "0x404430",
            "funcEndAddr": "0x4045cb",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_00404430(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  ulong uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  undefined4 *puVar8;\n  ulong uVar9;\n  undefined *__ptr;\n  ulong *puVar10;\n  \n  piVar7 = __errno_location();\n  iVar1 = *piVar7;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  puVar8 = (undefined4 *)PTR_DAT_0060b2f8;\n  if (DAT_0060b310 <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00405490();\n    }\n    if (PTR_DAT_0060b2f8 == &DAT_0060b300) {\n      puVar8 = (undefined4 *)FUN_004052a0(0);\n      uVar6 = PTR_DAT_0060b308._4_4_;\n      uVar5 = PTR_DAT_0060b308._0_4_;\n      uVar3 = _UNK_0060b304;\n      PTR_DAT_0060b2f8 = (undefined *)puVar8;\n      *puVar8 = _DAT_0060b300;\n      puVar8[1] = uVar3;\n      puVar8[2] = uVar5;\n      puVar8[3] = uVar6;\n    }\n    else {\n      puVar8 = (undefined4 *)FUN_004052a0(PTR_DAT_0060b2f8);\n      PTR_DAT_0060b2f8 = (undefined *)puVar8;\n    }\n    memset(puVar8 + (long)DAT_0060b310 * 4,0,(long)((param_1 + 1) - DAT_0060b310) << 4);\n    DAT_0060b310 = param_1 + 1;\n  }\n  uVar2 = param_4[1];\n  puVar10 = (ulong *)(puVar8 + (long)param_1 * 4);\n  uVar4 = *puVar10;\n  __ptr = (undefined *)puVar10[1];\n  uVar9 = FUN_00403200(__ptr,uVar4,param_2,param_3,*param_4,uVar2 | 1,param_4 + 2,\n                       *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar4 <= uVar9) {\n    uVar9 = uVar9 + 1;\n    *puVar10 = uVar9;\n    if (__ptr != &DAT_0060b560) {\n      free(__ptr);\n    }\n    __ptr = (undefined *)FUN_00405240(uVar9);\n    uVar3 = *param_4;\n    puVar10[1] = (ulong)__ptr;\n    FUN_00403200(__ptr,uVar9,param_2,param_3,uVar3,uVar2 | 1,param_4 + 2,\n                 *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar7 = iVar1;\n  return __ptr;\n}\n\n",
            "funcName": "FUN_00404430"
        },
        {
            "funcStartAddr": "0x4045d0",
            "funcEndAddr": "0x404604",
            "decompiledFuncCode": "\nvoid FUN_004045d0(undefined *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060b660;\n  }\n  FUN_00405440(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_004045d0"
        },
        {
            "funcStartAddr": "0x404610",
            "funcEndAddr": "0x40461f",
            "decompiledFuncCode": "\nundefined4 FUN_00404610(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060b660;\n  }\n  return *param_1;\n}\n\n",
            "funcName": "FUN_00404610"
        },
        {
            "funcStartAddr": "0x404620",
            "funcEndAddr": "0x40462f",
            "decompiledFuncCode": "\nvoid FUN_00404620(undefined4 *param_1,undefined4 param_2)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060b660;\n  }\n  *param_1 = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_00404620"
        },
        {
            "funcStartAddr": "0x404630",
            "funcEndAddr": "0x404663",
            "decompiledFuncCode": "\nuint FUN_00404630(undefined *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060b660;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n",
            "funcName": "FUN_00404630"
        },
        {
            "funcStartAddr": "0x404670",
            "funcEndAddr": "0x404683",
            "decompiledFuncCode": "\nundefined4 FUN_00404670(undefined *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060b660;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00404670"
        },
        {
            "funcStartAddr": "0x404690",
            "funcEndAddr": "0x4046bb",
            "decompiledFuncCode": "\nvoid FUN_00404690(undefined4 *param_1,long param_2,long param_3)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060b660;\n  }\n  *param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)(param_1 + 10) = param_2;\n    *(long *)(param_1 + 0xc) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404690"
        },
        {
            "funcStartAddr": "0x4046c0",
            "funcEndAddr": "0x404732",
            "decompiledFuncCode": "\nvoid FUN_004046c0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined4 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (param_5 == (undefined4 *)0x0) {\n    param_5 = (undefined4 *)&DAT_0060b660;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  FUN_00403200(param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5 + 2,\n               *(undefined8 *)(param_5 + 10),*(undefined8 *)(param_5 + 0xc));\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_004046c0"
        },
        {
            "funcStartAddr": "0x404740",
            "funcEndAddr": "0x404821",
            "decompiledFuncCode": "\nundefined8 FUN_00404740(undefined8 param_1,undefined8 param_2,long *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if (param_4 == (undefined4 *)0x0) {\n    param_4 = (undefined4 *)&DAT_0060b660;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | param_4[1];\n  lVar3 = FUN_00403200(0,0,param_1,param_2,*param_4,uVar5,param_4 + 2,*(undefined8 *)(param_4 + 10),\n                       *(undefined8 *)(param_4 + 0xc));\n  uVar4 = FUN_00405240(lVar3 + 1);\n  FUN_00403200(uVar4,lVar3 + 1,param_1,param_2,*param_4,uVar5,param_4 + 2,\n               *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n",
            "funcName": "FUN_00404740"
        },
        {
            "funcStartAddr": "0x404830",
            "funcEndAddr": "0x40483a",
            "decompiledFuncCode": "\nvoid FUN_00404830(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00404740(param_1,param_2,0,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00404830"
        },
        {
            "funcStartAddr": "0x404840",
            "funcEndAddr": "0x4048d5",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404840(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = PTR_DAT_0060b2f8;\n  if (1 < DAT_0060b310) {\n    ppvVar2 = (void **)(PTR_DAT_0060b2f8 + 0x18);\n    ppvVar1 = (void **)(PTR_DAT_0060b2f8 + (ulong)(DAT_0060b310 - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined **)(__ptr_00 + 8) != &DAT_0060b560) {\n    free(*(undefined **)(__ptr_00 + 8));\n    _DAT_0060b300 = 0x100;\n    PTR_DAT_0060b308 = &DAT_0060b560;\n  }\n  if (__ptr_00 != &DAT_0060b300) {\n    free(__ptr_00);\n    PTR_DAT_0060b2f8 = &DAT_0060b300;\n  }\n  DAT_0060b310 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_00404840"
        },
        {
            "funcStartAddr": "0x4048e0",
            "funcEndAddr": "0x4048f1",
            "decompiledFuncCode": "\nvoid FUN_004048e0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404430(param_1,param_2,0xffffffffffffffff,&DAT_0060b660);\n  return;\n}\n\n",
            "funcName": "FUN_004048e0"
        },
        {
            "funcStartAddr": "0x404900",
            "funcEndAddr": "0x40490a",
            "decompiledFuncCode": "\nvoid FUN_00404900(void)\n\n{\n  FUN_00404430();\n  return;\n}\n\n",
            "funcName": "FUN_00404900"
        },
        {
            "funcStartAddr": "0x404910",
            "funcEndAddr": "0x404926",
            "decompiledFuncCode": "\nvoid FUN_00404910(undefined8 param_1)\n\n{\n  FUN_00404430(0,param_1,0xffffffffffffffff,&DAT_0060b660);\n  return;\n}\n\n",
            "funcName": "FUN_00404910"
        },
        {
            "funcStartAddr": "0x404930",
            "funcEndAddr": "0x404942",
            "decompiledFuncCode": "\nvoid FUN_00404930(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404430(0,param_1,param_2,&DAT_0060b660);\n  return;\n}\n\n",
            "funcName": "FUN_00404930"
        },
        {
            "funcStartAddr": "0x404950",
            "funcEndAddr": "0x4049b8",
            "decompiledFuncCode": "\nvoid FUN_00404950(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00404430(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404950"
        },
        {
            "funcStartAddr": "0x4049c0",
            "funcEndAddr": "0x404a24",
            "decompiledFuncCode": "\nvoid FUN_004049c0(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00404430(param_1,param_3,param_4,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_004049c0"
        },
        {
            "funcStartAddr": "0x404a30",
            "funcEndAddr": "0x404a3c",
            "decompiledFuncCode": "\nvoid FUN_00404a30(undefined4 param_1,undefined8 param_2)\n\n{\n  FUN_00404950(0,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00404a30"
        },
        {
            "funcStartAddr": "0x404a40",
            "funcEndAddr": "0x404a4f",
            "decompiledFuncCode": "\nvoid FUN_00404a40(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_004049c0(0,param_1,param_2,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00404a40"
        },
        {
            "funcStartAddr": "0x404a50",
            "funcEndAddr": "0x404ac0",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404a50(undefined8 param_1,undefined8 param_2,byte param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  \n  local_18 = DAT_0060b690;\n  local_48 = _DAT_0060b660;\n  uStack_40 = uRam000000000060b668;\n  local_38 = _DAT_0060b670;\n  uStack_30 = uRam000000000060b678;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_3 >> 5) * 4);\n  local_28 = _DAT_0060b680;\n  uStack_20 = uRam000000000060b688;\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_3 & 0x1f)) & 1) << (param_3 & 0x1f) ^ uVar2;\n  FUN_00404430(0,param_1,param_2,&local_48);\n  return;\n}\n\n",
            "funcName": "FUN_00404a50"
        },
        {
            "funcStartAddr": "0x404ac0",
            "funcEndAddr": "0x404acd",
            "decompiledFuncCode": "\nvoid FUN_00404ac0(undefined8 param_1,char param_2)\n\n{\n  FUN_00404a50(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00404ac0"
        },
        {
            "funcStartAddr": "0x404ad0",
            "funcEndAddr": "0x404ae1",
            "decompiledFuncCode": "\nvoid FUN_00404ad0(undefined8 param_1)\n\n{\n  FUN_00404a50(param_1,0xffffffffffffffff,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_00404ad0"
        },
        {
            "funcStartAddr": "0x404af0",
            "funcEndAddr": "0x404afa",
            "decompiledFuncCode": "\nvoid FUN_00404af0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404a50(param_1,param_2,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_00404af0"
        },
        {
            "funcStartAddr": "0x404b00",
            "funcEndAddr": "0x404b6e",
            "decompiledFuncCode": "\nvoid FUN_00404b00(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_40 = 0x400000000000000;\n    local_44 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00404430(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404b00"
        },
        {
            "funcStartAddr": "0x404b70",
            "funcEndAddr": "0x404bdc",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404b70(undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5\n                 )\n\n{\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  \n  uStack_40 = uRam000000000060b668;\n  local_38 = _DAT_0060b670;\n  uStack_30 = uRam000000000060b678;\n  local_28 = _DAT_0060b680;\n  lStack_20 = uRam000000000060b688;\n  local_18 = DAT_0060b690;\n  local_48 = CONCAT44((int)((ulong)_DAT_0060b660 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_00404430(param_1,param_4,param_5,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00404b70"
        },
        {
            "funcStartAddr": "0x404be0",
            "funcEndAddr": "0x404be9",
            "decompiledFuncCode": "\nvoid FUN_00404be0(void)\n\n{\n  FUN_00404b70();\n  return;\n}\n\n",
            "funcName": "FUN_00404be0"
        },
        {
            "funcStartAddr": "0x404bf0",
            "funcEndAddr": "0x404c07",
            "decompiledFuncCode": "\nvoid FUN_00404bf0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00404b70(0,param_1,param_2,param_3,0xffffffffffffffff);\n  return;\n}\n\n",
            "funcName": "FUN_00404bf0"
        },
        {
            "funcStartAddr": "0x404c10",
            "funcEndAddr": "0x404c23",
            "decompiledFuncCode": "\nvoid FUN_00404c10(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_00404b70(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
            "funcName": "FUN_00404c10"
        },
        {
            "funcStartAddr": "0x404c30",
            "funcEndAddr": "0x404c3a",
            "decompiledFuncCode": "\nvoid FUN_00404c30(void)\n\n{\n  FUN_00404430();\n  return;\n}\n\n",
            "funcName": "FUN_00404c30"
        },
        {
            "funcStartAddr": "0x404c40",
            "funcEndAddr": "0x404c52",
            "decompiledFuncCode": "\nvoid FUN_00404c40(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404430(0,param_1,param_2,&DAT_0060b2c0);\n  return;\n}\n\n",
            "funcName": "FUN_00404c40"
        },
        {
            "funcStartAddr": "0x404c60",
            "funcEndAddr": "0x404c71",
            "decompiledFuncCode": "\nvoid FUN_00404c60(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00404430(param_1,param_2,0xffffffffffffffff,&DAT_0060b2c0);\n  return;\n}\n\n",
            "funcName": "FUN_00404c60"
        },
        {
            "funcStartAddr": "0x404c80",
            "funcEndAddr": "0x404c96",
            "decompiledFuncCode": "\nvoid FUN_00404c80(undefined8 param_1)\n\n{\n  FUN_00404430(0,param_1,0xffffffffffffffff,&DAT_0060b2c0);\n  return;\n}\n\n",
            "funcName": "FUN_00404c80"
        },
        {
            "funcStartAddr": "0x404ca0",
            "funcEndAddr": "0x405044",
            "decompiledFuncCode": "\nundefined8\nFUN_00404ca0(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5,\n            undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0040874b,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e1);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00404f1c;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_00404f1c:\n    __fprintf_chk(param_1,1,uVar7,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[1];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar1 = param_5[2];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_00404fb9;\n  case 7:\n    uVar1 = param_5[2];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    local_58 = param_5[1];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_00404fb9:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_58,uVar1,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00404d9a;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_00404d9a:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_50,local_58,uVar6,uVar5,uVar4,uVar1,local_48);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00404ca0"
        },
        {
            "funcStartAddr": "0x405080",
            "funcEndAddr": "0x4050a0",
            "decompiledFuncCode": "\nvoid FUN_00405080(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  FUN_00404ca0();\n  return;\n}\n\n",
            "funcName": "FUN_00405080"
        },
        {
            "funcStartAddr": "0x4050a0",
            "funcEndAddr": "0x4050f9",
            "decompiledFuncCode": "\nvoid FUN_004050a0(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long local_58 [11];\n  \n  lVar4 = 0;\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_58[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_58[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_00404ca0();\n  return;\n}\n\n",
            "funcName": "FUN_004050a0"
        },
        {
            "funcStartAddr": "0x405100",
            "funcEndAddr": "0x4051b8",
            "decompiledFuncCode": "\nvoid FUN_00405100(void)\n\n{\n  long lVar1;\n  undefined8 in_R8;\n  ulong uVar2;\n  undefined8 in_R9;\n  long lVar3;\n  long *plVar4;\n  long local_88 [10];\n  long local_38 [4];\n  long local_18 [3];\n  \n  local_18[0] = in_R8;\n  plVar4 = (long *)&stack0x00000008;\n  uVar2 = 0x20;\n  local_18[1] = in_R9;\n  lVar3 = 0;\n  do {\n    if ((uint)uVar2 < 0x30) {\n      lVar1 = *(long *)((long)local_38 + uVar2);\n      local_88[lVar3] = lVar1;\n      uVar2 = (ulong)((uint)uVar2 + 8);\n    }\n    else {\n      lVar1 = *plVar4;\n      local_88[lVar3] = lVar1;\n      plVar4 = plVar4 + 1;\n    }\n  } while ((lVar1 != 0) && (lVar3 = lVar3 + 1, lVar3 != 10));\n  FUN_00404ca0();\n  return;\n}\n\n",
            "funcName": "FUN_00405100"
        },
        {
            "funcStartAddr": "0x4051c0",
            "funcEndAddr": "0x405234",
            "decompiledFuncCode": "\nvoid FUN_004051c0(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n",
            "funcName": "FUN_004051c0"
        },
        {
            "funcStartAddr": "0x405240",
            "funcEndAddr": "0x40525a",
            "decompiledFuncCode": "\nvoid FUN_00405240(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00405490();\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00405240"
        },
        {
            "funcStartAddr": "0x405260",
            "funcEndAddr": "0x405281",
            "decompiledFuncCode": "\nvoid FUN_00405260(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    FUN_00405240();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00405490();\n}\n\n",
            "funcName": "FUN_00405260"
        },
        {
            "funcStartAddr": "0x405290",
            "funcEndAddr": "0x405292",
            "decompiledFuncCode": "\nvoid thunk_FUN_00405240(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00405490();\n  }\n  return;\n}\n\n",
            "funcName": "thunk_405290"
        },
        {
            "funcStartAddr": "0x4052a0",
            "funcEndAddr": "0x4052d0",
            "decompiledFuncCode": "\nvoid * FUN_004052a0(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00405490();\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "FUN_004052a0"
        },
        {
            "funcStartAddr": "0x4052e0",
            "funcEndAddr": "0x405301",
            "decompiledFuncCode": "\nvoid FUN_004052e0(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    FUN_004052a0();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00405490();\n}\n\n",
            "funcName": "FUN_004052e0"
        },
        {
            "funcStartAddr": "0x405310",
            "funcEndAddr": "0x405388",
            "decompiledFuncCode": "\nvoid FUN_00405310(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar2 = *param_2;\n  if (param_1 == 0) {\n    if (uVar2 == 0) {\n      uVar2 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar3 = (ulong)(SUB168(ZEXT816(uVar2) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar2) * ZEXT816(param_3),0) < 0) || (uVar3 != 0)) goto LAB_0040536b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar3 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar2) {\nLAB_0040536b:\n                    /* WARNING: Subroutine does not return */\n      FUN_00405490(param_1,param_2,uVar3);\n    }\n    uVar2 = (uVar2 >> 1) + 1 + uVar2;\n  }\n  *param_2 = uVar2;\n  FUN_004052a0(param_1,uVar2 * param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00405310"
        },
        {
            "funcStartAddr": "0x4053a0",
            "funcEndAddr": "0x4053ea",
            "decompiledFuncCode": "\nvoid FUN_004053a0(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = *param_2;\n  if (param_1 == 0) {\n    if (uVar1 == 0) {\n      *param_2 = 0x80;\n      FUN_004052a0(0,0x80);\n      return;\n    }\n    if ((long)uVar1 < 0) goto LAB_004053ea;\n  }\n  else {\n    if (0x5555555555555553 < uVar1) {\nLAB_004053ea:\n                    /* WARNING: Subroutine does not return */\n      FUN_00405490();\n    }\n    uVar1 = (uVar1 >> 1) + 1 + uVar1;\n  }\n  *param_2 = uVar1;\n  FUN_004052a0(param_1,uVar1);\n  return;\n}\n\n",
            "funcName": "FUN_004053a0"
        },
        {
            "funcStartAddr": "0x4053f0",
            "funcEndAddr": "0x405407",
            "decompiledFuncCode": "\nvoid FUN_004053f0(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_00405240();\n  memset(__s,0,param_1);\n  return;\n}\n\n",
            "funcName": "FUN_004053f0"
        },
        {
            "funcStartAddr": "0x405410",
            "funcEndAddr": "0x40543e",
            "decompiledFuncCode": "\nvoid FUN_00405410(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00405490();\n}\n\n",
            "funcName": "FUN_00405410"
        },
        {
            "funcStartAddr": "0x405440",
            "funcEndAddr": "0x405468",
            "decompiledFuncCode": "\nvoid FUN_00405440(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)FUN_00405240(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00405440"
        },
        {
            "funcStartAddr": "0x405470",
            "funcEndAddr": "0x405483",
            "decompiledFuncCode": "\nvoid FUN_00405470(char *param_1)\n\n{\n  void *__dest;\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  __dest = (void *)FUN_00405240(sVar1 + 1);\n  memcpy(__dest,param_1,sVar1 + 1);\n  return;\n}\n\n",
            "funcName": "FUN_00405470"
        },
        {
            "funcStartAddr": "0x405490",
            "funcEndAddr": "0x4054c1",
            "decompiledFuncCode": "\nvoid FUN_00405490(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  error(DAT_0060b2a0,0,\"%s\",uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00405490"
        },
        {
            "funcStartAddr": "0x4054d0",
            "funcEndAddr": "0x405563",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nbool FUN_004054d0(char *param_1,char **param_2,double *param_3,code *param_4)\n\n{\n  int *piVar1;\n  bool bVar2;\n  double dVar3;\n  char *local_30;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  dVar3 = (double)(*param_4)(param_1,&local_30);\n  if (local_30 == param_1) {\n    bVar2 = false;\nLAB_00405529:\n    if (param_2 == (char **)0x0) goto LAB_00405532;\n  }\n  else {\n    if (param_2 == (char **)0x0) {\n      bVar2 = false;\n      if (*local_30 != '\\0') goto LAB_00405532;\n      if (dVar3 == _DAT_00407928) {\n        bVar2 = true;\n        goto LAB_00405532;\n      }\nLAB_00405521:\n      bVar2 = *piVar1 != 0x22;\n      goto LAB_00405529;\n    }\n    bVar2 = true;\n    if (dVar3 != _DAT_00407928) goto LAB_00405521;\n  }\n  *param_2 = local_30;\nLAB_00405532:\n  *param_3 = dVar3;\n  return bVar2;\n}\n\n",
            "funcName": "FUN_004054d0"
        },
        {
            "funcStartAddr": "0x405570",
            "funcEndAddr": "0x405645",
            "decompiledFuncCode": "\nvoid FUN_00405570(long param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  iVar1 = param_2[0xb];\n  iVar2 = *param_2;\n  iVar3 = param_2[0xc];\n  iVar8 = iVar1;\n  iVar9 = iVar2;\n  while (iVar3 < iVar9) {\n    while( true ) {\n      if (iVar3 <= iVar8) goto LAB_004055ec;\n      iVar10 = iVar9 - iVar3;\n      iVar7 = iVar3 - iVar8;\n      if (iVar10 <= iVar7) break;\n      lVar6 = (long)iVar8;\n      iVar9 = iVar9 - iVar7;\n      puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n      do {\n        uVar4 = *puVar5;\n        *puVar5 = puVar5[iVar9 - lVar6];\n        puVar5[iVar9 - lVar6] = uVar4;\n        puVar5 = puVar5 + 1;\n      } while ((undefined8 *)(param_1 + 8 + ((ulong)(iVar7 - 1) + lVar6) * 8) != puVar5);\n      if (iVar9 <= iVar3) goto LAB_004055ec;\n    }\n    lVar6 = (long)iVar8;\n    puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n    do {\n      uVar4 = *puVar5;\n      *puVar5 = puVar5[iVar3 - lVar6];\n      puVar5[iVar3 - lVar6] = uVar4;\n      puVar5 = puVar5 + 1;\n    } while (puVar5 != (undefined8 *)(param_1 + 8 + ((ulong)(iVar10 - 1) + lVar6) * 8));\n    iVar8 = iVar8 + iVar10;\n  }\nLAB_004055ec:\n  param_2[0xc] = iVar2;\n  param_2[0xb] = iVar1 + (iVar2 - iVar3);\n  return;\n}\n\n",
            "funcName": "FUN_00405570"
        },
        {
            "funcStartAddr": "0x405650",
            "funcEndAddr": "0x405c4e",
            "decompiledFuncCode": "\nint FUN_00405650(int param_1,undefined8 *param_2,char *param_3,char **param_4,undefined4 *param_5,\n                int param_6,int *param_7,int param_8,undefined8 param_9)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  char **ppcVar12;\n  char *pcVar13;\n  char *__s1;\n  FILE *__stream;\n  ulong uVar14;\n  size_t sVar15;\n  char *__s1_00;\n  long lVar16;\n  char *local_70;\n  uint local_44;\n  \n  pcVar13 = *(char **)(param_7 + 8);\n  cVar1 = *pcVar13;\n  pcVar11 = pcVar13;\n  if ((cVar1 == '=') || (cVar1 == '\\0')) {\n    sVar15 = 0;\n  }\n  else {\n    do {\n      pcVar11 = pcVar11 + 1;\n      if (*pcVar11 == '\\0') break;\n    } while (*pcVar11 != '=');\n    sVar15 = (long)pcVar11 - (long)pcVar13;\n  }\n  uVar14 = 0;\n  __s1 = *param_4;\n  ppcVar10 = param_4;\n  __s1_00 = __s1;\n  if (__s1 != (char *)0x0) {\n    while( true ) {\n      iVar5 = strncmp(__s1_00,pcVar13,sVar15);\n      if ((iVar5 == 0) && (sVar7 = strlen(__s1_00), sVar7 == sVar15)) goto LAB_00405870;\n      ppcVar10 = ppcVar10 + 4;\n      __s1_00 = *ppcVar10;\n      iVar5 = (int)uVar14 + 1;\n      if (__s1_00 == (char *)0x0) break;\n      uVar14 = (ulong)iVar5;\n    }\n    lVar16 = 0;\n    ppcVar10 = (char **)0x0;\n    local_44 = 0xffffffff;\n    bVar3 = false;\n    bVar4 = false;\n    local_70 = (char *)0x0;\n    ppcVar12 = param_4;\n    do {\n      iVar6 = strncmp(__s1,pcVar13,sVar15);\n      if (iVar6 == 0) {\n        if (ppcVar10 == (char **)0x0) {\n          local_44 = (uint)lVar16;\n          ppcVar10 = ppcVar12;\n        }\n        else if (((((param_6 != 0) || (*(int *)(ppcVar10 + 1) != *(int *)(ppcVar12 + 1))) ||\n                  (ppcVar10[2] != ppcVar12[2])) ||\n                 (*(int *)(ppcVar10 + 3) != *(int *)(ppcVar12 + 3))) && (!bVar3)) {\n          if (param_8 == 0) {\n            bVar3 = true;\n            if (local_70 == (char *)0x0) goto LAB_004057b0;\n          }\n          else if (local_70 == (char *)0x0) {\n            local_70 = (char *)calloc((long)iVar5,1);\n            if (local_70 == (char *)0x0) {\n              bVar3 = true;\n              goto LAB_004057b0;\n            }\n            bVar4 = true;\n            local_70[(int)local_44] = '\\x01';\n          }\n          local_70[lVar16] = '\\x01';\n        }\n      }\nLAB_004057b0:\n      ppcVar12 = ppcVar12 + 4;\n      __s1 = *ppcVar12;\n      lVar16 = lVar16 + 1;\n    } while (__s1 != (char *)0x0);\n    if ((local_70 != (char *)0x0) || (bVar3)) {\n      if (param_8 != 0) {\n        if (bVar3) {\n          uVar2 = *param_2;\n          uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous\\n\",5);\n          __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n        else {\n          flockfile(stderr);\n          uVar2 = *(undefined8 *)(param_7 + 8);\n          uVar8 = *param_2;\n          uVar9 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous; possibilities:\",5);\n          __fprintf_chk(stderr,1,uVar9,uVar8,param_9,uVar2);\n          pcVar13 = local_70;\n          __stream = stderr;\n          do {\n            if (*pcVar13 != '\\0') {\n              __fprintf_chk(__stream,1,&DAT_00408bd1,param_9,*param_4);\n              __stream = stderr;\n            }\n            pcVar13 = pcVar13 + 1;\n            param_4 = param_4 + 4;\n          } while (local_70 + uVar14 + 1 != pcVar13);\n          fputc(10,__stream);\n          funlockfile(stderr);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n      }\n      if (bVar4) {\n        free(local_70);\n      }\n      sVar15 = strlen(pcVar13);\n      *(char **)(param_7 + 8) = pcVar13 + sVar15;\n      *param_7 = *param_7 + 1;\n      param_7[2] = 0;\n      return 0x3f;\n    }\n    if (ppcVar10 != (char **)0x0) {\n      uVar14 = (ulong)local_44;\nLAB_00405870:\n      iVar6 = *param_7;\n      *(undefined8 *)(param_7 + 8) = 0;\n      iVar5 = iVar6 + 1;\n      *param_7 = iVar5;\n      if (*pcVar11 == '\\0') {\n        if (*(int *)(ppcVar10 + 1) == 1) {\n          if (param_1 <= iVar5) {\n            if (param_8 != 0) {\n              pcVar13 = *ppcVar10;\n              uVar2 = *param_2;\n              uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' requires an argument\\n\",5);\n              __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n            }\n            param_7[2] = *(int *)(ppcVar10 + 3);\n            return (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          *param_7 = iVar6 + 2;\n          *(undefined8 *)(param_7 + 4) = param_2[iVar5];\n        }\n      }\n      else {\n        if (*(int *)(ppcVar10 + 1) == 0) {\n          if (param_8 != 0) {\n            pcVar13 = *ppcVar10;\n            uVar2 = *param_2;\n            uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' doesn\\'t allow an argument\\n\",5);\n            __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          }\n          param_7[2] = *(int *)(ppcVar10 + 3);\n          return 0x3f;\n        }\n        *(char **)(param_7 + 4) = pcVar11 + 1;\n      }\n      if (param_5 != (undefined4 *)0x0) {\n        *param_5 = (int)uVar14;\n      }\n      if ((int *)ppcVar10[2] == (int *)0x0) {\n        return *(int *)(ppcVar10 + 3);\n      }\n      *(int *)ppcVar10[2] = *(int *)(ppcVar10 + 3);\n      return 0;\n    }\n  }\n  if (((param_6 != 0) && (*(char *)(param_2[*param_7] + 1) != '-')) &&\n     (pcVar11 = strchr(param_3,(int)cVar1), pcVar11 != (char *)0x0)) {\n    return -1;\n  }\n  if (param_8 != 0) {\n    uVar2 = *param_2;\n    uVar8 = dcgettext(0,\"%s: unrecognized option \\'%s%s\\'\\n\",5);\n    __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n  }\n  *(undefined8 *)(param_7 + 8) = 0;\n  *param_7 = *param_7 + 1;\n  param_7[2] = 0;\n  return 0x3f;\n}\n\n",
            "funcName": "FUN_00405650"
        },
        {
            "funcStartAddr": "0x405c70",
            "funcEndAddr": "0x4061d7",
            "decompiledFuncCode": "\nuint FUN_00405c70(uint param_1,undefined8 *param_2,char *param_3,long param_4,undefined8 param_5,\n                 ulong param_6,uint *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long lVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  uint uVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  undefined1 *puVar15;\n  \n  bVar14 = 0;\n  uVar3 = param_7[1];\n  if ((int)param_1 < 1) {\n    return 0xffffffff;\n  }\n  uVar11 = *param_7;\n  *(undefined8 *)(param_7 + 4) = 0;\n  if (uVar11 == 0) {\n    *param_7 = 1;\n    uVar11 = 1;\nLAB_00405cba:\n    param_7[0xc] = uVar11;\n    param_7[0xb] = uVar11;\n    *(undefined8 *)(param_7 + 8) = 0;\n    if (*param_3 == '-') {\n      param_7[10] = 2;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else if (*param_3 == '+') {\n      param_7[10] = 0;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else {\n      pbVar8 = (byte *)0x0;\n      if (param_8 == 0) {\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        param_6 = param_6 & 0xffffffff;\n        if (pcVar4 == (char *)0x0) {\n          param_7[10] = 1;\n          pbVar8 = *(byte **)(param_7 + 8);\n          goto LAB_00405dbd;\n        }\n        pbVar8 = *(byte **)(param_7 + 8);\n      }\n      param_7[10] = 0;\n    }\nLAB_00405dbd:\n    param_7[6] = 1;\n    cVar2 = *param_3;\nLAB_00405dc8:\n    if (cVar2 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 == (byte *)0x0) goto LAB_00405d38;\nLAB_00405ddc:\n    if (*pbVar8 == 0) goto LAB_00405d38;\n  }\n  else {\n    if (param_7[6] == 0) goto LAB_00405cba;\n    cVar2 = *param_3;\n    pbVar8 = *(byte **)(param_7 + 8);\n    if ((cVar2 - 0x2bU & 0xfd) != 0) goto LAB_00405dc8;\n    pcVar4 = param_3 + 1;\n    param_3 = param_3 + 1;\n    if (*pcVar4 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 != (byte *)0x0) goto LAB_00405ddc;\nLAB_00405d38:\n    uVar11 = *param_7;\n    if (param_7[0xc] != uVar11 && (int)uVar11 <= (int)param_7[0xc]) {\n      param_7[0xc] = uVar11;\n    }\n    if ((int)uVar11 < (int)param_7[0xb]) {\n      param_7[0xb] = uVar11;\n    }\n    if (param_7[10] == 1) {\n      uVar7 = param_7[0xc];\n      if (param_7[0xb] == uVar7) {\n        if (uVar11 != uVar7) {\n          param_7[0xb] = uVar11;\n          uVar7 = uVar11;\n        }\n      }\n      else if (uVar11 != uVar7) {\n        FUN_00405570(param_2,param_7);\n        param_6 = param_6 & 0xffffffff;\n        uVar7 = *param_7;\n      }\n      uVar11 = uVar7;\n      uVar7 = uVar11;\n      if ((int)uVar11 < (int)param_1) {\n        lVar6 = (long)(int)uVar11;\n        do {\n          if ((*(char *)param_2[lVar6] == '-') && (((char *)param_2[lVar6])[1] != '\\0')) {\n            uVar11 = *param_7;\n            uVar7 = (uint)lVar6;\n            break;\n          }\n          uVar11 = (uint)lVar6 + 1;\n          lVar6 = lVar6 + 1;\n          *param_7 = uVar11;\n          uVar7 = uVar11;\n        } while ((int)lVar6 < (int)param_1);\n      }\n      param_7[0xc] = uVar7;\n    }\n    bVar12 = param_1 < uVar11;\n    bVar13 = param_1 == uVar11;\n    if (bVar13) {\n      param_1 = param_7[0xc];\n      uVar11 = param_7[0xb];\nLAB_00405ea6:\n      if (uVar11 != param_1) {\n        *param_7 = uVar11;\n      }\n      return 0xffffffff;\n    }\n    lVar6 = 3;\n    pbVar8 = (byte *)param_2[(int)uVar11];\n    pbVar9 = pbVar8;\n    pbVar10 = &DAT_00408be9;\n    do {\n      if (lVar6 == 0) break;\n      lVar6 = lVar6 + -1;\n      bVar12 = *pbVar9 < *pbVar10;\n      bVar13 = *pbVar9 == *pbVar10;\n      pbVar9 = pbVar9 + (ulong)bVar14 * -2 + 1;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n    if ((!bVar12 && !bVar13) == bVar12) {\n      uVar11 = uVar11 + 1;\n      *param_7 = uVar11;\n      if (param_7[0xb] == param_7[0xc]) {\n        param_7[0xb] = uVar11;\n      }\n      else {\n        bVar12 = uVar11 != param_7[0xc];\n        uVar11 = param_7[0xb];\n        if (bVar12) {\n          FUN_00405570(param_2,param_7);\n          uVar11 = param_7[0xb];\n        }\n      }\n      param_7[0xc] = param_1;\n      *param_7 = param_1;\n      goto LAB_00405ea6;\n    }\n    if ((*pbVar8 != 0x2d) || (bVar14 = pbVar8[1], bVar14 == 0)) {\n      if (param_7[10] == 0) {\n        return 0xffffffff;\n      }\n      *(byte **)(param_7 + 4) = pbVar8;\n      *param_7 = uVar11 + 1;\n      return 1;\n    }\n    if (param_4 != 0) {\n      if (bVar14 == 0x2d) {\n        *(byte **)(param_7 + 8) = pbVar8 + 2;\n        puVar15 = &DAT_00408be9;\n        goto LAB_00406005;\n      }\n      if ((int)param_6 != 0) {\n        if (pbVar8[2] == 0) {\n          pcVar4 = strchr(param_3,(int)(char)bVar14);\n          param_6 = param_6 & 0xffffffff;\n          if (pcVar4 != (char *)0x0) goto LAB_00405fb0;\n        }\n        *(byte **)(param_7 + 8) = pbVar8 + 1;\n        uVar11 = FUN_00405650(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,\n                              &DAT_00408bea);\n        if (uVar11 != 0xffffffff) {\n          return uVar11;\n        }\n        pbVar8 = (byte *)param_2[(int)*param_7];\n      }\n    }\nLAB_00405fb0:\n    pbVar8 = pbVar8 + 1;\n  }\n  pbVar9 = pbVar8 + 1;\n  *(byte **)(param_7 + 8) = pbVar9;\n  bVar14 = *pbVar8;\n  uVar11 = (uint)(char)bVar14;\n  pcVar4 = strchr(param_3,uVar11);\n  if (pbVar8[1] == 0) {\n    *param_7 = *param_7 + 1;\n  }\n  if (((byte)(bVar14 - 0x3a) < 2) || (pcVar4 == (char *)0x0)) {\n    if (uVar3 != 0) {\n      uVar1 = *param_2;\n      uVar5 = dcgettext(0,\"%s: invalid option -- \\'%c\\'\\n\",5);\n      __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n    }\n    param_7[2] = uVar11;\n    return 0x3f;\n  }\n  if (((*pcVar4 != 'W') || (param_4 == 0)) || (pcVar4[1] != ';')) {\n    if (pcVar4[1] == ':') {\n      if (pcVar4[2] == ':') {\n        if (pbVar8[1] == 0) {\n          *(undefined8 *)(param_7 + 4) = 0;\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = *param_7 + 1;\n        }\n      }\n      else {\n        uVar7 = *param_7;\n        if (pbVar8[1] == 0) {\n          if (param_1 == uVar7) {\n            if (uVar3 != 0) {\n              uVar1 = *param_2;\n              uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n              __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n            }\n            param_7[2] = uVar11;\n            uVar11 = (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          else {\n            uVar1 = param_2[(int)uVar7];\n            *param_7 = uVar7 + 1;\n            *(undefined8 *)(param_7 + 4) = uVar1;\n          }\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = uVar7 + 1;\n        }\n      }\n      *(undefined8 *)(param_7 + 8) = 0;\n      return uVar11;\n    }\n    return uVar11;\n  }\n  if (pbVar8[1] == 0) {\n    if (*param_7 == param_1) {\n      if (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n        __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n      }\n      param_7[2] = uVar11;\n      return (uint)(*param_3 != ':') * 5 + 0x3a;\n    }\n    pbVar9 = (byte *)param_2[(int)*param_7];\n  }\n  *(byte **)(param_7 + 8) = pbVar9;\n  param_6 = 0;\n  *(undefined8 *)(param_7 + 4) = 0;\n  puVar15 = &DAT_00408c08;\nLAB_00406005:\n  uVar3 = FUN_00405650(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,puVar15);\n  return uVar3;\n}\n\n",
            "funcName": "FUN_00405c70"
        },
        {
            "funcStartAddr": "0x406240",
            "funcEndAddr": "0x406296",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00406240(void)\n\n{\n  DAT_0060b6a0 = DAT_0060b318._4_4_;\n  _DAT_0060b6a4 = (undefined4)DAT_0060b318;\n  FUN_00405c70();\n  DAT_0060b318._4_4_ = DAT_0060b6a0;\n  DAT_0060b6e0 = DAT_0060b6b0;\n  _DAT_0060b314 = DAT_0060b6a8;\n  return;\n}\n\n",
            "funcName": "FUN_00406240"
        },
        {
            "funcStartAddr": "0x4062a0",
            "funcEndAddr": "0x4062b8",
            "decompiledFuncCode": "\nvoid FUN_004062a0(void)\n\n{\n  FUN_00406240();\n  return;\n}\n\n",
            "funcName": "FUN_004062a0"
        },
        {
            "funcStartAddr": "0x4062c0",
            "funcEndAddr": "0x4062d3",
            "decompiledFuncCode": "\nvoid FUN_004062c0(void)\n\n{\n  FUN_00406240();\n  return;\n}\n\n",
            "funcName": "FUN_004062c0"
        },
        {
            "funcStartAddr": "0x4062e0",
            "funcEndAddr": "0x4062f5",
            "decompiledFuncCode": "\nvoid FUN_004062e0(void)\n\n{\n  FUN_00405c70();\n  return;\n}\n\n",
            "funcName": "FUN_004062e0"
        },
        {
            "funcStartAddr": "0x406300",
            "funcEndAddr": "0x406316",
            "decompiledFuncCode": "\nvoid FUN_00406300(void)\n\n{\n  FUN_00406240();\n  return;\n}\n\n",
            "funcName": "FUN_00406300"
        },
        {
            "funcStartAddr": "0x406320",
            "funcEndAddr": "0x406338",
            "decompiledFuncCode": "\nvoid FUN_00406320(void)\n\n{\n  FUN_00405c70();\n  return;\n}\n\n",
            "funcName": "FUN_00406320"
        },
        {
            "funcStartAddr": "0x406340",
            "funcEndAddr": "0x4063af",
            "decompiledFuncCode": "\nsize_t FUN_00406340(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  wchar_t local_1c;\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = 1;\n    param_2 = (byte *)0x408c07;\n  }\n  else {\n    if (param_3 == 0) {\n      return 0xfffffffffffffffe;\n    }\n    if (param_1 != (wchar_t *)0x0) goto LAB_00406364;\n  }\n  param_1 = &local_1c;\nLAB_00406364:\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (cVar1 = FUN_00406650(0), cVar1 == '\\0')) {\n    sVar2 = 1;\n    *param_1 = (uint)*param_2;\n  }\n  return sVar2;\n}\n\n",
            "funcName": "FUN_00406340"
        },
        {
            "funcStartAddr": "0x4063c0",
            "funcEndAddr": "0x406511",
            "decompiledFuncCode": "\nint FUN_004063c0(byte *param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong uVar3;\n  long lVar4;\n  uint uVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  char *__s1;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  char *local_30 [2];\n  \n  bVar10 = 0;\n  __s1 = \"HUP\";\n  uVar3 = 0;\n  if ((int)(char)*param_1 - 0x30U < 10) {\n    uVar3 = strtol((char *)param_1,local_30,10);\n    if ((*local_30[0] == '\\0') && ((long)uVar3 < 0x41)) {\nLAB_0040640e:\n      *param_2 = (int)uVar3;\n      return (int)uVar3 >> 0x1f;\n    }\n  }\n  else {\n    do {\n      iVar1 = strcmp(__s1,(char *)param_1);\n      if (iVar1 == 0) {\n        uVar3 = (ulong)(uint)(&DAT_0060b320)[uVar3 * 3];\n        goto LAB_0040640e;\n      }\n      uVar5 = (int)uVar3 + 1;\n      uVar3 = (ulong)uVar5;\n      __s1 = __s1 + 0xc;\n    } while (uVar5 != 0x23);\n    iVar1 = __libc_current_sigrtmin();\n    iVar2 = __libc_current_sigrtmax();\n    bVar8 = false;\n    bVar9 = iVar1 == 0;\n    if (0 < iVar1) {\n      lVar4 = 5;\n      pbVar6 = param_1;\n      pbVar7 = (byte *)\"RTMIN\";\n      do {\n        if (lVar4 == 0) break;\n        lVar4 = lVar4 + -1;\n        bVar8 = *pbVar6 < *pbVar7;\n        bVar9 = *pbVar6 == *pbVar7;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        pbVar7 = pbVar7 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      if ((!bVar8 && !bVar9) == bVar8) {\n        lVar4 = strtol((char *)(param_1 + 5),local_30,10);\n        if (((*local_30[0] == '\\0') && (-1 < lVar4)) && (lVar4 <= iVar2 - iVar1)) {\n          uVar3 = (ulong)(uint)((int)lVar4 + iVar1);\n          goto LAB_0040640e;\n        }\n        goto LAB_00406440;\n      }\n    }\n    bVar8 = false;\n    bVar9 = iVar2 == 0;\n    if (0 < iVar2) {\n      lVar4 = 5;\n      pbVar6 = param_1;\n      pbVar7 = (byte *)\"RTMAX\";\n      do {\n        if (lVar4 == 0) break;\n        lVar4 = lVar4 + -1;\n        bVar8 = *pbVar6 < *pbVar7;\n        bVar9 = *pbVar6 == *pbVar7;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        pbVar7 = pbVar7 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      if ((((!bVar8 && !bVar9) == bVar8) &&\n          (lVar4 = strtol((char *)(param_1 + 5),local_30,10), *local_30[0] == '\\0')) &&\n         ((iVar1 - iVar2 <= lVar4 && (lVar4 < 1)))) {\n        uVar3 = (ulong)(uint)((int)lVar4 + iVar2);\n        goto LAB_0040640e;\n      }\n    }\n  }\nLAB_00406440:\n  *param_2 = -1;\n  return -1;\n}\n\n",
            "funcName": "FUN_004063c0"
        },
        {
            "funcStartAddr": "0x406520",
            "funcEndAddr": "0x4065dd",
            "decompiledFuncCode": "\nint FUN_00406520(int param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  uint uVar4;\n  ulong uVar5;\n  \n  piVar3 = &DAT_0060b320;\n  uVar5 = 0;\n  do {\n    if (*piVar3 == param_1) {\n      strcpy((char *)param_2,&DAT_0060b324 + uVar5 * 0xc);\n      return 0;\n    }\n    uVar4 = (int)uVar5 + 1;\n    uVar5 = (ulong)uVar4;\n    piVar3 = piVar3 + 3;\n  } while (uVar4 != 0x23);\n  iVar1 = __libc_current_sigrtmin();\n  iVar2 = __libc_current_sigrtmax();\n  if ((param_1 < iVar1) || (iVar2 < param_1)) {\n    param_1 = -1;\n  }\n  else {\n    if ((iVar2 - iVar1 >> 1) + iVar1 < param_1) {\n      *param_2 = 0x414d5452;\n      *(undefined2 *)(param_2 + 1) = 0x58;\n      iVar1 = iVar2;\n    }\n    else {\n      *param_2 = 0x494d5452;\n      *(undefined2 *)(param_2 + 1) = 0x4e;\n    }\n    param_1 = param_1 - iVar1;\n    if (param_1 != 0) {\n      __sprintf_chk((long)param_2 + 5,1,0xffffffffffffffff,&DAT_00408c18,param_1);\n      return 0;\n    }\n  }\n  return param_1;\n}\n\n",
            "funcName": "FUN_00406520"
        },
        {
            "funcStartAddr": "0x4065f0",
            "funcEndAddr": "0x40664c",
            "decompiledFuncCode": "\nulong FUN_004065f0(uint *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  uVar1 = *param_1;\n  uVar3 = FUN_00406c20(param_1);\n  if ((uVar1 & 0x20) == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_004065f0"
        },
        {
            "funcStartAddr": "0x406650",
            "funcEndAddr": "0x4066a6",
            "decompiledFuncCode": "\nbool FUN_00406650(int param_1)\n\n{\n  bool bVar1;\n  byte *pbVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  pbVar2 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar1 = true;\n  bVar6 = false;\n  bVar8 = pbVar2 == (byte *)0x0;\n  if (!bVar8) {\n    lVar3 = 2;\n    pbVar4 = pbVar2;\n    pbVar5 = &DAT_0040797b;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar8 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n    } while (bVar8);\n    bVar1 = false;\n    bVar7 = false;\n    bVar6 = (!bVar6 && !bVar8) == bVar6;\n    if (!bVar6) {\n      lVar3 = 6;\n      pbVar4 = (byte *)\"POSIX\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar2 < *pbVar4;\n        bVar6 = *pbVar2 == *pbVar4;\n        pbVar2 = pbVar2 + (ulong)bVar9 * -2 + 1;\n        pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      } while (bVar6);\n      return (!bVar7 && !bVar6) != bVar7;\n    }\n  }\n  return bVar1;\n}\n\n",
            "funcName": "FUN_00406650"
        },
        {
            "funcStartAddr": "0x4066b0",
            "funcEndAddr": "0x406c04",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * FUN_004066b0(void)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  char *__s1;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  size_t __n;\n  char *__file;\n  FILE *__stream;\n  byte *pbVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  ulong uVar12;\n  undefined8 *puVar13;\n  char *__ptr;\n  bool bVar14;\n  long local_d0;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined auStack_80 [8];\n  undefined8 local_78;\n  \n  __s1 = nl_langinfo(0xe);\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  if (DAT_0060b6d8 != (char *)0x0) goto LAB_004066ea;\n  pcVar7 = getenv(\"CHARSETALIASDIR\");\n  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\\0')) {\n    sVar6 = 0x73;\n    sVar5 = 0x65;\n    __n = 100;\n    pcVar7 = \n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\"\n    ;\nLAB_004067d5:\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      __file[__n] = '/';\n      goto LAB_004067f6;\n    }\n  }\n  else {\n    __n = strlen(pcVar7);\n    if (__n == 0) {\n      sVar6 = 0xe;\n    }\n    else {\n      if (pcVar7[__n - 1] != '/') {\n        sVar6 = __n + 0xf;\n        sVar5 = __n + 1;\n        goto LAB_004067d5;\n      }\n      sVar6 = __n + 0xe;\n    }\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      sVar5 = __n;\nLAB_004067f6:\n      puVar13 = (undefined8 *)(__file + sVar5);\n      *puVar13 = 0x2e74657372616863;\n      *(undefined2 *)((long)puVar13 + 0xc) = 0x73;\n      *(undefined4 *)(puVar13 + 1) = 0x61696c61;\n      iVar2 = open(__file,0);\n      if (-1 < iVar2) {\n        __stream = fdopen(iVar2,\"r\");\n        local_d0 = 0;\n        if (__stream != (FILE *)0x0) {\n          pcVar7 = (char *)0x0;\nLAB_00406890:\n          pbVar8 = (byte *)__stream->_IO_read_ptr;\n          if (__stream->_IO_read_end <= pbVar8) goto LAB_00406a1c;\n          do {\n            __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n            uVar4 = (uint)*pbVar8;\n            __ptr = pcVar7;\n            while( true ) {\n              pcVar7 = __ptr;\n              if ((uVar4 - 9 < 2) || (uVar4 == 0x20)) goto LAB_00406890;\n              if (uVar4 == 0x23) goto LAB_00406a81;\n              ungetc(uVar4,__stream);\n              iVar2 = fscanf(__stream,\"%50s %50s\",&local_b8,&local_78);\n              puVar13 = &local_b8;\n              if (iVar2 < 2) goto LAB_00406a2f;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              lVar11 = (long)puVar13 +\n                       ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_b8);\n              puVar13 = &local_78;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              local_c0 = (long)puVar13 +\n                         ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_78);\n              lVar9 = lVar11 + local_c0;\n              if (local_d0 == 0) {\n                pcVar7 = (char *)malloc(lVar9 + 3);\n              }\n              else {\n                lVar9 = lVar9 + local_d0;\n                pcVar7 = (char *)realloc(__ptr,lVar9 + 3);\n              }\n              local_d0 = lVar9 + 2;\n              if (pcVar7 == (char *)0x0) {\n                pcVar7 = \"\";\n                free(__ptr);\n                FUN_00406c20(__stream);\n                goto LAB_00406834;\n              }\n              uVar12 = lVar11 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (-2 - lVar11) + (local_d0 - local_c0));\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_b8;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 2));\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_b8;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 4));\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_b8._4_4_,(undefined4)local_b8);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 8));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_b8 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              uVar12 = local_c0 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (local_d0 - local_c0) + -1);\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_78;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 6);\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_78;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 4);\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_78._4_4_,(undefined4)local_78);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)auStack_80 + (uVar12 & 0xffffffff));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_78 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              pbVar8 = (byte *)__stream->_IO_read_ptr;\n              if (pbVar8 < __stream->_IO_read_end) break;\nLAB_00406a1c:\n              uVar4 = __uflow(__stream);\n              __ptr = pcVar7;\n              if (uVar4 == 0xffffffff) goto LAB_00406a2f;\n            }\n          } while( true );\n        }\n        close(iVar2);\n      }\n      goto LAB_0040682e;\n    }\n  }\n  DAT_0060b6d8 = \"\";\nLAB_004066ea:\n  cVar1 = *DAT_0060b6d8;\n  pcVar7 = DAT_0060b6d8;\n  do {\n    if (cVar1 == '\\0') {\nLAB_00406744:\n      if (*__s1 == '\\0') {\n        __s1 = \"ASCII\";\n      }\n      return __s1;\n    }\n    iVar2 = strcmp(__s1,pcVar7);\n    if ((iVar2 == 0) || ((cVar1 == '*' && (pcVar7[1] == '\\0')))) {\n      sVar6 = strlen(pcVar7);\n      __s1 = pcVar7 + sVar6 + 1;\n      goto LAB_00406744;\n    }\n    sVar6 = strlen(pcVar7);\n    sVar5 = strlen(pcVar7 + sVar6 + 1);\n    pcVar7 = pcVar7 + sVar6 + 1 + sVar5 + 1;\n    cVar1 = *pcVar7;\n  } while( true );\nLAB_00406a81:\n  do {\n    pbVar8 = (byte *)__stream->_IO_read_ptr;\n    if (pbVar8 < __stream->_IO_read_end) {\n      __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n      uVar4 = (uint)*pbVar8;\n      bVar14 = true;\n    }\n    else {\n      uVar4 = __uflow(__stream);\n      bVar14 = uVar4 != 0xffffffff;\n    }\n  } while ((uVar4 != 10) && (bVar14));\n  if (uVar4 == 0xffffffff) goto LAB_00406a2f;\n  goto LAB_00406890;\nLAB_00406a2f:\n  FUN_00406c20(__stream);\n  if (local_d0 == 0) {\nLAB_0040682e:\n    pcVar7 = \"\";\n  }\n  else {\n    pcVar7[local_d0] = '\\0';\n  }\nLAB_00406834:\n  free(__file);\n  DAT_0060b6d8 = pcVar7;\n  goto LAB_004066ea;\n}\n\n",
            "funcName": "FUN_004066b0"
        },
        {
            "funcStartAddr": "0x406c20",
            "funcEndAddr": "0x406c98",
            "decompiledFuncCode": "\nint FUN_00406c20(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00406c87;\n    }\n    iVar1 = FUN_00406ca0(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00406c87:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_00406c20"
        },
        {
            "funcStartAddr": "0x406ca0",
            "funcEndAddr": "0x406cdb",
            "decompiledFuncCode": "\nvoid FUN_00406ca0(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if ((iVar1 != 0) && ((param_1->_flags & 0x100U) != 0)) {\n      FUN_00406ce0(param_1,0,1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00406ca0"
        },
        {
            "funcStartAddr": "0x406ce0",
            "funcEndAddr": "0x406d36",
            "decompiledFuncCode": "\nulong FUN_00406ce0(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  uint uVar1;\n  int __fd;\n  ulong uVar2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    __fd = fileno(param_1);\n    uVar2 = lseek(__fd,param_2,param_3);\n    if (uVar2 != 0xffffffffffffffff) {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = uVar2;\n      uVar2 = 0;\n    }\n    return uVar2;\n  }\n  uVar1 = fseeko(param_1,param_2,param_3);\n  return (ulong)uVar1;\n}\n\n",
            "funcName": "FUN_00406ce0"
        },
        {
            "funcStartAddr": "0x406d40",
            "funcEndAddr": "0x406d9d",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00406d73) */\n/* WARNING: Removing unreachable block (ram,0x00406d78) */\n\nvoid FUN_00406d40(void)\n\n{\n  __DT_INIT();\n  return;\n}\n\n",
            "funcName": "FUN_00406d40"
        },
        {
            "funcStartAddr": "0x406da0",
            "funcEndAddr": "0x406da1",
            "decompiledFuncCode": "\nvoid FUN_00406da0(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_00406da0"
        },
        {
            "funcStartAddr": "0x406db0",
            "funcEndAddr": "0x406dc8",
            "decompiledFuncCode": "\nvoid FUN_00406db0(undefined8 param_1)\n\n{\n  __cxa_atexit(param_1,0,DAT_0060b288);\n  return;\n}\n\n",
            "funcName": "FUN_00406db0"
        },
        {
            "funcStartAddr": "0x406dc8",
            "funcEndAddr": "0x406de8",
            "decompiledFuncCode": "\nundefined8 FUN_00406dc8(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  code **ppcVar1;\n  \n  for (ppcVar1 = (code **)&DAT_0060ae10; *ppcVar1 != (code *)0xffffffffffffffff;\n      ppcVar1 = ppcVar1 + -1) {\n    (**ppcVar1)();\n  }\n  return param_3;\n}\n\n",
            "funcName": "FUN_00406dc8"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_timeout.elf",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}