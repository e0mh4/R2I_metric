{
    "funcCount": 251,
    "funcInfo": [
        {
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f05",
            "decompiledFuncCode": "\nvoid FUN_00402f00(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f00"
        },
        {
            "funcStartAddr": "0x402f05",
            "funcEndAddr": "0x402f0a",
            "decompiledFuncCode": "\nvoid FUN_00402f05(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f05"
        },
        {
            "funcStartAddr": "0x402f0a",
            "funcEndAddr": "0x402f0f",
            "decompiledFuncCode": "\nvoid FUN_00402f0a(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f0a"
        },
        {
            "funcStartAddr": "0x402f0f",
            "funcEndAddr": "0x402f14",
            "decompiledFuncCode": "\nvoid FUN_00402f0f(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f0f"
        },
        {
            "funcStartAddr": "0x402f19",
            "funcEndAddr": "0x402f1e",
            "decompiledFuncCode": "\nvoid FUN_00402f19(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f19"
        },
        {
            "funcStartAddr": "0x402f1e",
            "funcEndAddr": "0x402f23",
            "decompiledFuncCode": "\nvoid FUN_00402f1e(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f1e"
        },
        {
            "funcStartAddr": "0x402f23",
            "funcEndAddr": "0x402f28",
            "decompiledFuncCode": "\nvoid FUN_00402f23(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f23"
        },
        {
            "funcStartAddr": "0x402f28",
            "funcEndAddr": "0x402f2d",
            "decompiledFuncCode": "\nvoid FUN_00402f28(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f28"
        },
        {
            "funcStartAddr": "0x402f2d",
            "funcEndAddr": "0x402f32",
            "decompiledFuncCode": "\nvoid FUN_00402f2d(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f2d"
        },
        {
            "funcStartAddr": "0x402f37",
            "funcEndAddr": "0x402f3c",
            "decompiledFuncCode": "\nvoid FUN_00402f37(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402f37"
        },
        {
            "funcStartAddr": "0x402f3c",
            "funcEndAddr": "0x402f41",
            "decompiledFuncCode": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "thunk_402f3c"
        },
        {
            "funcStartAddr": "0x402f50",
            "funcEndAddr": "0x4051b3",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Could not reconcile some variable overlaps */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_00402f50(ulong param_1,undefined8 *param_2)\n\n{\n  ushort uVar1;\n  __int32_t *p_Var2;\n  FILE *pFVar3;\n  pthread_mutex_t *ppVar4;\n  char cVar5;\n  char cVar6;\n  int iVar7;\n  int iVar8;\n  uint uVar9;\n  lconv *plVar10;\n  ushort **ppuVar11;\n  __int32_t **pp_Var12;\n  pthread_mutex_t *ppVar13;\n  size_t sVar14;\n  undefined *puVar15;\n  long **__ptr;\n  char *pcVar16;\n  undefined8 *puVar17;\n  ulong uVar18;\n  long **pplVar19;\n  undefined *puVar20;\n  undefined8 uVar21;\n  long *plVar22;\n  _union_1454 _Var23;\n  undefined8 uVar24;\n  undefined8 uVar25;\n  ulong uVar26;\n  undefined **ppuVar27;\n  long lVar28;\n  pthread_mutex_t *ppVar29;\n  void *__n;\n  undefined **ppuVar30;\n  pthread_mutex_t *ppVar31;\n  pthread_mutex_t *extraout_RDX;\n  long *plVar32;\n  long **pplVar33;\n  void **ppvVar34;\n  long **pplVar35;\n  byte bVar36;\n  ulong *puVar37;\n  byte *pbVar38;\n  undefined *puVar39;\n  pthread_mutex_t *in_R10;\n  ushort *in_R11;\n  ulong unaff_R12;\n  void *pvVar40;\n  void *pvVar41;\n  long lVar42;\n  long **pplVar43;\n  void **ppvVar44;\n  bool bVar45;\n  undefined uVar46;\n  bool bVar47;\n  undefined uVar48;\n  byte bVar49;\n  double dVar50;\n  double dVar51;\n  undefined auVar52 [16];\n  undefined8 local_388;\n  long *local_380;\n  pthread_mutex_t *local_378;\n  pthread_mutex_t *local_370;\n  pthread_mutex_t *local_368;\n  _union_1454 local_360;\n  undefined8 local_358;\n  char *local_350;\n  long *local_348;\n  undefined8 local_340;\n  _union_1454 local_338;\n  pthread_mutex_t *local_330;\n  long **local_328;\n  byte *local_320;\n  undefined local_2f8 [48];\n  undefined local_2c8 [16];\n  ulong local_2b8;\n  long **local_2b0;\n  void *local_2a8;\n  char local_298;\n  ulong local_288;\n  ulong local_280;\n  long local_278;\n  long local_270 [4];\n  undefined local_24f;\n  undefined8 local_238;\n  undefined local_230 [16];\n  undefined local_220 [16];\n  undefined local_210 [16];\n  undefined local_200 [16];\n  undefined local_1e8 [16];\n  __nlink_t local_1d8;\n  uint local_1d0;\n  __uid_t _Stack_1cc;\n  ulong local_1b8;\n  undefined local_158 [12];\n  undefined4 uStack_14c;\n  undefined4 uStack_148;\n  undefined4 uStack_144;\n  undefined4 local_140;\n  undefined4 uStack_13c;\n  undefined4 uStack_138;\n  undefined4 uStack_134;\n  undefined4 local_130;\n  undefined4 uStack_12c;\n  undefined4 uStack_128;\n  undefined4 uStack_124;\n  undefined4 local_120;\n  undefined4 uStack_11c;\n  undefined4 uStack_118;\n  undefined4 uStack_114;\n  undefined4 local_110;\n  undefined4 uStack_10c;\n  undefined4 uStack_108;\n  undefined4 uStack_104;\n  undefined local_100 [16];\n  undefined local_f0 [16];\n  undefined4 local_e0;\n  undefined4 uStack_dc;\n  undefined4 uStack_d8;\n  undefined4 uStack_d4;\n  int local_d0;\n  \n  bVar49 = 0;\n  puVar15 = (undefined *)(param_1 & 0xffffffff);\n  local_350 = getenv(\"POSIXLY_CORRECT\");\n  uVar18 = unaff_R12 & 0xffffffffffffff00 | (ulong)(local_350 != (char *)0x0);\n  iVar7 = FUN_0040dbe0();\n  local_380 = (long *)((ulong)local_380 & 0xffffffffffffff00 | (ulong)(0x2b8 < iVar7 - 0x30db0U));\n  FUN_0040dc60(*param_2);\n  local_360.sa_handler = (__sighandler_t)setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\n                 \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\"\n                );\n  textdomain(\"coreutils\");\n  DAT_0061c518 = 2;\n  DAT_0061cba1 = FUN_0040bd10(3);\n  cVar5 = FUN_0040bd10(2);\n  DAT_0061cba0 = cVar5;\n  plVar10 = localeconv();\n  bVar36 = *plVar10->decimal_point;\n  DAT_0061cba8 = (uint)bVar36;\n  if ((bVar36 == 0) || (plVar10->decimal_point[1] != 0)) {\n    DAT_0061cba8 = 0x2e;\n  }\n  bVar36 = *plVar10->thousands_sep;\n  DAT_0061cba4 = (uint)bVar36;\n  if ((bVar36 == 0) || (plVar10->thousands_sep[1] != 0)) {\n    DAT_0061cba4 = 0xffffffff;\n  }\n  DAT_0061c758 = '\\0';\n  ppuVar11 = __ctype_b_loc();\n  pp_Var12 = __ctype_toupper_loc();\n  puVar39 = (undefined *)0x1;\n  lVar42 = 0;\nLAB_004030bd:\n  do {\n    uVar46 = 1;\n    uVar1 = (*ppuVar11)[lVar42];\n    if ((uVar1 & 1) == 0) {\n      if (lVar42 == 10) {\n        DAT_0061ca8a = 1;\n        DAT_0061c88a = 0;\n        DAT_0061c98a = ((byte)((*ppuVar11)[10] >> 0xe) ^ 1) & 1;\n        DAT_0061c78a = (undefined)(*pp_Var12)[10];\n        lVar42 = 0xb;\n        goto LAB_004030bd;\n      }\n      uVar46 = 0;\n    }\n    (&DAT_0061ca80)[lVar42] = uVar46;\n    (&DAT_0061c980)[lVar42] = ((byte)(uVar1 >> 0xe) ^ 1) & 1;\n    bVar36 = 0;\n    if ((uVar1 & 8) == 0) {\n      bVar36 = ((byte)uVar1 & 1 | lVar42 == 10) ^ 1;\n    }\n    p_Var2 = *pp_Var12;\n    (&DAT_0061c880)[lVar42] = bVar36;\n    lVar28 = lVar42 + 1;\n    (&DAT_0061c780)[lVar42] = (char)p_Var2[lVar42];\n    lVar42 = lVar28;\n  } while (lVar28 != 0x100);\n  if (cVar5 != '\\0') {\n    local_388 = (FILE *)((ulong)local_388 & 0xffffffff00000000 | (ulong)puVar15);\n    lVar42 = 1;\n    do {\n      ppVar13 = (pthread_mutex_t *)nl_langinfo((int)lVar42 + 0x2000d);\n      sVar14 = strlen(ppVar13->__size);\n      puVar15 = (undefined *)FUN_00411210(sVar14 + 1);\n      *(undefined **)(&UNK_0061c430 + lVar42 * 0x10) = puVar15;\n      *(int *)(&UNK_0061c438 + lVar42 * 0x10) = (int)lVar42;\n      puVar39 = puVar15;\n      if (sVar14 != 0) {\n        in_R11 = *ppuVar11;\n        in_R10 = (pthread_mutex_t *)(ppVar13->__size + sVar14);\n        lVar28 = 0;\n        do {\n          if ((*(byte *)(in_R11 + (byte)ppVar13->__size[0]) & 1) == 0) {\n            lVar28 = lVar28 + 1;\n            *puVar39 = (&DAT_0061c780)[(byte)ppVar13->__size[0]];\n            puVar39 = puVar15 + lVar28;\n          }\n          ppVar13 = (pthread_mutex_t *)((long)&(ppVar13->__data).__lock + 1);\n        } while (in_R10 != ppVar13);\n      }\n      lVar42 = lVar42 + 1;\n      *puVar39 = 0;\n    } while (lVar42 != 0xd);\n    puVar15 = (undefined *)((ulong)local_388 & 0xffffffff);\n    qsort(&PTR_DAT_0061c440,0xc,0x10,FUN_00405cf0);\n  }\n  iVar7 = 0xe;\n  lVar42 = 0;\n  sigemptyset((sigset_t *)&DAT_0061c6c0);\n  while( true ) {\n    sigaction(iVar7,(sigaction *)0x0,(sigaction *)local_158);\n    if (local_158._0_8_ != (__sighandler_t)0x1) {\n      sigaddset((sigset_t *)&DAT_0061c6c0,iVar7);\n    }\n    lVar42 = lVar42 + 1;\n    if (lVar42 == 0xb) break;\n    iVar7 = *(int *)(&UNK_00414980 + lVar42 * 4);\n  }\n  local_158._0_8_ = FUN_00405d80;\n  iVar7 = 0xe;\n  local_d0 = 0;\n  lVar42 = 0;\n  local_158._8_4_ = _DAT_0061c6c0;\n  uStack_14c = uRam000000000061c6c4;\n  uStack_148 = uRam000000000061c6c8;\n  uStack_144 = uRam000000000061c6cc;\n  local_140 = _DAT_0061c6d0;\n  uStack_13c = uRam000000000061c6d4;\n  uStack_138 = uRam000000000061c6d8;\n  uStack_134 = uRam000000000061c6dc;\n  local_130 = _DAT_0061c6e0;\n  uStack_12c = uRam000000000061c6e4;\n  uStack_128 = uRam000000000061c6e8;\n  uStack_124 = uRam000000000061c6ec;\n  local_120 = _DAT_0061c6f0;\n  uStack_11c = uRam000000000061c6f4;\n  uStack_118 = uRam000000000061c6f8;\n  uStack_114 = uRam000000000061c6fc;\n  local_110 = _DAT_0061c700;\n  uStack_10c = uRam000000000061c704;\n  uStack_108 = uRam000000000061c708;\n  uStack_104 = uRam000000000061c70c;\n  local_100 = _DAT_0061c710;\n  local_f0 = _DAT_0061c720;\n  local_e0 = _DAT_0061c730;\n  uStack_dc = uRam000000000061c734;\n  uStack_d8 = uRam000000000061c738;\n  uStack_d4 = uRam000000000061c73c;\n  auVar52 = _DAT_0061c720;\n  while( true ) {\n    iVar8 = sigismember((sigset_t *)&DAT_0061c6c0,iVar7);\n    if (iVar8 != 0) {\n      sigaction(iVar7,(sigaction *)local_158,(sigaction *)0x0);\n    }\n    if (lVar42 == 10) break;\n    lVar42 = lVar42 + 1;\n    iVar7 = *(int *)(&UNK_00414980 + lVar42 * 4);\n  }\n  signal(0x11,(__sighandler_t)0x0);\n  FUN_00413f20(FUN_00407890);\n  local_238 = 0xffffffffffffffff;\n  local_230 = ZEXT816(0xffffffffffffffff) << 0x40;\n  local_220 = (undefined  [16])0x0;\n  local_210 = (undefined  [16])0x0;\n  local_200 = (undefined  [16])0x0;\n  if (((long)(int)puVar15 << 3 < 0) || ((ulong)(long)(int)puVar15 >> 0x3d != 0)) {\nLAB_004057e1:\n                    /* WARNING: Subroutine does not return */\n    FUN_00411460();\n  }\n  __ptr = (long **)FUN_00411210();\n  pplVar43 = (long **)0x0;\n  local_358 = (long **)((ulong)local_358 & 0xffffffffffffff00);\n  pplVar19 = (long **)0x0;\n  local_388 = (FILE *)((ulong)local_388 & 0xffffffffffffff00);\n  local_348 = &local_278;\n  local_368 = (pthread_mutex_t *)0x0;\n  local_378 = (pthread_mutex_t *)0x0;\n  local_338.sa_handler = (__sighandler_t)0x0;\n  local_370 = (pthread_mutex_t *)0x0;\n  iVar7 = DAT_0061c424;\n  ppVar13 = DAT_0061c748;\nLAB_0040344f:\n  DAT_0061c748 = ppVar13;\n  DAT_0061c424 = iVar7;\n  local_2f8._0_8_ = CONCAT44(local_2f8._4_4_,0xffffffff);\n  iVar8 = (int)puVar15;\n  if ((int)pplVar19 == -1) {\nLAB_00403460:\n    lVar42 = (long)DAT_0061c578._4_4_;\n    goto LAB_00403430;\n  }\n  if ((pplVar43 != (long **)0x0) && ((char)uVar18 != '\\0')) {\n    lVar42 = (long)DAT_0061c578._4_4_;\n    if (((byte)local_380 == '\\x01') && ((char)local_388 == '\\0')) {\n      if (DAT_0061c578._4_4_ != iVar8) {\n        pcVar16 = (char *)param_2[DAT_0061c578._4_4_];\n        if (((*pcVar16 == '-') && (pcVar16[1] == 'o')) &&\n           ((pcVar16[2] != '\\0' || (DAT_0061c578._4_4_ + 1 != iVar8)))) goto LAB_00403488;\n        goto LAB_00403430;\n      }\n      if (local_378 != (pthread_mutex_t *)0x0) goto LAB_004052df;\n      local_388 = (FILE *)((ulong)local_388 & 0xffffffffffffff00);\n    }\n    else {\nLAB_00403430:\n      if ((int)lVar42 < iVar8) {\n        DAT_0061c578._4_4_ = (int)lVar42 + 1;\n        __ptr[(long)pplVar43] = (long *)param_2[lVar42];\n        pplVar43 = (long **)((long)pplVar43 + 1);\n        iVar7 = DAT_0061c424;\n        ppVar13 = DAT_0061c748;\n        goto LAB_0040344f;\n      }\n      if (local_378 != (pthread_mutex_t *)0x0) {\n        if (pplVar43 != (long **)0x0) {\nLAB_004052df:\n          uVar24 = FUN_0040f630(4,*__ptr);\n          uVar25 = dcgettext(0,\"extra operand %s\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,0,uVar25,uVar24);\n        }\n        lVar42 = FUN_00407cd0(local_378,\"r\");\n        if (lVar42 == 0) {\n          FUN_00407dd0(local_378);\nLAB_00405778:\n          uVar24 = FUN_0040f630(4,local_378);\n          uVar25 = dcgettext(0,\"no input from %s\",5);\n                    /* WARNING: Subroutine does not return */\n          error(2,0,uVar25,uVar24);\n        }\n        FUN_004103a0(local_158);\n        cVar5 = FUN_00410440(lVar42,local_158);\n        if (cVar5 == '\\0') {\n          uVar24 = FUN_0040f630(4,local_378);\n          uVar25 = dcgettext(0,\"cannot read file names from %s\",5);\n                    /* WARNING: Subroutine does not return */\n          error(2,0,uVar25,uVar24);\n        }\n        FUN_00407df0(lVar42);\n        _Var23 = (_union_1454)local_158._0_8_;\n        uVar46 = 0;\n        uVar48 = (long **)local_158._0_8_ == (long **)0x0;\n        if ((bool)uVar48) goto LAB_00405778;\n        free(__ptr);\n        __ptr = (long **)CONCAT44(uStack_14c,local_158._8_4_);\n        do {\n          plVar32 = __ptr[(long)pplVar43];\n          lVar42 = 2;\n          plVar22 = plVar32;\n          pbVar38 = &DAT_0041814a;\n          do {\n            if (lVar42 == 0) break;\n            lVar42 = lVar42 + -1;\n            uVar46 = *(byte *)plVar22 < *pbVar38;\n            uVar48 = *(byte *)plVar22 == *pbVar38;\n            plVar22 = (long *)((long)plVar22 + (ulong)bVar49 * -2 + 1);\n            pbVar38 = pbVar38 + (ulong)bVar49 * -2 + 1;\n          } while ((bool)uVar48);\n          if ((!(bool)uVar46 && !(bool)uVar48) == (bool)uVar46) {\n            uVar24 = FUN_0040f630(4,plVar32);\n            uVar25 = dcgettext(0,\"when reading file names from stdin, no file name of %s allowed\",5)\n            ;\n                    /* WARNING: Subroutine does not return */\n            error(2,0,uVar25,uVar24);\n          }\n          pplVar43 = (long **)((long)pplVar43 + 1);\n          if (*(char *)plVar32 == '\\0') {\n            uVar24 = FUN_0040f700(0,3,local_378);\n            uVar25 = dcgettext(0,\"%s:%lu: invalid zero-length file name\",5);\n                    /* WARNING: Subroutine does not return */\n            error(2,0,uVar25,uVar24,pplVar43);\n          }\n          uVar46 = _Var23.sa_handler < pplVar43;\n          uVar48 = (long **)_Var23.sa_handler == pplVar43;\n        } while (!(bool)uVar48);\n      }\n    }\n    if (DAT_0061c750 != (undefined **)0x0) {\n      puVar15 = (undefined *)0x0;\n      ppuVar27 = DAT_0061c750;\n      ppuVar30 = DAT_0061c750;\n      do {\n        while( true ) {\n          cVar5 = FUN_00405af0(ppuVar30);\n          if ((cVar5 != '\\0') && (*(char *)((long)ppuVar30 + 0x37) == '\\0')) break;\n          pbVar38 = (byte *)((long)ppuVar30 + 0x33);\n          ppuVar30 = (undefined **)ppuVar30[8];\n          puVar15 = (undefined *)(ulong)((uint)puVar15 | (uint)*pbVar38);\n          if (ppuVar30 == (undefined **)0x0) goto LAB_0040365f;\n        }\n        ppuVar30[4] = local_220._8_8_;\n        ppuVar30[5] = local_210._0_8_;\n        *(undefined *)(ppuVar30 + 6) = local_210[8];\n        *(undefined *)((long)ppuVar30 + 0x31) = local_210[9];\n        *(undefined *)((long)ppuVar30 + 0x36) = local_210[14];\n        *(undefined *)((long)ppuVar30 + 0x32) = local_210[10];\n        *(undefined *)((long)ppuVar30 + 0x34) = local_210[12];\n        *(undefined *)((long)ppuVar30 + 0x35) = local_210[13];\n        *(undefined *)((long)ppuVar30 + 0x37) = local_210[15];\n        *(undefined *)(ppuVar30 + 7) = local_200[0];\n        *(byte *)((long)ppuVar30 + 0x33) = local_210[11];\n        ppuVar30 = (undefined **)ppuVar30[8];\n        puVar15 = (undefined *)(ulong)((uint)puVar15 | (uint)local_210[11]);\n      } while (ppuVar30 != (undefined **)0x0);\nLAB_0040365f:\n      uVar18 = 0;\nLAB_00403662:\n      uVar9 = (uint)*(byte *)((long)ppuVar27 + 0x32) + (uint)*(byte *)((long)ppuVar27 + 0x34) +\n              (uint)*(byte *)((long)ppuVar27 + 0x35) + (uint)*(byte *)((long)ppuVar27 + 0x36) +\n              ((uint)*(byte *)((long)ppuVar27 + 0x33) | *(uint *)(ppuVar27 + 7) & 0xff |\n              (uint)(ppuVar27[4] != (undefined *)0x0));\n      while (uVar9 < 2) {\n        ppuVar27 = (undefined **)ppuVar27[8];\n        if (ppuVar27 == (undefined **)0x0) goto LAB_004036df;\n        uVar9 = (uint)(byte)(*(byte *)(ppuVar27 + 7) | *(byte *)((long)ppuVar27 + 0x33) |\n                            ppuVar27[4] != (undefined *)0x0) +\n                (uint)*(byte *)((long)ppuVar27 + 0x36) +\n                (uint)*(byte *)((long)ppuVar27 + 0x32) + (uint)*(byte *)((long)ppuVar27 + 0x34) +\n                (uint)*(byte *)((long)ppuVar27 + 0x35);\n      }\nLAB_00405348:\n      *(undefined *)((long)ppuVar27 + 0x37) = 0;\n      *(undefined2 *)(ppuVar27 + 6) = 0;\n      FUN_00405b50(ppuVar27,local_1e8);\n      dVar51 = (double)FUN_00405d00(local_1e8);\nLAB_0040536f:\n      local_1e8._0_8_ = (undefined *)((long)(dVar51 - SUB168(auVar52,0)) ^ 0x8000000000000000);\nLAB_00403f7f:\n      iVar7 = DAT_0061c424;\n      ppVar13 = DAT_0061c748;\n      if ((DAT_0061c778 <= local_1e8._0_8_) &&\n         (DAT_0061c778 = (undefined *)((ulong)DAT_0061c420 * 0x22), DAT_0061c778 < local_1e8._0_8_))\n      {\n        DAT_0061c778 = local_1e8._0_8_;\n      }\n      goto LAB_0040344f;\n    }\n    cVar5 = FUN_00405af0(&local_238);\n    if (cVar5 == '\\0') {\n      puVar15 = (undefined *)FUN_00411410(&local_238,0x48);\n      ppuVar27 = (undefined **)&DAT_0061c750;\n      for (ppuVar30 = DAT_0061c750; ppuVar30 != (undefined **)0x0;\n          ppuVar30 = (undefined **)ppuVar30[8]) {\n        ppuVar27 = ppuVar30 + 8;\n      }\n      *ppuVar27 = puVar15;\n      ppuVar27 = DAT_0061c750;\n      uVar18 = 1;\n      *(undefined8 *)(puVar15 + 0x40) = 0;\n      puVar15 = (undefined *)(ulong)local_210[11];\n      if (ppuVar27 != (undefined **)0x0) goto LAB_00403662;\nLAB_004036df:\n      if (DAT_0061c740 != '\\0') goto LAB_004036ec;\n      DAT_0061c75b = local_210[15];\n      if ((char)puVar15 != '\\0') {\n        lVar42 = FUN_0040f900(local_370,0x10);\n        pcVar16 = \"open failed\";\n        if (lVar42 == 0) {\nLAB_0040543a:\n          uVar24 = dcgettext(0,pcVar16,5);\n                    /* WARNING: Subroutine does not return */\n          FUN_00405dd0(uVar24,local_370);\n        }\n        local_380 = (long *)local_1e8;\n        FUN_0040fc10(lVar42,local_380,0x10);\n        iVar7 = FUN_0040fd70(lVar42);\n        if (iVar7 != 0) {\n          pcVar16 = \"close failed\";\n          goto LAB_0040543a;\n        }\n        FUN_0040aa90(&DAT_0061c600);\n        FUN_0040b360(local_380,0x10,&DAT_0061c600);\n      }\n    }\n    else {\n      if (DAT_0061c740 != '\\0') {\nLAB_004036ec:\n        if (((char)local_388 == '\\0') && (local_368 == (pthread_mutex_t *)0x0)) {\n          if (((long **)local_360.sa_handler != (long **)0x0) &&\n             (pcVar16 = setlocale(3,\"\"), pcVar16 != (char *)0x0)) {\n            if (DAT_0061cba1 == '\\0') {\n              uVar24 = dcgettext(0,\"using simple byte comparison\",5);\n                    /* WARNING: Subroutine does not return */\n              error(0,0,&DAT_00416abc,uVar24);\n            }\n            pcVar16 = setlocale(3,(char *)0x0);\n            uVar24 = FUN_0040f880(pcVar16);\n            uVar25 = dcgettext(0,\"using %s sorting rules\",5);\n                    /* WARNING: Subroutine does not return */\n            error(0,0,uVar25,uVar24);\n          }\n          uVar24 = dcgettext(0,\"failed to set locale\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,0,&DAT_00416abc,uVar24);\n        }\n        if ((char)local_388 == '\\0') {\n          local_388 = (FILE *)CONCAT71(local_388._1_7_,0x6f);\n        }\n        s_X___debug_0061c408[0] = (char)local_388;\n        FUN_00405d00(s_X___debug_0061c408);\n        goto LAB_00405524;\n      }\n      DAT_0061c75b = local_210[15];\n    }\n    if (DAT_0061c768 == 0) {\n      pcVar16 = getenv(\"TMPDIR\");\n      if (pcVar16 == (char *)0x0) {\n        pcVar16 = \"/tmp\";\n      }\n      FUN_0040a010(pcVar16);\n    }\n    if (pplVar43 == (long **)0x0) {\n      pplVar43 = (long **)0x1;\n      free(__ptr);\n      __ptr = (long **)FUN_00411210(8);\n      *__ptr = (long *)&DAT_0041814a;\n    }\n    puVar15 = DAT_0061c778;\n    if ((DAT_0061c778 != (undefined *)0x0) &&\n       (puVar15 = (undefined *)((ulong)DAT_0061c420 * 0x22),\n       (undefined *)((ulong)DAT_0061c420 * 0x22) < DAT_0061c778)) {\n      puVar15 = DAT_0061c778;\n    }\n    DAT_0061c778 = puVar15;\n    if ((char)local_388 != '\\0') {\n      if ((long **)0x1 < pplVar43) {\n        uVar24 = FUN_0040f630(4,__ptr[1]);\n        uVar25 = dcgettext(0,\"extra operand %s not allowed with -%c\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar25,uVar24,(int)(char)local_388);\n      }\n      if (local_368 == (pthread_mutex_t *)0x0) {\n        __ptr = (long **)*__ptr;\n        lVar42 = FUN_00407cd0(__ptr,\"r\");\n        if (lVar42 != 0) {\n          uVar9 = (uint)DAT_0061c759;\n          local_370 = (pthread_mutex_t *)DAT_0061c750;\n          puVar15 = DAT_0061c428;\n          if (DAT_0061c428 <= DAT_0061c778) {\n            puVar15 = DAT_0061c778;\n          }\n          pvVar40 = (void *)0x0;\n          local_380 = (long *)local_1e8;\n          FUN_00405e30(local_380,0x20,puVar15);\n          local_2c8._0_8_ = (void *)0x0;\n          local_378 = (pthread_mutex_t *)0x0;\n          do {\n            cVar5 = FUN_004074d0(local_380,lVar42,__ptr);\n            if (cVar5 == '\\0') {\n              uVar9 = 1;\nLAB_004042b7:\n              FUN_00407df0(lVar42,__ptr);\n              free(local_1e8._0_8_);\n              free(local_2c8._0_8_);\n              return uVar9 ^ 1;\n            }\n            ppvVar44 = (void **)(local_1e8._0_8_ + CONCAT44(_Stack_1cc,local_1d0) + -0x20);\n            ppvVar34 = (void **)(local_1e8._0_8_ +\n                                local_1d8 * -0x20 + CONCAT44(_Stack_1cc,local_1d0));\n            if (pvVar40 != (void *)0x0) {\n              iVar7 = FUN_004082a0(local_2c8,ppvVar44);\n              goto joined_r0x004042a5;\n            }\n            while (ppvVar34 < ppvVar44) {\n              iVar7 = FUN_004082a0(ppvVar44,ppvVar44 + -4);\n              ppvVar44 = ppvVar44 + -4;\njoined_r0x004042a5:\n              if ((int)(uVar9 ^ 1) <= iVar7) {\n                uVar9 = 0;\n                if ((char)local_388 == 'c') {\n                  uVar25 = FUN_0040d370(((long)(local_1e8._0_8_ +\n                                               (CONCAT44(_Stack_1cc,local_1d0) - (long)ppvVar44)) >>\n                                        5) + (long)local_378,local_2f8);\n                  uVar24 = DAT_0061cbc8;\n                  uVar21 = dcgettext(0,\"%s: %s:%s: disorder: \",5);\n                  __fprintf_chk(stderr,1,uVar21,uVar24,__ptr,uVar25);\n                  uVar24 = dcgettext(0,\"standard error\",5);\n                  FUN_00407e70(ppvVar44,stderr,uVar24);\n                }\n                goto LAB_004042b7;\n              }\n            }\n            __n = ppvVar44[1];\n            local_378 = (pthread_mutex_t *)((long)local_378 + local_1d8);\n            pvVar41 = pvVar40;\n            if (pvVar40 < __n) {\n              do {\n                pvVar41 = (void *)((long)pvVar41 * 2);\n                pvVar40 = __n;\n                if (pvVar41 == (void *)0x0) break;\n                pvVar40 = pvVar41;\n              } while (pvVar41 < __n);\n              free(local_2c8._0_8_);\n              local_2c8._0_8_ = (void *)FUN_00411210(pvVar40);\n              __n = ppvVar44[1];\n            }\n            memcpy(local_2c8._0_8_,*ppvVar44,(size_t)__n);\n            local_2c8._8_8_ = ppvVar44[1];\n            if (local_370 != (pthread_mutex_t *)0x0) {\n              local_2b8 = ((long)ppvVar44[2] + (long)local_2c8._0_8_) - (long)*ppvVar44;\n              local_2b0 = (long **)(((long)local_2c8._0_8_ + (long)ppvVar44[3]) - (long)*ppvVar44);\n            }\n          } while( true );\n        }\n      }\n      else {\nLAB_00405800:\n        DAT_0061c400 = (char)local_388;\n        FUN_00405d00(&DAT_0061c400);\n      }\n      FUN_00407dd0(__ptr);\nLAB_0040581c:\n      auVar52 = FUN_00405d30(DAT_0061cd60,\"stray character in field spec\");\n      pFVar3 = local_388;\n      local_388 = SUB168(auVar52,0);\n      (*(code *)PTR___libc_start_main_0061bff0)\n                (FUN_00402f50,pFVar3,&local_380,FUN_00413eb0,FUN_00413f10,SUB168(auVar52 >> 0x40,0),\n                 &local_388);\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    bVar45 = false;\n    bVar47 = true;\n    local_320 = &DAT_0041814a;\n    pplVar19 = (long **)0x0;\n    pplVar35 = __ptr;\n    do {\n      pplVar33 = pplVar19;\n      lVar42 = 2;\n      plVar32 = *pplVar35;\n      pbVar38 = &DAT_0041814a;\n      do {\n        if (lVar42 == 0) break;\n        lVar42 = lVar42 + -1;\n        bVar45 = *(byte *)plVar32 < *pbVar38;\n        bVar47 = *(byte *)plVar32 == *pbVar38;\n        plVar32 = (long *)((long)plVar32 + (ulong)bVar49 * -2 + 1);\n        pbVar38 = pbVar38 + (ulong)bVar49 * -2 + 1;\n      } while (bVar47);\n      if (((!bVar45 && !bVar47) != bVar45) && (iVar7 = euidaccess((char *)*pplVar35,4), iVar7 != 0))\n      {\n        plVar32 = *pplVar35;\n        pcVar16 = \"cannot read\";\nLAB_0040541e:\n        uVar24 = dcgettext(0,pcVar16,5);\n                    /* WARNING: Subroutine does not return */\n        FUN_00405dd0(uVar24,plVar32);\n      }\n      pplVar19 = (long **)((long)pplVar33 + 1);\n      pplVar35 = pplVar35 + 1;\n      bVar45 = pplVar43 < pplVar19;\n      bVar47 = pplVar43 == pplVar19;\n    } while (!bVar47);\n    if (local_368 != (pthread_mutex_t *)0x0) {\n      iVar7 = open(local_368->__size,0x80041,0x1b6);\n      if (iVar7 < 0) {\n        uVar24 = dcgettext(0,\"open failed\",5);\n                    /* WARNING: Subroutine does not return */\n        FUN_00405dd0(uVar24,local_368);\n      }\n      if (iVar7 != 1) {\n        FUN_00408e10(iVar7,1);\n      }\n    }\n    if ((char)local_358 != '\\0') {\n      lVar42 = FUN_004113e0(pplVar19,0x10);\n      pplVar43 = (long **)0x0;\n      do {\n        *(long **)(lVar42 + (long)pplVar43 * 0x10) = __ptr[(long)pplVar43];\n        bVar45 = pplVar43 != pplVar33;\n        pplVar43 = (long **)((long)pplVar43 + 1);\n      } while (bVar45);\n      FUN_00409330(lVar42,0,pplVar19,local_368);\n      goto LAB_00404b19;\n    }\n    if ((long **)local_338.sa_handler == (long **)0x0) {\nLAB_00405199:\n      _Var23.sa_handler = (__sighandler_t)FUN_0040d6f0(2);\n      local_338 = (_union_1454)0x8;\n      if (_Var23.sa_handler < (long **)0x9) {\n        local_338.sa_handler = _Var23.sa_handler;\n      }\n    }\n    local_2b0 = (long **)0x0;\n    local_360 = (_union_1454)0xffffffffffffff;\n    if (local_338.sa_handler < (long **)0x100000000000000) {\n      local_360 = local_338;\n    }\n    ppVar13 = (pthread_mutex_t *)0x0;\n    local_348 = (long *)((long)local_360.sa_handler * 2);\n    local_350 = (char *)((long)local_360.sa_handler << 8);\n    local_340 = (pthread_mutex_t *)(local_1e8 + 8);\n    local_358 = pplVar19;\n    local_328 = __ptr;\nLAB_00404732:\n    local_380 = *local_328;\n    local_388 = (FILE *)FUN_00407cd0(local_380,\"r\");\n    if (local_388 != (FILE *)0x0) {\n      local_330 = (pthread_mutex_t *)0x30;\n      if ((long **)0x1 < local_338.sa_handler) {\n        lVar42 = 1;\n        pplVar19 = (long **)0x1;\n        do {\n          pplVar19 = (long **)((long)pplVar19 * 2);\n          lVar42 = lVar42 + 1;\n        } while (pplVar19 < local_360.sa_handler);\n        local_330 = (pthread_mutex_t *)(lVar42 * 0x20);\n      }\n      local_370 = (pthread_mutex_t *)local_2c8;\n      if (local_2b0 == (long **)0x0) {\n        param_2 = (undefined8 *)((long)&(local_330->__data).__lock + 1);\n        puVar15 = (undefined *)((long)&(local_330->__data).__lock + 2);\n        __ptr = local_358;\n        pplVar43 = local_2b0;\n        local_370 = ppVar13;\n        do {\n          bVar45 = false;\n          bVar47 = pplVar43 == (long **)0x0;\n          if (bVar47) {\n            iVar7 = fileno(local_388);\n            iVar7 = __fxstat(1,iVar7,(stat *)local_1e8);\n            bVar45 = iVar7 != 0;\n          }\n          else {\n            lVar42 = 2;\n            plVar32 = local_328[(long)pplVar43];\n            pbVar38 = local_320;\n            do {\n              if (lVar42 == 0) break;\n              lVar42 = lVar42 + -1;\n              bVar45 = *(byte *)plVar32 < *pbVar38;\n              bVar47 = *(byte *)plVar32 == *pbVar38;\n              plVar32 = (long *)((long)plVar32 + (ulong)bVar49 * -2 + 1);\n              pbVar38 = pbVar38 + (ulong)bVar49 * -2 + 1;\n            } while (bVar47);\n            if ((!bVar45 && !bVar47) == bVar45) {\n              iVar7 = __fxstat(1,0,(stat *)local_1e8);\n              bVar45 = iVar7 != 0;\n            }\n            else {\n              iVar7 = __xstat(1,(char *)local_328[(long)pplVar43],(stat *)local_1e8);\n              bVar45 = iVar7 != 0;\n            }\n          }\n          if (bVar45) {\n            pcVar16 = \"stat failed\";\n            plVar32 = local_328[(long)pplVar43];\n            goto LAB_0040541e;\n          }\n          if ((local_1d0 & 0xf000) == 0x8000) {\n            uVar18 = local_1b8;\n            puVar39 = DAT_0061c778;\n            if (DAT_0061c5e0 == (undefined *)0x0) goto joined_r0x00404bce;\n          }\n          else {\n            puVar39 = DAT_0061c778;\n            ppVar13 = local_370;\n            if (DAT_0061c778 != (undefined *)0x0) goto LAB_00404f99;\n            uVar18 = 0x20000;\n            puVar39 = DAT_0061c5e0;\njoined_r0x00404bce:\n            DAT_0061c5e0 = puVar39;\n            if (DAT_0061c5e0 == (undefined *)0x0) {\n              iVar7 = getrlimit(RLIMIT_DATA,(rlimit *)local_2f8);\n              uVar26 = 0xffffffffffffffff;\n              if (iVar7 == 0) {\n                uVar26 = local_2f8._0_8_;\n              }\n              iVar7 = getrlimit(RLIMIT_AS,(rlimit *)local_2f8);\n              if ((iVar7 == 0) && (local_2f8._0_8_ < uVar26)) {\n                uVar26 = local_2f8._0_8_;\n              }\n              puVar39 = (undefined *)(uVar26 >> 1);\n              iVar7 = getrlimit(__RLIMIT_RSS,(rlimit *)local_2f8);\n              if ((iVar7 == 0) &&\n                 (puVar20 = (undefined *)((local_2f8._0_8_ >> 4) * 0xf), puVar20 < puVar39)) {\n                puVar39 = puVar20;\n              }\n              local_378 = (pthread_mutex_t *)FUN_0040d900();\n              dVar51 = (double)FUN_0040d840();\n              dVar50 = dVar51 * _DAT_00416a58;\n              ppVar13 = local_378;\n              if ((double)local_378 <= (double)(pthread_mutex_t *)(DAT_00416a50 * dVar51)) {\n                ppVar13 = (pthread_mutex_t *)(DAT_00416a50 * dVar51);\n              }\n              if (dVar50 < (double)(long)puVar39) {\n                if (dVar50 < DAT_00416a48) {\n                  puVar39 = (undefined *)(long)dVar50;\n                }\n                else {\n                  puVar39 = (undefined *)((long)(dVar50 - DAT_00416a48) ^ 0x8000000000000000);\n                }\n              }\n              if ((long)puVar39 < 0) {\n                dVar51 = (double)((ulong)puVar39 >> 1 | (ulong)((uint)puVar39 & 1));\n                dVar51 = dVar51 + dVar51;\n              }\n              else {\n                dVar51 = (double)(long)puVar39;\n              }\n              if ((double)ppVar13 < dVar51) {\n                if ((double)ppVar13 < DAT_00416a48) {\nLAB_004050ca:\n                  puVar39 = (undefined *)(long)(double)ppVar13;\n                }\n                else {\n                  puVar39 = (undefined *)\n                            ((long)((double)ppVar13 - DAT_00416a48) ^ 0x8000000000000000);\n                }\n              }\n              DAT_0061c5e0 = (undefined *)((ulong)DAT_0061c420 * 0x22);\n              if ((undefined *)((ulong)DAT_0061c420 * 0x22) < puVar39) {\n                DAT_0061c5e0 = puVar39;\n              }\n            }\n          }\n          uVar26 = (long)param_2 * uVar18 + 1;\n          puVar39 = DAT_0061c5e0;\n          ppVar13 = local_370;\n          if ((uVar18 != uVar26 / (ulong)param_2) ||\n             ((ulong)((long)DAT_0061c5e0 - (long)puVar15) <= uVar26)) goto LAB_00404f99;\n          pplVar43 = (long **)((long)pplVar43 + 1);\n          puVar15 = puVar15 + uVar26;\n          puVar39 = puVar15;\n          if (__ptr <= pplVar43) goto LAB_00404f99;\n        } while( true );\n      }\n      goto LAB_0040478c;\n    }\n    goto LAB_00405558;\n  }\nLAB_00403488:\n  ppuVar27 = &PTR_s_ignore_leading_blanks_00414b40;\n  puVar17 = param_2;\n  uVar9 = FUN_00412f30(puVar15,param_2,\"-bcCdfghik:mMno:rRsS:t:T:uVy:z\",\n                       &PTR_s_ignore_leading_blanks_00414b40,local_2f8);\n  ppVar4 = local_340;\n  ppVar31 = local_368;\n  ppVar29 = local_370;\n  pplVar19 = (long **)(ulong)uVar9;\n  if (uVar9 == 0xffffffff) goto LAB_00403460;\n  iVar7 = DAT_0061c424;\n  ppVar13 = DAT_0061c748;\n  switch(uVar9) {\n  case 1:\n    if (DAT_0061cd60->__size[0] != '+') {\nLAB_00403ef7:\n      __ptr[(long)pplVar43] = (long *)DAT_0061cd60;\n      pplVar43 = (long **)((long)pplVar43 + 1);\n      iVar7 = DAT_0061c424;\n      ppVar13 = DAT_0061c748;\n      goto LAB_0040344f;\n    }\n    if (DAT_0061c578._4_4_ == iVar8) {\n      local_340 = (pthread_mutex_t *)((ulong)local_340._4_4_ << 0x20);\n    }\n    else {\n      local_340 = (pthread_mutex_t *)((ulong)local_340._4_4_ << 0x20);\n      if (*(char *)param_2[DAT_0061c578._4_4_] == '-') {\n        local_340 = (pthread_mutex_t *)\n                    ((ulong)ppVar4 & 0xffffffff00000000 |\n                    (ulong)((int)((char *)param_2[DAT_0061c578._4_4_])[1] - 0x30U < 10));\n      }\n    }\n    local_380._0_1_ = (byte)local_380 | local_350 == (char *)0x0 & (byte)local_340;\n    local_380 = (long *)((ulong)local_380 & 0xffffffffffffff00 | (ulong)(byte)local_380);\n    if ((byte)local_380 == 0) goto LAB_00403ef7;\n    puVar37 = &local_288;\n    for (lVar42 = 0x12; lVar42 != 0; lVar42 = lVar42 + -1) {\n      *(undefined4 *)puVar37 = 0;\n      puVar37 = (ulong *)((long)puVar37 + (ulong)bVar49 * -8 + 4);\n    }\n    local_278 = -1;\n    pcVar16 = (char *)FUN_00407c00((undefined *)((long)&(DAT_0061cd60->__data).__lock + 1),\n                                   &local_288,0);\n    if (pcVar16 == (char *)0x0) {\n      if ((local_288 | local_280) == 0) {\n        local_288 = 0xffffffffffffffff;\n      }\n      goto LAB_00403ef7;\n    }\n    if (*pcVar16 == '.') {\n      pcVar16 = (char *)FUN_00407c00(pcVar16 + 1,&local_280,0);\n      if ((local_288 | local_280) == 0) goto LAB_00404473;\nLAB_0040447f:\n      if (pcVar16 == (char *)0x0) goto LAB_00403ef7;\n    }\n    else if ((local_288 | local_280) == 0) {\nLAB_00404473:\n      local_288 = 0xffffffffffffffff;\n      goto LAB_0040447f;\n    }\n    pcVar16 = (char *)FUN_00405c00(pcVar16,&local_288,0);\n    if (*pcVar16 != '\\0') goto LAB_00403ef7;\n    if ((int)local_340 != 0) {\n      lVar42 = (long)DAT_0061c578._4_4_;\n      DAT_0061c578._4_4_ = DAT_0061c578._4_4_ + 1;\n      local_340 = (pthread_mutex_t *)param_2[lVar42];\n      pcVar16 = (char *)FUN_00407c00((undefined *)((long)&(local_340->__data).__lock + 1),local_348,\n                                     \"invalid number after \\'-\\'\");\n      if (pcVar16 == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"s\",\"src/sort.c\",0x110d,\"main\");\n      }\n      if (*pcVar16 == '.') {\n        pcVar16 = (char *)FUN_00407c00(pcVar16 + 1,local_270,\"invalid number after \\'.\\'\");\n      }\n      if ((local_270[0] == 0) && (local_278 != 0)) {\n        local_278 = local_278 + -1;\n      }\n      pcVar16 = (char *)FUN_00405c00(pcVar16,&local_288,1);\n      if (*pcVar16 != '\\0') goto LAB_00405549;\n    }\n    local_24f = 1;\n    puVar20 = (undefined *)FUN_00411410(&local_288,0x48);\n    ppuVar27 = (undefined **)&DAT_0061c750;\n    for (ppuVar30 = DAT_0061c750; ppuVar30 != (undefined **)0x0;\n        ppuVar30 = (undefined **)ppuVar30[8]) {\n      ppuVar27 = ppuVar30 + 8;\n    }\nLAB_004042f4:\n    *ppuVar27 = puVar20;\n    *(undefined8 *)(puVar20 + 0x40) = 0;\n    iVar7 = DAT_0061c424;\n    ppVar13 = DAT_0061c748;\n    goto LAB_0040344f;\n  case 0x43:\n  case 99:\n    goto switchD_004034bd_caseD_43;\n  case 0x4d:\n  case 0x52:\n  case 0x56:\n  case 0x62:\n  case 100:\n  case 0x66:\n  case 0x67:\n  case 0x68:\n  case 0x69:\n  case 0x6e:\n  case 0x72:\n    goto switchD_004034bd_caseD_4d;\n  case 0x53:\n    local_340 = DAT_0061cd60;\n    local_330 = (pthread_mutex_t *)\n                ((ulong)local_330 & 0xffffffff00000000 | local_2f8._0_8_ & 0xffffffff);\n    iVar7 = FUN_00411b40(DAT_0061cd60,local_158,10,local_1e8,\"EgGkKmMPtTYZ\");\n    if (iVar7 != 0) {\n      if (((iVar7 != 2) || (9 < (int)(char)local_158._0_8_[-1] - 0x30U)) ||\n         (local_158._0_8_[1] != (code)0x0)) {\nLAB_0040438e:\n        FUN_00411ab0(iVar7,(ulong)local_330 & 0xffffffff,0x53,&PTR_s_ignore_leading_blanks_00414b40,\n                     local_340);\n        goto LAB_004043a8;\n      }\n      if (*local_158._0_8_ != (code)0x25) {\n        if (*local_158._0_8_ == (code)0x62) goto LAB_00403f7f;\n        goto LAB_0040438e;\n      }\n      dVar51 = (double)FUN_0040d840();\n      if ((long)local_1e8._0_8_ < 0) {\n        dVar50 = (double)((ulong)local_1e8._0_8_ >> 1 | (ulong)((uint)local_1e8._0_8_ & 1));\n        dVar50 = dVar50 + dVar50;\n      }\n      else {\n        dVar50 = (double)(long)local_1e8._0_8_;\n      }\n      auVar52 = ZEXT816((ulong)DAT_00416a40);\n      dVar51 = (dVar51 * dVar50) / _DAT_00416a38;\n      if (DAT_00416a40 <= dVar51) goto LAB_0040514b;\n      auVar52 = ZEXT816((ulong)DAT_00416a48);\n      if (dVar51 < DAT_00416a48) {\n        local_1e8._0_8_ = (undefined *)(long)dVar51;\n        goto LAB_00403f7f;\n      }\n      goto LAB_0040536f;\n    }\n    if ((int)(char)local_158._0_8_[-1] - 0x30U < 10) {\n      if ((undefined *)0x3fffffffffffff < local_1e8._0_8_) {\nLAB_0040514b:\n        iVar7 = 1;\n        goto LAB_0040438e;\n      }\n      local_1e8._0_8_ = (undefined *)((long)local_1e8._0_8_ << 10);\n    }\n    goto LAB_00403f7f;\n  case 0x54:\n    FUN_0040a010(DAT_0061cd60);\n    iVar7 = DAT_0061c424;\n    ppVar13 = DAT_0061c748;\n    goto LAB_0040344f;\n  case 0x6b:\n    puVar37 = &local_288;\n    for (lVar42 = 0x12; lVar42 != 0; lVar42 = lVar42 + -1) {\n      *(undefined4 *)puVar37 = 0;\n      puVar37 = (ulong *)((long)puVar37 + (ulong)bVar49 * -8 + 4);\n    }\n    local_278 = -1;\n    pcVar16 = (char *)FUN_00407c00(DAT_0061cd60,&local_288,\"invalid number at field start\");\n    uVar26 = local_288 - 1;\n    bVar45 = local_288 != 0;\n    local_288 = uVar26;\n    if (bVar45) {\n      if (*pcVar16 == '.') {\n        pcVar16 = (char *)FUN_00407c00(pcVar16 + 1,&local_280,\"invalid number after \\'.\\'\");\n        ppVar13 = SUB168(auVar52,0);\n        uVar26 = local_280 - 1;\n        bVar45 = local_280 == 0;\n        local_280 = uVar26;\n        if (bVar45) {\n          FUN_00405d30(DAT_0061cd60,\"character offset is zero\");\n          goto LAB_004050ca;\n        }\n      }\n      if ((local_288 | local_280) == 0) goto LAB_004043cb;\n      goto LAB_00403dff;\n    }\nLAB_00405524:\n    FUN_00405d30(DAT_0061cd60,\"field number is zero\");\n    goto LAB_00405535;\n  case 0x6d:\n    local_358 = (long **)CONCAT71(local_358._1_7_,1);\n    goto LAB_0040344f;\n  case 0x6f:\n    bVar45 = local_368 != (pthread_mutex_t *)0x0;\n    local_368 = DAT_0061cd60;\n    if (bVar45) {\n      iVar8 = strcmp(ppVar31->__size,DAT_0061cd60->__size);\n      iVar7 = DAT_0061c424;\n      ppVar13 = DAT_0061c748;\n      if (iVar8 != 0) {\n        uVar24 = dcgettext(0,\"multiple output files specified\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar24);\n      }\n    }\n    goto LAB_0040344f;\n  case 0x73:\n    DAT_0061c75a = 1;\n    goto LAB_0040344f;\n  case 0x74:\n    iVar7 = (int)DAT_0061cd60->__size[0];\n    if (DAT_0061cd60->__size[0] == '\\0') {\n      uVar24 = dcgettext(0,\"empty tab\",5);\n                    /* WARNING: Subroutine does not return */\n      error(2,0,uVar24);\n    }\n    if (DAT_0061cd60->__size[1] != '\\0') {\n      local_340 = DAT_0061cd60;\n      iVar7 = strcmp(DAT_0061cd60->__size,\"\\\\0\");\n      if (iVar7 != 0) {\n        uVar24 = FUN_0040f880(local_340);\n        uVar25 = dcgettext(0,\"multi-character tab %s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar25,uVar24);\n      }\n      iVar7 = 0;\n    }\n    ppVar13 = DAT_0061c748;\n    if ((DAT_0061c424 != 0x80) && (DAT_0061c424 != iVar7)) {\n      uVar24 = dcgettext(0,\"incompatible tabs\",5);\n                    /* WARNING: Subroutine does not return */\n      error(2,0,uVar24);\n    }\n    goto LAB_0040344f;\n  case 0x75:\n    DAT_0061c759 = 1;\n    goto LAB_0040344f;\n  case 0x79:\n    ppVar29 = DAT_0061cd60;\n    if ((pthread_mutex_t *)param_2[(long)DAT_0061c578._4_4_ + -1] == DAT_0061cd60) {\n      for (; (int)ppVar29->__size[0] - 0x30U < 10;\n          ppVar29 = (pthread_mutex_t *)((long)&(ppVar29->__data).__lock + 1)) {\n      }\n      DAT_0061c578._4_4_ = DAT_0061c578._4_4_ - (uint)(ppVar29->__size[0] != '\\0');\n    }\n    goto LAB_0040344f;\n  case 0x7a:\n    DAT_0061c500 = 0;\n    goto LAB_0040344f;\n  case 0x80:\n    pplVar19 = (long **)0x63;\n    if (DAT_0061cd60 != (pthread_mutex_t *)0x0) {\n      puVar39 = PTR_FUN_0061c510;\n      lVar42 = FUN_0040a910(\"--check\",DAT_0061cd60,&PTR_s_quiet_00414b20,&DAT_00414b18,1);\n      pplVar19 = (long **)(ulong)(uint)(int)(char)(&DAT_00414b18)[lVar42];\n    }\nswitchD_004034bd_caseD_43:\n    if (((char)local_388 != '\\0') && ((int)(char)local_388 != (int)pplVar19)) {\nLAB_00405535:\n      FUN_00405d00(&DAT_0041667f);\nLAB_0040553f:\n      FUN_00407dd0(local_368);\nLAB_00405549:\n      FUN_00405d30(local_340,\"stray character in field spec\");\nLAB_00405558:\n      FUN_00407dd0(local_380);\nLAB_00405562:\n      uVar24 = FUN_0040f880(in_R10);\n      puVar15 = (&PTR_s_ignore_leading_blanks_00414b40)[(long)(int)local_328 * 4];\n      uVar25 = dcgettext(0,\"invalid --%s argument %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar25,puVar15,uVar24);\n    }\n    local_388 = (FILE *)((ulong)local_388 & 0xffffffffffffff00 | (ulong)pplVar19 & 0xff);\n    iVar7 = DAT_0061c424;\n    ppVar13 = DAT_0061c748;\n    goto LAB_0040344f;\n  case 0x81:\n    ppVar13 = DAT_0061cd60;\n    if (DAT_0061c748 != (pthread_mutex_t *)0x0) {\n      local_340 = DAT_0061cd60;\n      iVar8 = strcmp(DAT_0061c748->__size,DAT_0061cd60->__size);\n      iVar7 = DAT_0061c424;\n      ppVar13 = local_340;\n      if (iVar8 != 0) {\n        uVar24 = dcgettext(0,\"multiple compress programs specified\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar24);\n      }\n    }\n    goto LAB_0040344f;\n  case 0x82:\n    DAT_0061c740 = '\\x01';\n    goto LAB_0040344f;\n  case 0x83:\n    local_378 = DAT_0061cd60;\n    goto LAB_0040344f;\n  case 0x84:\n    goto switchD_004034bd_caseD_84;\n  case 0x85:\n    bVar45 = local_370 != (pthread_mutex_t *)0x0;\n    local_370 = DAT_0061cd60;\n    if (bVar45) {\n      iVar8 = strcmp(ppVar29->__size,DAT_0061cd60->__size);\n      iVar7 = DAT_0061c424;\n      ppVar13 = DAT_0061c748;\n      if (iVar8 != 0) {\n        uVar24 = dcgettext(0,\"multiple random sources specified\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar24);\n      }\n    }\n    goto LAB_0040344f;\n  case 0x86:\n    puVar39 = PTR_FUN_0061c510;\n    lVar42 = FUN_0040a910(\"--sort\",DAT_0061cd60,&PTR_s_general_numeric_00414ae0,\"ghMnRV\",1);\n    pplVar19 = (long **)(ulong)(uint)(int)\"ghMnRV\"[lVar42];\nswitchD_004034bd_caseD_4d:\n    local_158._0_8_ = (code *)((ulong)local_158._0_8_ & 0xffffffffffff0000 | (ulong)pplVar19 & 0xff)\n    ;\n    FUN_00405c00(local_158,&local_238,2);\n    iVar7 = DAT_0061c424;\n    ppVar13 = DAT_0061c748;\n    goto LAB_0040344f;\n  case 0x87:\n    local_340 = DAT_0061cd60;\n    local_338.sa_handler =\n         (__sighandler_t)\n         ((ulong)local_338.sa_handler & 0xffffffff00000000 | local_2f8._0_8_ & 0xffffffff);\n    iVar8 = FUN_00411680(DAT_0061cd60,0,10,local_158,\"\");\n    iVar7 = DAT_0061c424;\n    ppVar13 = DAT_0061c748;\n    if (iVar8 == 1) {\n      local_338 = (_union_1454)0xffffffffffffffff;\n    }\n    else {\n      if (iVar8 != 0) {\n        FUN_00411ab0(iVar8,(ulong)local_338.sa_handler & 0xffffffff,0xffffff87,\n                     &PTR_s_ignore_leading_blanks_00414b40,local_340);\n        goto LAB_00405800;\n      }\n      local_338.sa_handler = local_158._0_8_;\n      if ((long **)local_158._0_8_ == (long **)0x0) {\n        uVar24 = dcgettext(0,\"number in parallel must be nonzero\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar24);\n      }\n    }\n    goto LAB_0040344f;\n  case 0xffffff7d:\n    FUN_004110d0(stdout,\"sort\",\"GNU coreutils\",PTR_DAT_0061c508,\"Mike Haertel\",\"Paul Eggert\",0,\n                 puVar17);\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  case 0xffffff7e:\n    FUN_0040a0d0(0);\n    goto LAB_00405199;\n  default:\n    FUN_0040a0d0(2);\n    goto LAB_00405348;\n  }\nLAB_00404f99:\n  local_370 = (pthread_mutex_t *)local_2c8;\n  FUN_00405e30(local_370,local_330,puVar39);\nLAB_0040478c:\n  local_298 = '\\0';\n  local_358 = (long **)((long)local_358 + -1);\n  while (cVar6 = FUN_004074d0(local_370,local_388,local_380), cVar5 = local_298,\n        pplVar19 = local_2b0, pvVar40 = local_2c8._0_8_, cVar6 != '\\0') {\n    if (local_298 == '\\0') {\nLAB_00404923:\n      _DAT_0061cb80 = 0;\n      ppVar13 = (pthread_mutex_t *)((long)&(ppVar13->__data).__lock + 1);\n      cVar5 = '\\0';\n      lVar42 = FUN_004090c0(local_2f8,0);\n      ppVar29 = (pthread_mutex_t *)(lVar42 + 0xd);\n    }\n    else {\n      if (local_358 != (long **)0x0) {\n        if ((undefined *)\n            ((long)local_2b0 + (-((long)local_330 * local_2b8) - (long)local_2c8._8_8_)) <=\n            (undefined *)((long)&(local_330->__data).__lock + 1U)) goto LAB_00404923;\n        local_2a8 = local_2c8._8_8_;\n        FUN_00407df0(local_388,local_380);\n        goto LAB_00404ae0;\n      }\n      _DAT_0061cb80 = 0;\n      if (((ulong)ppVar13 | (ulong)local_2a8) != 0) goto LAB_00404923;\n      FUN_00407df0(local_388,local_380);\n      uVar18 = FUN_00407cd0(local_368,&DAT_0041655c);\n      if (uVar18 == 0) goto LAB_0040553f;\n      ppVar13 = (pthread_mutex_t *)0x0;\n      ppVar29 = local_368;\n      local_2f8._0_8_ = uVar18;\n    }\n    lVar42 = (long)pplVar19 + (long)pvVar40;\n    if (local_2b8 < 2) {\n      FUN_004085d0(lVar42 + -0x20,local_2f8._0_8_,ppVar29);\n      ppVar31 = extraout_RDX;\n    }\n    else {\n      local_1e8._0_8_ = (undefined *)FUN_0040cfd0(FUN_00407850);\n      pthread_mutex_init(local_340,(pthread_mutexattr_t *)0x0);\n      pthread_cond_init((pthread_cond_t *)&local_1b8,(pthread_condattr_t *)0x0);\n      uVar18 = local_2b8;\n      puVar17 = (undefined8 *)FUN_00411210(local_350);\n      puVar17[6] = uVar18;\n      puVar17[5] = uVar18;\n      puVar17[3] = 0;\n      puVar17[2] = 0;\n      puVar17[1] = 0;\n      *puVar17 = 0;\n      puVar17[4] = 0;\n      puVar17[7] = 0;\n      *(undefined4 *)(puVar17 + 10) = 0;\n      *(undefined *)((long)puVar17 + 0x54) = 0;\n      pthread_mutex_init((pthread_mutex_t *)(puVar17 + 0xb),(pthread_mutexattr_t *)0x0);\n      _Var23 = local_360;\n      local_378 = (pthread_mutex_t *)(puVar17 + 0x10);\n      FUN_004061f0(puVar17,local_378,lVar42,local_360.sa_handler,uVar18,0);\n      in_R10 = local_378;\n      ppVar31 = ppVar29;\n      FUN_00409880(lVar42,_Var23.sa_handler,local_2b8,local_378,local_1e8);\n    }\n    FUN_00407df0(local_2f8._0_8_,ppVar29,ppVar31);\n    if (cVar5 != '\\0') {\n      free(local_2c8._0_8_);\n      goto joined_r0x00404b02;\n    }\n  }\n  FUN_00407df0(local_388,local_380);\n  if (local_358 == (long **)0x0) {\n    free(local_2c8._0_8_);\n    puVar17 = DAT_0061c6a8;\n    if ((-1 < SUB168(ZEXT816(0x10) * ZEXT816(ppVar13),0)) &&\n       (SUB168(ZEXT816(0x10) * ZEXT816(ppVar13) >> 0x40,0) == 0)) {\n      plVar22 = (long *)FUN_00411210((long)ppVar13 << 4);\n      plVar32 = plVar22;\n      while (puVar17 != (undefined8 *)0x0) {\n        lVar42 = (long)puVar17 + 0xd;\n        plVar32[1] = (long)puVar17;\n        puVar17 = (undefined8 *)*puVar17;\n        *plVar32 = lVar42;\n        plVar32 = plVar32 + 2;\n      }\n      FUN_00409330(plVar22,ppVar13,ppVar13,local_368);\n      free(plVar22);\njoined_r0x00404b02:\n      while (0 < DAT_0061c69c) {\n        FUN_00405fb0(0xffffffff);\n      }\nLAB_00404b19:\n      if ((DAT_0061c758 != '\\0') && (iVar7 = FUN_00411f80(stdin), iVar7 == -1)) {\n        uVar24 = dcgettext(0,\"close failed\",5);\n                    /* WARNING: Subroutine does not return */\n        FUN_00405dd0(uVar24,&DAT_0041814a);\n      }\n      return 0;\n    }\n    goto LAB_004057e1;\n  }\nLAB_00404ae0:\n  local_328 = local_328 + 1;\n  goto LAB_00404732;\nswitchD_004034bd_caseD_84:\n  local_330 = DAT_0061cd60;\n  local_328 = (long **)((ulong)local_328 & 0xffffffff00000000 | local_2f8._0_8_ & 0xffffffff);\n  uVar9 = FUN_00411b40(DAT_0061cd60,0,10,local_2c8,0);\n  local_340 = (pthread_mutex_t *)((ulong)local_340 & 0xffffffff00000000 | (ulong)uVar9);\n  iVar7 = getrlimit(RLIMIT_NOFILE,(rlimit *)local_158);\n  in_R11 = (ushort *)0x11;\n  puVar39 = (undefined *)((ulong)local_340 & 0xffffffff);\n  if (iVar7 == 0) {\n    in_R11 = (ushort *)(ulong)(local_158._0_4_ - 3);\n  }\n  uVar9 = (uint)in_R11;\n  in_R10 = local_330;\n  if ((int)local_340 == 0) {\n    DAT_0061c420 = (uint)local_2c8._0_8_;\n    if (local_2c8._0_8_ == (void *)((ulong)local_2c8._0_8_ & 0xffffffff)) {\n      if (DAT_0061c420 < 2) goto LAB_00405562;\n      iVar7 = DAT_0061c424;\n      ppVar13 = DAT_0061c748;\n      if (uVar9 < DAT_0061c420) goto LAB_00403bea;\n      goto LAB_0040344f;\n    }\n  }\n  else {\nLAB_004043a8:\n    uVar9 = (uint)in_R11;\n    if ((int)puVar39 != 1) {\n      pcVar16 = (char *)FUN_00411ab0((ulong)puVar39 & 0xffffffff,(ulong)local_328 & 0xffffffff,\n                                     0xffffff84,&PTR_s_ignore_leading_blanks_00414b40,in_R10);\nLAB_004043cb:\n      local_288 = 0xffffffffffffffff;\nLAB_00403dff:\n      pcVar16 = (char *)FUN_00405c00(pcVar16,&local_288,0);\n      if (*pcVar16 == ',') {\n        pcVar16 = (char *)FUN_00407c00(pcVar16 + 1,local_348,\"invalid number after \\',\\'\");\n        lVar42 = local_278 + -1;\n        bVar45 = local_278 == 0;\n        local_278 = lVar42;\n        if (bVar45) goto LAB_00405524;\n        if (*pcVar16 == '.') {\n          pcVar16 = (char *)FUN_00407c00(pcVar16 + 1,local_270,\"invalid number after \\'.\\'\");\n        }\n        pcVar16 = (char *)FUN_00405c00(pcVar16,&local_288,1);\n      }\n      else {\n        local_278 = -1;\n        local_270[0] = 0;\n      }\n      if (*pcVar16 != '\\0') goto LAB_0040581c;\n      puVar20 = (undefined *)FUN_00411410(&local_288,0x48);\n      ppuVar27 = (undefined **)&DAT_0061c750;\n      for (ppuVar30 = DAT_0061c750; ppuVar30 != (undefined **)0x0;\n          ppuVar30 = (undefined **)ppuVar30[8]) {\n        ppuVar27 = ppuVar30 + 8;\n      }\n      goto LAB_004042f4;\n    }\n  }\nLAB_00403bea:\n  local_388 = (FILE *)((ulong)local_388 & 0xffffffff00000000 | (ulong)uVar9);\n  uVar24 = FUN_0040f880(in_R10);\n  puVar15 = (&PTR_s_ignore_leading_blanks_00414b40)[(long)(int)local_328 * 4];\n  uVar25 = dcgettext(0,\"--%s argument %s too large\",5);\n                    /* WARNING: Subroutine does not return */\n  error(0,0,uVar25,puVar15,uVar24);\n}\n\n",
            "funcName": "FUN_00402f50"
        },
        {
            "funcStartAddr": "0x405830",
            "funcEndAddr": "0x40585b",
            "decompiledFuncCode": "\nvoid FUN_00405830(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_0061bff0)\n            (FUN_00402f50,unaff_retaddr,&stack0x00000008,FUN_00413eb0,FUN_00413f10,param_3,auStack_8\n            );\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "FUN_00405830"
        },
        {
            "funcStartAddr": "0x40585b",
            "funcEndAddr": "0x40587a",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00405868) */\n/* WARNING: Removing unreachable block (ram,0x00405872) */\n\nvoid FUN_0040585b(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040585b"
        },
        {
            "funcStartAddr": "0x40587a",
            "funcEndAddr": "0x4058b1",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004058a9) */\n\nvoid FUN_0040587a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040587a"
        },
        {
            "funcStartAddr": "0x4058b1",
            "funcEndAddr": "0x405908",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004058e6) */\n\nvoid FUN_004058b1(void)\n\n{\n  if (DAT_0061c5c8 != '\\0') {\n    return;\n  }\n  FUN_0040585b();\n  DAT_0061c5c8 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_004058b1"
        },
        {
            "funcStartAddr": "0x405908",
            "funcEndAddr": "0x40590d",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004058a9) */\n\nvoid thunk_FUN_0040587a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "thunk_405908"
        },
        {
            "funcStartAddr": "0x405910",
            "funcEndAddr": "0x40591d",
            "decompiledFuncCode": "\nulong FUN_00405910(long param_1,ulong param_2)\n\n{\n  return (ulong)(long)*(int *)(param_1 + 8) % param_2;\n}\n\n",
            "funcName": "FUN_00405910"
        },
        {
            "funcStartAddr": "0x405920",
            "funcEndAddr": "0x40592a",
            "decompiledFuncCode": "\nuint FUN_00405920(long param_1,long param_2)\n\n{\n  return *(uint *)(param_2 + 8) & 0xffffff00 |\n         (uint)(*(uint *)(param_1 + 8) == *(uint *)(param_2 + 8));\n}\n\n",
            "funcName": "FUN_00405920"
        },
        {
            "funcStartAddr": "0x405930",
            "funcEndAddr": "0x4059d0",
            "decompiledFuncCode": "\nvoid FUN_00405930(byte **param_1)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  uint uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  bVar7 = false;\n  uVar3 = 0;\n  pbVar5 = *param_1;\n  uVar6 = (uint)**param_1;\n  while( true ) {\n    pbVar4 = pbVar5;\n    if (9 < (uVar6 & 0xff) - 0x30) break;\n    if ((byte)uVar3 < (byte)uVar6) {\n      uVar3 = uVar6;\n    }\n    bVar7 = (int)(char)pbVar4[1] == DAT_0061cba4;\n    pbVar5 = pbVar4 + 1;\n    uVar6 = (int)(char)pbVar4[1];\n    if (bVar7) {\n      uVar6 = (uint)pbVar4[2];\n      pbVar5 = pbVar4 + 2;\n    }\n  }\n  if (bVar7) {\n    *param_1 = pbVar4 + -1;\n    return;\n  }\n  pbVar5 = pbVar4;\n  if ((uVar6 & 0xff) == DAT_0061cba8) {\n    pbVar2 = pbVar4 + 2;\n    pbVar5 = pbVar4 + 1;\n    bVar1 = pbVar4[1];\n    if (pbVar4[1] - 0x30 < 10) {\n      do {\n        pbVar5 = pbVar2;\n        if ((byte)uVar3 < bVar1) {\n          uVar3 = (uint)bVar1;\n        }\n        pbVar2 = pbVar5 + 1;\n        bVar1 = *pbVar5;\n      } while (*pbVar5 - 0x30 < 10);\n      *param_1 = pbVar5;\n      return;\n    }\n  }\n  *param_1 = pbVar5;\n  return;\n}\n\n",
            "funcName": "FUN_00405930"
        },
        {
            "funcStartAddr": "0x4059f0",
            "funcEndAddr": "0x405a39",
            "decompiledFuncCode": "\nint FUN_004059f0(char *param_1)\n\n{\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  byte *local_10;\n  \n  cVar1 = *param_1;\n  local_10 = (byte *)(param_1 + (cVar1 == '-'));\n  bVar2 = FUN_00405930(&local_10);\n  iVar3 = 0;\n  if (0x30 < bVar2) {\n    iVar3 = (int)(char)(&DAT_004149c0)[*local_10];\n    if (cVar1 == '-') {\n      iVar3 = -(int)(char)(&DAT_004149c0)[*local_10];\n    }\n  }\n  return iVar3;\n}\n\n",
            "funcName": "FUN_004059f0"
        },
        {
            "funcStartAddr": "0x405a40",
            "funcEndAddr": "0x405a42",
            "decompiledFuncCode": "\nundefined4 thunk_FUN_00405a4c(byte *param_1,byte **param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  bool bVar7;\n  \n  while ((&DAT_0061ca80)[*param_1] != '\\0') {\n    param_1 = param_1 + 1;\n  }\n  uVar5 = 0;\n  uVar6 = 0xc;\n  while( true ) {\n    uVar4 = uVar5 + uVar6 >> 1;\n    pbVar2 = (&PTR_DAT_0061c440)[uVar5 + uVar6 & 0xfffffffffffffffe];\n    bVar1 = *pbVar2;\n    pbVar3 = param_1;\n    if (bVar1 == 0) break;\n    bVar7 = (byte)(&DAT_0061c780)[*param_1] < bVar1;\n    if (!bVar7) {\n      if (bVar7 || (&DAT_0061c780)[*param_1] == bVar1) {\n        do {\n          pbVar2 = pbVar2 + 1;\n          bVar1 = *pbVar2;\n          pbVar3 = pbVar3 + 1;\n          if (bVar1 == 0) goto LAB_00405aae;\n          bVar7 = (byte)(&DAT_0061c780)[*pbVar3] < bVar1;\n          if (bVar7) goto LAB_00405acb;\n        } while (bVar7 || (&DAT_0061c780)[*pbVar3] == bVar1);\n      }\n      uVar5 = uVar4 + 1;\n      uVar4 = uVar6;\n    }\nLAB_00405acb:\n    uVar6 = uVar4;\n    if (uVar4 <= uVar5) {\n      return 0;\n    }\n  }\nLAB_00405aae:\n  if (param_2 != (byte **)0x0) {\n    *param_2 = pbVar3;\n  }\n  return (&DAT_0061c448)[uVar4 * 4];\n}\n\n",
            "funcName": "thunk_405a40"
        },
        {
            "funcStartAddr": "0x405a4c",
            "funcEndAddr": "0x405adb",
            "decompiledFuncCode": "\nundefined4 FUN_00405a4c(byte *param_1,byte **param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  bool bVar7;\n  \n  while ((&DAT_0061ca80)[*param_1] != '\\0') {\n    param_1 = param_1 + 1;\n  }\n  uVar5 = 0;\n  uVar6 = 0xc;\n  while( true ) {\n    uVar4 = uVar5 + uVar6 >> 1;\n    pbVar2 = (&PTR_DAT_0061c440)[uVar5 + uVar6 & 0xfffffffffffffffe];\n    bVar1 = *pbVar2;\n    pbVar3 = param_1;\n    if (bVar1 == 0) break;\n    bVar7 = (byte)(&DAT_0061c780)[*param_1] < bVar1;\n    if (!bVar7) {\n      if (bVar7 || (&DAT_0061c780)[*param_1] == bVar1) {\n        do {\n          pbVar2 = pbVar2 + 1;\n          bVar1 = *pbVar2;\n          pbVar3 = pbVar3 + 1;\n          if (bVar1 == 0) goto LAB_00405aae;\n          bVar7 = (byte)(&DAT_0061c780)[*pbVar3] < bVar1;\n          if (bVar7) goto LAB_00405acb;\n        } while (bVar7 || (&DAT_0061c780)[*pbVar3] == bVar1);\n      }\n      uVar5 = uVar4 + 1;\n      uVar4 = uVar6;\n    }\nLAB_00405acb:\n    uVar6 = uVar4;\n    if (uVar4 <= uVar5) {\n      return 0;\n    }\n  }\nLAB_00405aae:\n  if (param_2 != (byte **)0x0) {\n    *param_2 = pbVar3;\n  }\n  return (&DAT_0061c448)[uVar4 * 4];\n}\n\n",
            "funcName": "FUN_00405a4c"
        },
        {
            "funcStartAddr": "0x405af0",
            "funcEndAddr": "0x405b38",
            "decompiledFuncCode": "\nbyte FUN_00405af0(long param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0;\n  if ((*(long *)(param_1 + 0x20) == 0) && (*(long *)(param_1 + 0x28) == 0)) {\n    bVar1 = *(byte *)(param_1 + 0x30);\n    if (bVar1 != 0) {\n      return 0;\n    }\n    if ((*(char *)(param_1 + 0x31) == '\\0') && ((*(ulong *)(param_1 + 0x30) & 0xffff00ff0000) == 0))\n    {\n      bVar1 = *(byte *)(param_1 + 0x36);\n      if (bVar1 != 0) {\n        return 0;\n      }\n      if (*(char *)(param_1 + 0x38) == '\\0') {\n        return *(byte *)(param_1 + 0x33) ^ 1;\n      }\n    }\n  }\n  return bVar1;\n}\n\n",
            "funcName": "FUN_00405af0"
        },
        {
            "funcStartAddr": "0x405b50",
            "funcEndAddr": "0x405bf7",
            "decompiledFuncCode": "\nvoid FUN_00405b50(long param_1,undefined *param_2)\n\n{\n  if (*(short *)(param_1 + 0x30) != 0) {\n    *param_2 = 0x62;\n    param_2 = param_2 + 1;\n  }\n  if (*(undefined1 **)(param_1 + 0x20) == &DAT_0061c880) {\n    *param_2 = 100;\n    param_2 = param_2 + 1;\n  }\n  if (*(long *)(param_1 + 0x28) != 0) {\n    *param_2 = 0x66;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x34) != '\\0') {\n    *param_2 = 0x67;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x35) != '\\0') {\n    *param_2 = 0x68;\n    param_2 = param_2 + 1;\n  }\n  if (*(undefined1 **)(param_1 + 0x20) == &DAT_0061c980) {\n    *param_2 = 0x69;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x36) != '\\0') {\n    *param_2 = 0x4d;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x32) != '\\0') {\n    *param_2 = 0x6e;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x33) != '\\0') {\n    *param_2 = 0x52;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x37) != '\\0') {\n    *param_2 = 0x72;\n    param_2 = param_2 + 1;\n  }\n  if (*(char *)(param_1 + 0x38) != '\\0') {\n    *param_2 = 0x56;\n    param_2 = param_2 + 1;\n  }\n  *param_2 = 0;\n  return;\n}\n\n",
            "funcName": "FUN_00405b50"
        },
        {
            "funcStartAddr": "0x405c00",
            "funcEndAddr": "0x405ca1",
            "decompiledFuncCode": "\nchar * FUN_00405c00(char *param_1,long param_2,uint param_3)\n\n{\n  char cVar1;\n  \n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    do {\n      switch(cVar1) {\n      case 'M':\n        *(undefined *)(param_2 + 0x36) = 1;\n        break;\n      default:\n        goto switchD_00405c1b_caseD_4e;\n      case 'R':\n        *(undefined *)(param_2 + 0x33) = 1;\n        break;\n      case 'V':\n        *(undefined *)(param_2 + 0x38) = 1;\n        break;\n      case 'b':\n        if ((param_3 & 0xfffffffd) == 0) {\n          *(undefined *)(param_2 + 0x30) = 1;\n        }\n        if (param_3 - 1 < 2) {\n          *(undefined *)(param_2 + 0x31) = 1;\n        }\n        break;\n      case 'd':\n        *(undefined1 **)(param_2 + 0x20) = &DAT_0061c880;\n        break;\n      case 'f':\n        *(undefined1 **)(param_2 + 0x28) = &DAT_0061c780;\n        break;\n      case 'g':\n        *(undefined *)(param_2 + 0x34) = 1;\n        break;\n      case 'h':\n        *(undefined *)(param_2 + 0x35) = 1;\n        break;\n      case 'i':\n        if (*(long *)(param_2 + 0x20) == 0) {\n          *(undefined1 **)(param_2 + 0x20) = &DAT_0061c980;\n        }\n        break;\n      case 'n':\n        *(undefined *)(param_2 + 0x32) = 1;\n        break;\n      case 'r':\n        *(undefined *)(param_2 + 0x37) = 1;\n      }\n      param_1 = param_1 + 1;\n      cVar1 = *param_1;\n    } while (cVar1 != '\\0');\n  }\nswitchD_00405c1b_caseD_4e:\n  return param_1;\n}\n\n",
            "funcName": "FUN_00405c00"
        },
        {
            "funcStartAddr": "0x405cf0",
            "funcEndAddr": "0x405cfb",
            "decompiledFuncCode": "\nvoid FUN_00405cf0(char **param_1,char **param_2)\n\n{\n  strcmp(*param_1,*param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00405cf0"
        },
        {
            "funcStartAddr": "0x405d00",
            "funcEndAddr": "0x405d29",
            "decompiledFuncCode": "\nvoid FUN_00405d00(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"options \\'-%s\\' are incompatible\",5);\n                    /* WARNING: Subroutine does not return */\n  error(2,0,uVar1,param_1);\n}\n\n",
            "funcName": "FUN_00405d00"
        },
        {
            "funcStartAddr": "0x405d30",
            "funcEndAddr": "0x405d7b",
            "decompiledFuncCode": "\nvoid FUN_00405d30(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar1 = FUN_0040f880();\n  uVar2 = dcgettext(0,param_2,5);\n  uVar3 = dcgettext(0,\"%s: invalid field specification %s\",5);\n                    /* WARNING: Subroutine does not return */\n  error(2,0,uVar3,uVar2,uVar1);\n}\n\n",
            "funcName": "FUN_00405d30"
        },
        {
            "funcStartAddr": "0x405d80",
            "funcEndAddr": "0x405dca",
            "decompiledFuncCode": "\nvoid FUN_00405d80(int param_1)\n\n{\n  long *plVar1;\n  \n  plVar1 = DAT_0061c6a8;\n  if (DAT_0061c6a8 != (long *)0x0) {\n    do {\n      unlink((char *)((long)plVar1 + 0xd));\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  DAT_0061c6a8 = (long *)0x0;\n  signal(param_1,(__sighandler_t)0x0);\n  raise(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00405d80"
        },
        {
            "funcStartAddr": "0x405dd0",
            "funcEndAddr": "0x405e24",
            "decompiledFuncCode": "\nvoid FUN_00405dd0(undefined8 param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  \n  if (param_2 == 0) {\n    param_2 = dcgettext(0,\"standard output\",5);\n  }\n  uVar1 = FUN_0040f700(0,3,param_2);\n  piVar2 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(2,*piVar2,\"%s: %s\",param_1,uVar1);\n}\n\n",
            "funcName": "FUN_00405dd0"
        },
        {
            "funcStartAddr": "0x405e30",
            "funcEndAddr": "0x405e9e",
            "decompiledFuncCode": "\nvoid FUN_00405e30(void **param_1,void *param_2,ulong param_3)\n\n{\n  void *pvVar1;\n  void *__size;\n  \n  do {\n    __size = (void *)((param_3 & 0xffffffffffffffe0) + 0x20);\n    pvVar1 = malloc((size_t)__size);\n    *param_1 = pvVar1;\n    if (pvVar1 != (void *)0x0) {\n      param_1[5] = param_2;\n      param_1[3] = __size;\n      param_1[2] = (void *)0x0;\n      param_1[4] = (void *)0x0;\n      param_1[1] = (void *)0x0;\n      *(undefined *)(param_1 + 6) = 0;\n      return;\n    }\n    param_3 = (ulong)__size >> 1;\n  } while ((long)param_2 + 1U < param_3);\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_00405e30"
        },
        {
            "funcStartAddr": "0x405eb0",
            "funcEndAddr": "0x405eec",
            "decompiledFuncCode": "\nlong FUN_00405eb0(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  char *pcVar3;\n  \n  iVar1 = FUN_0040d3c0(param_1,(long)param_2 - (long)param_1,0);\n  lVar2 = (long)iVar1;\n  if (param_1 < param_2) {\n    do {\n      pcVar3 = param_1 + 1;\n      lVar2 = lVar2 + (ulong)(*param_1 == '\\t');\n      param_1 = pcVar3;\n    } while (param_2 != pcVar3);\n  }\n  return lVar2;\n}\n\n",
            "funcName": "FUN_00405eb0"
        },
        {
            "funcStartAddr": "0x405ef0",
            "funcEndAddr": "0x405f4f",
            "decompiledFuncCode": "\nvoid FUN_00405ef0(char *param_1,char *param_2,size_t param_3)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  strxfrm(param_1,param_2,param_3);\n  if (*piVar1 == 0) {\n    return;\n  }\n  uVar2 = dcgettext(0,\"string transformation failed\",5);\n                    /* WARNING: Subroutine does not return */\n  error(0,*piVar1,uVar2);\n}\n\n",
            "funcName": "FUN_00405ef0"
        },
        {
            "funcStartAddr": "0x405fb0",
            "funcEndAddr": "0x406099",
            "decompiledFuncCode": "\n__pid_t FUN_00405fb0(int param_1)\n\n{\n  __pid_t _Var1;\n  long lVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  uint local_2c;\n  undefined local_28 [8];\n  __pid_t local_20;\n  \n  _Var1 = -1;\n  if (param_1 != 0) {\n    _Var1 = param_1;\n  }\n  _Var1 = waitpid(_Var1,(int *)&local_2c,(uint)(param_1 == 0));\n  if (_Var1 < 0) {\n    uVar3 = FUN_0040f630(4,DAT_0061c748);\n    uVar4 = dcgettext(0,\"waiting for %s [-d]\",5);\n    piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n    error(2,*piVar5,uVar4,uVar3);\n  }\n  if (_Var1 != 0) {\n    if (param_1 < 1) {\n      local_20 = _Var1;\n      lVar2 = FUN_0040cde0(DAT_0061c6a0,local_28);\n      if (lVar2 == 0) {\n        return _Var1;\n      }\n      *(undefined *)(lVar2 + 0xc) = 2;\n    }\n    if ((local_2c >> 8 & 0xff | local_2c & 0x7f) != 0) {\n      uVar3 = FUN_0040f630(4,DAT_0061c748);\n      uVar4 = dcgettext(0,\"%s [-d] terminated abnormally\",5);\n                    /* WARNING: Subroutine does not return */\n      error(2,0,uVar4,uVar3);\n    }\n    DAT_0061c69c = DAT_0061c69c + -1;\n  }\n  return _Var1;\n}\n\n",
            "funcName": "FUN_00405fb0"
        },
        {
            "funcStartAddr": "0x4060a0",
            "funcEndAddr": "0x4060d0",
            "decompiledFuncCode": "\nvoid FUN_004060a0(undefined4 param_1)\n\n{\n  long lVar1;\n  undefined auStack_18 [8];\n  undefined4 local_10;\n  \n  local_10 = param_1;\n  lVar1 = FUN_0040cde0(DAT_0061c6a0,auStack_18);\n  if (lVar1 != 0) {\n    *(undefined *)(lVar1 + 0xc) = 2;\n    FUN_00405fb0(param_1);\n  }\n  return;\n}\n\n",
            "funcName": "FUN_004060a0"
        },
        {
            "funcStartAddr": "0x4060d0",
            "funcEndAddr": "0x406185",
            "decompiledFuncCode": "\nvoid FUN_004060d0(int param_1,uint *param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  uint uVar3;\n  char *__buf;\n  ulong uVar4;\n  uint *puVar5;\n  uint *puVar6;\n  char *pcVar7;\n  bool bVar8;\n  byte bVar9;\n  undefined local_14 [12];\n  \n  bVar9 = 0;\n  puVar6 = param_2;\n  do {\n    puVar5 = puVar6;\n    uVar2 = *puVar5 + 0xfefefeff & ~*puVar5;\n    uVar3 = uVar2 & 0x80808080;\n    puVar6 = puVar5 + 1;\n  } while (uVar3 == 0);\n  bVar8 = (uVar2 & 0x8080) == 0;\n  if (bVar8) {\n    uVar3 = uVar3 >> 0x10;\n  }\n  if (bVar8) {\n    puVar6 = (uint *)((long)puVar5 + 6);\n  }\n  write(2,param_2,(long)puVar6 + ((-3 - (ulong)CARRY1((byte)uVar3,(byte)uVar3)) - (long)param_2));\n  if (param_1 != 0) {\n    __buf = (char *)FUN_0040d2b0(param_1,local_14);\n    write(2,\": errno \",8);\n    uVar4 = 0xffffffffffffffff;\n    pcVar7 = __buf;\n    do {\n      if (uVar4 == 0) break;\n      uVar4 = uVar4 - 1;\n      cVar1 = *pcVar7;\n      pcVar7 = pcVar7 + (ulong)bVar9 * -2 + 1;\n    } while (cVar1 != '\\0');\n    write(2,__buf,~uVar4 - 1);\n  }\n  write(2,\"\\n\",1);\n                    /* WARNING: Subroutine does not return */\n  _exit(2);\n}\n\n",
            "funcName": "FUN_004060d0"
        },
        {
            "funcStartAddr": "0x406190",
            "funcEndAddr": "0x4061e0",
            "decompiledFuncCode": "\nvoid FUN_00406190(long param_1)\n\n{\n  long lVar1;\n  \n  if (DAT_0061c6a0 == 0) {\n    DAT_0061c6a0 = FUN_0040c600(0x2f,0,FUN_00405910,FUN_00405920,0);\n    if (DAT_0061c6a0 == 0) goto LAB_004061e0;\n  }\n  lVar1 = DAT_0061c6a0;\n  *(undefined *)(param_1 + 0xc) = 1;\n  lVar1 = FUN_0040cda0(lVar1,param_1);\n  if (lVar1 != 0) {\n    return;\n  }\nLAB_004061e0:\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_00406190"
        },
        {
            "funcStartAddr": "0x4061f0",
            "funcEndAddr": "0x406311",
            "decompiledFuncCode": "\nlong * FUN_004061f0(long *param_1,long *param_2,long param_3,ulong param_4,long param_5,char param_6\n                   )\n\n{\n  long *plVar1;\n  int iVar2;\n  long lVar3;\n  long *plVar4;\n  long lVar5;\n  ulong uVar6;\n  long *plVar7;\n  \n  while( true ) {\n    plVar7 = param_2;\n    lVar5 = param_3 + param_5 * -0x20;\n    if (param_6 == '\\0') {\n      uVar6 = (ulong)param_1[6] >> 1;\n      lVar3 = param_1[6] - uVar6;\n      plVar4 = param_1 + 3;\n    }\n    else {\n      uVar6 = (ulong)param_1[5] >> 1;\n      lVar3 = param_1[5] - uVar6;\n      plVar4 = param_1 + 2;\n    }\n    param_3 = lVar5 + uVar6 * -0x20;\n    plVar7[6] = lVar3;\n    iVar2 = *(int *)(param_1 + 10);\n    plVar1 = plVar7 + 0x10;\n    plVar7[7] = (long)param_1;\n    plVar7[2] = lVar5;\n    *plVar7 = lVar5;\n    plVar7[3] = param_3;\n    plVar7[1] = param_3;\n    plVar7[4] = (long)plVar4;\n    plVar7[5] = uVar6;\n    *(int *)(plVar7 + 10) = iVar2 + 1;\n    *(undefined *)((long)plVar7 + 0x54) = 0;\n    pthread_mutex_init((pthread_mutex_t *)(plVar7 + 0xb),(pthread_mutexattr_t *)0x0);\n    if (param_4 < 2) break;\n    plVar7[8] = (long)plVar1;\n    uVar6 = param_4 >> 1;\n    param_4 = param_4 - uVar6;\n    param_2 = (long *)FUN_004061f0(plVar7,plVar1,lVar5,uVar6,param_5);\n    plVar7[9] = (long)param_2;\n    param_6 = '\\0';\n    param_1 = plVar7;\n  }\n  plVar7[8] = 0;\n  plVar7[9] = 0;\n  return plVar1;\n}\n\n",
            "funcName": "FUN_004061f0"
        },
        {
            "funcStartAddr": "0x406320",
            "funcEndAddr": "0x40635c",
            "decompiledFuncCode": "\nvoid FUN_00406320(undefined8 *param_1,long param_2)\n\n{\n  pthread_mutex_lock((pthread_mutex_t *)(param_1 + 1));\n  FUN_0040d070(*param_1,param_2);\n  *(undefined *)(param_2 + 0x54) = 1;\n  pthread_cond_signal((pthread_cond_t *)(param_1 + 6));\n  pthread_mutex_unlock((pthread_mutex_t *)(param_1 + 1));\n  return;\n}\n\n",
            "funcName": "FUN_00406320"
        },
        {
            "funcStartAddr": "0x406360",
            "funcEndAddr": "0x406455",
            "decompiledFuncCode": "\nbyte * FUN_00406360(byte *param_1,long param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  byte *pbVar3;\n  char cVar4;\n  byte *pbVar5;\n  long lVar6;\n  \n  pbVar3 = param_1 + param_2 + -1;\n  lVar1 = *param_3;\n  lVar2 = param_3[1];\n  pbVar5 = param_1;\n  if (DAT_0061c424 == 0x80) {\n    if (pbVar3 <= param_1) goto LAB_004063a0;\n    lVar6 = lVar1 + -1;\n    if (lVar1 != 0) {\n      do {\n        cVar4 = (&DAT_0061ca80)[*param_1];\n        while (cVar4 == '\\0') {\n          pbVar5 = param_1;\n          if (pbVar3 <= param_1) goto LAB_004063a0;\n          do {\n            param_1 = param_1 + 1;\n            pbVar5 = pbVar3;\n            if (pbVar3 == param_1) goto LAB_004063a0;\n            cVar4 = (&DAT_0061ca80)[*param_1];\n          } while (cVar4 == '\\0');\n          lVar6 = lVar6 + -1;\n          pbVar5 = param_1;\n          if (lVar6 == -1) goto LAB_004063c8;\n        }\n        param_1 = param_1 + 1;\n        if (pbVar3 <= param_1) {\n          if (param_1 + lVar2 < pbVar3) {\n            pbVar3 = param_1 + lVar2;\n          }\n          return pbVar3;\n        }\n      } while( true );\n    }\n  }\n  else {\n    if (pbVar3 <= param_1) goto LAB_004063a0;\n    lVar6 = lVar1 + -1;\n    if (lVar1 != 0) {\n      do {\n        while (DAT_0061c424 == (char)*param_1) {\n          pbVar5 = param_1;\n          if ((pbVar3 <= param_1) || (param_1 = param_1 + 1, pbVar5 = param_1, pbVar3 <= param_1))\n          goto LAB_004063a0;\n          lVar6 = lVar6 + -1;\n          if (lVar6 == -1) goto LAB_004063c8;\n        }\n        param_1 = param_1 + 1;\n        pbVar5 = param_1;\n      } while (param_1 < pbVar3);\n      goto LAB_004063a0;\n    }\n  }\nLAB_004063c8:\n  if (*(char *)(param_3 + 6) != '\\0') {\n    do {\n      if ((&DAT_0061ca80)[*pbVar5] == '\\0') {\n        if (pbVar5 + lVar2 < pbVar3) {\n          pbVar3 = pbVar5 + lVar2;\n        }\n        return pbVar3;\n      }\n      pbVar5 = pbVar5 + 1;\n    } while (pbVar5 < pbVar3);\n  }\nLAB_004063a0:\n  if (pbVar5 + lVar2 < pbVar3) {\n    pbVar3 = pbVar5 + lVar2;\n  }\n  return pbVar3;\n}\n\n",
            "funcName": "FUN_00406360"
        },
        {
            "funcStartAddr": "0x406470",
            "funcEndAddr": "0x406594",
            "decompiledFuncCode": "\nbyte * FUN_00406470(byte *param_1,long param_2,long param_3)\n\n{\n  byte *pbVar1;\n  ulong uVar2;\n  byte *pbVar3;\n  char cVar4;\n  long lVar5;\n  long lVar6;\n  ulong uVar7;\n  \n  uVar2 = *(ulong *)(param_3 + 0x18);\n  pbVar1 = param_1 + param_2 + -1;\n  lVar5 = *(long *)(param_3 + 0x10) + (ulong)(uVar2 == 0);\n  if (DAT_0061c424 == 0x80) {\n    if ((param_1 < pbVar1) && (lVar6 = lVar5 + -1, pbVar3 = param_1, lVar5 != 0)) {\n      do {\n        cVar4 = (&DAT_0061ca80)[*pbVar3];\n        while (cVar4 == '\\0') {\n          param_1 = pbVar3;\n          if (pbVar1 <= pbVar3) goto LAB_004064c0;\n          do {\n            pbVar3 = pbVar3 + 1;\n            param_1 = pbVar1;\n            if (pbVar1 == pbVar3) goto LAB_004064c0;\n            cVar4 = (&DAT_0061ca80)[*pbVar3];\n          } while (cVar4 == '\\0');\n          lVar6 = lVar6 + -1;\n          param_1 = pbVar3;\n          if (lVar6 == -1) goto LAB_004064c0;\n        }\n        param_1 = pbVar3 + 1;\n        pbVar3 = param_1;\n      } while (param_1 < pbVar1);\n    }\n  }\n  else if ((param_1 < pbVar1) && (uVar7 = lVar5 - 1, lVar5 != 0)) {\n    do {\n      while (DAT_0061c424 == (char)*param_1) {\n        if (pbVar1 <= param_1) goto LAB_004064c0;\n        if ((uVar2 | uVar7) == 0) {\n          return param_1;\n        }\n        param_1 = param_1 + 1;\n        if ((pbVar1 <= param_1) || (uVar7 = uVar7 - 1, uVar7 == 0xffffffffffffffff))\n        goto LAB_004064c0;\n      }\n      param_1 = param_1 + 1;\n    } while (param_1 < pbVar1);\n  }\nLAB_004064c0:\n  if (uVar2 == 0) {\n    return param_1;\n  }\n  if ((*(char *)(param_3 + 0x31) != '\\0') && (param_1 < pbVar1)) {\n    while ((&DAT_0061ca80)[*param_1] != '\\0') {\n      param_1 = param_1 + 1;\n      if (pbVar1 == param_1) {\n        pbVar3 = pbVar1 + uVar2;\n        if (pbVar1 <= pbVar1 + uVar2) {\n          pbVar3 = pbVar1;\n        }\n        return pbVar3;\n      }\n    }\n  }\n  pbVar3 = param_1 + uVar2;\n  if (pbVar1 <= param_1 + uVar2) {\n    pbVar3 = pbVar1;\n  }\n  return pbVar3;\n}\n\n",
            "funcName": "FUN_00406470"
        },
        {
            "funcStartAddr": "0x4065b0",
            "funcEndAddr": "0x407428",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00406a03) */\n/* WARNING: Removing unreachable block (ram,0x00406a12) */\n/* WARNING: Removing unreachable block (ram,0x00406a1a) */\n/* WARNING: Removing unreachable block (ram,0x00406a20) */\n/* WARNING: Removing unreachable block (ram,0x0040741c) */\n/* WARNING: Could not reconcile some variable overlaps */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUN_004065b0(byte **param_1,byte **param_2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  byte bVar3;\n  undefined4 uVar4;\n  int iVar5;\n  int iVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  byte *__nptr;\n  byte *pbVar9;\n  size_t sVar10;\n  long lVar11;\n  ulong __n;\n  ulong uVar12;\n  ulong uVar13;\n  ulong __n_00;\n  ulong uVar14;\n  ulong uVar15;\n  long *plVar16;\n  ulong __n_01;\n  byte *pbVar17;\n  byte *pbVar18;\n  byte *pbVar19;\n  size_t __size;\n  float10 in_ST0;\n  float10 fVar20;\n  float10 fVar21;\n  float10 in_ST1;\n  float10 in_ST2;\n  float10 in_ST3;\n  float10 in_ST4;\n  float10 in_ST5;\n  float10 in_ST6;\n  float10 in_ST7;\n  undefined local_2188 [8];\n  undefined2 uStack_2180;\n  byte local_2162;\n  byte local_2161;\n  byte *local_2160;\n  byte *local_2138;\n  byte *local_2130;\n  byte *local_2128;\n  byte *local_20e0;\n  byte *local_20d8 [2];\n  undefined local_20c8 [16];\n  undefined4 local_20b8;\n  undefined4 uStack_20b4;\n  undefined2 uStack_20b0;\n  undefined2 uStack_20ae;\n  undefined4 uStack_20ac;\n  undefined8 local_20a8;\n  undefined8 uStack_20a0;\n  undefined8 local_2098;\n  undefined8 uStack_2090;\n  undefined8 local_2088;\n  undefined8 uStack_2080;\n  undefined8 local_2078;\n  undefined8 uStack_2070;\n  undefined8 local_2068;\n  undefined8 uStack_2060;\n  undefined8 local_2058;\n  undefined8 uStack_2050;\n  undefined8 local_2048;\n  undefined8 uStack_2040;\n  undefined8 local_2038;\n  undefined8 uStack_2030;\n  undefined8 local_2028;\n  undefined4 local_2020;\n  undefined4 local_201c;\n  undefined4 uStack_2018;\n  undefined4 uStack_2014;\n  undefined4 uStack_2010;\n  undefined8 local_200c;\n  undefined8 uStack_2004;\n  undefined8 local_1ffc;\n  undefined8 uStack_1ff4;\n  undefined8 local_1fec;\n  undefined8 uStack_1fe4;\n  undefined8 local_1fdc;\n  undefined8 uStack_1fd4;\n  undefined8 local_1fcc;\n  undefined8 uStack_1fc4;\n  undefined8 local_1fbc;\n  undefined8 uStack_1fb4;\n  undefined8 local_1fac;\n  undefined8 uStack_1fa4;\n  undefined8 local_1f9c;\n  undefined8 uStack_1f94;\n  undefined8 local_1f8c;\n  undefined4 local_1f84;\n  byte local_1f78;\n  byte local_1f77 [3999];\n  byte local_fd8 [4008];\n  \n  __nptr = param_1[2];\n  pbVar7 = param_1[3];\n  pbVar8 = param_2[3];\n  plVar16 = DAT_0061c750;\n  pbVar9 = param_2[2];\nLAB_004065f8:\n  uVar13 = plVar16[5];\n  uVar2 = plVar16[4];\n  if (pbVar7 <= __nptr) {\n    pbVar7 = __nptr;\n  }\n  if (pbVar8 <= pbVar9) {\n    pbVar8 = pbVar9;\n  }\n  uVar15 = (long)pbVar7 - (long)__nptr;\n  uVar14 = (long)pbVar8 - (long)pbVar9;\n  if (((DAT_0061cba1 == '\\0') && ((plVar16[6] & 0xffffffffff0000U) == 0)) &&\n     (*(char *)(plVar16 + 7) == '\\0')) {\n    if (uVar2 != 0) {\n      if (uVar13 == 0) {\n        do {\n          if ((pbVar7 <= __nptr) || (*(char *)(uVar2 + *__nptr) == '\\0')) {\n            pbVar19 = pbVar9;\n            if (pbVar8 <= pbVar9) goto LAB_00406bee;\n            while (*(char *)(uVar2 + *pbVar9) != '\\0') {\n              pbVar9 = pbVar9 + 1;\n              pbVar19 = pbVar8;\n              if (pbVar8 == pbVar9) goto LAB_00406bee;\n            }\n            pbVar19 = pbVar9;\n            if ((pbVar7 <= __nptr) || (pbVar8 <= pbVar9)) goto LAB_00406bee;\n            iVar6 = (uint)*__nptr - (uint)*pbVar9;\n            if (iVar6 != 0) goto LAB_00407384;\n            pbVar9 = pbVar9 + 1;\n          }\n          __nptr = __nptr + 1;\n        } while( true );\n      }\n      do {\n        if ((pbVar7 <= __nptr) || (*(char *)(uVar2 + *__nptr) == '\\0')) {\n          pbVar19 = pbVar9;\n          if (pbVar8 <= pbVar9) goto LAB_00406bee;\n          while (*(char *)(uVar2 + *pbVar9) != '\\0') {\n            pbVar9 = pbVar9 + 1;\n            pbVar19 = pbVar8;\n            if (pbVar8 == pbVar9) goto LAB_00406bee;\n          }\n          pbVar19 = pbVar9;\n          if ((pbVar7 <= __nptr) || (pbVar8 <= pbVar9)) goto LAB_00406bee;\n          iVar6 = (uint)*(byte *)(uVar13 + *__nptr) - (uint)*(byte *)(uVar13 + *pbVar9);\n          if (iVar6 != 0) goto LAB_00407384;\n          pbVar9 = pbVar9 + 1;\n        }\n        __nptr = __nptr + 1;\n      } while( true );\n    }\n    if (uVar15 == 0) {\n      _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,-(uint)(uVar14 != 0));\n      goto LAB_004066f6;\n    }\n    if (uVar14 != 0) {\n      if (uVar13 != 0) {\n        while ((__nptr < pbVar7 && (pbVar9 < pbVar8))) {\n          iVar6 = (uint)*(byte *)(uVar13 + *__nptr) - (uint)*(byte *)(uVar13 + *pbVar9);\n          __nptr = __nptr + 1;\n          pbVar9 = pbVar9 + 1;\n          if (iVar6 != 0) goto LAB_00407384;\n        }\nLAB_00407409:\n        if (uVar14 <= uVar15) {\n          _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,(uint)(uVar15 != uVar14));\n          goto LAB_004066f6;\n        }\n        _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,0xffffffff);\n        goto LAB_0040738a;\n      }\n      uVar13 = uVar14;\n      if (uVar15 <= uVar14) {\n        uVar13 = uVar15;\n      }\n      iVar6 = memcmp(__nptr,pbVar9,uVar13);\n      _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\n      if (iVar6 == 0) goto LAB_00407409;\n      goto LAB_0040680d;\n    }\n    _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,1);\n    goto LAB_0040738a;\n  }\n  if ((uVar13 | uVar2) == 0) {\n    local_2162 = *pbVar7;\n    *pbVar7 = 0;\n    local_2161 = *pbVar8;\n    *pbVar8 = 0;\n    pbVar7 = pbVar9;\n    fVar20 = in_ST0;\n    fVar21 = in_ST1;\n  }\n  else {\n    if (uVar15 + 2 + uVar14 < 0xfa1) {\n      pbVar8 = &local_1f78;\n      local_2128 = (byte *)0x0;\n      pbVar7 = local_1f77 + uVar15;\n      if (uVar15 == 0) goto LAB_00406c75;\nLAB_004068d1:\n      pbVar19 = __nptr + uVar15;\n      uVar15 = 0;\n      do {\n        bVar3 = *__nptr;\n        if (uVar2 == 0) {\nLAB_00406909:\n          bVar3 = *(byte *)(uVar13 + bVar3);\nLAB_004068ec:\n          pbVar8[uVar15] = bVar3;\n          uVar15 = uVar15 + 1;\n        }\n        else if (*(char *)(uVar2 + bVar3) == '\\0') {\n          if (uVar13 != 0) goto LAB_00406909;\n          goto LAB_004068ec;\n        }\n        __nptr = __nptr + 1;\n      } while (pbVar19 != __nptr);\n      pbVar8[uVar15] = 0;\n      __nptr = pbVar8;\n      fVar20 = in_ST0;\n      fVar21 = in_ST1;\n    }\n    else {\n      _local_2188 = (float10)CONCAT28(uStack_2180,uVar15);\n      pbVar8 = (byte *)FUN_00411210();\n      pbVar7 = pbVar8 + uVar15 + 1;\n      local_2128 = pbVar8;\n      if (uVar15 != 0) goto LAB_004068d1;\nLAB_00406c75:\n      *pbVar8 = 0;\n      __nptr = pbVar8;\n      fVar20 = in_ST0;\n      fVar21 = in_ST1;\n    }\n    pbVar8 = pbVar7;\n    if (uVar14 != 0) {\n      pbVar8 = pbVar9 + uVar14;\n      uVar14 = 0;\n      do {\n        bVar3 = *pbVar9;\n        if (uVar2 == 0) {\nLAB_00406961:\n          bVar3 = *(byte *)(uVar13 + bVar3);\nLAB_00406944:\n          pbVar7[uVar14] = bVar3;\n          uVar14 = uVar14 + 1;\n        }\n        else if (*(char *)(uVar2 + bVar3) == '\\0') {\n          if (uVar13 != 0) goto LAB_00406961;\n          goto LAB_00406944;\n        }\n        pbVar9 = pbVar9 + 1;\n      } while (pbVar8 != pbVar9);\n      pbVar8 = pbVar7 + uVar14;\n    }\n    *pbVar8 = 0;\n  }\n  if (*(char *)((long)plVar16 + 0x32) == '\\0') {\n    if (*(char *)((long)plVar16 + 0x34) == '\\0') {\n      if (*(char *)((long)plVar16 + 0x35) == '\\0') {\n        if (*(char *)((long)plVar16 + 0x36) == '\\0') {\n          if (*(char *)((long)plVar16 + 0x33) == '\\0') {\n            if (*(char *)(plVar16 + 7) == '\\0') {\n              in_ST0 = fVar20;\n              in_ST1 = fVar21;\n              if (uVar15 == 0) {\n                _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,-(uint)(uVar14 != 0));\n              }\n              else {\n                _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,1);\n                if (uVar14 != 0) {\n                  uVar4 = FUN_004115c0(__nptr,uVar15 + 1,pbVar7,uVar14 + 1);\n                  _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,uVar4);\n                  in_ST0 = fVar20;\n                  in_ST1 = fVar21;\n                }\n              }\n            }\n            else {\n              uVar4 = FUN_0040b900(__nptr);\n              _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,uVar4);\n              in_ST0 = fVar20;\n              in_ST1 = fVar21;\n            }\n          }\n          else {\n            local_201c = _DAT_0061c600;\n            uStack_2018 = uRam000000000061c604;\n            uStack_2014 = uRam000000000061c608;\n            uStack_2010 = uRam000000000061c60c;\n            local_200c = _DAT_0061c610;\n            uStack_2004 = uRam000000000061c618;\n            local_1ffc = _DAT_0061c620;\n            uStack_1ff4 = uRam000000000061c628;\n            local_1fec = _DAT_0061c630;\n            uStack_1fe4 = uRam000000000061c638;\n            local_1fdc = _DAT_0061c640;\n            uStack_1fd4 = uRam000000000061c648;\n            local_1fcc = _DAT_0061c650;\n            uStack_1fc4 = uRam000000000061c658;\n            local_1fbc = _DAT_0061c660;\n            uStack_1fb4 = uRam000000000061c668;\n            local_1fac = _DAT_0061c670;\n            uStack_1fa4 = uRam000000000061c678;\n            local_1f9c = _DAT_0061c680;\n            uStack_1f94 = uRam000000000061c688;\n            local_1f8c = DAT_0061c690;\n            local_1f84 = DAT_0061c698;\n            local_20b8 = _DAT_0061c600;\n            uStack_20b4 = uRam000000000061c604;\n            uStack_20b0 = (undefined2)uRam000000000061c608;\n            uStack_20ae = (undefined2)((uint)uRam000000000061c608 >> 0x10);\n            uStack_20ac = uRam000000000061c60c;\n            local_20a8 = _DAT_0061c610;\n            uStack_20a0 = uRam000000000061c618;\n            local_2098 = _DAT_0061c620;\n            uStack_2090 = uRam000000000061c628;\n            local_2088 = _DAT_0061c630;\n            uStack_2080 = uRam000000000061c638;\n            local_2078 = _DAT_0061c640;\n            uStack_2070 = uRam000000000061c648;\n            local_2068 = _DAT_0061c650;\n            uStack_2060 = uRam000000000061c658;\n            local_2058 = _DAT_0061c660;\n            uStack_2050 = uRam000000000061c668;\n            local_2048 = _DAT_0061c670;\n            uStack_2040 = uRam000000000061c678;\n            local_2038 = _DAT_0061c680;\n            uStack_2030 = uRam000000000061c688;\n            local_2028 = DAT_0061c690;\n            local_2020 = DAT_0061c698;\n            if (DAT_0061cba1 != '\\0') {\n              pbVar8 = __nptr + uVar15;\n              _local_2188 = (float10)((unkuint10)stack0xffffffffffffde7c << 0x20);\n              pbVar18 = local_fd8;\n              pbVar9 = pbVar7 + uVar14;\n              uVar12 = (uVar15 + uVar14) * 3 + 2;\n              local_2138 = (byte *)0x0;\n              __size = 4000;\n              pbVar19 = __nptr;\n              local_2160 = pbVar7;\nLAB_00406e30:\n              if (__size < uVar12) goto LAB_00406f13;\nLAB_00406e3b:\n              pbVar17 = pbVar18;\n              sVar10 = __size;\n              if (pbVar19 < pbVar8) goto LAB_00406f66;\nLAB_00406e46:\n              sVar10 = __size;\n              if (local_2160 < pbVar9) {\n                __n_00 = 0;\n                pbVar17 = pbVar18;\n                goto LAB_00406f95;\n              }\n              __n_01 = 0;\n              __n_00 = 0;\nLAB_00406e5b:\n              __size = sVar10;\n              local_2130 = pbVar18 + __n_00;\n              if (pbVar19 < pbVar8) {\n                sVar10 = strlen((char *)pbVar19);\n                pbVar19 = pbVar19 + sVar10 + 1;\n                if (pbVar9 <= local_2160) goto LAB_00406e90;\n              }\n              else if (pbVar9 <= local_2160) {\nLAB_0040703a:\n                local_2160 = (byte *)__n_01;\n                FUN_0040b360(pbVar18,__n_00,&local_20b8);\n                FUN_0040b250(&local_20b8,local_20d8);\n                FUN_0040b360(local_2130,local_2160,&local_201c);\n                FUN_0040b250(&local_201c,local_20c8);\n                iVar6 = memcmp(local_20d8,local_20c8,0x10);\n                if (iVar6 != 0) goto LAB_00407315;\n                if (local_2188._0_4_ != 0) goto LAB_00407318;\n                goto LAB_004072d3;\n              }\nLAB_004070fa:\n              sVar10 = strlen((char *)local_2160);\n              local_2160 = local_2160 + sVar10 + 1;\nLAB_00406e90:\n              do {\n                if ((pbVar8 <= pbVar19) && (pbVar9 <= local_2160)) goto LAB_0040703a;\n                FUN_0040b360(pbVar18,__n_00,&local_20b8);\n                FUN_0040b360(local_2130,__n_01,&local_201c);\n                if (local_2188._0_4_ != 0) goto LAB_00406e30;\n                __n = __n_01;\n                if (__n_00 <= __n_01) {\n                  __n = __n_00;\n                }\n                iVar6 = memcmp(pbVar18,local_2130,__n);\n                _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\n                if (iVar6 != 0) goto LAB_00406e30;\n                _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,\n                                                (uint)(__n_01 < __n_00) - (uint)(__n_00 < __n_01));\n                if (uVar12 <= __size) goto LAB_00406e3b;\nLAB_00406f13:\n                __size = __size * 3 >> 1;\n                if (__size <= uVar12) {\n                  __size = uVar12;\n                }\n                free(local_2138);\n                local_2138 = (byte *)malloc(__size);\n                pbVar18 = local_2138;\n                if (local_2138 == (byte *)0x0) {\n                  __size = 4000;\n                  pbVar18 = local_fd8;\n                }\n                pbVar17 = pbVar18;\n                sVar10 = __size;\n                if (pbVar8 <= pbVar19) goto LAB_00406e46;\nLAB_00406f66:\n                lVar11 = FUN_00405ef0(pbVar17,pbVar19,sVar10);\n                __n_00 = lVar11 + 1;\n                if (local_2160 < pbVar9) {\n                  if (sVar10 < __n_00) {\n                    __size = 0;\n                    pbVar18 = (byte *)0x0;\n                  }\n                  else {\n                    pbVar18 = pbVar17 + __n_00;\n                    __size = sVar10 - __n_00;\n                  }\nLAB_00406f95:\n                  lVar11 = FUN_00405ef0(pbVar18,local_2160,__size);\n                  __n_01 = lVar11 + 1;\n                  __size = __n_01 + __n_00;\n                  if (__n_00 <= sVar10) {\nLAB_004073ac:\n                    pbVar18 = pbVar17;\n                    if (__size <= sVar10) goto LAB_00406e5b;\n                  }\n                }\n                else {\n                  __n_01 = 0;\n                  __size = __n_00;\n                  if (__n_00 <= sVar10) goto LAB_004073ac;\n                }\n                if (__size < 0x5555555555555555) {\n                  __size = __size * 3 >> 1;\n                }\n                free(local_2138);\n                pbVar18 = (byte *)FUN_00411210(__size);\n                if (pbVar19 < pbVar8) {\n                  strxfrm((char *)pbVar18,(char *)pbVar19,__n_00);\n                }\n                local_2130 = pbVar18 + __n_00;\n                local_2138 = pbVar18;\n                if (local_2160 < pbVar9) goto LAB_004070d0;\n                if (pbVar8 <= pbVar19) goto LAB_0040703a;\n                sVar10 = strlen((char *)pbVar19);\n                pbVar19 = pbVar19 + sVar10 + 1;\n              } while( true );\n            }\n            _local_2188 = (float10)CONCAT28(uStack_2180,uVar14);\n            FUN_0040b360(__nptr,uVar15,&local_20b8);\n            FUN_0040b250(&local_20b8,local_20d8);\n            FUN_0040b360(pbVar7,uVar14,&local_201c);\n            FUN_0040b250(&local_201c,local_20c8);\n            iVar6 = memcmp(local_20d8,local_20c8,0x10);\n            _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\n            if (iVar6 == 0) {\n              local_2138 = (byte *)0x0;\n              __n_00 = uVar15;\n              pbVar18 = __nptr;\n              local_2160 = (byte *)uVar14;\n              local_2130 = pbVar7;\nLAB_004072d3:\n              uVar12 = (ulong)local_2160;\n              if (__n_00 <= local_2160) {\n                uVar12 = __n_00;\n              }\n              iVar6 = memcmp(pbVar18,local_2130,uVar12);\n              _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\n              if (iVar6 == 0) {\n                iVar6 = (uint)(local_2160 < __n_00) - (uint)(__n_00 < local_2160);\nLAB_00407315:\n                _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\n              }\n            }\n            else {\n              local_2138 = (byte *)0x0;\n            }\nLAB_00407318:\n            free(local_2138);\n            in_ST0 = fVar20;\n            in_ST1 = fVar21;\n          }\n        }\n        else {\n          iVar6 = thunk_FUN_00405a4c(__nptr,0);\n          iVar5 = thunk_FUN_00405a4c(pbVar7);\n          _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6 - iVar5);\n          in_ST0 = fVar20;\n          in_ST1 = fVar21;\n        }\n      }\n      else {\n        cVar1 = (&DAT_0061ca80)[*__nptr];\n        pbVar8 = __nptr;\n        while (cVar1 != '\\0') {\n          pbVar8 = pbVar8 + 1;\n          cVar1 = (&DAT_0061ca80)[*pbVar8];\n        }\n        cVar1 = (&DAT_0061ca80)[*pbVar7];\n        pbVar9 = pbVar7;\n        while (cVar1 != '\\0') {\n          pbVar9 = pbVar9 + 1;\n          cVar1 = (&DAT_0061ca80)[*pbVar9];\n        }\n        iVar6 = FUN_004059f0(pbVar8);\n        iVar5 = FUN_004059f0(pbVar9);\n        _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6 - iVar5);\n        in_ST0 = fVar20;\n        in_ST1 = fVar21;\n        if (iVar6 - iVar5 == 0) {\n          uVar4 = FUN_004106a0(pbVar8,pbVar9,DAT_0061cba8,DAT_0061cba4);\n          _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,uVar4);\n          in_ST0 = fVar20;\n          in_ST1 = fVar21;\n        }\n      }\n    }\n    else {\n      in_ST0 = in_ST2;\n      in_ST1 = in_ST3;\n      in_ST2 = in_ST4;\n      in_ST3 = in_ST5;\n      in_ST4 = in_ST6;\n      in_ST5 = in_ST7;\n      strtold((char *)__nptr,(char **)&local_20e0);\n      strtold((char *)pbVar7,(char **)local_20d8);\n      stack0xffffffffffffde7c = (uint6)((unkuint10)fVar20 >> 0x20);\n      in_ST6 = in_ST5;\n      in_ST7 = in_ST5;\n      if (__nptr == local_20e0) {\n        _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,-(uint)(local_20d8[0] != pbVar7));\n      }\n      else if (pbVar7 == local_20d8[0]) {\n        _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,1);\n      }\n      else {\n        _local_2188 = fVar20;\n        if (fVar20 < fVar21) {\nLAB_0040749d:\n          _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,0xffffffff);\n        }\n        else {\n          _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,1);\n          if (fVar20 <= fVar21) {\n            if (fVar20 != fVar21) goto LAB_0040749d;\n            _local_2188 = (float10)((unkuint10)stack0xffffffffffffde7c << 0x20);\n          }\n        }\n      }\n    }\n  }\n  else {\n    cVar1 = (&DAT_0061ca80)[*__nptr];\n    pbVar8 = __nptr;\n    while (cVar1 != '\\0') {\n      pbVar8 = pbVar8 + 1;\n      cVar1 = (&DAT_0061ca80)[*pbVar8];\n    }\n    cVar1 = (&DAT_0061ca80)[*pbVar7];\n    pbVar9 = pbVar7;\n    while (cVar1 != '\\0') {\n      pbVar9 = pbVar9 + 1;\n      cVar1 = (&DAT_0061ca80)[*pbVar9];\n    }\n    uVar4 = FUN_004106a0(pbVar8,pbVar9,DAT_0061cba8,DAT_0061cba4);\n    _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,uVar4);\n    in_ST0 = fVar20;\n    in_ST1 = fVar21;\n  }\n  if ((uVar13 | uVar2) == 0) {\n    __nptr[uVar15] = local_2162;\n    pbVar7[uVar14] = local_2161;\n    goto LAB_004066f6;\n  }\n  free(local_2128);\n  if (local_2188._0_4_ != 0) goto LAB_0040680d;\n  goto LAB_00406701;\nLAB_00407384:\n  _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,iVar6);\nLAB_0040738a:\n  cVar1 = *(char *)((long)plVar16 + 0x37);\n  goto joined_r0x0040738f;\nLAB_004070d0:\n  strxfrm((char *)local_2130,(char *)local_2160,__n_01);\n  if (pbVar19 < pbVar8) {\n    sVar10 = strlen((char *)pbVar19);\n    pbVar19 = pbVar19 + sVar10 + 1;\n  }\n  goto LAB_004070fa;\nLAB_00406bee:\n  _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,\n                                  (uint)(__nptr < pbVar7) - (uint)(pbVar19 < pbVar8));\nLAB_004066f6:\n  if (local_2188._0_4_ == 0) {\nLAB_00406701:\n    plVar16 = (long *)plVar16[8];\n    if (plVar16 == (long *)0x0) goto LAB_0040681b;\n    __nptr = *param_1;\n    pbVar9 = param_1[1];\n    pbVar19 = *param_2;\n    pbVar18 = param_2[1];\n    if (plVar16[2] == -1) {\n      lVar11 = *plVar16;\n      pbVar7 = __nptr + -1 + (long)pbVar9;\n      pbVar8 = pbVar19 + -1 + (long)pbVar18;\n    }\n    else {\n      pbVar7 = (byte *)FUN_00406470(__nptr,pbVar9,plVar16);\n      pbVar8 = (byte *)FUN_00406470(pbVar19,pbVar18,plVar16);\n      lVar11 = *plVar16;\n    }\n    if (lVar11 == -1) {\n      pbVar9 = pbVar19;\n      if (*(char *)(plVar16 + 6) != '\\0') {\n        pbVar18 = __nptr;\n        if (__nptr < pbVar7) {\n          do {\n            __nptr = pbVar18;\n            if ((&DAT_0061ca80)[*pbVar18] == '\\0') break;\n            pbVar18 = pbVar18 + 1;\n            __nptr = pbVar7;\n          } while (pbVar7 != pbVar18);\n        }\n        if (pbVar19 < pbVar8) {\n          do {\n            pbVar9 = pbVar19;\n            if ((&DAT_0061ca80)[*pbVar19] == '\\0') break;\n            pbVar19 = pbVar19 + 1;\n            pbVar9 = pbVar8;\n          } while (pbVar8 != pbVar19);\n        }\n      }\n    }\n    else {\n      __nptr = (byte *)FUN_00406360(__nptr,pbVar9,plVar16);\n      pbVar9 = (byte *)FUN_00406360(pbVar19,pbVar18,plVar16);\n    }\n    goto LAB_004065f8;\n  }\nLAB_0040680d:\n  cVar1 = *(char *)((long)plVar16 + 0x37);\njoined_r0x0040738f:\n  if (cVar1 != '\\0') {\n    stack0xffffffffffffde7c = (uint6)((unkuint10)_local_2188 >> 0x20);\n    _local_2188 = (float10)CONCAT64(stack0xffffffffffffde7c,-local_2188._0_4_);\n  }\nLAB_0040681b:\n  return local_2188._0_4_;\n}\n\n",
            "funcName": "FUN_004065b0"
        },
        {
            "funcStartAddr": "0x4074d0",
            "funcEndAddr": "0x40782f",
            "decompiledFuncCode": "\nundefined8 FUN_004074d0(byte **param_1,FILE *param_2,undefined8 param_3)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte bVar3;\n  long *plVar4;\n  byte *pbVar5;\n  ulong __n;\n  size_t sVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  undefined8 uVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  byte *pbVar12;\n  byte *pbVar13;\n  byte *pbVar14;\n  byte **ppbVar15;\n  byte **ppbVar16;\n  byte *local_70;\n  \n  plVar4 = DAT_0061c750;\n  bVar3 = DAT_0061c500;\n  lVar2 = (long)DAT_0061c428;\n  if (*(char *)(param_1 + 6) != '\\0') {\n    return 0;\n  }\n  pbVar12 = param_1[1];\n  pbVar11 = *param_1;\n  pbVar7 = param_1[4];\n  pbVar1 = param_1[5];\n  if (pbVar12 == pbVar7) {\n    pbVar7 = param_1[2];\n  }\n  else {\n    memmove(pbVar11,pbVar11 + ((long)pbVar12 - (long)pbVar7),(size_t)pbVar7);\n    pbVar12 = param_1[4];\n    pbVar11 = *param_1;\n    param_1[2] = (byte *)0x0;\n    param_1[1] = pbVar12;\n    pbVar7 = (byte *)0x0;\n  }\n  pbVar10 = (byte *)(lVar2 + -0x22);\n  pbVar14 = param_1[3];\n  do {\n    pbVar12 = pbVar11 + (long)pbVar12;\n    ppbVar15 = (byte **)(pbVar14 + (long)pbVar11 + (long)pbVar7 * -0x20);\n    pbVar14 = pbVar14 + (long)pbVar11 + (-(long)pbVar12 - (long)pbVar1 * (long)pbVar7);\n    if (pbVar7 != (byte *)0x0) {\n      pbVar11 = ppbVar15[1] + (long)*ppbVar15;\n    }\n    do {\n      local_70 = pbVar12;\n      if (pbVar14 <= pbVar1 + 1) break;\n      __n = (ulong)(pbVar14 + -1) / (ulong)(pbVar1 + 1);\n      sVar6 = fread_unlocked(pbVar12,1,__n,param_2);\n      pbVar7 = pbVar12 + sVar6;\n      pbVar14 = pbVar14 + -sVar6;\n      pbVar5 = pbVar11;\n      ppbVar16 = ppbVar15;\n      local_70 = pbVar7;\n      if (__n != sVar6) {\n        if ((param_2->_flags & 0x20U) != 0) {\n          uVar9 = dcgettext(0,\"read failed\",5);\n                    /* WARNING: Subroutine does not return */\n          FUN_00405dd0(uVar9,param_3);\n        }\n        if ((param_2->_flags & 0x10U) != 0) {\n          *(undefined *)(param_1 + 6) = 1;\n          if (*param_1 == pbVar7) {\n            return 0;\n          }\n          if ((pbVar11 != pbVar7) && (pbVar7[-1] != bVar3)) {\n            *pbVar7 = bVar3;\n            pbVar7 = pbVar7 + 1;\n            local_70 = pbVar7;\n          }\n        }\n      }\n      while (ppbVar15 = ppbVar16, pbVar11 = pbVar5,\n            pbVar8 = (byte *)FUN_00413030(pbVar12,(int)(char)bVar3,(long)pbVar7 - (long)pbVar12),\n            pbVar8 != (byte *)0x0) {\n        pbVar12 = pbVar8 + 1;\n        ppbVar16 = ppbVar15 + -4;\n        *pbVar8 = 0;\n        *ppbVar16 = pbVar11;\n        pbVar13 = pbVar12 + -(long)pbVar11;\n        ppbVar15[-3] = pbVar13;\n        if (pbVar10 < pbVar13) {\n          pbVar10 = pbVar13;\n        }\n        pbVar14 = pbVar14 + -(long)pbVar1;\n        pbVar5 = pbVar12;\n        if (plVar4 != (long *)0x0) {\n          if (plVar4[2] != -1) {\n            pbVar8 = (byte *)FUN_00406470(pbVar11,pbVar13,plVar4);\n          }\n          lVar2 = *plVar4;\n          ppbVar15[-1] = pbVar8;\n          if (lVar2 == -1) {\n            if (*(char *)(plVar4 + 6) != '\\0') {\n              while ((&DAT_0061ca80)[*pbVar11] != '\\0') {\n                pbVar11 = pbVar11 + 1;\n              }\n            }\n            ppbVar15[-2] = pbVar11;\n            pbVar5 = pbVar12;\n          }\n          else {\n            pbVar11 = (byte *)FUN_00406360(pbVar11,pbVar13,plVar4);\n            ppbVar15[-2] = pbVar11;\n            pbVar5 = pbVar12;\n          }\n        }\n      }\n      pbVar12 = local_70;\n    } while (*(char *)(param_1 + 6) == '\\0');\n    pbVar12 = *param_1;\n    pbVar14 = param_1[3];\n    param_1[1] = local_70 + -(long)pbVar12;\n    pbVar7 = (byte *)((long)(pbVar12 + (long)pbVar14) - (long)ppbVar15 >> 5);\n    param_1[2] = pbVar7;\n    if (pbVar7 != (byte *)0x0) {\n      DAT_0061c428 = pbVar10 + 0x22;\n      param_1[4] = local_70 + -(long)pbVar11;\n      return 1;\n    }\n    if (pbVar12 == (byte *)0x0) {\n      if (pbVar14 < (byte *)0x20) {\n        pbVar14 = (byte *)0x80;\n      }\n      else {\n        pbVar14 = (byte *)((ulong)pbVar14 & 0xffffffffffffffe0);\n        if ((long)pbVar14 < 0) goto LAB_00407842;\n      }\n    }\n    else {\n      if ((byte *)0x555555555555553f < pbVar14) {\nLAB_00407842:\n                    /* WARNING: Subroutine does not return */\n        FUN_00411460();\n      }\n      pbVar14 = (byte *)((((ulong)pbVar14 >> 5) + 1 + ((ulong)pbVar14 >> 6)) * 0x20);\n    }\n    pbVar11 = (byte *)FUN_00411270(pbVar12,pbVar14);\n    *param_1 = pbVar11;\n    pbVar12 = param_1[1];\n    param_1[3] = pbVar14;\n    pbVar7 = param_1[2];\n  } while( true );\n}\n\n",
            "funcName": "FUN_004074d0"
        },
        {
            "funcStartAddr": "0x407850",
            "funcEndAddr": "0x40787c",
            "decompiledFuncCode": "\nbool FUN_00407850(long param_1,long param_2)\n\n{\n  if (*(uint *)(param_1 + 0x50) != *(uint *)(param_2 + 0x50)) {\n    return *(uint *)(param_1 + 0x50) < *(uint *)(param_2 + 0x50);\n  }\n  return (ulong)(*(long *)(param_1 + 0x30) + *(long *)(param_1 + 0x28)) <\n         (ulong)(*(long *)(param_2 + 0x30) + *(long *)(param_2 + 0x28));\n}\n\n",
            "funcName": "FUN_00407850"
        },
        {
            "funcStartAddr": "0x407880",
            "funcEndAddr": "0x407890",
            "decompiledFuncCode": "\nvoid FUN_00407880(long param_1)\n\n{\n  pthread_sigmask(2,(__sigset_t *)(param_1 + 8),(__sigset_t *)0x0);\n  return;\n}\n\n",
            "funcName": "FUN_00407880"
        },
        {
            "funcStartAddr": "0x407890",
            "funcEndAddr": "0x407918",
            "decompiledFuncCode": "\nvoid FUN_00407890(void)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  char local_98 [8];\n  __sigset_t local_90;\n  \n  if (DAT_0061c6a8 != (undefined8 *)0x0) {\n    iVar2 = pthread_sigmask(0,(__sigset_t *)&DAT_0061c6c0,&local_90);\n    local_98[0] = iVar2 == 0;\n    for (puVar1 = DAT_0061c6a8; puVar1 != (undefined8 *)0x0; puVar1 = (undefined8 *)*puVar1) {\n      unlink((char *)((long)puVar1 + 0xd));\n    }\n    DAT_0061c6a8 = (undefined8 *)0x0;\n    if (local_98[0] != '\\0') {\n      FUN_00407880(local_98);\n      FUN_0040a9f0();\n      return;\n    }\n  }\n  FUN_0040a9f0();\n  return;\n}\n\n",
            "funcName": "FUN_00407890"
        },
        {
            "funcStartAddr": "0x407920",
            "funcEndAddr": "0x407a28",
            "decompiledFuncCode": "\nvoid FUN_00407920(char *param_1)\n\n{\n  long *plVar1;\n  long **pplVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long **__ptr;\n  long **pplVar8;\n  char local_c8 [8];\n  __sigset_t local_c0;\n  \n  pplVar8 = (long **)&DAT_0061c6a8;\n  __ptr = DAT_0061c6a8;\n  if (param_1 != (char *)((long)DAT_0061c6a8 + 0xd)) {\n    pplVar2 = (long **)*DAT_0061c6a8;\n    pplVar8 = DAT_0061c6a8;\n    while (__ptr = pplVar2, (char *)((long)__ptr + 0xd) != param_1) {\n      pplVar8 = __ptr;\n      pplVar2 = (long **)*__ptr;\n    }\n  }\n  if (*(char *)((long)__ptr + 0xc) == '\\x01') {\n    FUN_004060a0();\n  }\n  plVar1 = *__ptr;\n  iVar3 = pthread_sigmask(0,(__sigset_t *)&DAT_0061c6c0,&local_c0);\n  local_c8[0] = iVar3 == 0;\n  iVar4 = unlink(param_1);\n  piVar5 = __errno_location();\n  iVar3 = *piVar5;\n  *pplVar8 = plVar1;\n  if (local_c8[0] != '\\0') {\n    FUN_00407880(local_c8);\n  }\n  if (iVar4 != 0) {\n    uVar6 = FUN_0040f700(0,3,param_1);\n    uVar7 = dcgettext(0,\"warning: cannot remove: %s\",5);\n                    /* WARNING: Subroutine does not return */\n    error(0,iVar3,uVar7,uVar6);\n  }\n  if (plVar1 == (long *)0x0) {\n    PTR_DAT_0061c418 = (undefined *)pplVar8;\n  }\n  free(__ptr);\n  return;\n}\n\n",
            "funcName": "FUN_00407920"
        },
        {
            "funcStartAddr": "0x407a30",
            "funcEndAddr": "0x407bdb",
            "decompiledFuncCode": "\n__pid_t FUN_00407a30(int *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  int iVar3;\n  __pid_t _Var4;\n  int *piVar5;\n  double local_e0;\n  __sigset_t local_c0;\n  \n  iVar2 = FUN_0040da00(param_1,0x80000);\n  if (iVar2 < 0) {\n    _Var4 = -1;\n  }\n  else {\n    if (DAT_0061c420 + 1U < DAT_0061c69c) {\n      FUN_00405fb0();\n      do {\n        if ((int)DAT_0061c69c < 1) break;\n        iVar2 = FUN_00405fb0();\n      } while (iVar2 != 0);\n    }\n    piVar5 = __errno_location();\n    param_2 = param_2 + -1;\n    local_e0 = DAT_00416a30;\n    do {\n      iVar3 = pthread_sigmask(0,(__sigset_t *)&DAT_0061c6c0,&local_c0);\n      uVar1 = DAT_0061c6a8;\n      DAT_0061c6a8 = 0;\n      _Var4 = fork();\n      iVar2 = *piVar5;\n      if (_Var4 == 0) {\n        if (iVar3 != 0) goto LAB_00407ba0;\nLAB_00407b45:\n        FUN_00407880();\n      }\n      else {\n        DAT_0061c6a8 = uVar1;\n        if (iVar3 == 0) goto LAB_00407b45;\n      }\n      *piVar5 = iVar2;\n      if (-1 < _Var4) {\n        if (_Var4 != 0) {\n          DAT_0061c69c = DAT_0061c69c + 1;\n          return _Var4;\n        }\nLAB_00407ba0:\n        close(0);\n        close(1);\n        return 0;\n      }\n      if (iVar2 != 0xb) goto LAB_00407b84;\n      FUN_00411620(local_e0);\n      local_e0 = local_e0 + local_e0;\n      do {\n        if ((int)DAT_0061c69c < 1) break;\n        iVar2 = FUN_00405fb0();\n      } while (iVar2 != 0);\n      param_2 = param_2 + -1;\n    } while (param_2 != -1);\n    iVar2 = *piVar5;\nLAB_00407b84:\n    close(*param_1);\n    close(param_1[1]);\n    *piVar5 = iVar2;\n  }\n  return _Var4;\n}\n\n",
            "funcName": "FUN_00407a30"
        },
        {
            "funcStartAddr": "0x407c00",
            "funcEndAddr": "0x407cac",
            "decompiledFuncCode": "\nundefined8 FUN_00407c00(undefined8 param_1,undefined8 *param_2,long param_3)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 local_28;\n  undefined8 local_20;\n  \n  uVar1 = FUN_00411b40(param_1,&local_28,10,&local_20,\"\");\n  switch(uVar1) {\n  case 0:\n  case 2:\n    *param_2 = local_20;\n    break;\n  case 1:\n  case 3:\n    *param_2 = 0xffffffffffffffff;\n    break;\n  case 4:\n    if (param_3 != 0) {\n      uVar2 = FUN_0040f880(param_1);\n      uVar3 = dcgettext(0,param_3,5);\n      uVar4 = dcgettext(0,\"%s: invalid count at start of %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(2,0,uVar4,uVar3,uVar2);\n    }\n    return 0;\n  }\n  return local_28;\n}\n\n",
            "funcName": "FUN_00407c00"
        },
        {
            "funcStartAddr": "0x407cd0",
            "funcEndAddr": "0x407dca",
            "decompiledFuncCode": "\nFILE * FUN_00407cd0(byte *param_1,byte *param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  FILE *pFVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  long lVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  bool bVar10;\n  bool bVar11;\n  \n  bVar1 = *param_2;\n  bVar10 = bVar1 < 0x72;\n  bVar11 = bVar1 == 0x72;\n  if (!bVar11) {\n    if (bVar1 != 0x77) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"!\\\"unexpected mode passed to stream_open\\\"\",\"src/sort.c\",0x3cc,\"stream_open\");\n    }\n    if (param_1 != (byte *)0x0) {\n      iVar2 = ftruncate(1,0);\n      if (iVar2 != 0) {\n        uVar4 = FUN_0040f700(0,3,param_1);\n        uVar5 = dcgettext(0,\"%s: error truncating\",5);\n        piVar6 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(2,*piVar6,uVar5,uVar4);\n      }\n    }\n    return stdout;\n  }\n  lVar7 = 2;\n  pbVar8 = param_1;\n  pbVar9 = &DAT_0041814a;\n  do {\n    if (lVar7 == 0) break;\n    lVar7 = lVar7 + -1;\n    bVar10 = *pbVar8 < *pbVar9;\n    bVar11 = *pbVar8 == *pbVar9;\n    pbVar8 = pbVar8 + 1;\n    pbVar9 = pbVar9 + 1;\n  } while (bVar11);\n  if ((!bVar10 && !bVar11) == bVar10) {\n    DAT_0061c758 = 1;\n    pFVar3 = stdin;\n  }\n  else {\n    pFVar3 = (FILE *)0x0;\n    iVar2 = open((char *)param_1,0x80000);\n    if (-1 < iVar2) {\n      pFVar3 = fdopen(iVar2,(char *)param_2);\n    }\n  }\n  FUN_0040b800(pFVar3,2);\n  return pFVar3;\n}\n\n",
            "funcName": "FUN_00407cd0"
        },
        {
            "funcStartAddr": "0x407dd0",
            "funcEndAddr": "0x407df0",
            "decompiledFuncCode": "\nvoid FUN_00407dd0(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"open failed\",5);\n                    /* WARNING: Subroutine does not return */\n  FUN_00405dd0(uVar1,param_1);\n}\n\n",
            "funcName": "FUN_00407dd0"
        },
        {
            "funcStartAddr": "0x407df0",
            "funcEndAddr": "0x407e64",
            "decompiledFuncCode": "\nvoid FUN_00407df0(FILE *param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  char *pcVar3;\n  \n  iVar2 = fileno(param_1);\n  if (iVar2 == 0) {\n    if ((*(byte *)&param_1->_flags & 0x10) != 0) {\n      clearerr_unlocked(param_1);\n      return;\n    }\n  }\n  else if (iVar2 == 1) {\n    iVar2 = fflush_unlocked(param_1);\n    if (iVar2 != 0) {\n      pcVar3 = \"fflush failed\";\n      goto LAB_00407e5a;\n    }\n  }\n  else {\n    iVar2 = FUN_00411f80(param_1);\n    if (iVar2 != 0) {\n      pcVar3 = \"close failed\";\nLAB_00407e5a:\n      uVar1 = dcgettext(0,pcVar3,5);\n                    /* WARNING: Subroutine does not return */\n      FUN_00405dd0(uVar1,param_2);\n    }\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00407df0"
        },
        {
            "funcStartAddr": "0x407e70",
            "funcEndAddr": "0x40824e",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid FUN_00407e70(byte **param_1,_IO_FILE *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte bVar3;\n  byte bVar4;\n  int iVar5;\n  byte *pbVar6;\n  byte *__nptr;\n  byte *pbVar7;\n  long lVar8;\n  long lVar9;\n  undefined8 uVar10;\n  byte *pbVar11;\n  uint uVar12;\n  long *plVar13;\n  byte *local_48;\n  byte *local_40 [2];\n  \n  pbVar6 = *param_1;\n  pbVar11 = param_1[1];\n  pbVar7 = pbVar6 + (long)pbVar11;\n  if ((param_3 != 0) || (DAT_0061c740 == '\\0')) {\n    pbVar7[-1] = DAT_0061c500;\n    pbVar6 = (byte *)fwrite_unlocked(pbVar6,1,(size_t)pbVar11,param_2);\n    if (pbVar11 == pbVar6) {\n      pbVar7[-1] = 0;\n      return;\n    }\n    uVar10 = dcgettext(0,\"write failed\",5);\n                    /* WARNING: Subroutine does not return */\n    FUN_00405dd0(uVar10,param_3);\n  }\n  if (pbVar6 < pbVar7) {\n    do {\n      pbVar11 = pbVar6 + 1;\n      bVar3 = *pbVar6;\n      if (bVar3 == 9) {\n        uVar12 = 0x3e;\n        bVar3 = 0x3e;\n        pbVar6 = (byte *)param_2->_IO_write_ptr;\n        if (param_2->_IO_write_end < pbVar6 || (byte *)param_2->_IO_write_end == pbVar6)\n        goto LAB_00407f31;\nLAB_00407f02:\n        param_2->_IO_write_ptr = (char *)(pbVar6 + 1);\n        *pbVar6 = bVar3;\n      }\n      else {\n        uVar12 = (uint)(char)bVar3;\n        if (pbVar7 == pbVar11) {\n          uVar12 = 10;\n          bVar3 = 10;\n        }\n        pbVar6 = (byte *)param_2->_IO_write_ptr;\n        if (pbVar6 <= param_2->_IO_write_end && (byte *)param_2->_IO_write_end != pbVar6)\n        goto LAB_00407f02;\nLAB_00407f31:\n        iVar5 = __overflow(param_2,uVar12 & 0xff);\n        if (iVar5 == -1) {\n          uVar10 = dcgettext(0,\"write failed\",5);\n                    /* WARNING: Subroutine does not return */\n          FUN_00405dd0(uVar10,0);\n        }\n      }\n      pbVar6 = pbVar11;\n    } while (pbVar7 != pbVar11);\n    pbVar6 = *param_1;\n    pbVar11 = param_1[1];\n  }\n  pbVar7 = pbVar6 + -1 + (long)pbVar11;\n  plVar13 = DAT_0061c750;\n  do {\n    __nptr = pbVar6;\n    if (plVar13 != (long *)0x0) {\n      lVar8 = *plVar13;\n      lVar9 = plVar13[2];\n      if (lVar8 == -1) {\n        if (lVar9 != -1) goto LAB_00407fba;\nLAB_00407fcb:\n        if ((*(char *)(plVar13 + 6) == '\\0') || (lVar8 != -1)) goto LAB_00407fd9;\n      }\n      else {\n        __nptr = (byte *)FUN_00406360(pbVar6,pbVar11,plVar13);\n        if (lVar9 != -1) {\nLAB_00407fba:\n          pbVar7 = (byte *)FUN_00406470(pbVar6,pbVar11,plVar13);\n          goto LAB_00407fcb;\n        }\nLAB_00407fd9:\n        if ((*(char *)((long)plVar13 + 0x36) == '\\0') && ((plVar13[6] & 0xffff00ff0000U) == 0))\n        goto LAB_004080a7;\n      }\n      bVar3 = *pbVar7;\n      *pbVar7 = 0;\n      cVar1 = (&DAT_0061ca80)[*__nptr];\n      while (cVar1 != '\\0') {\n        __nptr = __nptr + 1;\n        cVar1 = (&DAT_0061ca80)[*__nptr];\n      }\n      local_48 = pbVar7;\n      if (__nptr <= pbVar7) {\n        if (*(char *)((long)plVar13 + 0x36) == '\\0') {\n          if (*(char *)((long)plVar13 + 0x34) == '\\0') {\n            if ((plVar13[6] & 0xff0000ff0000U) != 0) {\n              local_40[0] = __nptr;\n              if (__nptr < pbVar7) {\n                local_40[0] = __nptr + (*__nptr == 0x2d);\n              }\n              local_48 = __nptr;\n              bVar4 = FUN_00405930(local_40);\n              if ((0x2f < bVar4) &&\n                 (local_48 = local_40[0], *(char *)((long)plVar13 + 0x35) != '\\0')) {\n                local_48 = local_40[0] + ((&DAT_004149c0)[*local_40[0]] != '\\0');\n              }\n            }\n          }\n          else {\n            local_48 = __nptr;\n            strtold((char *)__nptr,(char **)&local_48);\n          }\n        }\n        else {\n          local_48 = __nptr;\n          thunk_FUN_00405a4c(__nptr,&local_48);\n        }\n      }\n      *pbVar7 = bVar3;\n      pbVar7 = local_48;\n    }\nLAB_004080a7:\n    while( true ) {\n      lVar8 = FUN_00405eb0(pbVar6,__nptr);\n      lVar9 = FUN_00405eb0(__nptr,pbVar7);\n      while (lVar8 = lVar8 + -1, lVar8 != -1) {\n        pcVar2 = stdout->_IO_write_ptr;\n        if (pcVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = pcVar2 + 1;\n          *pcVar2 = ' ';\n        }\n        else {\n          __overflow(stdout,0x20);\n        }\n      }\n      if (lVar9 == 0) {\n        uVar10 = dcgettext(0,\"^ no match for key\\n\",5);\n        __printf_chk(1,uVar10);\n      }\n      else {\n        do {\n          pcVar2 = stdout->_IO_write_ptr;\n          if (pcVar2 < stdout->_IO_write_end) {\n            stdout->_IO_write_ptr = pcVar2 + 1;\n            *pcVar2 = '_';\n          }\n          else {\n            __overflow(stdout,0x5f);\n          }\n          lVar9 = lVar9 + -1;\n        } while (lVar9 != 0);\n        pcVar2 = stdout->_IO_write_ptr;\n        if (pcVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = pcVar2 + 1;\n          *pcVar2 = '\\n';\n        }\n        else {\n          __overflow(stdout,10);\n        }\n      }\n      if (plVar13 == (long *)0x0) {\n        return;\n      }\n      plVar13 = (long *)plVar13[8];\n      if (plVar13 != (long *)0x0) break;\n      if (DAT_0061c759 != '\\0') {\n        return;\n      }\n      if (DAT_0061c75a != '\\0') {\n        return;\n      }\n      pbVar6 = *param_1;\n      pbVar7 = pbVar6 + -1 + (long)param_1[1];\n      __nptr = pbVar6;\n    }\n    pbVar6 = *param_1;\n    pbVar11 = param_1[1];\n    pbVar7 = pbVar6 + -1 + (long)pbVar11;\n  } while( true );\n}\n\n",
            "funcName": "FUN_00407e70"
        },
        {
            "funcStartAddr": "0x4082a0",
            "funcEndAddr": "0x408366",
            "decompiledFuncCode": "\nulong FUN_004082a0(void **param_1,void **param_2)\n\n{\n  void *pvVar1;\n  void *pvVar2;\n  uint uVar3;\n  ulong uVar4;\n  ulong __n;\n  ulong uVar5;\n  \n  if (DAT_0061c750 != 0) {\n    uVar4 = FUN_004065b0();\n    if ((int)uVar4 != 0) {\n      return uVar4;\n    }\n    if (DAT_0061c759 != '\\0') {\n      return uVar4;\n    }\n    if (DAT_0061c75a != '\\0') {\n      return uVar4;\n    }\n  }\n  pvVar1 = param_1[1];\n  pvVar2 = param_2[1];\n  uVar4 = (long)pvVar2 - 1;\n  uVar5 = (long)pvVar1 - 1;\n  if (uVar5 == 0) {\n    uVar3 = -(uint)(uVar4 != 0);\n  }\n  else {\n    uVar3 = 1;\n    if (uVar4 != 0) {\n      if (DAT_0061cba1 == '\\0') {\n        __n = uVar4;\n        if (uVar5 <= uVar4) {\n          __n = uVar5;\n        }\n        uVar3 = memcmp(*param_1,*param_2,__n);\n        if ((uVar3 == 0) && (uVar3 = 0xffffffff, uVar4 <= uVar5)) {\n          uVar3 = (uint)(pvVar1 != pvVar2);\n        }\n      }\n      else {\n        uVar3 = FUN_004115c0(*param_1,pvVar1,*param_2,pvVar2);\n      }\n    }\n  }\n  if (DAT_0061c75b != '\\0') {\n    uVar3 = -uVar3;\n  }\n  return (ulong)uVar3;\n}\n\n",
            "funcName": "FUN_004082a0"
        },
        {
            "funcStartAddr": "0x408370",
            "funcEndAddr": "0x4085af",
            "decompiledFuncCode": "\nvoid FUN_00408370(undefined4 *param_1,ulong param_2,undefined4 *param_3,char param_4)\n\n{\n  undefined8 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  int iVar18;\n  undefined4 *puVar19;\n  undefined4 *puVar20;\n  undefined4 *puVar21;\n  undefined4 *puVar22;\n  ulong uVar23;\n  undefined4 *puVar24;\n  undefined4 *puVar25;\n  long lVar26;\n  \n  if (param_2 == 2) {\n    iVar18 = FUN_004082a0(param_1 + -8,param_1 + -0x10);\n    if (param_4 != '\\0') {\n      puVar20 = param_1 + (long)(int)~(uint)(0 < iVar18) * 8;\n      param_1 = param_1 + (long)(int)((0 < iVar18) - 2) * 8;\n      uVar2 = puVar20[1];\n      uVar3 = puVar20[2];\n      uVar4 = puVar20[3];\n      uVar5 = puVar20[4];\n      uVar6 = puVar20[5];\n      uVar7 = puVar20[6];\n      uVar8 = puVar20[7];\n      param_3[-8] = *puVar20;\n      param_3[-7] = uVar2;\n      param_3[-6] = uVar3;\n      param_3[-5] = uVar4;\n      uVar2 = *param_1;\n      uVar3 = param_1[1];\n      uVar4 = param_1[2];\n      uVar9 = param_1[3];\n      param_3[-4] = uVar5;\n      param_3[-3] = uVar6;\n      param_3[-2] = uVar7;\n      param_3[-1] = uVar8;\n      uVar5 = param_1[4];\n      uVar6 = param_1[5];\n      uVar7 = param_1[6];\n      uVar8 = param_1[7];\n      param_3[-0x10] = uVar2;\n      param_3[-0xf] = uVar3;\n      param_3[-0xe] = uVar4;\n      param_3[-0xd] = uVar9;\n      param_3[-0xc] = uVar5;\n      param_3[-0xb] = uVar6;\n      param_3[-10] = uVar7;\n      param_3[-9] = uVar8;\n      return;\n    }\n    if (0 < iVar18) {\n      uVar2 = param_1[-8];\n      uVar3 = param_1[-7];\n      uVar4 = param_1[-6];\n      uVar5 = param_1[-5];\n      uVar6 = param_1[-4];\n      uVar7 = param_1[-3];\n      uVar8 = param_1[-2];\n      uVar9 = param_1[-1];\n      uVar10 = param_1[-0x10];\n      uVar11 = param_1[-0xf];\n      uVar12 = param_1[-0xe];\n      uVar13 = param_1[-0xd];\n      uVar14 = param_1[-0xc];\n      uVar15 = param_1[-0xb];\n      uVar16 = param_1[-10];\n      uVar17 = param_1[-9];\n      param_3[-8] = uVar2;\n      param_3[-7] = uVar3;\n      param_3[-6] = uVar4;\n      param_3[-5] = uVar5;\n      param_3[-4] = uVar6;\n      param_3[-3] = uVar7;\n      param_3[-2] = uVar8;\n      param_3[-1] = uVar9;\n      param_1[-8] = uVar10;\n      param_1[-7] = uVar11;\n      param_1[-6] = uVar12;\n      param_1[-5] = uVar13;\n      param_1[-4] = uVar14;\n      param_1[-3] = uVar15;\n      param_1[-2] = uVar16;\n      param_1[-1] = uVar17;\n      param_1[-0x10] = uVar2;\n      param_1[-0xf] = uVar3;\n      param_1[-0xe] = uVar4;\n      param_1[-0xd] = uVar5;\n      param_1[-0xc] = uVar6;\n      param_1[-0xb] = uVar7;\n      param_1[-10] = uVar8;\n      param_1[-9] = uVar9;\n    }\n  }\n  else {\n    uVar23 = param_2 >> 1;\n    lVar26 = param_2 - uVar23;\n    puVar20 = param_1 + uVar23 * -8;\n    if (param_4 == '\\0') {\n      FUN_00408370(puVar20,lVar26,param_3,0);\n      puVar21 = param_1;\n      puVar24 = puVar20;\n      if (param_2 < 4) {\n        uVar1 = *(undefined8 *)(param_1 + -6);\n        uVar2 = param_1[-4];\n        uVar3 = param_1[-3];\n        uVar4 = param_1[-2];\n        uVar5 = param_1[-1];\n        *(undefined8 *)(param_3 + -8) = *(undefined8 *)(param_1 + -8);\n        *(undefined8 *)(param_3 + -6) = uVar1;\n        param_3[-4] = uVar2;\n        param_3[-3] = uVar3;\n        param_3[-2] = uVar4;\n        param_3[-1] = uVar5;\n        param_1 = param_3;\n      }\n      else {\n        FUN_00408370(param_1,uVar23,param_3,1);\n        param_1 = param_3;\n      }\n    }\n    else {\n      puVar24 = param_3 + uVar23 * -8;\n      FUN_00408370(puVar20,lVar26,puVar24,1);\n      puVar21 = param_3;\n      if (3 < param_2) {\n        FUN_00408370(param_1,uVar23,param_3,0);\n      }\n    }\n    puVar20 = param_1 + -8;\n    puVar25 = puVar24 + -8;\n    while( true ) {\n      while( true ) {\n        puVar19 = puVar20;\n        puVar22 = puVar21 + -8;\n        iVar18 = FUN_004082a0(puVar19,puVar25);\n        if (iVar18 < 1) break;\n        uVar2 = puVar24[-7];\n        uVar3 = puVar24[-6];\n        uVar4 = puVar24[-5];\n        *puVar22 = puVar24[-8];\n        puVar21[-7] = uVar2;\n        puVar21[-6] = uVar3;\n        puVar21[-5] = uVar4;\n        uVar2 = puVar24[-3];\n        uVar3 = puVar24[-2];\n        uVar4 = puVar24[-1];\n        puVar21[-4] = puVar24[-4];\n        puVar21[-3] = uVar2;\n        puVar21[-2] = uVar3;\n        puVar21[-1] = uVar4;\n        lVar26 = lVar26 + -1;\n        if (lVar26 == 0) {\n          lVar26 = -0x20;\n          do {\n            puVar24 = (undefined4 *)((long)param_1 + lVar26);\n            uVar2 = puVar24[1];\n            uVar3 = puVar24[2];\n            uVar4 = puVar24[3];\n            puVar20 = (undefined4 *)((long)puVar22 + lVar26);\n            *puVar20 = *puVar24;\n            puVar20[1] = uVar2;\n            puVar20[2] = uVar3;\n            puVar20[3] = uVar4;\n            puVar20 = (undefined4 *)((long)param_1 + lVar26 + 0x10);\n            uVar2 = puVar20[1];\n            uVar3 = puVar20[2];\n            uVar4 = puVar20[3];\n            puVar24 = (undefined4 *)((long)puVar21 + lVar26 + -0x10);\n            *puVar24 = *puVar20;\n            puVar24[1] = uVar2;\n            puVar24[2] = uVar3;\n            puVar24[3] = uVar4;\n            lVar26 = lVar26 + -0x20;\n            uVar23 = uVar23 - 1;\n          } while (uVar23 != 0);\n          return;\n        }\n        puVar20 = puVar19;\n        puVar21 = puVar22;\n        puVar24 = puVar25;\n        puVar25 = puVar25 + -8;\n      }\n      uVar2 = param_1[-7];\n      uVar3 = param_1[-6];\n      uVar4 = param_1[-5];\n      *puVar22 = param_1[-8];\n      puVar21[-7] = uVar2;\n      puVar21[-6] = uVar3;\n      puVar21[-5] = uVar4;\n      uVar2 = param_1[-3];\n      uVar3 = param_1[-2];\n      uVar4 = param_1[-1];\n      puVar21[-4] = param_1[-4];\n      puVar21[-3] = uVar2;\n      puVar21[-2] = uVar3;\n      puVar21[-1] = uVar4;\n      uVar23 = uVar23 - 1;\n      if (uVar23 == 0) break;\n      puVar20 = puVar19 + -8;\n      puVar21 = puVar22;\n      param_1 = puVar19;\n    }\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00408370"
        },
        {
            "funcStartAddr": "0x4085d0",
            "funcEndAddr": "0x408636",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_004085d0(byte **param_1,_IO_FILE *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte bVar3;\n  byte bVar4;\n  int iVar5;\n  byte *pbVar6;\n  byte *__nptr;\n  byte *pbVar7;\n  long lVar8;\n  long lVar9;\n  undefined8 uVar10;\n  byte *pbVar11;\n  uint uVar12;\n  long *plVar13;\n  byte *pbStack_48;\n  byte *apbStack_40 [2];\n  undefined8 uStack_30;\n  \n  if (DAT_0061c759 != '\\0') {\n    if (CONCAT44(uRam000000000061cb84,_DAT_0061cb80) != 0) {\n      uStack_30 = 0x4085fe;\n      iVar5 = FUN_004082a0(param_1,&DAT_0061cb80);\n      if (iVar5 == 0) {\n        return;\n      }\n    }\n    _DAT_0061cb80 = *(undefined4 *)param_1;\n    uRam000000000061cb84 = *(undefined4 *)((long)param_1 + 4);\n    uRam000000000061cb88 = *(undefined4 *)(param_1 + 1);\n    uRam000000000061cb8c = *(undefined4 *)((long)param_1 + 0xc);\n    _DAT_0061cb90 = *(undefined4 *)(param_1 + 2);\n    uRam000000000061cb94 = *(undefined4 *)((long)param_1 + 0x14);\n    uRam000000000061cb98 = *(undefined4 *)(param_1 + 3);\n    uRam000000000061cb9c = *(undefined4 *)((long)param_1 + 0x1c);\n  }\n  pbVar6 = *param_1;\n  pbVar11 = param_1[1];\n  pbVar7 = pbVar6 + (long)pbVar11;\n  if ((param_3 != 0) || (DAT_0061c740 == '\\0')) {\n    pbVar7[-1] = DAT_0061c500;\n    pbVar6 = (byte *)fwrite_unlocked(pbVar6,1,(size_t)pbVar11,param_2);\n    if (pbVar11 == pbVar6) {\n      pbVar7[-1] = 0;\n      return;\n    }\n    uVar10 = dcgettext(0,\"write failed\",5);\n                    /* WARNING: Subroutine does not return */\n    FUN_00405dd0(uVar10,param_3);\n  }\n  if (pbVar6 < pbVar7) {\n    do {\n      pbVar11 = pbVar6 + 1;\n      bVar3 = *pbVar6;\n      if (bVar3 == 9) {\n        uVar12 = 0x3e;\n        bVar3 = 0x3e;\n        pbVar6 = (byte *)param_2->_IO_write_ptr;\n        if (param_2->_IO_write_end < pbVar6 || (byte *)param_2->_IO_write_end == pbVar6)\n        goto LAB_00407f31;\nLAB_00407f02:\n        param_2->_IO_write_ptr = (char *)(pbVar6 + 1);\n        *pbVar6 = bVar3;\n      }\n      else {\n        uVar12 = (uint)(char)bVar3;\n        if (pbVar7 == pbVar11) {\n          uVar12 = 10;\n          bVar3 = 10;\n        }\n        pbVar6 = (byte *)param_2->_IO_write_ptr;\n        if (pbVar6 <= param_2->_IO_write_end && (byte *)param_2->_IO_write_end != pbVar6)\n        goto LAB_00407f02;\nLAB_00407f31:\n        iVar5 = __overflow(param_2,uVar12 & 0xff);\n        if (iVar5 == -1) {\n          uVar10 = dcgettext(0,\"write failed\",5);\n                    /* WARNING: Subroutine does not return */\n          FUN_00405dd0(uVar10,0);\n        }\n      }\n      pbVar6 = pbVar11;\n    } while (pbVar7 != pbVar11);\n    pbVar6 = *param_1;\n    pbVar11 = param_1[1];\n  }\n  pbVar7 = pbVar6 + -1 + (long)pbVar11;\n  plVar13 = DAT_0061c750;\n  do {\n    __nptr = pbVar6;\n    if (plVar13 != (long *)0x0) {\n      lVar8 = *plVar13;\n      lVar9 = plVar13[2];\n      if (lVar8 == -1) {\n        if (lVar9 != -1) goto LAB_00407fba;\nLAB_00407fcb:\n        if ((*(char *)(plVar13 + 6) == '\\0') || (lVar8 != -1)) goto LAB_00407fd9;\n      }\n      else {\n        __nptr = (byte *)FUN_00406360(pbVar6,pbVar11,plVar13);\n        if (lVar9 != -1) {\nLAB_00407fba:\n          pbVar7 = (byte *)FUN_00406470(pbVar6,pbVar11,plVar13);\n          goto LAB_00407fcb;\n        }\nLAB_00407fd9:\n        if ((*(char *)((long)plVar13 + 0x36) == '\\0') && ((plVar13[6] & 0xffff00ff0000U) == 0))\n        goto LAB_004080a7;\n      }\n      bVar3 = *pbVar7;\n      *pbVar7 = 0;\n      cVar1 = (&DAT_0061ca80)[*__nptr];\n      while (cVar1 != '\\0') {\n        __nptr = __nptr + 1;\n        cVar1 = (&DAT_0061ca80)[*__nptr];\n      }\n      pbStack_48 = pbVar7;\n      if (__nptr <= pbVar7) {\n        if (*(char *)((long)plVar13 + 0x36) == '\\0') {\n          if (*(char *)((long)plVar13 + 0x34) == '\\0') {\n            if ((plVar13[6] & 0xff0000ff0000U) != 0) {\n              apbStack_40[0] = __nptr;\n              if (__nptr < pbVar7) {\n                apbStack_40[0] = __nptr + (*__nptr == 0x2d);\n              }\n              pbStack_48 = __nptr;\n              bVar4 = FUN_00405930(apbStack_40);\n              if ((0x2f < bVar4) &&\n                 (pbStack_48 = apbStack_40[0], *(char *)((long)plVar13 + 0x35) != '\\0')) {\n                pbStack_48 = apbStack_40[0] + ((&DAT_004149c0)[*apbStack_40[0]] != '\\0');\n              }\n            }\n          }\n          else {\n            pbStack_48 = __nptr;\n            strtold((char *)__nptr,(char **)&pbStack_48);\n          }\n        }\n        else {\n          pbStack_48 = __nptr;\n          thunk_FUN_00405a4c(__nptr,&pbStack_48);\n        }\n      }\n      *pbVar7 = bVar3;\n      pbVar7 = pbStack_48;\n    }\nLAB_004080a7:\n    while( true ) {\n      lVar8 = FUN_00405eb0(pbVar6,__nptr);\n      lVar9 = FUN_00405eb0(__nptr,pbVar7);\n      while (lVar8 = lVar8 + -1, lVar8 != -1) {\n        pcVar2 = stdout->_IO_write_ptr;\n        if (pcVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = pcVar2 + 1;\n          *pcVar2 = ' ';\n        }\n        else {\n          __overflow(stdout,0x20);\n        }\n      }\n      if (lVar9 == 0) {\n        uVar10 = dcgettext(0,\"^ no match for key\\n\",5);\n        __printf_chk(1,uVar10);\n      }\n      else {\n        do {\n          pcVar2 = stdout->_IO_write_ptr;\n          if (pcVar2 < stdout->_IO_write_end) {\n            stdout->_IO_write_ptr = pcVar2 + 1;\n            *pcVar2 = '_';\n          }\n          else {\n            __overflow(stdout,0x5f);\n          }\n          lVar9 = lVar9 + -1;\n        } while (lVar9 != 0);\n        pcVar2 = stdout->_IO_write_ptr;\n        if (pcVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = pcVar2 + 1;\n          *pcVar2 = '\\n';\n        }\n        else {\n          __overflow(stdout,10);\n        }\n      }\n      if (plVar13 == (long *)0x0) {\n        return;\n      }\n      plVar13 = (long *)plVar13[8];\n      if (plVar13 != (long *)0x0) break;\n      if (DAT_0061c759 != '\\0') {\n        return;\n      }\n      if (DAT_0061c75a != '\\0') {\n        return;\n      }\n      pbVar6 = *param_1;\n      pbVar7 = pbVar6 + -1 + (long)param_1[1];\n      __nptr = pbVar6;\n    }\n    pbVar6 = *param_1;\n    pbVar11 = param_1[1];\n    pbVar7 = pbVar6 + -1 + (long)pbVar11;\n  } while( true );\n}\n\n",
            "funcName": "FUN_004085d0"
        },
        {
            "funcStartAddr": "0x408640",
            "funcEndAddr": "0x408de0",
            "decompiledFuncCode": "\nvoid FUN_00408640(long param_1,ulong param_2,ulong param_3,undefined8 param_4,undefined8 param_5,\n                 void *param_6)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined4 *puVar3;\n  void *pvVar4;\n  ulong uVar5;\n  undefined8 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  undefined4 uVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  char cVar23;\n  int iVar24;\n  void *__ptr;\n  void *__ptr_00;\n  void *__ptr_01;\n  ulong *__ptr_02;\n  ulong *puVar25;\n  long lVar26;\n  ulong *puVar27;\n  ulong uVar28;\n  void *pvVar29;\n  undefined4 *puVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  undefined8 *puVar33;\n  ulong uVar34;\n  ulong uVar35;\n  void **ppvVar36;\n  ulong local_c8;\n  ulong local_c0;\n  void **local_a0;\n  ulong local_70;\n  void *local_68;\n  void *local_58;\n  void *local_50;\n  long local_48;\n  long local_40;\n  \n  if ((-1 < SUB168(ZEXT816(0x38) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(0x38) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    lVar2 = param_3 * 8;\n    __ptr = (void *)FUN_00411210();\n    if ((-1 < lVar2) && (param_3 >> 0x3d == 0)) {\n      uVar34 = 0;\n      __ptr_00 = (void *)FUN_00411210(lVar2);\n      __ptr_01 = (void *)FUN_00411210(lVar2);\n      __ptr_02 = (ulong *)FUN_00411210(lVar2);\n      lVar2 = DAT_0061c750;\n      local_58 = (void *)0x0;\n      local_c0 = param_3;\n      local_70 = param_2;\n      if (param_3 != 0) {\n        do {\n          while( true ) {\n            lVar26 = uVar34 * 8;\n            ppvVar36 = (void **)((long)__ptr + uVar34 * 0x38);\n            uVar28 = DAT_0061c428;\n            if (DAT_0061c428 <= DAT_0061c778 / local_c0) {\n              uVar28 = DAT_0061c778 / local_c0;\n            }\n            FUN_00405e30(ppvVar36,0x20,uVar28);\n            puVar31 = (undefined8 *)(uVar34 * 0x10 + param_1);\n            cVar23 = FUN_004074d0(ppvVar36,*(undefined8 *)((long)param_6 + lVar26),*puVar31);\n            if (cVar23 != '\\0') break;\n            FUN_00407df0(*(undefined8 *)((long)param_6 + lVar26),*puVar31);\n            if (uVar34 < local_70) {\n              local_70 = local_70 - 1;\n              FUN_00407920(*puVar31);\n            }\n            free(*ppvVar36);\n            uVar28 = local_c0 - 1;\n            if (uVar28 <= uVar34) goto LAB_004087e2;\n            lVar1 = local_c0 * 8;\n            do {\n              puVar3 = (undefined4 *)(param_1 + 0x10 + lVar26 * 2);\n              uVar7 = puVar3[1];\n              uVar8 = puVar3[2];\n              uVar9 = puVar3[3];\n              uVar6 = *(undefined8 *)((long)param_6 + lVar26 + 8);\n              puVar30 = (undefined4 *)(param_1 + lVar26 * 2);\n              *puVar30 = *puVar3;\n              puVar30[1] = uVar7;\n              puVar30[2] = uVar8;\n              puVar30[3] = uVar9;\n              *(undefined8 *)((long)param_6 + lVar26) = uVar6;\n              lVar26 = lVar26 + 8;\n              local_c0 = uVar28;\n            } while (lVar1 + -8 != lVar26);\n          }\n          pvVar29 = ppvVar36[3];\n          pvVar4 = *ppvVar36;\n          *(long *)((long)__ptr_00 + uVar34 * 8) = (long)pvVar29 + (long)pvVar4 + -0x20;\n          *(long *)((long)__ptr_01 + uVar34 * 8) =\n               (long)pvVar29 + (long)pvVar4 + (long)ppvVar36[2] * -0x20;\n          uVar34 = uVar34 + 1;\n          uVar28 = local_c0;\n        } while (uVar34 < local_c0);\nLAB_004087e2:\n        local_c0 = uVar28;\n        if (local_c0 != 0) {\n          uVar34 = 0;\n          do {\n            __ptr_02[uVar34] = uVar34;\n            uVar34 = uVar34 + 1;\n          } while (uVar34 != local_c0);\n          if (local_c0 != 1) {\n            uVar34 = 1;\n            do {\n              while( true ) {\n                puVar27 = __ptr_02 + uVar34;\n                uVar28 = *puVar27;\n                uVar5 = __ptr_02[uVar34 - 1];\n                iVar24 = FUN_004082a0(*(undefined8 *)((long)__ptr_00 + uVar5 * 8),\n                                      *(undefined8 *)((long)__ptr_00 + uVar28 * 8));\n                if (iVar24 < 1) break;\n                __ptr_02[uVar34 - 1] = uVar28;\n                uVar34 = 1;\n                *puVar27 = uVar5;\n              }\n              uVar34 = uVar34 + 1;\n            } while (uVar34 < local_c0);\n          }\n          local_68 = (void *)0x0;\n          local_a0 = (void **)0x0;\nLAB_004088a0:\n          local_c8 = *__ptr_02;\n          lVar26 = local_c8 * 8;\n          puVar27 = (ulong *)((long)__ptr_00 + lVar26);\n          ppvVar36 = (void **)*puVar27;\n          if (DAT_0061c759 == '\\0') {\n            FUN_00407e70(ppvVar36,param_4,param_5);\n          }\n          else {\n            if (local_a0 != (void **)0x0) {\n              iVar24 = FUN_004082a0(local_a0,ppvVar36);\n              if (iVar24 == 0) goto LAB_004088e6;\n              FUN_00407e70(&local_58,param_4,param_5);\n            }\n            pvVar29 = ppvVar36[1];\n            pvVar4 = local_68;\n            if (local_68 < pvVar29) {\n              do {\n                local_68 = pvVar29;\n                if (pvVar4 == (void *)0x0) break;\n                local_68 = (void *)((long)pvVar4 * 2);\n                pvVar4 = local_68;\n              } while (local_68 < pvVar29);\n              free(local_58);\n              local_58 = (void *)FUN_00411210(local_68);\n              pvVar29 = ppvVar36[1];\n            }\n            local_50 = pvVar29;\n            memcpy(local_58,*ppvVar36,(size_t)pvVar29);\n            local_a0 = &local_58;\n            if (lVar2 != 0) {\n              local_48 = ((long)ppvVar36[2] + (long)local_58) - (long)*ppvVar36;\n              local_40 = ((long)local_58 + (long)ppvVar36[3]) - (long)*ppvVar36;\n            }\n          }\nLAB_004088e6:\n          if (*(void ***)(ulong *)((long)__ptr_01 + lVar26) < ppvVar36) {\n            *puVar27 = (ulong)(ppvVar36 + -4);\n            if (local_c0 == 1) goto LAB_00408a47;\nLAB_00408980:\n            uVar28 = *puVar27;\n            uVar34 = 1;\n            uVar5 = 1;\n            uVar35 = local_c0;\n            do {\n              while( true ) {\n                uVar32 = uVar5;\n                uVar5 = __ptr_02[uVar32];\n                iVar24 = FUN_004082a0(uVar28,*(undefined8 *)((long)__ptr_00 + uVar5 * 8));\n                if ((-1 < iVar24) && ((uVar5 <= local_c8 || (iVar24 != 0)))) break;\n                uVar5 = uVar34 + uVar32 >> 1;\n                uVar35 = uVar32;\n                if (uVar32 <= uVar34) goto LAB_004089ea;\n              }\n              uVar34 = uVar32 + 1;\n              uVar5 = uVar34 + uVar35 >> 1;\n            } while (uVar34 < uVar35);\nLAB_004089ea:\n            if (uVar34 - 1 != 0) {\n              puVar27 = __ptr_02;\n              do {\n                puVar25 = puVar27 + 1;\n                *puVar27 = puVar27[1];\n                puVar27 = puVar25;\n              } while (puVar25 != __ptr_02 + (uVar34 - 1));\n            }\n            __ptr_02[uVar34 - 1] = local_c8;\n            goto LAB_004088a0;\n          }\n          puVar31 = (undefined8 *)((long)param_6 + lVar26);\n          puVar33 = (undefined8 *)(local_c8 * 0x10 + param_1);\n          ppvVar36 = (void **)((long)__ptr + local_c8 * 0x38);\n          cVar23 = FUN_004074d0(ppvVar36,*puVar31,*puVar33);\n          if (cVar23 != '\\0') {\n            pvVar29 = ppvVar36[3];\n            pvVar4 = *ppvVar36;\n            *puVar27 = ((long)pvVar29 + (long)pvVar4) - 0x20;\n            *(ulong *)((long)__ptr_01 + lVar26) =\n                 (long)pvVar29 + (long)pvVar4 + (long)ppvVar36[2] * -0x20;\n            if (local_c0 != 1) goto LAB_00408980;\nLAB_00408a47:\n            *__ptr_02 = local_c8;\n            goto LAB_004088a0;\n          }\n          puVar27 = __ptr_02 + 1;\n          if (local_c0 != 1) {\n            do {\n              if (local_c8 < *puVar27) {\n                *puVar27 = *puVar27 - 1;\n                local_c8 = *__ptr_02;\n              }\n              puVar27 = puVar27 + 1;\n            } while (__ptr_02 + local_c0 != puVar27);\n            puVar33 = (undefined8 *)(local_c8 * 0x10 + param_1);\n            puVar31 = (undefined8 *)((long)param_6 + local_c8 * 8);\n            ppvVar36 = (void **)((long)__ptr + local_c8 * 0x38);\n          }\n          uVar34 = local_c0 - 1;\n          FUN_00407df0(*puVar31,*puVar33);\n          if (local_c8 < local_70) {\n            local_70 = local_70 - 1;\n            FUN_00407920(*puVar33);\n          }\n          free(*ppvVar36);\n          if (local_c8 < uVar34) {\n            lVar26 = local_c8 * 8;\n            puVar30 = (undefined4 *)((long)__ptr + local_c8 * 0x38);\n            do {\n              puVar3 = (undefined4 *)(param_1 + 0x10 + lVar26 * 2);\n              uVar7 = *puVar3;\n              uVar8 = puVar3[1];\n              uVar9 = puVar3[2];\n              uVar10 = puVar3[3];\n              uVar11 = puVar30[0xe];\n              uVar12 = puVar30[0xf];\n              uVar13 = puVar30[0x10];\n              uVar14 = puVar30[0x11];\n              uVar15 = puVar30[0x12];\n              uVar16 = puVar30[0x13];\n              uVar17 = puVar30[0x14];\n              uVar18 = puVar30[0x15];\n              *(undefined8 *)((long)param_6 + lVar26) = *(undefined8 *)((long)param_6 + lVar26 + 8);\n              uVar6 = *(undefined8 *)(puVar30 + 0x1a);\n              uVar19 = puVar30[0x16];\n              uVar20 = puVar30[0x17];\n              uVar21 = puVar30[0x18];\n              uVar22 = puVar30[0x19];\n              puVar3 = (undefined4 *)(param_1 + lVar26 * 2);\n              *puVar3 = uVar7;\n              puVar3[1] = uVar8;\n              puVar3[2] = uVar9;\n              puVar3[3] = uVar10;\n              *(undefined8 *)(puVar30 + 0xc) = uVar6;\n              uVar6 = *(undefined8 *)((long)__ptr_00 + lVar26 + 8);\n              *puVar30 = uVar11;\n              puVar30[1] = uVar12;\n              puVar30[2] = uVar13;\n              puVar30[3] = uVar14;\n              *(undefined8 *)((long)__ptr_00 + lVar26) = uVar6;\n              uVar6 = *(undefined8 *)((long)__ptr_01 + lVar26 + 8);\n              puVar30[4] = uVar15;\n              puVar30[5] = uVar16;\n              puVar30[6] = uVar17;\n              puVar30[7] = uVar18;\n              *(undefined8 *)((long)__ptr_01 + lVar26) = uVar6;\n              lVar26 = lVar26 + 8;\n              puVar30[8] = uVar19;\n              puVar30[9] = uVar20;\n              puVar30[10] = uVar21;\n              puVar30[0xb] = uVar22;\n              puVar30 = puVar30 + 0xe;\n            } while (local_c0 * 8 + -8 != lVar26);\n          }\n          if (uVar34 != 0) {\n            lVar26 = local_c0 - 1;\n            puVar27 = __ptr_02;\n            do {\n              puVar25 = puVar27 + 1;\n              *puVar27 = puVar27[1];\n              puVar27 = puVar25;\n              local_c0 = uVar34;\n            } while (__ptr_02 + lVar26 != puVar25);\n            goto LAB_004088a0;\n          }\n          if ((local_a0 != (void **)0x0) && (DAT_0061c759 != '\\0')) {\n            FUN_00407e70(&local_58,param_4,param_5);\n            free(local_58);\n          }\n        }\n      }\n      FUN_00407df0(param_4,param_5);\n      free(param_6);\n      free(__ptr);\n      free(__ptr_02);\n      free(__ptr_01);\n      free(__ptr_00);\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_00408640"
        },
        {
            "funcStartAddr": "0x408e10",
            "funcEndAddr": "0x408e20",
            "decompiledFuncCode": "\nvoid FUN_00408e10(int param_1,int param_2)\n\n{\n  dup2(param_1,param_2);\n  close(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00408e10"
        },
        {
            "funcStartAddr": "0x408e20",
            "funcEndAddr": "0x40901c",
            "decompiledFuncCode": "\nulong FUN_00408e20(undefined8 *param_1,ulong param_2,long *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  int *piVar5;\n  FILE *pFVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  int local_40;\n  int local_3c;\n  \n  if (((long)(param_2 << 3) < 0) || (param_2 >> 0x3d != 0)) {\nLAB_00408ff0:\n                    /* WARNING: Subroutine does not return */\n    FUN_00411460();\n  }\n  lVar3 = FUN_00411210();\n  *param_3 = lVar3;\n  uVar9 = 0;\n  if (param_2 != 0) {\n    do {\n      lVar4 = param_1[1];\n      if ((lVar4 == 0) || (*(char *)(lVar4 + 0xc) == '\\0')) {\n        lVar4 = FUN_00407cd0(*param_1);\n        *(long *)(lVar3 + uVar9 * 8) = lVar4;\n        if (lVar4 == 0) {\n          return uVar9;\n        }\n      }\n      else {\n        if (*(char *)(lVar4 + 0xc) == '\\x01') {\n          FUN_004060a0(*(undefined4 *)(lVar4 + 8));\n        }\n        iVar1 = open((char *)(lVar4 + 0xd),0);\n        if (iVar1 < 0) {\nLAB_00408f00:\n          *(undefined8 *)(lVar3 + uVar9 * 8) = 0;\n          return uVar9;\n        }\n        iVar2 = FUN_00407a30(&local_40,9);\n        if (iVar2 == -1) {\n          piVar5 = __errno_location();\n          if (*piVar5 != 0x18) {\n            uVar7 = FUN_0040f630(4,DAT_0061c748);\n            uVar8 = dcgettext(0,\"couldn\\'t create process for %s -d\",5);\n                    /* WARNING: Subroutine does not return */\n            error(2,*piVar5,uVar8,uVar7);\n          }\n          close(iVar1);\n          *piVar5 = 0x18;\n          goto LAB_00408f00;\n        }\n        if (iVar2 == 0) {\n          close(local_40);\n          if (iVar1 != 0) {\n            FUN_00408e10(iVar1,0);\n          }\n          if (local_3c != 1) {\n            FUN_00408e10(local_3c,1);\n          }\n          execlp(DAT_0061c748,DAT_0061c748,&DAT_00416559,0);\n          piVar5 = __errno_location();\n          FUN_004060d0(*piVar5,\"couldn\\'t execute compress program (with -d)\");\n          goto LAB_00408ff0;\n        }\n        *(int *)(lVar4 + 8) = iVar2;\n        FUN_00406190(lVar4);\n        close(iVar1);\n        close(local_3c);\n        pFVar6 = fdopen(local_40,\"r\");\n        if (pFVar6 == (FILE *)0x0) {\n          piVar5 = __errno_location();\n          iVar1 = *piVar5;\n          close(local_40);\n          *(undefined8 *)(lVar3 + uVar9 * 8) = 0;\n          *piVar5 = iVar1;\n          return uVar9;\n        }\n        *(FILE **)(lVar3 + uVar9 * 8) = pFVar6;\n      }\n      uVar9 = uVar9 + 1;\n      param_1 = param_1 + 2;\n    } while (param_2 != uVar9);\n  }\n  return uVar9;\n}\n\n",
            "funcName": "FUN_00408e20"
        },
        {
            "funcStartAddr": "0x409030",
            "funcEndAddr": "0x4090b8",
            "decompiledFuncCode": "\nulong FUN_00409030(long param_1,undefined8 param_2,ulong param_3,undefined8 param_4,\n                  undefined8 param_5)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  undefined8 local_40 [2];\n  \n  uVar2 = FUN_00408e20(param_1,param_3,local_40);\n  if ((uVar2 < param_3) && (uVar2 < 2)) {\n    uVar1 = *(undefined8 *)(param_1 + uVar2 * 0x10);\n    uVar3 = dcgettext(0,\"open failed\",5);\n                    /* WARNING: Subroutine does not return */\n    FUN_00405dd0(uVar3,uVar1);\n  }\n  FUN_00408640(param_1,param_2,uVar2,param_4,param_5,local_40[0]);\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00409030"
        },
        {
            "funcStartAddr": "0x4090c0",
            "funcEndAddr": "0x409312",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 * FUN_004090c0(FILE **param_1,char param_2)\n\n{\n  void *__dest;\n  char *__s;\n  int iVar1;\n  int iVar2;\n  size_t __n;\n  undefined8 *__ptr;\n  int *piVar3;\n  FILE *pFVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 *puVar7;\n  bool bVar8;\n  uint local_c8;\n  int local_c4;\n  __sigset_t local_c0;\n  \n  __s = *(char **)(DAT_0061c770 + DAT_0061c5e8 * 8);\n  __n = strlen(__s);\n  __ptr = (undefined8 *)FUN_00411210(__n + 0x20 & 0xfffffffffffffff8);\n  __dest = (void *)((long)__ptr + 0xd);\n  memcpy(__dest,__s,__n);\n  *(undefined8 *)((long)__ptr + __n + 0xd) = s__sortXXXXXX_00414950._0_8_;\n  *(undefined4 *)((long)__ptr + __n + 0x15) = s__sortXXXXXX_00414950._8_4_;\n  *__ptr = 0;\n  DAT_0061c5e8 = DAT_0061c5e8 + 1;\n  if (DAT_0061c5e8 == DAT_0061c768) {\n    DAT_0061c5e8 = 0;\n  }\n  iVar1 = pthread_sigmask(0,(__sigset_t *)&DAT_0061c6c0,&local_c0);\n  local_c8 = local_c8 & 0xffffff00 | (uint)(iVar1 == 0);\n  iVar1 = FUN_00410680(__dest,0x80000);\n  piVar3 = __errno_location();\n  if (iVar1 < 0) {\n    iVar1 = *piVar3;\n    if ((char)local_c8 != '\\0') {\n      FUN_00407880(&local_c8);\n      *piVar3 = iVar1;\n    }\n    if ((iVar1 != 0x18) || (param_2 != '\\x01')) {\n      uVar5 = FUN_0040f630(4,__s);\n      uVar6 = dcgettext(0,\"cannot create temporary file in %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(2,*piVar3,uVar6,uVar5);\n    }\n    puVar7 = (undefined8 *)0x0;\n    free(__ptr);\n  }\n  else {\n    puVar7 = __ptr;\n    *(undefined8 **)PTR_DAT_0061c418 = __ptr;\n    PTR_DAT_0061c418 = (undefined *)puVar7;\n    if ((char)local_c8 != '\\0') {\n      iVar2 = *piVar3;\n      FUN_00407880(&local_c8);\n      *piVar3 = iVar2;\n    }\n    bVar8 = DAT_0061c748 != (char *)0x0;\n    *(undefined *)((long)__ptr + 0xc) = 0;\n    if (bVar8) {\n      iVar2 = FUN_00407a30(&local_c8,4);\n      *(int *)(__ptr + 1) = iVar2;\n      if (iVar2 < 1) {\n        if (iVar2 == 0) {\n          close(local_c4);\n          if (iVar1 != 1) {\n            FUN_00408e10(iVar1,1);\n          }\n          if (local_c8 != 0) {\n            FUN_00408e10(local_c8,0);\n          }\n          execlp(DAT_0061c748,DAT_0061c748,0);\n          FUN_004060d0(*piVar3,\"couldn\\'t execute compress program\");\n          goto LAB_004092d2;\n        }\n      }\n      else {\n        close(iVar1);\n        close(local_c8);\n        FUN_00406190(__ptr);\n        iVar1 = local_c4;\n      }\n    }\n    pFVar4 = fdopen(iVar1,\"w\");\n    *param_1 = pFVar4;\n    puVar7 = __ptr;\n    if (pFVar4 == (FILE *)0x0) {\nLAB_004092d2:\n      uVar5 = dcgettext(0,\"couldn\\'t create temporary file\",5);\n                    /* WARNING: Subroutine does not return */\n      FUN_00405dd0(uVar5,__dest);\n    }\n  }\n  return puVar7;\n}\n\n",
            "funcName": "FUN_004090c0"
        },
        {
            "funcStartAddr": "0x409330",
            "funcEndAddr": "0x409813",
            "decompiledFuncCode": "\nvoid FUN_00409330(long *param_1,ulong param_2,ulong param_3,char *param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  int *piVar6;\n  ulong uVar7;\n  byte *pbVar8;\n  undefined8 uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  long lVar12;\n  byte *pbVar13;\n  byte *pbVar14;\n  long *plVar15;\n  byte **ppbVar16;\n  long *plVar17;\n  bool bVar18;\n  bool bVar19;\n  byte bVar20;\n  ulong local_198;\n  stat *local_188;\n  undefined8 local_160;\n  stat local_158;\n  stat local_c8;\n  \n  bVar20 = 0;\n  uVar5 = (ulong)DAT_0061c420;\n  local_198 = param_3;\n  if (uVar5 < param_3) {\n    do {\n      uVar4 = 0;\n      lVar12 = 0;\n      uVar7 = uVar4;\n      if (local_198 < uVar5) {\n        uVar10 = 0;\n        uVar11 = uVar5;\n        uVar7 = local_198;\n        plVar15 = param_1;\n        plVar17 = param_1;\n      }\n      else {\n        do {\n          lVar3 = FUN_004090c0(&local_c8,0);\n          uVar4 = (ulong)DAT_0061c420;\n          uVar5 = param_2;\n          if (uVar4 <= param_2) {\n            uVar5 = uVar4;\n          }\n          uVar4 = FUN_00409030(param_1 + lVar12 * 2,uVar5,uVar4,local_c8.st_dev,lVar3 + 0xd);\n          uVar11 = (ulong)DAT_0061c420;\n          uVar5 = param_2;\n          if (uVar4 <= param_2) {\n            uVar5 = uVar4;\n          }\n          lVar12 = lVar12 + uVar4;\n          param_2 = param_2 - uVar5;\n          uVar4 = uVar7 + 1;\n          param_1[uVar7 * 2] = lVar3 + 0xd;\n          param_1[uVar7 * 2 + 1] = lVar3;\n          uVar7 = uVar4;\n        } while (uVar11 <= local_198 - lVar12);\n        uVar10 = uVar4 % uVar11;\n        uVar5 = uVar11 - uVar10;\n        uVar7 = local_198 - lVar12;\n        plVar15 = param_1 + lVar12 * 2;\n        plVar17 = param_1 + uVar4 * 2;\n      }\n      if (uVar5 < uVar7) {\n        uVar11 = (uVar7 + 1 + uVar10) - uVar11;\n        lVar3 = FUN_004090c0(&local_c8,0);\n        uVar5 = param_2;\n        if (uVar11 <= param_2) {\n          uVar5 = uVar11;\n        }\n        uVar7 = FUN_00409030(plVar15,uVar5,uVar11,local_c8.st_dev,lVar3 + 0xd);\n        uVar5 = param_2;\n        if (uVar7 <= param_2) {\n          uVar5 = uVar7;\n        }\n        uVar4 = uVar4 + 1;\n        lVar12 = lVar12 + uVar7;\n        *plVar17 = lVar3 + 0xd;\n        plVar17[1] = lVar3;\n        param_2 = param_2 - uVar5;\n        plVar15 = param_1 + lVar12 * 2;\n        plVar17 = param_1 + uVar4 * 2;\n      }\n      param_2 = param_2 + uVar4;\n      param_3 = local_198 + (uVar4 - lVar12);\n      memmove(plVar17,plVar15,(local_198 - lVar12) * 0x10);\n      uVar5 = (ulong)DAT_0061c420;\n      local_198 = param_3;\n    } while (uVar5 < param_3);\n  }\n  if (param_2 < param_3) {\n    bVar18 = false;\n    pbVar8 = (byte *)0x0;\n    bVar19 = true;\n    ppbVar16 = (byte **)(param_1 + param_2 * 2);\n    bVar1 = false;\n    uVar5 = param_2;\nLAB_004094d1:\n    do {\n      lVar12 = 2;\n      pbVar13 = *ppbVar16;\n      pbVar14 = &DAT_0041814a;\n      do {\n        if (lVar12 == 0) break;\n        lVar12 = lVar12 + -1;\n        bVar18 = *pbVar13 < *pbVar14;\n        bVar19 = *pbVar13 == *pbVar14;\n        pbVar13 = pbVar13 + (ulong)bVar20 * -2 + 1;\n        pbVar14 = pbVar14 + (ulong)bVar20 * -2 + 1;\n      } while (bVar19);\n      if (((param_4 != (char *)0x0) &&\n          (iVar2 = strcmp(param_4,(char *)*ppbVar16), (!bVar18 && !bVar19) != bVar18)) &&\n         (iVar2 == 0)) {\nLAB_0040964e:\n        if (pbVar8 == (byte *)0x0) {\n          pbVar8 = (byte *)FUN_004090c0(&local_160,0);\n          pbVar13 = pbVar8 + 0xd;\n          FUN_00409030(ppbVar16,0,1,local_160,pbVar13);\n        }\n        else {\n          pbVar13 = pbVar8 + 0xd;\n        }\n        *ppbVar16 = pbVar13;\n        ppbVar16[1] = pbVar8;\nLAB_004094c3:\n        uVar5 = uVar5 + 1;\n        ppbVar16 = ppbVar16 + 2;\n        bVar18 = uVar5 < param_3;\n        bVar19 = uVar5 == param_3;\n        if (bVar19) break;\n        goto LAB_004094d1;\n      }\n      if ((!bVar1) && (iVar2 = __fxstat(1,1,&local_158), iVar2 != 0)) break;\n      if ((!bVar18 && !bVar19) == bVar18) {\n        bVar1 = true;\n        iVar2 = __fxstat(1,0,&local_c8);\n        if (iVar2 == 0) goto LAB_004094aa;\n        goto LAB_004094c3;\n      }\n      bVar1 = true;\n      iVar2 = __xstat(1,(char *)*ppbVar16,&local_c8);\n      if (iVar2 == 0) {\nLAB_004094aa:\n        bVar1 = true;\n        if ((local_c8.st_ino == local_158.st_ino) && (local_c8.st_dev == local_158.st_dev))\n        goto LAB_0040964e;\n        goto LAB_004094c3;\n      }\n      uVar5 = uVar5 + 1;\n      ppbVar16 = ppbVar16 + 2;\n      bVar18 = uVar5 < param_3;\n      bVar19 = uVar5 == param_3;\n    } while (!bVar19);\n  }\n  do {\n    local_188 = &local_158;\n    uVar5 = FUN_00408e20(param_1,param_3,local_188);\n    if (param_3 == uVar5) {\n      lVar12 = FUN_00407cd0(param_4,&DAT_0041655c);\n      if (lVar12 != 0) {\n        FUN_00408640(param_1,param_2,param_3,lVar12,param_4,local_158.st_dev);\n        return;\n      }\n      piVar6 = __errno_location();\n      if ((*piVar6 != 0x18) || (param_3 < 3)) {\n        uVar9 = dcgettext(0,\"open failed\",5);\n                    /* WARNING: Subroutine does not return */\n        FUN_00405dd0(uVar9,param_4);\n      }\n    }\n    else if (uVar5 < 3) {\n      lVar12 = param_1[uVar5 * 2];\n      uVar9 = dcgettext(0,\"open failed\",5);\n                    /* WARNING: Subroutine does not return */\n      FUN_00405dd0(uVar9,lVar12);\n    }\n    plVar15 = param_1 + uVar5 * 2 + -2;\n    do {\n      plVar17 = plVar15;\n      uVar5 = uVar5 - 1;\n      FUN_00407df0(*(undefined8 *)(local_158.st_dev + uVar5 * 8),*plVar17);\n      lVar12 = FUN_004090c0(&local_c8,2 < uVar5);\n      plVar15 = plVar17 + -2;\n    } while (lVar12 == 0);\n    uVar7 = uVar5;\n    if (param_2 <= uVar5) {\n      uVar7 = param_2;\n    }\n    lVar3 = param_3 - uVar5;\n    FUN_00408640(param_1,uVar7,uVar5,local_c8.st_dev,lVar12 + 0xd,local_158.st_dev);\n    param_2 = (param_2 - uVar7) + 1;\n    *param_1 = lVar12 + 0xd;\n    param_3 = lVar3 + 1;\n    param_1[1] = lVar12;\n    memmove(param_1 + 2,plVar17,lVar3 * 0x10);\n  } while( true );\n}\n\n",
            "funcName": "FUN_00409330"
        },
        {
            "funcStartAddr": "0x409830",
            "funcEndAddr": "0x409864",
            "decompiledFuncCode": "\nvoid FUN_00409830(undefined8 param_1,long *param_2)\n\n{\n  if (*param_2 == param_2[2]) {\n    if ((param_2[1] != param_2[3]) && (param_2[5] == 0)) {\n      FUN_00406320();\n      return;\n    }\n  }\n  else if ((param_2[1] != param_2[3]) || (param_2[6] == 0)) {\n    FUN_00406320();\n    return;\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00409830"
        },
        {
            "funcStartAddr": "0x409880",
            "funcEndAddr": "0x409f55",
            "decompiledFuncCode": "\nundefined8\nFUN_00409880(long param_1,ulong param_2,ulong param_3,long *param_4,undefined8 *param_5,\n            undefined8 param_6,undefined8 param_7)\n\n{\n  pthread_mutex_t *__mutex;\n  pthread_mutex_t *__mutex_00;\n  uint uVar1;\n  undefined4 *puVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int iVar7;\n  ulong uVar8;\n  long *plVar9;\n  long lVar10;\n  undefined8 uVar11;\n  long lVar12;\n  undefined4 *puVar13;\n  undefined4 *puVar14;\n  undefined4 *puVar15;\n  ulong uVar16;\n  undefined4 *puVar17;\n  undefined4 *puVar18;\n  undefined4 *puVar19;\n  ulong uVar20;\n  long lVar21;\n  long lVar22;\n  long lVar23;\n  long lVar24;\n  pthread_t local_80;\n  long local_78;\n  ulong local_70;\n  ulong local_68;\n  long local_60;\n  undefined8 *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  uVar20 = param_2 >> 1;\n  uVar16 = param_4[5];\n  uVar8 = param_4[6];\n  local_60 = param_4[8];\n  local_48 = param_7;\n  local_78 = param_1;\n  local_70 = uVar20;\n  local_68 = param_3;\n  local_58 = param_5;\n  local_50 = param_6;\n  if ((0x1ffff < uVar16 + uVar8) && (1 < param_2)) {\n    iVar7 = pthread_create(&local_80,(pthread_attr_t *)0x0,FUN_00409fe0,&local_78);\n    if (iVar7 == 0) {\n      FUN_00409880(param_1 + param_4[5] * -0x20,param_2 - uVar20,param_3,param_4[9],param_5,param_6)\n      ;\n      pthread_join(local_80,(void **)0x0);\n      return param_7;\n    }\n    uVar16 = param_4[5];\n    uVar8 = param_4[6];\n  }\n  lVar21 = param_1 + param_3 * -0x20;\n  lVar23 = param_1 + uVar16 * -0x20;\n  if (1 < uVar8) {\n    FUN_00408370(lVar23,uVar8,lVar21 + (uVar16 >> 1) * -0x20,0);\n  }\n  if (1 < uVar16) {\n    FUN_00408370(param_1,uVar16,lVar21,0);\n  }\n  *param_4 = param_1;\n  param_4[1] = lVar23;\n  param_4[2] = lVar23;\n  param_4[3] = param_1 + uVar16 * -0x20 + uVar8 * -0x20;\n  FUN_00406320(param_5,param_4);\n  __mutex = (pthread_mutex_t *)(param_5 + 1);\nLAB_004099d0:\n  pthread_mutex_lock(__mutex);\n  while (plVar9 = (long *)FUN_0040d190(*param_5), plVar9 == (long *)0x0) {\n    pthread_cond_wait((pthread_cond_t *)(param_5 + 6),__mutex);\n  }\n  pthread_mutex_unlock(__mutex);\n  __mutex_00 = (pthread_mutex_t *)(plVar9 + 0xb);\n  pthread_mutex_lock(__mutex_00);\n  uVar1 = *(uint *)(plVar9 + 10);\n  *(undefined *)((long)plVar9 + 0x54) = 0;\n  if (uVar1 == 0) {\n    pthread_mutex_unlock(__mutex_00);\n    uVar11 = FUN_00406320(param_5,plVar9);\n    return uVar11;\n  }\n  puVar2 = (undefined4 *)*plVar9;\n  puVar14 = (undefined4 *)plVar9[1];\n  lVar23 = (param_3 >> ((char)uVar1 * '\\x02' + 2U & 0x3f)) + 1;\n  puVar13 = puVar14;\n  puVar15 = puVar2;\n  if (1 < uVar1) {\n    puVar19 = *(undefined4 **)plVar9[4];\n    while (puVar17 = (undefined4 *)plVar9[2], puVar17 != puVar15) {\n      puVar18 = puVar19;\n      if ((undefined4 *)plVar9[3] == puVar13) {\n        lVar24 = plVar9[6];\n        lVar22 = plVar9[5];\n        lVar21 = (long)puVar14 - (long)puVar13 >> 5;\n        lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n        if (lVar24 != lVar21) goto LAB_00409bdd;\n        lVar12 = lVar23 + -1;\n        if (lVar23 == 0) goto LAB_00409b70;\n        goto LAB_00409b3a;\n      }\n      if (lVar23 == 0) {\n        lVar22 = plVar9[5];\n        lVar23 = -1;\n        lVar21 = (long)puVar14 - (long)puVar13 >> 5;\n        lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n        lVar24 = plVar9[6];\n        if (plVar9[6] != lVar21) goto LAB_00409bdd;\n        lVar12 = -2;\n        goto LAB_00409b3a;\n      }\n      iVar7 = FUN_004082a0(puVar15 + -8,puVar13 + -8);\n      puVar17 = puVar19 + -8;\n      if (iVar7 < 1) {\n        lVar21 = *plVar9;\n        puVar13 = (undefined4 *)plVar9[1];\n        uVar3 = *(undefined4 *)(lVar21 + -0x20);\n        uVar4 = *(undefined4 *)(lVar21 + -0x1c);\n        uVar5 = *(undefined4 *)(&DAT_ffffffffffffffe8 + lVar21);\n        uVar6 = *(undefined4 *)(lVar21 + -0x14);\n        puVar15 = (undefined4 *)(lVar21 + -0x20);\n        *plVar9 = (long)puVar15;\n        *puVar17 = uVar3;\n        puVar19[-7] = uVar4;\n        puVar19[-6] = uVar5;\n        puVar19[-5] = uVar6;\n        uVar3 = *(undefined4 *)(lVar21 + -0xc);\n        uVar4 = *(undefined4 *)(lVar21 + -8);\n        uVar5 = *(undefined4 *)(lVar21 + -4);\n        puVar19[-4] = *(undefined4 *)(lVar21 + -0x10);\n        puVar19[-3] = uVar3;\n        puVar19[-2] = uVar4;\n        puVar19[-1] = uVar5;\n      }\n      else {\n        lVar21 = plVar9[1];\n        puVar15 = (undefined4 *)*plVar9;\n        uVar3 = *(undefined4 *)(lVar21 + -0x20);\n        uVar4 = *(undefined4 *)(lVar21 + -0x1c);\n        uVar5 = *(undefined4 *)(&DAT_ffffffffffffffe8 + lVar21);\n        uVar6 = *(undefined4 *)(lVar21 + -0x14);\n        puVar13 = (undefined4 *)(lVar21 + -0x20);\n        plVar9[1] = (long)puVar13;\n        *puVar17 = uVar3;\n        puVar19[-7] = uVar4;\n        puVar19[-6] = uVar5;\n        puVar19[-5] = uVar6;\n        uVar3 = *(undefined4 *)(lVar21 + -0xc);\n        uVar4 = *(undefined4 *)(lVar21 + -8);\n        uVar5 = *(undefined4 *)(lVar21 + -4);\n        puVar19[-4] = *(undefined4 *)(lVar21 + -0x10);\n        puVar19[-3] = uVar3;\n        puVar19[-2] = uVar4;\n        puVar19[-1] = uVar5;\n      }\n      lVar23 = lVar23 + -1;\n      puVar19 = puVar17;\n    }\n    lVar21 = plVar9[6];\n    lVar22 = plVar9[5];\n    lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n    lVar24 = lVar21;\n    if ((long)puVar14 - (long)puVar13 >> 5 != lVar21) {\nLAB_00409bdd:\n      if (((lVar10 == lVar22) && (puVar2 = (undefined4 *)plVar9[3], puVar2 != puVar13)) &&\n         (lVar21 = lVar23 + -1, puVar15 = puVar19, lVar23 != 0)) {\n        do {\n          puVar17 = puVar13 + -8;\n          uVar3 = *puVar17;\n          uVar4 = puVar13[-7];\n          uVar5 = puVar13[-6];\n          uVar6 = puVar13[-5];\n          puVar19 = puVar15 + -8;\n          plVar9[1] = (long)puVar17;\n          *puVar19 = uVar3;\n          puVar15[-7] = uVar4;\n          puVar15[-6] = uVar5;\n          puVar15[-5] = uVar6;\n          uVar3 = puVar13[-3];\n          uVar4 = puVar13[-2];\n          uVar5 = puVar13[-1];\n          puVar15[-4] = puVar13[-4];\n          puVar15[-3] = uVar3;\n          puVar15[-2] = uVar4;\n          puVar15[-1] = uVar5;\n          if (puVar17 == puVar2) {\n            lVar21 = (long)puVar14 - (long)puVar17 >> 5;\n            goto LAB_00409b70;\n          }\n          lVar21 = lVar21 + -1;\n          puVar15 = puVar19;\n          puVar13 = puVar17;\n        } while (lVar21 != -1);\n        lVar21 = (long)puVar14 - (long)puVar17 >> 5;\n      }\n      else {\n        lVar21 = (long)puVar14 - (long)puVar13 >> 5;\n      }\n    }\n    goto LAB_00409b70;\n  }\n  while ((undefined4 *)plVar9[2] != puVar15) {\n    if ((undefined4 *)plVar9[3] == puVar13) {\n      lVar21 = plVar9[6];\n      lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n      if ((long)puVar14 - (long)puVar13 >> 5 != lVar21) {\nLAB_00409d61:\n        lVar22 = plVar9[5];\n        if (lVar10 == lVar22) goto LAB_00409d6a;\n        goto LAB_00409d2a;\n      }\n      lVar24 = lVar23 + -1;\n      if (lVar23 != 0) goto LAB_00409e7a;\n      lVar22 = plVar9[5];\n      lVar24 = lVar21;\n      goto LAB_00409b77;\n    }\n    if (lVar23 == 0) {\n      lVar23 = -1;\n      lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n      if (plVar9[6] != (long)puVar14 - (long)puVar13 >> 5) goto LAB_00409d61;\n      lVar24 = -2;\n      goto LAB_00409e7a;\n    }\n    iVar7 = FUN_004082a0(puVar15 + -8,puVar13 + -8);\n    if (iVar7 < 1) {\n      lVar21 = *plVar9;\n      *plVar9 = lVar21 + -0x20;\n      FUN_004085d0(lVar21 + -0x20,param_6,param_7);\n    }\n    else {\n      lVar21 = plVar9[1];\n      plVar9[1] = lVar21 + -0x20;\n      FUN_004085d0(lVar21 + -0x20,param_6,param_7);\n    }\n    lVar23 = lVar23 + -1;\n    puVar13 = (undefined4 *)plVar9[1];\n    puVar15 = (undefined4 *)*plVar9;\n  }\n  lVar21 = plVar9[6];\n  lVar22 = plVar9[5];\n  lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n  lVar24 = lVar21;\n  if ((long)puVar14 - (long)puVar13 >> 5 != lVar21) {\n    if (lVar10 == lVar22) {\nLAB_00409d6a:\n      if (((undefined4 *)plVar9[3] != puVar13) && (lVar21 = lVar23 + -1, lVar23 != 0)) {\n        do {\n          plVar9[1] = (long)(puVar13 + -8);\n          FUN_004085d0(puVar13 + -8,param_6,param_7);\n          puVar13 = (undefined4 *)plVar9[1];\n          if (puVar13 == (undefined4 *)plVar9[3]) break;\n          lVar21 = lVar21 + -1;\n        } while (lVar21 != -1);\n        lVar22 = plVar9[5];\n        lVar10 = (long)puVar2 - *plVar9 >> 5;\n        lVar21 = (long)puVar14 - (long)puVar13 >> 5;\n        lVar24 = plVar9[6];\n        goto LAB_00409b77;\n      }\n    }\nLAB_00409d2a:\n    lVar21 = (long)puVar14 - (long)puVar13 >> 5;\n    lVar24 = plVar9[6];\n  }\n  goto LAB_00409b77;\n  while (lVar12 = lVar12 + -1, puVar18 = puVar19, puVar15 = puVar14, lVar12 != -1) {\nLAB_00409b3a:\n    puVar14 = puVar15 + -8;\n    uVar3 = *puVar14;\n    uVar4 = puVar15[-7];\n    uVar5 = puVar15[-6];\n    uVar6 = puVar15[-5];\n    puVar19 = puVar18 + -8;\n    *plVar9 = (long)puVar14;\n    *puVar19 = uVar3;\n    puVar18[-7] = uVar4;\n    puVar18[-6] = uVar5;\n    puVar18[-5] = uVar6;\n    uVar3 = puVar15[-3];\n    uVar4 = puVar15[-2];\n    uVar5 = puVar15[-1];\n    puVar18[-4] = puVar15[-4];\n    puVar18[-3] = uVar3;\n    puVar18[-2] = uVar4;\n    puVar18[-1] = uVar5;\n    lVar24 = lVar21;\n    if (puVar17 == puVar14) {\n      lVar10 = (long)puVar2 - (long)puVar17 >> 5;\n      goto LAB_00409b70;\n    }\n  }\n  lVar10 = (long)puVar2 - (long)puVar14 >> 5;\nLAB_00409b70:\n  *(undefined4 **)plVar9[4] = puVar19;\nLAB_00409b77:\n  plVar9[5] = lVar22 - lVar10;\n  plVar9[6] = lVar24 - lVar21;\n  if (*(char *)((long)plVar9 + 0x54) == '\\0') {\n    FUN_00409830(param_5,plVar9);\n  }\n  if (*(uint *)(plVar9 + 10) < 2) {\n    if (plVar9[6] + plVar9[5] == 0) {\n      FUN_00406320(param_5,plVar9[7]);\n    }\n  }\n  else {\n    pthread_mutex_lock((pthread_mutex_t *)(plVar9[7] + 0x58));\n    lVar23 = plVar9[7];\n    if (*(char *)(lVar23 + 0x54) == '\\0') {\n      FUN_00409830(param_5);\n      lVar23 = plVar9[7];\n    }\n    pthread_mutex_unlock((pthread_mutex_t *)(lVar23 + 0x58));\n  }\n  pthread_mutex_unlock(__mutex_00);\n  goto LAB_004099d0;\n  while (lVar24 = lVar24 + -1, lVar24 != -1) {\nLAB_00409e7a:\n    *plVar9 = (long)(puVar15 + -8);\n    FUN_004085d0(puVar15 + -8,param_6,param_7);\n    puVar15 = (undefined4 *)*plVar9;\n    if (puVar15 == (undefined4 *)plVar9[2]) break;\n  }\n  lVar22 = plVar9[5];\n  lVar10 = (long)puVar2 - (long)puVar15 >> 5;\n  lVar21 = (long)puVar14 - plVar9[1] >> 5;\n  lVar24 = plVar9[6];\n  goto LAB_00409b77;\n}\n\n",
            "funcName": "FUN_00409880"
        },
        {
            "funcStartAddr": "0x409fe0",
            "funcEndAddr": "0x40a00a",
            "decompiledFuncCode": "\nundefined8 FUN_00409fe0(undefined8 *param_1)\n\n{\n  FUN_00409880(*param_1,param_1[1],param_1[2],param_1[3],param_1[4],param_1[5],param_1[6]);\n  return 0;\n}\n\n",
            "funcName": "FUN_00409fe0"
        },
        {
            "funcStartAddr": "0x40a010",
            "funcEndAddr": "0x40a0b5",
            "decompiledFuncCode": "\nvoid FUN_0040a010(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  if (DAT_0061c768 == DAT_0061c760) {\n    if (DAT_0061c770 == 0) {\n      if (DAT_0061c760 == 0) {\n        lVar1 = 0x80;\n        DAT_0061c760 = 0x10;\n      }\n      else {\n        lVar1 = DAT_0061c760 << 3;\n        if ((lVar1 < 0) || (DAT_0061c760 >> 0x3d != 0)) goto LAB_0040a0af;\n      }\n    }\n    else {\n      if (0xaaaaaaaaaaaaaa9 < DAT_0061c760) {\nLAB_0040a0af:\n                    /* WARNING: Subroutine does not return */\n        FUN_00411460();\n      }\n      DAT_0061c760 = DAT_0061c760 + 1 + (DAT_0061c760 >> 1);\n      lVar1 = DAT_0061c760 * 8;\n    }\n    DAT_0061c770 = FUN_00411270(DAT_0061c770,lVar1);\n  }\n  *(undefined8 *)(DAT_0061c770 + DAT_0061c768 * 8) = param_1;\n  DAT_0061c768 = DAT_0061c768 + 1;\n  return;\n}\n\n",
            "funcName": "FUN_0040a010"
        },
        {
            "funcStartAddr": "0x40a0d0",
            "funcEndAddr": "0x40a63d",
            "decompiledFuncCode": "\nvoid FUN_0040a0d0(int param_1)\n\n{\n  FILE *pFVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  byte **ppbVar6;\n  long lVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  bool bVar11;\n  bool bVar12;\n  byte bVar13;\n  byte *local_88;\n  char *local_80;\n  byte *local_78 [5];\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char *local_38;\n  char *local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  byte **ppbVar7;\n  \n  uVar5 = DAT_0061cbc8;\n  bVar13 = 0;\n  if (param_1 != 0) {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar5);\n    goto LAB_0040a10f;\n  }\n  uVar3 = dcgettext(0,\"Usage: %s [OPTION]... [FILE]...\\n  or:  %s [OPTION]... --files0-from=F\\n\",5);\n  __printf_chk(1,uVar3,uVar5,uVar5);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"Write sorted concatenation of all FILE(s) to standard output.\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"\\nWith no FILE, or when FILE is -, read standard input.\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"Ordering options:\\n\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -b, --ignore-leading-blanks  ignore leading blanks\\n  -d, --dictionary-order      consider only blanks and alphanumeric characters\\n  -f, --ignore-case           fold lower case to upper case characters\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -g, --general-numeric-sort  compare according to general numerical value\\n  -i, --ignore-nonprinting    consider only printable characters\\n  -M, --month-sort            compare (unknown) < \\'JAN\\' < ... < \\'DEC\\'\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -n, --numeric-sort          compare according to string numerical value\\n  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\\n      --random-source=FILE    get random bytes from FILE\\n  -r, --reverse               reverse the result of comparisons\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"      --sort=WORD             sort according to WORD:\\n                                general-numeric -g, human-numeric -h, month -M,\\n                                numeric -n, random -R, version -V\\n  -V, --version-sort          natural sort of (version) numbers within text\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"Other options:\\n\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\\n                            for more use temp files\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\\n  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\\n      --compress-program=PROG  compress temporaries with PROG;\\n                              decompress them with PROG -d\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"      --debug               annotate the part of the line used to sort,\\n                              and warn about questionable usage to stderr\\n      --files0-from=F       read input from the files specified by\\n                            NUL-terminated names in file F;\\n                            If F is - then read names from standard input\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\\n  -m, --merge               merge already sorted files; do not sort\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -o, --output=FILE         write result to FILE instead of standard output\\n  -s, --stable              stabilize sort by disabling last-resort comparison\\n  -S, --buffer-size=SIZE    use SIZE for main memory buffer\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  uVar5 = dcgettext(0,\n                    \"  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\\n  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\\n                              multiple options specify multiple directories\\n      --parallel=N          change the number of sorts run concurrently to N\\n  -u, --unique              with -c, check for strict ordering;\\n                              without -c, output only the first of an equal run\\n\"\n                    ,5);\n  __printf_chk(1,uVar5,&DAT_00416583);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\",5)\n  ;\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\\nfield number and C a character position in the field; both are origin 1, and\\nthe stop position defaults to the line\\'s end.  If neither -t nor -b is in\\neffect, characters in a field are counted from the beginning of the preceding\\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\\nwhich override global ordering options for that key.  If no key is given, use\\nthe entire line as the key.  Use --debug to diagnose incorrect key usage.\\n\\nSIZE may be followed by the following multiplicative suffixes:\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\\n\\n*** WARNING ***\\nThe locale specified by the environment affects sort order.\\nSet LC_ALL=C to get the traditional sort order that uses\\nnative byte values.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  local_88 = &DAT_00416588;\n  local_80 = \"test invocation\";\n  local_78[0] = (byte *)0x416602;\n  local_78[1] = (byte *)0x41659a;\n  local_78[2] = (byte *)0x4165b0;\n  local_78[3] = (byte *)0x4165ba;\n  local_78[4] = (byte *)0x4165c9;\n  local_50 = \"sha2 utilities\";\n  local_48 = \"sha384sum\";\n  local_40 = \"sha2 utilities\";\n  local_38 = \"sha512sum\";\n  local_30 = \"sha2 utilities\";\n  local_28 = 0;\n  local_20 = 0;\n  ppbVar6 = &local_88;\n  do {\n    ppbVar7 = ppbVar6;\n    ppbVar6 = ppbVar7 + 2;\n    pbVar9 = *ppbVar6;\n    bVar11 = false;\n    bVar12 = pbVar9 == (byte *)0x0;\n    if (bVar12) break;\n    lVar8 = 5;\n    pbVar10 = (byte *)0x416672;\n    do {\n      if (lVar8 == 0) break;\n      lVar8 = lVar8 + -1;\n      bVar11 = *pbVar10 < *pbVar9;\n      bVar12 = *pbVar10 == *pbVar9;\n      pbVar10 = pbVar10 + (ulong)bVar13 * -2 + 1;\n      pbVar9 = pbVar9 + (ulong)bVar13 * -2 + 1;\n    } while (bVar12);\n  } while ((!bVar11 && !bVar12) != bVar11);\n  pbVar9 = ppbVar7[3];\n  if (pbVar9 == (byte *)0x0) {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar2 = strncmp(pcVar4,\"en_\",3);\n      if (iVar2 != 0) {\n        pbVar9 = (byte *)0x416672;\n        goto LAB_0040a613;\n      }\n    }\n    pbVar9 = (byte *)0x416672;\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar4 = \" invocation\";\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"sort\");\n  }\n  else {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar2 = strncmp(pcVar4,\"en_\",3);\n      if (iVar2 != 0) {\nLAB_0040a613:\n        uVar5 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar5,\"sort\");\n      }\n    }\n    pcVar4 = \" invocation\";\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"sort\");\n    if (pbVar9 != (byte *)0x416672) {\n      pcVar4 = \"\";\n    }\n  }\n  uVar5 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  __printf_chk(1,uVar5,pbVar9,pcVar4);\nLAB_0040a10f:\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
            "funcName": "FUN_0040a0d0"
        },
        {
            "funcStartAddr": "0x40a640",
            "funcEndAddr": "0x40a64a",
            "decompiledFuncCode": "\nvoid FUN_0040a640(void)\n\n{\n  FUN_0040a0d0(1);\n  return;\n}\n\n",
            "funcName": "FUN_0040a640"
        },
        {
            "funcStartAddr": "0x40a650",
            "funcEndAddr": "0x40a753",
            "decompiledFuncCode": "\nlong FUN_0040a650(char *param_1,char **param_2,void *param_3,size_t param_4)\n\n{\n  bool bVar1;\n  long lVar2;\n  int iVar3;\n  size_t __n;\n  size_t sVar4;\n  long lVar5;\n  void *__s2;\n  char *__s1;\n  long local_58;\n  \n  __n = strlen(param_1);\n  __s1 = *param_2;\n  local_58 = -1;\n  lVar2 = local_58;\n  if (__s1 != (char *)0x0) {\n    bVar1 = false;\n    lVar2 = 0;\n    __s2 = param_3;\nLAB_0040a6e7:\n    do {\n      lVar5 = lVar2;\n      iVar3 = strncmp(__s1,param_1,__n);\n      if (iVar3 == 0) {\n        sVar4 = strlen(__s1);\n        if (sVar4 == __n) {\n          return lVar5;\n        }\n        if (local_58 == -1) {\n          __s2 = (void *)((long)__s2 + param_4);\n          __s1 = param_2[lVar5 + 1];\n          lVar2 = lVar5 + 1;\n          local_58 = lVar5;\n          if (__s1 == (char *)0x0) break;\n          goto LAB_0040a6e7;\n        }\n        if (param_3 == (void *)0x0) {\n          bVar1 = true;\n        }\n        else {\n          iVar3 = memcmp((void *)(local_58 * param_4 + (long)param_3),__s2,param_4);\n          if (iVar3 != 0) {\n            bVar1 = true;\n          }\n        }\n      }\n      __s2 = (void *)((long)__s2 + param_4);\n      __s1 = param_2[lVar5 + 1];\n      lVar2 = lVar5 + 1;\n    } while (__s1 != (char *)0x0);\n    lVar2 = -2;\n    if (!bVar1) {\n      lVar2 = local_58;\n    }\n  }\n  local_58 = lVar2;\n  return local_58;\n}\n\n",
            "funcName": "FUN_0040a650"
        },
        {
            "funcStartAddr": "0x40a770",
            "funcEndAddr": "0x40a7dc",
            "decompiledFuncCode": "\nvoid FUN_0040a770(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_3 == -1) {\n    uVar1 = dcgettext(0,\"invalid argument %s for %s\",5);\n  }\n  else {\n    uVar1 = dcgettext(0,\"ambiguous argument %s for %s\",5);\n  }\n  uVar2 = FUN_0040f860(1,param_1);\n  uVar3 = FUN_0040f550(0,8,param_2);\n                    /* WARNING: Subroutine does not return */\n  error(0,0,uVar1,uVar3,uVar2);\n}\n\n",
            "funcName": "FUN_0040a770"
        },
        {
            "funcStartAddr": "0x40a7f0",
            "funcEndAddr": "0x40a8ff",
            "decompiledFuncCode": "\nvoid FUN_0040a7f0(long *param_1,void *param_2,size_t param_3)\n\n{\n  FILE *__stream;\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long lVar4;\n  void *__s2;\n  long lVar5;\n  void *__s1;\n  \n  __stream = stderr;\n  __s1 = (void *)0x0;\n  pcVar2 = (char *)dcgettext(0,\"Valid arguments are:\",5);\n  lVar4 = 0;\n  fputs_unlocked(pcVar2,__stream);\n  lVar5 = *param_1;\n  while (lVar5 != 0) {\n    while ((__s2 = param_2, lVar4 == 0 || (iVar1 = memcmp(__s1,__s2,param_3), iVar1 != 0))) {\n      lVar4 = lVar4 + 1;\n      uVar3 = FUN_0040f880(lVar5);\n      __fprintf_chk(stderr,1,\"\\n  - %s\",uVar3);\n      lVar5 = param_1[lVar4];\n      param_2 = (void *)((long)__s2 + param_3);\n      __s1 = __s2;\n      if (lVar5 == 0) goto LAB_0040a8c0;\n    }\n    lVar4 = lVar4 + 1;\n    param_2 = (void *)((long)__s2 + param_3);\n    uVar3 = FUN_0040f880(lVar5);\n    __fprintf_chk(stderr,1,&DAT_00416aba,uVar3);\n    lVar5 = param_1[lVar4];\n  }\nLAB_0040a8c0:\n  pcVar2 = stderr->_IO_write_ptr;\n  if (pcVar2 < stderr->_IO_write_end) {\n    stderr->_IO_write_ptr = pcVar2 + 1;\n    *pcVar2 = '\\n';\n    return;\n  }\n  __overflow(stderr,10);\n  return;\n}\n\n",
            "funcName": "FUN_0040a7f0"
        },
        {
            "funcStartAddr": "0x40a910",
            "funcEndAddr": "0x40a97d",
            "decompiledFuncCode": "\nlong FUN_0040a910(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,code *param_6)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_0040a650(param_2,param_3,param_4,param_5);\n  if (lVar1 < 0) {\n    FUN_0040a770(param_1,param_2,lVar1);\n    FUN_0040a7f0(param_3,param_4,param_5);\n    (*param_6)();\n    lVar1 = -1;\n  }\n  return lVar1;\n}\n\n",
            "funcName": "FUN_0040a910"
        },
        {
            "funcStartAddr": "0x40a980",
            "funcEndAddr": "0x40a9cc",
            "decompiledFuncCode": "\nlong FUN_0040a980(void *param_1,long *param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = *param_2;\n  if (lVar2 != 0) {\n    param_2 = param_2 + 1;\n    do {\n      iVar1 = memcmp(param_1,param_3,param_4);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = *param_2;\n      param_3 = (void *)((long)param_3 + param_4);\n      param_2 = param_2 + 1;\n    } while (lVar2 != 0);\n  }\n  return lVar2;\n}\n\n",
            "funcName": "FUN_0040a980"
        },
        {
            "funcStartAddr": "0x40a9d0",
            "funcEndAddr": "0x40a9d8",
            "decompiledFuncCode": "\nvoid FUN_0040a9d0(undefined8 param_1)\n\n{\n  DAT_0061cbb8 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_0040a9d0"
        },
        {
            "funcStartAddr": "0x40a9e0",
            "funcEndAddr": "0x40a9e8",
            "decompiledFuncCode": "\nvoid FUN_0040a9e0(undefined param_1)\n\n{\n  DAT_0061cbb0 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_0040a9e0"
        },
        {
            "funcStartAddr": "0x40a9f0",
            "funcEndAddr": "0x40aa8c",
            "decompiledFuncCode": "\nvoid FUN_0040a9f0(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = FUN_00413520(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((DAT_0061cbb0 == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (DAT_0061cbb8 != 0) {\n        uVar4 = FUN_0040f6d0();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar2,&DAT_00416abc,uVar3);\n    }\n  }\n  iVar1 = FUN_00413520(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(DAT_0061c518);\n}\n\n",
            "funcName": "FUN_0040a9f0"
        },
        {
            "funcStartAddr": "0x40aa90",
            "funcEndAddr": "0x40aabb",
            "decompiledFuncCode": "\nvoid FUN_0040aa90(undefined8 *param_1)\n\n{\n  param_1[2] = 0;\n  *param_1 = 0xefcdab8967452301;\n  param_1[1] = 0x1032547698badcfe;\n  *(undefined4 *)(param_1 + 3) = 0;\n  return;\n}\n\n",
            "funcName": "FUN_0040aa90"
        },
        {
            "funcStartAddr": "0x40aac0",
            "funcEndAddr": "0x40aada",
            "decompiledFuncCode": "\nundefined4 * FUN_0040aac0(undefined4 *param_1,undefined4 *param_2)\n\n{\n  *param_2 = *param_1;\n  param_2[1] = param_1[1];\n  param_2[2] = param_1[2];\n  param_2[3] = param_1[3];\n  return param_2;\n}\n\n",
            "funcName": "FUN_0040aac0"
        },
        {
            "funcStartAddr": "0x40aae0",
            "funcEndAddr": "0x40b24f",
            "decompiledFuncCode": "\nvoid FUN_0040aae0(int *param_1,ulong param_2,int *param_3)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  int iVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  uint uVar18;\n  uint uVar19;\n  uint uVar20;\n  uint uVar21;\n  uint uVar22;\n  uint uVar23;\n  uint uVar24;\n  uint local_50;\n  int local_48;\n  \n  uVar23 = param_3[1];\n  piVar1 = (int *)((long)param_1 + (param_2 & 0xfffffffffffffffc));\n  local_48 = *param_3;\n  uVar24 = param_3[2];\n  local_50 = param_3[3];\n  uVar18 = param_3[4];\n  param_3[4] = (uint)param_2 + param_3[4];\n  param_3[5] = (int)(param_2 >> 0x20) + param_3[5] + (uint)CARRY4((uint)param_2,uVar18);\n  if (param_1 < piVar1) {\n    do {\n      iVar2 = *param_1;\n      iVar3 = param_1[1];\n      iVar4 = param_1[3];\n      iVar5 = param_1[5];\n      iVar6 = param_1[6];\n      iVar7 = param_1[7];\n      iVar8 = param_1[9];\n      iVar9 = param_1[0xb];\n      uVar18 = ((local_50 ^ uVar24) & uVar23 ^ local_50) + iVar2 + -0x28955b88 + local_48;\n      uVar18 = (uVar18 * 0x80 | uVar18 >> 0x19) + uVar23;\n      uVar19 = ((uVar23 ^ uVar24) & uVar18 ^ uVar24) + iVar3 + -0x173848aa + local_50;\n      iVar10 = param_1[2];\n      uVar20 = (uVar19 * 0x1000 | uVar19 >> 0x14) + uVar18;\n      uVar19 = ((uVar18 ^ uVar23) & uVar20 ^ uVar23) + iVar10 + 0x242070db + uVar24;\n      iVar11 = param_1[4];\n      uVar19 = (uVar19 >> 0xf | uVar19 * 0x20000) + uVar20;\n      uVar21 = ((uVar18 ^ uVar20) & uVar19 ^ uVar18) + iVar4 + -0x3e423112 + uVar23;\n      iVar12 = param_1[0xf];\n      uVar21 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar19;\n      uVar18 = ((uVar20 ^ uVar19) & uVar21 ^ uVar20) + iVar11 + -0xa83f051 + uVar18;\n      uVar18 = (uVar18 * 0x80 | uVar18 >> 0x19) + uVar21;\n      uVar20 = ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + iVar5 + 0x4787c62a + uVar20;\n      uVar20 = (uVar20 * 0x1000 | uVar20 >> 0x14) + uVar18;\n      uVar19 = ((uVar21 ^ uVar18) & uVar20 ^ uVar21) + iVar6 + -0x57cfb9ed + uVar19;\n      iVar13 = param_1[8];\n      uVar19 = (uVar19 >> 0xf | uVar19 * 0x20000) + uVar20;\n      uVar21 = ((uVar18 ^ uVar20) & uVar19 ^ uVar18) + iVar7 + -0x2b96aff + uVar21;\n      iVar14 = param_1[0xc];\n      uVar21 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar19;\n      uVar18 = ((uVar20 ^ uVar19) & uVar21 ^ uVar20) + iVar13 + 0x698098d8 + uVar18;\n      iVar15 = param_1[0xe];\n      uVar18 = (uVar18 * 0x80 | uVar18 >> 0x19) + uVar21;\n      uVar20 = ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + iVar8 + -0x74bb0851 + uVar20;\n      iVar16 = param_1[10];\n      uVar20 = (uVar20 * 0x1000 | uVar20 >> 0x14) + uVar18;\n      uVar19 = ((uVar21 ^ uVar18) & uVar20 ^ uVar21) + iVar16 + -0xa44f + uVar19;\n      iVar17 = param_1[0xd];\n      param_1 = param_1 + 0x10;\n      uVar19 = (uVar19 >> 0xf | uVar19 * 0x20000) + uVar20;\n      uVar21 = ((uVar18 ^ uVar20) & uVar19 ^ uVar18) + iVar9 + -0x76a32842 + uVar21;\n      uVar21 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar19;\n      uVar18 = ((uVar20 ^ uVar19) & uVar21 ^ uVar20) + iVar14 + 0x6b901122 + uVar18;\n      uVar18 = (uVar18 * 0x80 | uVar18 >> 0x19) + uVar21;\n      uVar20 = ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + iVar17 + -0x2678e6d + uVar20;\n      uVar20 = (uVar20 * 0x1000 | uVar20 >> 0x14) + uVar18;\n      uVar19 = ((uVar21 ^ uVar18) & uVar20 ^ uVar21) + iVar15 + -0x5986bc72 + uVar19;\n      uVar19 = (uVar19 >> 0xf | uVar19 * 0x20000) + uVar20;\n      uVar21 = ((uVar18 ^ uVar20) & uVar19 ^ uVar18) + iVar12 + 0x49b40821 + uVar21;\n      uVar21 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar19;\n      uVar18 = ((uVar19 ^ uVar21) & uVar20 ^ uVar19) + iVar3 + -0x9e1da9e + uVar18;\n      uVar18 = (uVar18 * 0x20 | uVar18 >> 0x1b) + uVar21;\n      uVar20 = ((uVar21 ^ uVar18) & uVar19 ^ uVar21) + iVar6 + -0x3fbf4cc0 + uVar20;\n      uVar20 = (uVar20 * 0x200 | uVar20 >> 0x17) + uVar18;\n      uVar19 = ((uVar18 ^ uVar20) & uVar21 ^ uVar18) + iVar9 + 0x265e5a51 + uVar19;\n      uVar19 = (uVar19 * 0x4000 | uVar19 >> 0x12) + uVar20;\n      uVar21 = ((uVar20 ^ uVar19) & uVar18 ^ uVar20) + iVar2 + -0x16493856 + uVar21;\n      uVar21 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar19;\n      uVar18 = ((uVar19 ^ uVar21) & uVar20 ^ uVar19) + iVar5 + -0x29d0efa3 + uVar18;\n      uVar18 = (uVar18 * 0x20 | uVar18 >> 0x1b) + uVar21;\n      uVar20 = ((uVar21 ^ uVar18) & uVar19 ^ uVar21) + iVar16 + 0x2441453 + uVar20;\n      uVar20 = (uVar20 * 0x200 | uVar20 >> 0x17) + uVar18;\n      uVar19 = ((uVar18 ^ uVar20) & uVar21 ^ uVar18) + iVar12 + -0x275e197f + uVar19;\n      uVar19 = (uVar19 * 0x4000 | uVar19 >> 0x12) + uVar20;\n      uVar21 = ((uVar20 ^ uVar19) & uVar18 ^ uVar20) + iVar11 + -0x182c0438 + uVar21;\n      uVar21 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar19;\n      uVar18 = ((uVar19 ^ uVar21) & uVar20 ^ uVar19) + iVar8 + 0x21e1cde6 + uVar18;\n      uVar18 = (uVar18 * 0x20 | uVar18 >> 0x1b) + uVar21;\n      uVar20 = ((uVar21 ^ uVar18) & uVar19 ^ uVar21) + iVar15 + -0x3cc8f82a + uVar20;\n      uVar20 = (uVar20 * 0x200 | uVar20 >> 0x17) + uVar18;\n      uVar19 = ((uVar18 ^ uVar20) & uVar21 ^ uVar18) + iVar4 + -0xb2af279 + uVar19;\n      uVar19 = (uVar19 * 0x4000 | uVar19 >> 0x12) + uVar20;\n      uVar21 = ((uVar20 ^ uVar19) & uVar18 ^ uVar20) + iVar13 + 0x455a14ed + uVar21;\n      uVar22 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar19;\n      uVar18 = ((uVar19 ^ uVar22) & uVar20 ^ uVar19) + iVar17 + -0x561c16fb + uVar18;\n      uVar18 = (uVar18 * 0x20 | uVar18 >> 0x1b) + uVar22;\n      uVar20 = ((uVar22 ^ uVar18) & uVar19 ^ uVar22) + iVar10 + -0x3105c08 + uVar20;\n      uVar20 = (uVar20 * 0x200 | uVar20 >> 0x17) + uVar18;\n      uVar19 = ((uVar18 ^ uVar20) & uVar22 ^ uVar18) + iVar7 + 0x676f02d9 + uVar19;\n      uVar21 = (uVar19 * 0x4000 | uVar19 >> 0x12) + uVar20;\n      uVar19 = ((uVar20 ^ uVar21) & uVar18 ^ uVar20) + iVar14 + -0x72d5b376 + uVar22;\n      uVar22 = (uVar19 >> 0xc | uVar19 * 0x100000) + uVar21;\n      uVar18 = (uVar20 ^ uVar21 ^ uVar22) + iVar5 + -0x5c6be + uVar18;\n      uVar19 = (uVar18 * 0x10 | uVar18 >> 0x1c) + uVar22;\n      uVar18 = (uVar21 ^ uVar22 ^ uVar19) + iVar13 + -0x788e097f + uVar20;\n      uVar20 = (uVar18 * 0x800 | uVar18 >> 0x15) + uVar19;\n      uVar18 = (uVar22 ^ uVar19 ^ uVar20) + iVar9 + 0x6d9d6122 + uVar21;\n      uVar21 = (uVar18 * 0x10000 | uVar18 >> 0x10) + uVar20;\n      uVar18 = (uVar19 ^ uVar20 ^ uVar21) + iVar15 + -0x21ac7f4 + uVar22;\n      uVar18 = (uVar18 >> 9 | uVar18 * 0x800000) + uVar21;\n      uVar19 = (uVar20 ^ uVar21 ^ uVar18) + iVar3 + -0x5b4115bc + uVar19;\n      uVar19 = (uVar19 * 0x10 | uVar19 >> 0x1c) + uVar18;\n      uVar20 = (uVar21 ^ uVar18 ^ uVar19) + iVar11 + 0x4bdecfa9 + uVar20;\n      uVar22 = (uVar20 * 0x800 | uVar20 >> 0x15) + uVar19;\n      uVar20 = (uVar18 ^ uVar19 ^ uVar22) + iVar7 + -0x944b4a0 + uVar21;\n      uVar20 = (uVar20 * 0x10000 | uVar20 >> 0x10) + uVar22;\n      uVar18 = (uVar19 ^ uVar22 ^ uVar20) + iVar16 + -0x41404390 + uVar18;\n      uVar21 = (uVar18 >> 9 | uVar18 * 0x800000) + uVar20;\n      uVar18 = (uVar22 ^ uVar20 ^ uVar21) + iVar17 + 0x289b7ec6 + uVar19;\n      uVar19 = (uVar18 * 0x10 | uVar18 >> 0x1c) + uVar21;\n      uVar18 = (uVar20 ^ uVar21 ^ uVar19) + iVar2 + -0x155ed806 + uVar22;\n      uVar18 = (uVar18 * 0x800 | uVar18 >> 0x15) + uVar19;\n      uVar20 = (uVar21 ^ uVar19 ^ uVar18) + iVar4 + -0x2b10cf7b + uVar20;\n      uVar22 = (uVar20 * 0x10000 | uVar20 >> 0x10) + uVar18;\n      uVar20 = (uVar19 ^ uVar18 ^ uVar22) + iVar6 + 0x4881d05 + uVar21;\n      uVar21 = (uVar20 >> 9 | uVar20 * 0x800000) + uVar22;\n      uVar19 = (uVar18 ^ uVar22 ^ uVar21) + iVar8 + -0x262b2fc7 + uVar19;\n      uVar20 = (uVar19 * 0x10 | uVar19 >> 0x1c) + uVar21;\n      uVar18 = (uVar22 ^ uVar21 ^ uVar20) + iVar14 + -0x1924661b + uVar18;\n      uVar19 = (uVar18 * 0x800 | uVar18 >> 0x15) + uVar20;\n      uVar18 = (uVar21 ^ uVar20 ^ uVar19) + iVar12 + 0x1fa27cf8 + uVar22;\n      uVar22 = (uVar18 * 0x10000 | uVar18 >> 0x10) + uVar19;\n      uVar18 = (uVar20 ^ uVar19 ^ uVar22) + iVar10 + -0x3b53a99b + uVar21;\n      uVar18 = (uVar18 >> 9 | uVar18 * 0x800000) + uVar22;\n      uVar20 = ((~uVar19 | uVar18) ^ uVar22) + iVar2 + -0xbd6ddbc + uVar20;\n      uVar20 = (uVar20 * 0x40 | uVar20 >> 0x1a) + uVar18;\n      uVar19 = ((~uVar22 | uVar20) ^ uVar18) + iVar7 + 0x432aff97 + uVar19;\n      uVar19 = (uVar19 * 0x400 | uVar19 >> 0x16) + uVar20;\n      uVar21 = ((~uVar18 | uVar19) ^ uVar20) + iVar15 + -0x546bdc59 + uVar22;\n      uVar21 = (uVar21 * 0x8000 | uVar21 >> 0x11) + uVar19;\n      uVar18 = ((~uVar20 | uVar21) ^ uVar19) + iVar5 + -0x36c5fc7 + uVar18;\n      uVar18 = (uVar18 >> 0xb | uVar18 * 0x200000) + uVar21;\n      uVar20 = ((~uVar19 | uVar18) ^ uVar21) + iVar14 + 0x655b59c3 + uVar20;\n      uVar20 = (uVar20 * 0x40 | uVar20 >> 0x1a) + uVar18;\n      uVar19 = ((~uVar21 | uVar20) ^ uVar18) + iVar4 + -0x70f3336e + uVar19;\n      uVar19 = (uVar19 * 0x400 | uVar19 >> 0x16) + uVar20;\n      uVar21 = ((~uVar18 | uVar19) ^ uVar20) + iVar16 + -0x100b83 + uVar21;\n      uVar21 = (uVar21 * 0x8000 | uVar21 >> 0x11) + uVar19;\n      uVar18 = ((~uVar20 | uVar21) ^ uVar19) + iVar3 + -0x7a7ba22f + uVar18;\n      uVar18 = (uVar18 >> 0xb | uVar18 * 0x200000) + uVar21;\n      uVar20 = ((~uVar19 | uVar18) ^ uVar21) + iVar13 + 0x6fa87e4f + uVar20;\n      uVar20 = (uVar20 * 0x40 | uVar20 >> 0x1a) + uVar18;\n      uVar19 = ((~uVar21 | uVar20) ^ uVar18) + iVar12 + -0x1d31920 + uVar19;\n      uVar19 = (uVar19 * 0x400 | uVar19 >> 0x16) + uVar20;\n      uVar21 = ((~uVar18 | uVar19) ^ uVar20) + iVar6 + -0x5cfebcec + uVar21;\n      uVar21 = (uVar21 * 0x8000 | uVar21 >> 0x11) + uVar19;\n      uVar18 = ((~uVar20 | uVar21) ^ uVar19) + iVar17 + 0x4e0811a1 + uVar18;\n      uVar22 = (uVar18 >> 0xb | uVar18 * 0x200000) + uVar21;\n      uVar18 = ((~uVar19 | uVar22) ^ uVar21) + iVar11 + -0x8ac817e + uVar20;\n      uVar18 = (uVar18 * 0x40 | uVar18 >> 0x1a) + uVar22;\n      uVar19 = ((~uVar21 | uVar18) ^ uVar22) + iVar9 + -0x42c50dcb + uVar19;\n      uVar20 = (uVar19 * 0x400 | uVar19 >> 0x16) + uVar18;\n      uVar19 = ((~uVar22 | uVar20) ^ uVar18) + iVar10 + 0x2ad7d2bb + uVar21;\n      uVar19 = (uVar19 * 0x8000 | uVar19 >> 0x11) + uVar20;\n      uVar21 = ((~uVar18 | uVar19) ^ uVar20) + iVar8 + -0x14792c6f + uVar22;\n      local_48 = local_48 + uVar18;\n      uVar24 = uVar24 + uVar19;\n      uVar23 = uVar23 + (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;\n      local_50 = local_50 + uVar20;\n    } while (param_1 < piVar1);\n  }\n  *param_3 = local_48;\n  param_3[1] = uVar23;\n  param_3[2] = uVar24;\n  param_3[3] = local_50;\n  return;\n}\n\n",
            "funcName": "FUN_0040aae0"
        },
        {
            "funcStartAddr": "0x40b250",
            "funcEndAddr": "0x40b351",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040b250(long param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 *puVar6;\n  long lVar7;\n  undefined8 *puVar8;\n  long lVar9;\n  \n  uVar1 = *(uint *)(param_1 + 0x18);\n  iVar4 = *(int *)(param_1 + 0x14);\n  lVar9 = (-(ulong)(uVar1 < 0x38) & 0xffffffffffffffc0) + 0x80;\n  uVar2 = *(uint *)(param_1 + 0x10);\n  uVar5 = uVar1 + *(uint *)(param_1 + 0x10);\n  *(uint *)(param_1 + 0x10) = uVar5;\n  if (CARRY4(uVar1,uVar2)) {\n    iVar4 = iVar4 + 1;\n    *(int *)(param_1 + 0x14) = iVar4;\n  }\n  *(uint *)(param_1 + 0x1c + ((-(ulong)(uVar1 < 0x38) & 0xfffffffffffffff0) + 0x1e) * 4) = uVar5 * 8\n  ;\n  lVar7 = lVar9 - (ulong)uVar1;\n  *(uint *)(param_1 + 0x1c + ((-(ulong)(uVar1 < 0x38) & 0xfffffffffffffff0) + 0x1f) * 4) =\n       iVar4 << 3 | uVar5 >> 0x1d;\n  puVar8 = (undefined8 *)(param_1 + 0x1c + (ulong)uVar1);\n  uVar3 = lVar7 - 8;\n  if (uVar3 < 8) {\n    if ((uVar3 & 4) == 0) {\n      if ((uVar3 != 0) && (*(char *)puVar8 = (char)_DAT_00416ae0, (uVar3 & 2) != 0)) {\n        *(undefined2 *)((long)puVar8 + lVar7 + -10) = *(undefined2 *)((long)&DAT_00416ad6 + lVar7);\n      }\n    }\n    else {\n      *(undefined4 *)puVar8 = _DAT_00416ae0;\n      *(undefined4 *)((long)puVar8 + lVar7 + -0xc) = *(undefined4 *)(&DAT_00416ad4 + lVar7);\n    }\n  }\n  else {\n    *puVar8 = CONCAT44(_UNK_00416ae4,_DAT_00416ae0);\n    *(undefined8 *)((long)puVar8 + lVar7 + -0x10) = *(undefined8 *)(&DAT_00416ad0 + lVar7);\n    lVar7 = (long)puVar8 - (long)(undefined8 *)((ulong)(puVar8 + 1) & 0xfffffffffffffff8);\n    puVar6 = (undefined8 *)(&DAT_00416ae0 + -lVar7);\n    puVar8 = (undefined8 *)((ulong)(puVar8 + 1) & 0xfffffffffffffff8);\n    for (uVar3 = uVar3 + lVar7 >> 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n      *puVar8 = *puVar6;\n      puVar6 = puVar6 + 1;\n      puVar8 = puVar8 + 1;\n    }\n  }\n  FUN_0040aae0(param_1 + 0x1c,lVar9,param_1);\n  FUN_0040aac0(param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_0040b250"
        },
        {
            "funcStartAddr": "0x40b360",
            "funcEndAddr": "0x40b644",
            "decompiledFuncCode": "\nvoid FUN_0040b360(undefined8 *param_1,ulong param_2,long param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  uint uVar3;\n  ulong uVar4;\n  long lVar5;\n  uint uVar6;\n  ulong uVar7;\n  undefined8 *puVar8;\n  void *__dest;\n  uint uVar9;\n  ulong uVar10;\n  \n  if (*(uint *)(param_3 + 0x18) != 0) {\n    uVar10 = (ulong)*(uint *)(param_3 + 0x18);\n    lVar5 = param_3 + 0x1c;\n    uVar4 = 0x80 - uVar10;\n    if (param_2 < 0x80 - uVar10) {\n      uVar4 = param_2;\n    }\n    memcpy((void *)(lVar5 + uVar10),param_1,uVar4);\n    uVar9 = *(int *)(param_3 + 0x18) + (int)uVar4;\n    *(uint *)(param_3 + 0x18) = uVar9;\n    if (0x40 < uVar9) {\n      FUN_0040aae0(lVar5,uVar9 & 0xffffffc0,param_3);\n      uVar9 = *(uint *)(param_3 + 0x18);\n      puVar8 = (undefined8 *)((uVar10 + uVar4 & 0xffffffffffffffc0) + lVar5);\n      uVar3 = uVar9 & 0x3f;\n      uVar10 = (ulong)uVar3;\n      *(uint *)(param_3 + 0x18) = uVar3;\n      if (uVar3 < 8) {\n        if ((uVar9 & 4) == 0) {\n          if ((uVar3 != 0) &&\n             (*(undefined *)(param_3 + 0x1c) = *(undefined *)puVar8, (uVar9 & 2) != 0)) {\n            *(undefined2 *)(param_3 + 0x1a + uVar10) = *(undefined2 *)((long)puVar8 + (uVar10 - 2));\n          }\n        }\n        else {\n          *(undefined4 *)(param_3 + 0x1c) = *(undefined4 *)puVar8;\n          *(undefined4 *)(param_3 + 0x18 + uVar10) = *(undefined4 *)((long)puVar8 + (uVar10 - 4));\n        }\n      }\n      else {\n        *(undefined8 *)(param_3 + 0x1c) = *puVar8;\n        *(undefined8 *)(param_3 + 0x14 + uVar10) = *(undefined8 *)((long)puVar8 + (uVar10 - 8));\n        uVar10 = param_3 + 0x24U & 0xfffffffffffffff8;\n        lVar5 = lVar5 - uVar10;\n        uVar9 = (int)lVar5 + uVar3 & 0xfffffff8;\n        if (7 < uVar9) {\n          uVar7 = 0;\n          do {\n            uVar3 = (int)uVar7 + 8;\n            *(undefined8 *)(uVar10 + uVar7) = *(undefined8 *)((long)puVar8 + (uVar7 - lVar5));\n            uVar7 = (ulong)uVar3;\n          } while (uVar3 < uVar9);\n        }\n      }\n    }\n    param_1 = (undefined8 *)((long)param_1 + uVar4);\n    param_2 = param_2 - uVar4;\n  }\n  puVar8 = param_1;\n  if (0x3f < param_2) {\n    if (((ulong)param_1 & 3) != 0) {\n      if (param_2 != 0x40) {\n        uVar4 = param_2 - 0x41 >> 6;\n        do {\n          uVar2 = param_1[1];\n          puVar8 = param_1 + 8;\n          *(undefined8 *)(param_3 + 0x1c) = *param_1;\n          *(undefined8 *)(param_3 + 0x24) = uVar2;\n          uVar2 = param_1[3];\n          *(undefined8 *)(param_3 + 0x2c) = param_1[2];\n          *(undefined8 *)(param_3 + 0x34) = uVar2;\n          uVar2 = param_1[5];\n          *(undefined8 *)(param_3 + 0x3c) = param_1[4];\n          *(undefined8 *)(param_3 + 0x44) = uVar2;\n          uVar2 = param_1[7];\n          *(undefined8 *)(param_3 + 0x4c) = param_1[6];\n          *(undefined8 *)(param_3 + 0x54) = uVar2;\n          FUN_0040aae0((undefined8 *)(param_3 + 0x1c),0x40,param_3);\n          param_1 = puVar8;\n        } while (puVar8 != param_1 + (uVar4 + 1) * 8);\n        param_2 = (param_2 - 0x40) + uVar4 * -0x40;\n        puVar8 = param_1 + (uVar4 + 1) * 8;\n      }\n      goto LAB_0040b40b;\n    }\n    puVar8 = (undefined8 *)((long)param_1 + (param_2 & 0xffffffffffffffc0));\n    FUN_0040aae0(param_1,param_2 & 0xffffffffffffffc0,param_3);\n    param_2 = (ulong)((uint)param_2 & 0x3f);\n  }\n  if (param_2 == 0) {\n    return;\n  }\nLAB_0040b40b:\n  __dest = (void *)(param_3 + 0x1c);\n  uVar9 = *(uint *)(param_3 + 0x18);\n  uVar3 = (uint)param_2;\n  puVar1 = (undefined8 *)((long)__dest + (ulong)uVar9);\n  if (uVar3 < 8) {\n    if ((param_2 & 4) == 0) {\n      if ((uVar3 != 0) && (*(undefined *)puVar1 = *(undefined *)puVar8, (param_2 & 2) != 0)) {\n        *(undefined2 *)((long)puVar1 + ((param_2 & 0xffffffff) - 2)) =\n             *(undefined2 *)((long)puVar8 + ((param_2 & 0xffffffff) - 2));\n      }\n    }\n    else {\n      *(undefined4 *)puVar1 = *(undefined4 *)puVar8;\n      *(undefined4 *)((long)puVar1 + ((param_2 & 0xffffffff) - 4)) =\n           *(undefined4 *)((long)puVar8 + ((param_2 & 0xffffffff) - 4));\n    }\n  }\n  else {\n    *puVar1 = *puVar8;\n    *(undefined8 *)((long)puVar1 + ((param_2 & 0xffffffff) - 8)) =\n         *(undefined8 *)((long)puVar8 + ((param_2 & 0xffffffff) - 8));\n    lVar5 = (long)puVar1 - ((ulong)(puVar1 + 1) & 0xfffffffffffffff8);\n    uVar3 = (int)lVar5 + uVar3 & 0xfffffff8;\n    if (7 < uVar3) {\n      uVar6 = 0;\n      do {\n        uVar4 = (ulong)uVar6;\n        uVar6 = uVar6 + 8;\n        *(undefined8 *)(((ulong)(puVar1 + 1) & 0xfffffffffffffff8) + uVar4) =\n             *(undefined8 *)((long)puVar8 + (uVar4 - lVar5));\n      } while (uVar6 < uVar3);\n    }\n  }\n  param_2 = param_2 + uVar9;\n  if (0x3f < param_2) {\n    param_2 = param_2 - 0x40;\n    FUN_0040aae0(__dest,0x40,param_3);\n    memcpy(__dest,(void *)(param_3 + 0x5c),param_2);\n  }\n  *(int *)(param_3 + 0x18) = (int)param_2;\n  return;\n}\n\n",
            "funcName": "FUN_0040b360"
        },
        {
            "funcStartAddr": "0x40b660",
            "funcEndAddr": "0x40b6b5",
            "decompiledFuncCode": "\nvoid FUN_0040b660(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined4 local_90;\n  \n  local_a8 = 0xefcdab8967452301;\n  local_a0 = 0x1032547698badcfe;\n  local_98 = 0;\n  local_90 = 0;\n  FUN_0040b360(param_1,param_2,&local_a8);\n  FUN_0040b250(&local_a8,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_0040b660"
        },
        {
            "funcStartAddr": "0x40b6c0",
            "funcEndAddr": "0x40b7d6",
            "decompiledFuncCode": "\nundefined8 FUN_0040b6c0(FILE *param_1,undefined8 param_2)\n\n{\n  void *__ptr;\n  size_t sVar1;\n  long lVar2;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined4 local_b0;\n  \n  __ptr = malloc(0x8048);\n  if (__ptr == (void *)0x0) {\n    return 1;\n  }\n  local_b0 = 0;\n  local_c8 = 0xefcdab8967452301;\n  local_c0 = 0x1032547698badcfe;\n  local_b8 = 0;\n  do {\n    lVar2 = 0;\n    while( true ) {\n      sVar1 = fread_unlocked((void *)((long)__ptr + lVar2),1,0x8000 - lVar2,param_1);\n      lVar2 = lVar2 + sVar1;\n      if (lVar2 == 0x8000) break;\n      if (sVar1 == 0) {\n        if ((param_1->_flags & 0x20U) != 0) {\n          free(__ptr);\n          return 1;\n        }\n        goto LAB_0040b76f;\n      }\n      if ((param_1->_flags & 0x10U) != 0) {\nLAB_0040b76f:\n        if (lVar2 != 0) {\n          FUN_0040b360(__ptr,lVar2,&local_c8);\n        }\n        FUN_0040b250(&local_c8,param_2);\n        free(__ptr);\n        return 0;\n      }\n    }\n    FUN_0040aae0(__ptr,0x8000,&local_c8);\n  } while( true );\n}\n\n",
            "funcName": "FUN_0040b6c0"
        },
        {
            "funcStartAddr": "0x40b7f0",
            "funcEndAddr": "0x40b7f5",
            "decompiledFuncCode": "\nvoid FUN_0040b7f0(void)\n\n{\n  (*(code *)PTR_posix_fadvise_0061c1c0)();\n  return;\n}\n\n",
            "funcName": "FUN_0040b7f0"
        },
        {
            "funcStartAddr": "0x40b800",
            "funcEndAddr": "0x40b81c",
            "decompiledFuncCode": "\nvoid FUN_0040b800(FILE *param_1,int param_2)\n\n{\n  int __fd;\n  \n  if (param_1 != (FILE *)0x0) {\n    __fd = fileno(param_1);\n    posix_fadvise(__fd,0,0,param_2);\n    return;\n  }\n  return;\n}\n\n",
            "funcName": "FUN_0040b800"
        },
        {
            "funcStartAddr": "0x40b830",
            "funcEndAddr": "0x40b8d6",
            "decompiledFuncCode": "\nchar * FUN_0040b830(char **param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  char *pcVar4;\n  \n  pcVar4 = *param_1;\n  cVar3 = *pcVar4;\n  if (cVar3 == '\\0') {\n    return (char *)0x0;\n  }\n  bVar1 = false;\n  pcVar2 = (char *)0x0;\n  do {\n    if (bVar1) {\n      if ((0x39 < (int)cVar3 - 0x41U) ||\n         (bVar1 = false, (1L << ((byte)((int)cVar3 - 0x41U) & 0x3f) & 0x3ffffff03ffffffU) == 0)) {\n        bVar1 = false;\n        if (cVar3 != '~') {\n          pcVar2 = (char *)0x0;\n          bVar1 = false;\n        }\n      }\nLAB_0040b881:\n      *param_1 = pcVar4 + 1;\n      cVar3 = pcVar4[1];\n    }\n    else {\n      if (cVar3 == '.') {\n        bVar1 = true;\n        if (pcVar2 == (char *)0x0) {\n          pcVar2 = pcVar4;\n        }\n        goto LAB_0040b881;\n      }\n      if (cVar3 < '[') {\n        if (('@' < cVar3) || ((byte)(cVar3 - 0x30U) < 10)) goto LAB_0040b881;\n      }\n      else if ((byte)(cVar3 + 0x9fU) < 0x1a) goto LAB_0040b881;\n      if (cVar3 != '~') {\n        pcVar2 = (char *)0x0;\n      }\n      *param_1 = pcVar4 + 1;\n      cVar3 = pcVar4[1];\n    }\n    pcVar4 = pcVar4 + 1;\n    if (cVar3 == '\\0') {\n      return pcVar2;\n    }\n  } while( true );\n}\n\n",
            "funcName": "FUN_0040b830"
        },
        {
            "funcStartAddr": "0x40b900",
            "funcEndAddr": "0x40bce0",
            "decompiledFuncCode": "\nuint FUN_0040b900(byte *param_1,byte *param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  long lVar6;\n  size_t sVar7;\n  int iVar8;\n  long lVar9;\n  ulong uVar10;\n  ulong uVar11;\n  byte *pbVar12;\n  ulong uVar13;\n  byte bVar14;\n  byte *pbVar15;\n  uint uVar16;\n  size_t __n;\n  bool bVar17;\n  bool bVar18;\n  bool bVar19;\n  byte bVar20;\n  byte *local_48;\n  byte *local_40 [2];\n  \n  bVar20 = 0;\n  uVar3 = strcmp((char *)param_1,(char *)param_2);\n  if (uVar3 == 0) {\n    return 0;\n  }\n  bVar14 = *param_1;\n  if (bVar14 == 0) {\n    return 0xffffffff;\n  }\n  bVar1 = *param_2;\n  bVar17 = false;\n  bVar19 = bVar1 == 0;\n  if (bVar19) {\n    return 1;\n  }\n  lVar9 = 2;\n  pbVar12 = &DAT_00416b21;\n  pbVar15 = param_1;\n  do {\n    if (lVar9 == 0) break;\n    lVar9 = lVar9 + -1;\n    bVar17 = *pbVar12 < *pbVar15;\n    bVar19 = *pbVar12 == *pbVar15;\n    pbVar12 = pbVar12 + (ulong)bVar20 * -2 + 1;\n    pbVar15 = pbVar15 + (ulong)bVar20 * -2 + 1;\n  } while (bVar19);\n  bVar18 = false;\n  bVar17 = (!bVar17 && !bVar19) == bVar17;\n  if (bVar17) {\n    return 0xffffffff;\n  }\n  lVar9 = 2;\n  pbVar12 = &DAT_00416b21;\n  pbVar15 = param_2;\n  do {\n    if (lVar9 == 0) break;\n    lVar9 = lVar9 + -1;\n    bVar18 = *pbVar12 < *pbVar15;\n    bVar17 = *pbVar12 == *pbVar15;\n    pbVar12 = pbVar12 + (ulong)bVar20 * -2 + 1;\n    pbVar15 = pbVar15 + (ulong)bVar20 * -2 + 1;\n  } while (bVar17);\n  bVar19 = false;\n  bVar17 = (!bVar18 && !bVar17) == bVar18;\n  if (bVar17) {\n    return 1;\n  }\n  lVar9 = 3;\n  pbVar12 = &DAT_00416b20;\n  pbVar15 = param_1;\n  do {\n    if (lVar9 == 0) break;\n    lVar9 = lVar9 + -1;\n    bVar19 = *pbVar12 < *pbVar15;\n    bVar17 = *pbVar12 == *pbVar15;\n    pbVar12 = pbVar12 + (ulong)bVar20 * -2 + 1;\n    pbVar15 = pbVar15 + (ulong)bVar20 * -2 + 1;\n  } while (bVar17);\n  bVar18 = false;\n  bVar17 = (!bVar19 && !bVar17) == bVar19;\n  if (bVar17) {\n    return 0xffffffff;\n  }\n  lVar9 = 3;\n  pbVar12 = &DAT_00416b20;\n  pbVar15 = param_2;\n  do {\n    if (lVar9 == 0) break;\n    lVar9 = lVar9 + -1;\n    bVar18 = *pbVar12 < *pbVar15;\n    bVar17 = *pbVar12 == *pbVar15;\n    pbVar12 = pbVar12 + (ulong)bVar20 * -2 + 1;\n    pbVar15 = pbVar15 + (ulong)bVar20 * -2 + 1;\n  } while (bVar17);\n  if ((!bVar18 && !bVar17) == bVar18) {\n    return 1;\n  }\n  if ((bVar1 != 0x2e) && (bVar14 == 0x2e)) {\n    return 0xffffffff;\n  }\n  if (bVar14 == 0x2e) {\n    if ((bVar1 == 0x2e) && (bVar14 == 0x2e)) {\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    }\n  }\n  else if (bVar1 == 0x2e) {\n    return 1;\n  }\n  local_48 = param_1;\n  local_40[0] = param_2;\n  lVar9 = FUN_0040b830(&local_48);\n  lVar6 = FUN_0040b830(local_40);\n  if (lVar9 == 0) {\n    __n = (long)local_48 - (long)param_1;\n    if (lVar6 != 0) goto LAB_0040ba15;\n  }\n  else {\n    __n = lVar9 - (long)param_1;\n    if (lVar6 == 0) {\n      sVar7 = (long)local_40[0] - (long)param_2;\n    }\n    else {\nLAB_0040ba15:\n      sVar7 = lVar6 - (long)param_2;\n    }\n    if ((__n != sVar7) || (iVar5 = strncmp((char *)param_1,(char *)param_2,__n), iVar5 != 0))\n    goto LAB_0040ba24;\n    __n = (long)local_48 - (long)param_1;\n  }\n  sVar7 = (long)local_40[0] - (long)param_2;\nLAB_0040ba24:\n  uVar10 = 0;\n  uVar13 = 0;\nLAB_0040ba38:\n  if ((__n <= uVar10) && (sVar7 <= uVar13)) {\n    return uVar3;\n  }\n  lVar9 = uVar13 - uVar10;\n  uVar11 = uVar10;\n  if (__n <= uVar10) goto LAB_0040bad0;\nLAB_0040ba51:\n  bVar20 = param_1[uVar10];\n  uVar11 = uVar10;\n  if ((int)(char)bVar20 - 0x30U < 10) goto LAB_0040bad0;\n  if (bVar20 - 0x30 < 10) {\n    if (sVar7 == uVar13) goto LAB_0040bac3;\n    bVar14 = param_2[uVar13];\n    goto LAB_0040bb06;\n  }\nLAB_0040ba74:\n  uVar16 = (uint)bVar20;\n  if ((uVar16 - 0x41 < 0x3a) && ((1L << ((byte)(uVar16 - 0x41) & 0x3f) & 0x3ffffff03ffffffU) != 0))\n  {\n    uVar4 = 0;\n    if (sVar7 == uVar10 + lVar9) goto LAB_0040baba;\n  }\n  else {\n    if (bVar20 == 0x7e) {\n      uVar16 = 0xffffffff;\n    }\n    else {\n      uVar16 = uVar16 + 0x100;\n    }\n    if (sVar7 == uVar10 + lVar9) {\n      return uVar16;\n    }\n  }\n  bVar14 = param_2[uVar13];\n  uVar4 = (uint)bVar14;\n  if (9 < bVar14 - 0x30) goto LAB_0040bb15;\n  uVar4 = 0;\nLAB_0040baba:\n  do {\n    if (uVar4 != uVar16) {\n      return uVar16 - uVar4;\n    }\nLAB_0040bac3:\n    do {\n      uVar10 = uVar10 + 1;\n      uVar13 = uVar13 + 1;\n      uVar11 = uVar10;\n      if (uVar10 < __n) goto LAB_0040ba51;\nLAB_0040bad0:\n      bVar14 = param_2[uVar13];\n      if ((sVar7 <= uVar13) || ((int)(char)bVar14 - 0x30U < 10)) goto LAB_0040bb44;\n      uVar10 = uVar11;\n      if ((__n != uVar11) && (bVar20 = param_1[uVar11], 9 < bVar20 - 0x30)) goto LAB_0040ba74;\nLAB_0040bb06:\n      uVar4 = (uint)bVar14;\n      uVar16 = 0;\n    } while (uVar4 - 0x30 < 10);\nLAB_0040bb15:\n    if ((0x39 < bVar14 - 0x41) || ((1L << ((byte)(bVar14 - 0x41) & 0x3f) & 0x3ffffff03ffffffU) == 0)\n       ) {\n      if (bVar14 == 0x7e) {\n        uVar4 = 0xffffffff;\n      }\n      else {\n        uVar4 = uVar4 + 0x100;\n      }\n    }\n  } while( true );\nLAB_0040bb44:\n  for (; iVar5 = (int)(char)param_1[uVar11], uVar2 = uVar13, param_1[uVar11] == 0x30;\n      uVar11 = uVar11 + 1) {\n  }\n  while (bVar14 == 0x30) {\n    bVar14 = param_2[uVar2 + 1];\n    uVar2 = uVar2 + 1;\n  }\n  iVar8 = (int)(char)bVar14;\n  uVar10 = uVar11;\n  if (iVar5 - 0x30U < 10) {\n    if (9 < iVar8 - 0x30U) {\n      return 1;\n    }\n    uVar16 = 0;\n    while( true ) {\n      if (uVar16 == 0) {\n        uVar16 = iVar5 - iVar8;\n      }\n      uVar10 = uVar10 + 1;\n      iVar8 = (int)(char)param_2[uVar10 + (uVar2 - uVar11)];\n      uVar13 = (uVar10 - uVar11) + uVar2;\n      iVar5 = (int)(char)param_1[uVar10];\n      if (9 < iVar5 - 0x30U) break;\n      if (9 < iVar8 - 0x30U) {\n        return 1;\n      }\n    }\n    if (iVar8 - 0x30U < 10) {\n      return 0xffffffff;\n    }\n    if (uVar16 != 0) {\n      return uVar16;\n    }\n  }\n  else {\n    uVar13 = uVar2;\n    if (iVar8 - 0x30U < 10) {\n      return 0xffffffff;\n    }\n  }\n  goto LAB_0040ba38;\n}\n\n",
            "funcName": "FUN_0040b900"
        },
        {
            "funcStartAddr": "0x40bd10",
            "funcEndAddr": "0x40bd66",
            "decompiledFuncCode": "\nbool FUN_0040bd10(int param_1)\n\n{\n  bool bVar1;\n  byte *pbVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  pbVar2 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar1 = true;\n  bVar6 = false;\n  bVar8 = pbVar2 == (byte *)0x0;\n  if (!bVar8) {\n    lVar3 = 2;\n    pbVar4 = pbVar2;\n    pbVar5 = &DAT_00416a04;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar8 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n    } while (bVar8);\n    bVar1 = false;\n    bVar7 = false;\n    bVar6 = (!bVar6 && !bVar8) == bVar6;\n    if (!bVar6) {\n      lVar3 = 6;\n      pbVar4 = (byte *)\"POSIX\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar2 < *pbVar4;\n        bVar6 = *pbVar2 == *pbVar4;\n        pbVar2 = pbVar2 + (ulong)bVar9 * -2 + 1;\n        pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      } while (bVar6);\n      return (!bVar7 && !bVar6) != bVar7;\n    }\n  }\n  return bVar1;\n}\n\n",
            "funcName": "FUN_0040bd10"
        },
        {
            "funcStartAddr": "0x40bd70",
            "funcEndAddr": "0x40be01",
            "decompiledFuncCode": "\nulong FUN_0040bd70(ulong param_1)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long lVar5;\n  \n  uVar3 = 10;\n  if (9 < param_1) {\n    uVar3 = param_1;\n  }\n  uVar3 = uVar3 | 1;\n  do {\n    if (uVar3 == 0xffffffffffffffff) {\n      return 0xffffffffffffffff;\n    }\n    uVar1 = uVar3 % 3;\n    if (uVar3 < 10) {\nLAB_0040bdf0:\n      if (uVar1 != 0) {\n        return uVar3;\n      }\n    }\n    else if (uVar1 != 0) {\n      lVar5 = 0x10;\n      uVar4 = 9;\n      uVar2 = 3;\n      do {\n        uVar2 = uVar2 + 2;\n        uVar4 = uVar4 + lVar5;\n        uVar1 = uVar3 % uVar2;\n        if (uVar3 <= uVar4) goto LAB_0040bdf0;\n        lVar5 = lVar5 + 8;\n      } while (uVar1 != 0);\n    }\n    uVar3 = uVar3 + 2;\n  } while( true );\n}\n\n",
            "funcName": "FUN_0040bd70"
        },
        {
            "funcStartAddr": "0x40be10",
            "funcEndAddr": "0x40be20",
            "decompiledFuncCode": "\nulong FUN_0040be10(ulong param_1,ulong param_2)\n\n{\n  return (param_1 >> 3 | param_1 << 0x3d) % param_2;\n}\n\n",
            "funcName": "FUN_0040be10"
        },
        {
            "funcStartAddr": "0x40be20",
            "funcEndAddr": "0x40be27",
            "decompiledFuncCode": "\nbool FUN_0040be20(long param_1,long param_2)\n\n{\n  return param_1 == param_2;\n}\n\n",
            "funcName": "FUN_0040be20"
        },
        {
            "funcStartAddr": "0x40be30",
            "funcEndAddr": "0x40be51",
            "decompiledFuncCode": "\nlong FUN_0040be30(long *param_1,undefined8 param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if (uVar1 <= (ulong)param_1[2] && param_1[2] != uVar1) {\n    return uVar1 * 0x10 + *param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040be30"
        },
        {
            "funcStartAddr": "0x40be60",
            "funcEndAddr": "0x40bf65",
            "decompiledFuncCode": "\nlong FUN_0040be60(long param_1,long param_2,long **param_3,char param_4)\n\n{\n  undefined8 *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  char cVar5;\n  long *plVar6;\n  long *plVar7;\n  long lVar8;\n  \n  plVar6 = (long *)FUN_0040be30();\n  *param_3 = plVar6;\n  lVar8 = *plVar6;\n  if (lVar8 == 0) {\n    return 0;\n  }\n  if (lVar8 != param_2) {\n    cVar5 = (**(code **)(param_1 + 0x38))(param_2);\n    if (cVar5 == '\\0') {\n      plVar7 = (long *)plVar6[1];\n      if (plVar7 == (long *)0x0) {\n        return 0;\n      }\n      lVar8 = *plVar7;\n      do {\n        if (param_2 == lVar8) {\nLAB_0040beec:\n          if (param_4 == '\\0') {\n            return lVar8;\n          }\n          plVar6[1] = plVar7[1];\n          *plVar7 = 0;\n          plVar7[1] = *(long *)(param_1 + 0x48);\n          *(long **)(param_1 + 0x48) = plVar7;\n          return lVar8;\n        }\n        cVar5 = (**(code **)(param_1 + 0x38))(param_2);\n        if (cVar5 != '\\0') {\n          plVar7 = (long *)plVar6[1];\n          lVar8 = *plVar7;\n          goto LAB_0040beec;\n        }\n        plVar6 = (long *)plVar6[1];\n        plVar7 = (long *)plVar6[1];\n        if (plVar7 == (long *)0x0) {\n          return 0;\n        }\n        lVar8 = *plVar7;\n      } while( true );\n    }\n    lVar8 = *plVar6;\n  }\n  if (param_4 != '\\0') {\n    puVar1 = (undefined8 *)plVar6[1];\n    if (puVar1 != (undefined8 *)0x0) {\n      uVar2 = *(undefined4 *)((long)puVar1 + 4);\n      uVar3 = *(undefined4 *)(puVar1 + 1);\n      uVar4 = *(undefined4 *)((long)puVar1 + 0xc);\n      *(undefined4 *)plVar6 = *(undefined4 *)puVar1;\n      *(undefined4 *)((long)plVar6 + 4) = uVar2;\n      *(undefined4 *)(plVar6 + 1) = uVar3;\n      *(undefined4 *)((long)plVar6 + 0xc) = uVar4;\n      *puVar1 = 0;\n      puVar1[1] = *(undefined8 *)(param_1 + 0x48);\n      *(undefined8 **)(param_1 + 0x48) = puVar1;\n      return lVar8;\n    }\n    *plVar6 = 0;\n  }\n  return lVar8;\n}\n\n",
            "funcName": "FUN_0040be60"
        },
        {
            "funcStartAddr": "0x40bf80",
            "funcEndAddr": "0x40bffa",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_0040bf80(float **param_1)\n\n{\n  float fVar1;\n  float *pfVar2;\n  float fVar3;\n  \n  pfVar2 = *param_1;\n  if (pfVar2 == (float *)&DAT_00416ba0) {\n    return 1;\n  }\n  fVar1 = pfVar2[2];\n  if ((((_DAT_00416bb4 < fVar1) && (fVar1 < DAT_00416bb8)) && (_DAT_00416bbc < pfVar2[3])) &&\n     (_DAT_00416bc0 <= *pfVar2)) {\n    fVar3 = *pfVar2 + _DAT_00416bb4;\n    if (((fVar3 < pfVar2[1]) && (pfVar2[1] <= DAT_00416bc4)) && (fVar3 < fVar1)) {\n      return 1;\n    }\n  }\n  *param_1 = (float *)&DAT_00416ba0;\n  return 0;\n}\n\n",
            "funcName": "FUN_0040bf80"
        },
        {
            "funcStartAddr": "0x40c000",
            "funcEndAddr": "0x40c13a",
            "decompiledFuncCode": "\nundefined8 FUN_0040c000(long param_1,long **param_2,char param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  long lVar6;\n  \n  plVar5 = *param_2;\n  if (param_2[1] <= plVar5) {\n    return 1;\n  }\n  do {\n    while (lVar6 = *plVar5, lVar6 == 0) {\nLAB_0040c028:\n      plVar5 = plVar5 + 2;\n      if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n        return 1;\n      }\n    }\n    plVar3 = (long *)plVar5[1];\n    if ((long *)plVar5[1] != (long *)0x0) {\n      do {\n        while( true ) {\n          lVar6 = *plVar3;\n          plVar2 = (long *)FUN_0040be30(param_1,lVar6);\n          plVar4 = (long *)plVar3[1];\n          if (*plVar2 != 0) break;\n          *plVar2 = lVar6;\n          *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n          *plVar3 = 0;\n          plVar3[1] = *(long *)(param_1 + 0x48);\n          *(long **)(param_1 + 0x48) = plVar3;\n          plVar3 = plVar4;\n          if (plVar4 == (long *)0x0) goto LAB_0040c09f;\n        }\n        plVar3[1] = plVar2[1];\n        plVar2[1] = (long)plVar3;\n        plVar3 = plVar4;\n      } while (plVar4 != (long *)0x0);\nLAB_0040c09f:\n      lVar6 = *plVar5;\n    }\n    plVar5[1] = 0;\n    if (param_3 != '\\0') goto LAB_0040c028;\n    plVar3 = (long *)FUN_0040be30(param_1,lVar6);\n    if (*plVar3 == 0) {\n      *plVar3 = lVar6;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n    }\n    else {\n      plVar4 = *(long **)(param_1 + 0x48);\n      if (plVar4 == (long *)0x0) {\n        plVar4 = (long *)malloc(0x10);\n        if (plVar4 == (long *)0x0) {\n          return 0;\n        }\n      }\n      else {\n        *(long *)(param_1 + 0x48) = plVar4[1];\n      }\n      lVar1 = plVar3[1];\n      *plVar4 = lVar6;\n      plVar4[1] = lVar1;\n      plVar3[1] = (long)plVar4;\n    }\n    *plVar5 = 0;\n    plVar5 = plVar5 + 2;\n    param_2[3] = (long *)((long)param_2[3] + -1);\n    if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n      return 1;\n    }\n  } while( true );\n}\n\n",
            "funcName": "FUN_0040c000"
        },
        {
            "funcStartAddr": "0x40c150",
            "funcEndAddr": "0x40c155",
            "decompiledFuncCode": "\nundefined8 FUN_0040c150(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
            "funcName": "FUN_0040c150"
        },
        {
            "funcStartAddr": "0x40c160",
            "funcEndAddr": "0x40c165",
            "decompiledFuncCode": "\nundefined8 FUN_0040c160(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n",
            "funcName": "FUN_0040c160"
        },
        {
            "funcStartAddr": "0x40c170",
            "funcEndAddr": "0x40c175",
            "decompiledFuncCode": "\nundefined8 FUN_0040c170(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x20);\n}\n\n",
            "funcName": "FUN_0040c170"
        },
        {
            "funcStartAddr": "0x40c180",
            "funcEndAddr": "0x40c1cf",
            "decompiledFuncCode": "\nvoid FUN_0040c180(long **param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  plVar1 = param_1[1];\n  uVar3 = 0;\n  if (plVar1 <= plVar5) {\n    return;\n  }\n  do {\n    while (*plVar5 == 0) {\n      plVar5 = plVar5 + 2;\n      if (plVar1 <= plVar5) {\n        return;\n      }\n    }\n    uVar4 = 1;\n    for (lVar2 = plVar5[1]; lVar2 != 0; lVar2 = *(long *)(lVar2 + 8)) {\n      uVar4 = uVar4 + 1;\n    }\n    if (uVar3 < uVar4) {\n      uVar3 = uVar4;\n    }\n    plVar5 = plVar5 + 2;\n  } while (plVar5 < plVar1);\n  return;\n}\n\n",
            "funcName": "FUN_0040c180"
        },
        {
            "funcStartAddr": "0x40c1d0",
            "funcEndAddr": "0x40c232",
            "decompiledFuncCode": "\nbool FUN_0040c1d0(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar2 = *param_1;\n  plVar3 = (long *)0x0;\n  plVar4 = (long *)0x0;\n  do {\n    while( true ) {\n      if (param_1[1] <= plVar2) {\n        if (param_1[3] != plVar4) {\n          return false;\n        }\n        return param_1[4] == plVar3;\n      }\n      if (*plVar2 != 0) break;\nLAB_0040c1e8:\n      plVar2 = plVar2 + 2;\n    }\n    lVar1 = plVar2[1];\n    plVar4 = (long *)((long)plVar4 + 1);\n    plVar3 = (long *)((long)plVar3 + 1);\n    if (lVar1 == 0) goto LAB_0040c1e8;\n    do {\n      lVar1 = *(long *)(lVar1 + 8);\n      plVar3 = (long *)((long)plVar3 + 1);\n    } while (lVar1 != 0);\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n",
            "funcName": "FUN_0040c1d0"
        },
        {
            "funcStartAddr": "0x40c240",
            "funcEndAddr": "0x40c37c",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040c240(long **param_1,undefined8 param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  long *plVar6;\n  double dVar7;\n  double dVar8;\n  \n  uVar5 = 0;\n  plVar1 = param_1[2];\n  plVar2 = param_1[3];\n  for (plVar6 = *param_1; plVar6 < param_1[1]; plVar6 = plVar6 + 2) {\n    while (*plVar6 != 0) {\n      uVar4 = 1;\n      for (lVar3 = plVar6[1]; lVar3 != 0; lVar3 = *(long *)(lVar3 + 8)) {\n        uVar4 = uVar4 + 1;\n      }\n      if (uVar5 < uVar4) {\n        uVar5 = uVar4;\n      }\n      plVar6 = plVar6 + 2;\n      if (param_1[1] <= plVar6) goto LAB_0040c2ad;\n    }\n  }\nLAB_0040c2ad:\n  __fprintf_chk(param_2,1,\"# entries:         %lu\\n\",param_1[4]);\n  __fprintf_chk(param_2,1,\"# buckets:         %lu\\n\",plVar1);\n  if ((long)plVar2 < 0) {\n    dVar7 = (double)((ulong)plVar2 >> 1 | (ulong)((uint)plVar2 & 1));\n    dVar7 = dVar7 + dVar7;\n  }\n  else {\n    dVar7 = (double)(long)plVar2;\n  }\n  if ((long)plVar1 < 0) {\n    dVar8 = (double)((ulong)plVar1 >> 1 | (ulong)((uint)plVar1 & 1));\n    dVar8 = dVar8 + dVar8;\n  }\n  else {\n    dVar8 = (double)(long)plVar1;\n  }\n  __fprintf_chk((dVar7 * _DAT_00416a38) / dVar8,param_2,1,\"# buckets used:    %lu (%.2f%%)\\n\",plVar2\n               );\n  __fprintf_chk(param_2,1,\"max bucket length: %lu\\n\",uVar5);\n  return;\n}\n\n",
            "funcName": "FUN_0040c240"
        },
        {
            "funcStartAddr": "0x40c390",
            "funcEndAddr": "0x40c3db",
            "decompiledFuncCode": "\nlong FUN_0040c390(long param_1,long param_2)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)FUN_0040be30();\n  lVar3 = *plVar2;\n  if (lVar3 == 0) {\n    return 0;\n  }\n  while( true ) {\n    if (lVar3 == param_2) {\n      return param_2;\n    }\n    cVar1 = (**(code **)(param_1 + 0x38))(param_2);\n    if (cVar1 != '\\0') break;\n    plVar2 = (long *)plVar2[1];\n    if (plVar2 == (long *)0x0) {\n      return 0;\n    }\n    lVar3 = *plVar2;\n  }\n  return *plVar2;\n}\n\n",
            "funcName": "FUN_0040c390"
        },
        {
            "funcStartAddr": "0x40c3f0",
            "funcEndAddr": "0x40c42a",
            "decompiledFuncCode": "\nlong FUN_0040c3f0(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1[4] == (long *)0x0) {\n    return 0;\n  }\n  plVar2 = *param_1;\n  if (param_1[1] <= plVar2) {\n    lVar1 = FUN_00402f05();\n    return lVar1;\n  }\n  do {\n    if (*plVar2 != 0) {\n      return *plVar2;\n    }\n    plVar2 = plVar2 + 2;\n  } while (plVar2 < param_1[1]);\n  lVar1 = FUN_00402f05();\n  return lVar1;\n}\n\n",
            "funcName": "FUN_0040c3f0"
        },
        {
            "funcStartAddr": "0x40c440",
            "funcEndAddr": "0x40c499",
            "decompiledFuncCode": "\nlong FUN_0040c440(long param_1,long param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = (long *)FUN_0040be30();\n  plVar3 = plVar2;\n  do {\n    lVar1 = *plVar3;\n    plVar3 = (long *)plVar3[1];\n    if (lVar1 == param_2) {\n      if (plVar3 != (long *)0x0) {\n        return *plVar3;\n      }\n      break;\n    }\n  } while (plVar3 != (long *)0x0);\n  do {\n    plVar2 = plVar2 + 2;\n    if (*(long **)(param_1 + 8) <= plVar2) {\n      return 0;\n    }\n  } while (*plVar2 == 0);\n  return *plVar2;\n}\n\n",
            "funcName": "FUN_0040c440"
        },
        {
            "funcStartAddr": "0x40c4b0",
            "funcEndAddr": "0x40c510",
            "decompiledFuncCode": "\nulong FUN_0040c4b0(long **param_1,long param_2,ulong param_3)\n\n{\n  undefined8 *puVar1;\n  ulong uVar2;\n  long *plVar3;\n  \n  plVar3 = *param_1;\n  if (param_1[1] < plVar3 || param_1[1] == plVar3) {\n    return 0;\n  }\n  uVar2 = 0;\n  do {\n    if (*plVar3 != 0) {\n      if (param_3 <= uVar2) {\n        return uVar2;\n      }\n      *(long *)(param_2 + uVar2 * 8) = *plVar3;\n      uVar2 = uVar2 + 1;\n      for (puVar1 = (undefined8 *)plVar3[1]; puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)puVar1[1]) {\n        if (param_3 == uVar2) {\n          return param_3;\n        }\n        uVar2 = uVar2 + 1;\n        *(undefined8 *)(param_2 + -8 + uVar2 * 8) = *puVar1;\n      }\n    }\n    plVar3 = plVar3 + 2;\n  } while (plVar3 <= param_1[1] && param_1[1] != plVar3);\n  return uVar2;\n}\n\n",
            "funcName": "FUN_0040c4b0"
        },
        {
            "funcStartAddr": "0x40c520",
            "funcEndAddr": "0x40c58b",
            "decompiledFuncCode": "\nlong FUN_0040c520(long **param_1,code *param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (param_1[1] < plVar5 || param_1[1] == plVar5) {\n    lVar3 = 0;\n  }\n  else {\n    lVar3 = 0;\n    do {\n      lVar4 = *plVar5;\n      plVar2 = plVar5;\n      if (lVar4 != 0) {\n        while( true ) {\n          cVar1 = (*param_2)(lVar4,param_3);\n          if (cVar1 == '\\0') {\n            return lVar3;\n          }\n          plVar2 = (long *)plVar2[1];\n          lVar3 = lVar3 + 1;\n          if (plVar2 == (long *)0x0) break;\n          lVar4 = *plVar2;\n        }\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\n  return lVar3;\n}\n\n",
            "funcName": "FUN_0040c520"
        },
        {
            "funcStartAddr": "0x40c5a0",
            "funcEndAddr": "0x40c5d1",
            "decompiledFuncCode": "\nulong FUN_0040c5a0(byte *param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  bVar1 = *param_1;\n  while (bVar1 != 0) {\n    param_1 = param_1 + 1;\n    uVar2 = (uVar2 * 0x1f + (ulong)bVar1) % param_2;\n    bVar1 = *param_1;\n  }\n  return uVar2;\n}\n\n",
            "funcName": "FUN_0040c5a0"
        },
        {
            "funcStartAddr": "0x40c5e0",
            "funcEndAddr": "0x40c600",
            "decompiledFuncCode": "\nvoid FUN_0040c5e0(undefined8 *param_1)\n\n{\n  *(undefined *)(param_1 + 2) = 0;\n  *param_1 = 0x3f80000000000000;\n  param_1[1] = 0x3fb4fdf43f4ccccd;\n  return;\n}\n\n",
            "funcName": "FUN_0040c5e0"
        },
        {
            "funcStartAddr": "0x40c600",
            "funcEndAddr": "0x40c780",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid ** FUN_0040c600(ulong param_1,void *param_2,code *param_3,code *param_4,void *param_5)\n\n{\n  char cVar1;\n  void **__ptr;\n  void *__nmemb;\n  void *pvVar2;\n  float fVar3;\n  float fVar4;\n  \n  if (param_3 == (code *)0x0) {\n    param_3 = FUN_0040be10;\n  }\n  if (param_4 == (code *)0x0) {\n    param_4 = FUN_0040be20;\n  }\n  __ptr = (void **)malloc(0x50);\n  if (__ptr == (void **)0x0) {\n    return (void **)0x0;\n  }\n  if (param_2 == (void *)0x0) {\n    __ptr[5] = &DAT_00416ba0;\n    cVar1 = FUN_0040bf80(__ptr + 5);\n    if (cVar1 == '\\0') goto LAB_0040c6e0;\n    fVar4 = DAT_00416bc8;\n    if ((long)param_1 < 0) goto LAB_0040c763;\nLAB_0040c71e:\n    fVar3 = (float)param_1;\nLAB_0040c727:\n    fVar3 = fVar3 / fVar4;\n    if (_DAT_00416bcc <= fVar3) goto LAB_0040c6e0;\n    if (fVar3 < _DAT_00416bd0) {\n      param_1 = (ulong)fVar3;\n    }\n    else {\n      param_1 = (long)(fVar3 - _DAT_00416bd0) ^ 0x8000000000000000;\n    }\n  }\n  else {\n    __ptr[5] = param_2;\n    cVar1 = FUN_0040bf80(__ptr + 5);\n    if (cVar1 == '\\0') goto LAB_0040c6e0;\n    if (*(char *)((long)param_2 + 0x10) == '\\0') {\n      fVar4 = *(float *)((long)param_2 + 8);\n      if (-1 < (long)param_1) goto LAB_0040c71e;\nLAB_0040c763:\n      fVar3 = (float)(param_1 >> 1 | (ulong)((uint)param_1 & 1));\n      fVar3 = fVar3 + fVar3;\n      goto LAB_0040c727;\n    }\n  }\n  __nmemb = (void *)FUN_0040bd70(param_1);\n  if (((((ulong)__nmemb >> 0x3c & 1) == 0) && ((ulong)__nmemb >> 0x3d == 0)) &&\n     (__ptr[2] = __nmemb, __nmemb != (void *)0x0)) {\n    pvVar2 = calloc((size_t)__nmemb,0x10);\n    *__ptr = pvVar2;\n    if (pvVar2 != (void *)0x0) {\n      __ptr[3] = (void *)0x0;\n      __ptr[4] = (void *)0x0;\n      __ptr[1] = (void *)((long)__nmemb * 0x10 + (long)pvVar2);\n      __ptr[6] = param_3;\n      __ptr[7] = param_4;\n      __ptr[8] = param_5;\n      __ptr[9] = (void *)0x0;\n      return __ptr;\n    }\n  }\nLAB_0040c6e0:\n  free(__ptr);\n  return (void **)0x0;\n}\n\n",
            "funcName": "FUN_0040c600"
        },
        {
            "funcStartAddr": "0x40c790",
            "funcEndAddr": "0x40c835",
            "decompiledFuncCode": "\nvoid FUN_0040c790(long **param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (*param_1 < param_1[1]) {\n    do {\n      while (*plVar5 != 0) {\n        plVar4 = param_1[8];\n        plVar3 = (long *)plVar5[1];\n        while (plVar3 != (long *)0x0) {\n          if (plVar4 != (long *)0x0) {\n            (*(code *)plVar4)(*plVar3);\n            plVar4 = param_1[8];\n          }\n          plVar1 = (long *)plVar3[1];\n          plVar2 = param_1[9];\n          *plVar3 = 0;\n          plVar3[1] = (long)plVar2;\n          param_1[9] = plVar3;\n          plVar3 = plVar1;\n        }\n        if (plVar4 != (long *)0x0) {\n          (*(code *)plVar4)(*plVar5);\n        }\n        *plVar5 = 0;\n        plVar4 = plVar5 + 2;\n        plVar5[1] = 0;\n        plVar5 = plVar4;\n        if (param_1[1] < plVar4 || param_1[1] == plVar4) goto LAB_0040c823;\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\nLAB_0040c823:\n  param_1[3] = (long *)0x0;\n  param_1[4] = (long *)0x0;\n  return;\n}\n\n",
            "funcName": "FUN_0040c790"
        },
        {
            "funcStartAddr": "0x40c840",
            "funcEndAddr": "0x40c910",
            "decompiledFuncCode": "\nvoid FUN_0040c840(long **param_1)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = *param_1;\n  plVar2 = param_1[1];\n  if ((param_1[8] != (long *)0x0) && (param_1[4] != (long *)0x0)) {\n    if (plVar2 <= plVar4) goto LAB_0040c8dc;\n    do {\n      while (lVar5 = *plVar4, plVar3 = plVar4, lVar5 == 0) {\n        plVar4 = plVar4 + 2;\n        if (plVar2 <= plVar4) goto LAB_0040c89f;\n      }\n      while( true ) {\n        (*(code *)param_1[8])(lVar5);\n        plVar3 = (long *)plVar3[1];\n        if (plVar3 == (long *)0x0) break;\n        lVar5 = *plVar3;\n      }\n      plVar2 = param_1[1];\n      plVar4 = plVar4 + 2;\n    } while (plVar4 < plVar2);\nLAB_0040c89f:\n    plVar4 = *param_1;\n  }\n  if (plVar4 < plVar2) {\n    do {\n      __ptr = (void *)plVar4[1];\n      while (__ptr != (void *)0x0) {\n        pvVar1 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        __ptr = pvVar1;\n      }\n      plVar4 = plVar4 + 2;\n    } while (plVar4 <= param_1[1] && param_1[1] != plVar4);\n  }\nLAB_0040c8dc:\n  plVar4 = param_1[9];\n  while (plVar4 != (long *)0x0) {\n    plVar2 = (long *)plVar4[1];\n    free(plVar4);\n    plVar4 = plVar2;\n  }\n  free(*param_1);\n  free(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_0040c840"
        },
        {
            "funcStartAddr": "0x40c920",
            "funcEndAddr": "0x40cb0b",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUN_0040c920(void **param_1,ulong param_2)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  float fVar3;\n  void *local_68;\n  void *local_60;\n  void *local_58;\n  void *local_50;\n  undefined8 local_48;\n  void *local_40;\n  void *local_38;\n  void *local_30;\n  void *local_28;\n  void *local_20;\n  \n  local_40 = param_1[5];\n  if (*(char *)((long)local_40 + 0x10) == '\\0') {\n    if ((long)param_2 < 0) {\n      fVar3 = (float)(param_2 >> 1 | (ulong)((uint)param_2 & 1));\n      fVar3 = fVar3 + fVar3;\n    }\n    else {\n      fVar3 = (float)param_2;\n    }\n    fVar3 = fVar3 / *(float *)((long)local_40 + 8);\n    if (_DAT_00416bcc <= fVar3) {\n      return 0;\n    }\n    if (fVar3 < _DAT_00416bd0) {\n      param_2 = (ulong)fVar3;\n    }\n    else {\n      param_2 = (long)(fVar3 - _DAT_00416bd0) ^ 0x8000000000000000;\n    }\n  }\n  local_58 = (void *)FUN_0040bd70(param_2);\n  if ((local_58 != (void *)0x0) && (-1 < (long)local_58 * 8 && (ulong)local_58 >> 0x3d == 0)) {\n    if (param_1[2] == local_58) {\n      return 1;\n    }\n    local_68 = calloc((size_t)local_58,0x10);\n    if (local_68 != (void *)0x0) {\n      local_60 = (void *)((long)local_58 * 0x10 + (long)local_68);\n      local_38 = param_1[6];\n      local_50 = (void *)0x0;\n      local_30 = param_1[7];\n      local_48 = 0;\n      local_28 = param_1[8];\n      local_20 = param_1[9];\n      uVar2 = FUN_0040c000(&local_68,param_1,0);\n      if ((char)uVar2 != '\\0') {\n        free(*param_1);\n        *param_1 = local_68;\n        param_1[1] = local_60;\n        param_1[2] = local_58;\n        param_1[3] = local_50;\n        param_1[9] = local_20;\n        return uVar2;\n      }\n      param_1[9] = local_20;\n      cVar1 = FUN_0040c000(param_1,&local_68,1);\n      if ((cVar1 != '\\0') && (cVar1 = FUN_0040c000(param_1,&local_68,0), cVar1 != '\\0')) {\n        free(local_68);\n        return uVar2;\n      }\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n  }\n  return 0;\n}\n\n",
            "funcName": "FUN_0040c920"
        },
        {
            "funcStartAddr": "0x40cb20",
            "funcEndAddr": "0x40cd71",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_0040cb20(long param_1,long param_2,long *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  long *plVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  float fVar7;\n  float fVar8;\n  long *local_20;\n  \n  if (param_2 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  lVar2 = FUN_0040be60(param_1,param_2,&local_20,0);\n  if (lVar2 != 0) {\n    if (param_3 != (long *)0x0) {\n      *param_3 = lVar2;\n    }\n    return 0;\n  }\n  uVar6 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar6 < 0) {\n    uVar3 = *(ulong *)(param_1 + 0x10);\n    fVar7 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n    lVar2 = *(long *)(param_1 + 0x28);\n    fVar7 = fVar7 + fVar7;\n    if ((long)uVar3 < 0) goto LAB_0040cc1a;\nLAB_0040cb8b:\n    if (fVar7 <= (float)uVar3 * *(float *)(lVar2 + 8)) goto LAB_0040cba2;\n  }\n  else {\n    lVar2 = *(long *)(param_1 + 0x28);\n    fVar7 = (float)uVar6;\n    uVar3 = *(ulong *)(param_1 + 0x10);\n    if (-1 < (long)uVar3) goto LAB_0040cb8b;\nLAB_0040cc1a:\n    fVar8 = (float)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    if (fVar7 <= (fVar8 + fVar8) * *(float *)(lVar2 + 8)) goto LAB_0040cba2;\n  }\n  FUN_0040bf80(param_1 + 0x28);\n  lVar2 = *(long *)(param_1 + 0x28);\n  uVar6 = *(ulong *)(param_1 + 0x10);\n  if ((long)uVar6 < 0) {\n    fVar7 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n    fVar7 = fVar7 + fVar7;\n  }\n  else {\n    fVar7 = (float)uVar6;\n  }\n  uVar6 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar6 < 0) {\n    fVar8 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n    fVar8 = fVar8 + fVar8;\n  }\n  else {\n    fVar8 = (float)uVar6;\n  }\n  if (*(float *)(lVar2 + 8) * fVar7 < fVar8) {\n    fVar7 = fVar7 * *(float *)(lVar2 + 0xc);\n    if (*(char *)(lVar2 + 0x10) == '\\0') {\n      fVar7 = fVar7 * *(float *)(lVar2 + 8);\n    }\n    if (_DAT_00416bcc <= fVar7) {\n      return 0xffffffff;\n    }\n    if (_DAT_00416bd0 <= fVar7) {\n      uVar6 = (long)(fVar7 - _DAT_00416bd0) ^ 0x8000000000000000;\n    }\n    else {\n      uVar6 = (ulong)fVar7;\n    }\n    cVar1 = FUN_0040c920(param_1,uVar6);\n    if (cVar1 == '\\0') {\n      return 0xffffffff;\n    }\n    lVar2 = FUN_0040be60(param_1,param_2,&local_20,0);\n    if (lVar2 != 0) {\n      uVar5 = FUN_00402f0f();\n      return uVar5;\n    }\n  }\nLAB_0040cba2:\n  if (*local_20 == 0) {\n    *local_20 = param_2;\n    *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n    *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n    return 1;\n  }\n  plVar4 = *(long **)(param_1 + 0x48);\n  if (plVar4 == (long *)0x0) {\n    plVar4 = (long *)malloc(0x10);\n    if (plVar4 == (long *)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    *(long *)(param_1 + 0x48) = plVar4[1];\n  }\n  lVar2 = local_20[1];\n  *plVar4 = param_2;\n  plVar4[1] = lVar2;\n  local_20[1] = (long)plVar4;\n  *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n  return 1;\n}\n\n",
            "funcName": "FUN_0040cb20"
        },
        {
            "funcStartAddr": "0x40cda0",
            "funcEndAddr": "0x40cdd4",
            "decompiledFuncCode": "\nundefined8 FUN_0040cda0(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 local_10;\n  \n  iVar1 = FUN_0040cb20(param_1,param_2,&local_10);\n  if (iVar1 != -1) {\n    if (iVar1 == 0) {\n      param_2 = local_10;\n    }\n    return param_2;\n  }\n  return 0;\n}\n\n",
            "funcName": "FUN_0040cda0"
        },
        {
            "funcStartAddr": "0x40cde0",
            "funcEndAddr": "0x40cf9f",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_0040cde0(long param_1,undefined8 param_2)\n\n{\n  float *pfVar1;\n  ulong uVar2;\n  void *pvVar3;\n  void *__ptr;\n  char cVar4;\n  long lVar5;\n  ulong uVar6;\n  float fVar7;\n  float fVar8;\n  long *local_20;\n  \n  lVar5 = FUN_0040be60(param_1,param_2,&local_20,1);\n  if (lVar5 == 0) {\n    return 0;\n  }\n  *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + -1;\n  if (*local_20 == 0) {\n    uVar6 = *(long *)(param_1 + 0x18) - 1;\n    *(ulong *)(param_1 + 0x18) = uVar6;\n    if ((long)uVar6 < 0) {\n      uVar2 = *(ulong *)(param_1 + 0x10);\n      fVar7 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n      pfVar1 = *(float **)(param_1 + 0x28);\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      pfVar1 = *(float **)(param_1 + 0x28);\n      fVar7 = (float)uVar6;\n      uVar2 = *(ulong *)(param_1 + 0x10);\n    }\n    if ((long)uVar2 < 0) {\n      fVar8 = (float)(uVar2 >> 1 | (ulong)((uint)uVar2 & 1));\n      fVar8 = fVar8 + fVar8;\n    }\n    else {\n      fVar8 = (float)uVar2;\n    }\n    if (fVar7 < fVar8 * *pfVar1) {\n      FUN_0040bf80(param_1 + 0x28);\n      uVar6 = *(ulong *)(param_1 + 0x10);\n      pfVar1 = *(float **)(param_1 + 0x28);\n      if ((long)uVar6 < 0) {\n        fVar7 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n        fVar7 = fVar7 + fVar7;\n      }\n      else {\n        fVar7 = (float)uVar6;\n      }\n      uVar6 = *(ulong *)(param_1 + 0x18);\n      if ((long)uVar6 < 0) {\n        fVar8 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n        fVar8 = fVar8 + fVar8;\n      }\n      else {\n        fVar8 = (float)uVar6;\n      }\n      if (fVar8 < *pfVar1 * fVar7) {\n        fVar7 = fVar7 * pfVar1[1];\n        if (*(char *)(pfVar1 + 4) == '\\0') {\n          fVar7 = fVar7 * pfVar1[2];\n        }\n        if (_DAT_00416bd0 <= fVar7) {\n          uVar6 = (long)(fVar7 - _DAT_00416bd0) ^ 0x8000000000000000;\n        }\n        else {\n          uVar6 = (ulong)fVar7;\n        }\n        cVar4 = FUN_0040c920(param_1,uVar6);\n        if (cVar4 == '\\0') {\n          __ptr = *(void **)(param_1 + 0x48);\n          while (__ptr != (void *)0x0) {\n            pvVar3 = *(void **)((long)__ptr + 8);\n            free(__ptr);\n            __ptr = pvVar3;\n          }\n          *(undefined8 *)(param_1 + 0x48) = 0;\n        }\n      }\n    }\n    return lVar5;\n  }\n  return lVar5;\n}\n\n",
            "funcName": "FUN_0040cde0"
        },
        {
            "funcStartAddr": "0x40cfc0",
            "funcEndAddr": "0x40cfc3",
            "decompiledFuncCode": "\nundefined8 FUN_0040cfc0(void)\n\n{\n  return 0;\n}\n\n",
            "funcName": "FUN_0040cfc0"
        },
        {
            "funcStartAddr": "0x40cfd0",
            "funcEndAddr": "0x40d049",
            "decompiledFuncCode": "\nundefined8 * FUN_0040cfd0(code *param_1,ulong param_2)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  \n  puVar1 = (undefined8 *)FUN_00411210(0x20);\n  if (param_2 == 0) {\n    lVar3 = 8;\n    param_2 = 1;\n  }\n  else {\n    lVar3 = param_2 << 3;\n    if ((lVar3 < 0) || (param_2 >> 0x3d != 0)) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00411460();\n    }\n  }\n  puVar2 = (undefined8 *)FUN_00411210(lVar3);\n  puVar1[1] = param_2;\n  *puVar2 = 0;\n  *puVar1 = puVar2;\n  if (param_1 == (code *)0x0) {\n    param_1 = FUN_0040cfc0;\n  }\n  puVar1[2] = 0;\n  puVar1[3] = param_1;\n  return puVar1;\n}\n\n",
            "funcName": "FUN_0040cfd0"
        },
        {
            "funcStartAddr": "0x40d050",
            "funcEndAddr": "0x40d065",
            "decompiledFuncCode": "\nvoid FUN_0040d050(void **param_1)\n\n{\n  free(*param_1);\n  free(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_0040d050"
        },
        {
            "funcStartAddr": "0x40d070",
            "funcEndAddr": "0x40d171",
            "decompiledFuncCode": "\nundefined8 FUN_0040d070(long *param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  undefined8 uVar3;\n  int iVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  ulong uVar7;\n  ulong uVar8;\n  long lVar9;\n  \n  uVar7 = param_1[1];\n  uVar8 = param_1[2];\n  lVar5 = *param_1;\n  if (uVar7 - 1 <= uVar8) {\n    if (lVar5 == 0) {\n      if (uVar7 == 0) {\n        lVar9 = 0x80;\n        uVar7 = 0x10;\n      }\n      else {\n        lVar9 = uVar7 << 3;\n        if ((lVar9 < 0) || (uVar7 >> 0x3d != 0)) goto LAB_0040d16f;\n      }\n    }\n    else {\n      if (0xaaaaaaaaaaaaaa9 < uVar7) {\nLAB_0040d16f:\n                    /* WARNING: Subroutine does not return */\n        FUN_00411460();\n      }\n      uVar7 = uVar7 + 1 + (uVar7 >> 1);\n      lVar9 = uVar7 * 8;\n    }\n    param_1[1] = uVar7;\n    lVar5 = FUN_00411270(lVar5,lVar9);\n    uVar8 = param_1[2];\n    *param_1 = lVar5;\n  }\n  uVar8 = uVar8 + 1;\n  param_1[2] = uVar8;\n  *(undefined8 *)(lVar5 + uVar8 * 8) = param_2;\n  pcVar2 = (code *)param_1[3];\n  lVar5 = *param_1;\n  uVar3 = *(undefined8 *)(lVar5 + uVar8 * 8);\n  while (uVar8 != 1) {\n    puVar1 = (undefined8 *)(lVar5 + (uVar8 >> 1) * 8);\n    iVar4 = (*pcVar2)(*puVar1,uVar3);\n    puVar6 = (undefined8 *)(lVar5 + uVar8 * 8);\n    if (0 < iVar4) goto LAB_0040d0ee;\n    *puVar6 = *puVar1;\n    uVar8 = uVar8 >> 1;\n  }\n  puVar6 = (undefined8 *)(lVar5 + 8);\nLAB_0040d0ee:\n  *puVar6 = uVar3;\n  return 0;\n}\n\n",
            "funcName": "FUN_0040d070"
        },
        {
            "funcStartAddr": "0x40d190",
            "funcEndAddr": "0x40d29c",
            "decompiledFuncCode": "\nundefined8 FUN_0040d190(long *param_1)\n\n{\n  ulong uVar1;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  ulong uVar9;\n  ulong uVar10;\n  undefined8 local_60;\n  \n  lVar2 = param_1[2];\n  local_60 = 0;\n  if (lVar2 != 0) {\n    lVar3 = *param_1;\n    uVar1 = lVar2 - 1;\n    uVar4 = *(undefined8 *)(lVar3 + lVar2 * 8);\n    local_60 = *(undefined8 *)(lVar3 + 8);\n    param_1[2] = uVar1;\n    *(undefined8 *)(lVar3 + 8) = uVar4;\n    lVar2 = *param_1;\n    pcVar5 = (code *)param_1[3];\n    uVar4 = *(undefined8 *)(lVar2 + 8);\n    if (uVar1 >> 1 == 0) {\n      puVar7 = (undefined8 *)(lVar2 + 8);\nLAB_0040d280:\n      *puVar7 = uVar4;\n    }\n    else {\n      uVar10 = 1;\n      do {\n        uVar9 = uVar10 * 2;\n        if (uVar9 < uVar1) {\n          puVar7 = (undefined8 *)(lVar2 + (uVar9 + 1) * 8);\n          puVar8 = (undefined8 *)(uVar10 * 0x10 + lVar2);\n          iVar6 = (*pcVar5)(*puVar8,*puVar7);\n          if (iVar6 < 0) {\n            puVar8 = puVar7;\n            uVar9 = uVar9 + 1;\n          }\n        }\n        else {\n          puVar8 = (undefined8 *)(uVar10 * 0x10 + lVar2);\n        }\n        iVar6 = (*pcVar5)(*puVar8,uVar4);\n        puVar7 = (undefined8 *)(lVar2 + uVar10 * 8);\n        if (iVar6 < 1) goto LAB_0040d280;\n        *puVar7 = *puVar8;\n        uVar10 = uVar9;\n      } while (uVar9 <= uVar1 >> 1);\n      *puVar8 = uVar4;\n    }\n  }\n  return local_60;\n}\n\n",
            "funcName": "FUN_0040d190"
        },
        {
            "funcStartAddr": "0x40d2b0",
            "funcEndAddr": "0x40d326",
            "decompiledFuncCode": "\nchar * FUN_0040d2b0(uint param_1,long param_2)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar2 = (char *)(param_2 + 0xb);\n  *(undefined *)(param_2 + 0xb) = 0;\n  if ((int)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (int)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      pcVar2 = pcVar3 + -1;\n      param_1 = uVar1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = (uint)((ulong)param_1 / 10);\n    *pcVar2 = (char)param_1 + (char)((ulong)param_1 / 10) * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_0040d2b0"
        },
        {
            "funcStartAddr": "0x40d330",
            "funcEndAddr": "0x40d368",
            "decompiledFuncCode": "\nchar * FUN_0040d330(uint param_1,long param_2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)(param_2 + 10);\n  *(undefined *)(param_2 + 10) = 0;\n  do {\n    pcVar2 = pcVar2 + -1;\n    *pcVar2 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_0040d330"
        },
        {
            "funcStartAddr": "0x40d370",
            "funcEndAddr": "0x40d3b4",
            "decompiledFuncCode": "\nchar * FUN_0040d370(ulong param_1,long param_2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)(param_2 + 0x14);\n  *(undefined *)(param_2 + 0x14) = 0;\n  do {\n    pcVar2 = pcVar2 + -1;\n    *pcVar2 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_0040d370"
        },
        {
            "funcStartAddr": "0x40d3c0",
            "funcEndAddr": "0x40d554",
            "decompiledFuncCode": "\nint FUN_0040d3c0(byte *param_1,long param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  ushort **ppuVar6;\n  byte *pbVar7;\n  int iVar8;\n  wchar_t local_44;\n  mbstate_t local_40 [2];\n  \n  pbVar1 = param_1 + param_2;\n  sVar4 = __ctype_get_mb_cur_max();\n  if (sVar4 < 2) {\n    iVar8 = 0;\n    if (param_1 < pbVar1) {\n      ppuVar6 = __ctype_b_loc();\n      iVar8 = 0;\n      do {\n        pbVar7 = param_1 + 1;\n        if (((*ppuVar6)[*param_1] & 0x4000) == 0) {\n          if ((param_3 & 2) != 0) {\n            return -1;\n          }\n          if (((*ppuVar6)[*param_1] & 2) == 0) goto LAB_0040d53a;\n        }\n        else {\nLAB_0040d53a:\n          if (iVar8 == 0x7fffffff) {\n            return 0x7fffffff;\n          }\n          iVar8 = iVar8 + 1;\n        }\n        param_1 = pbVar7;\n      } while (pbVar1 != pbVar7);\n    }\n  }\n  else {\n    iVar8 = 0;\n    if (param_1 < pbVar1) {\n      do {\n        bVar2 = *param_1;\n        if ((char)bVar2 < '@') {\n          if (((char)bVar2 < '%') && (3 < (byte)(bVar2 - 0x20))) goto LAB_0040d432;\nLAB_0040d40b:\n          param_1 = param_1 + 1;\n          iVar8 = iVar8 + 1;\n        }\n        else {\n          if (('@' < (char)bVar2) && (((char)bVar2 < '`' || ((byte)(bVar2 + 0x9f) < 0x1e))))\n          goto LAB_0040d40b;\nLAB_0040d432:\n          local_40[0] = (mbstate_t)0x0;\n          do {\n            lVar5 = FUN_00412fb0(&local_44,param_1,(long)pbVar1 - (long)param_1,local_40);\n            if (lVar5 == -1) {\n              if ((param_3 & 1) != 0) {\n                return -1;\n              }\n              goto LAB_0040d40b;\n            }\n            if (lVar5 == -2) {\n              if ((param_3 & 1) != 0) {\n                return -1;\n              }\n              iVar8 = iVar8 + 1;\n              param_1 = pbVar1;\n              break;\n            }\n            if (lVar5 == 0) {\n              lVar5 = 1;\n            }\n            iVar3 = wcwidth(local_44);\n            if (iVar3 < 0) {\n              if ((param_3 & 2) != 0) {\n                return -1;\n              }\n              iVar3 = iswcntrl(local_44);\n              if (iVar3 == 0) {\n                if (iVar8 == 0x7fffffff) {\n                  return 0x7fffffff;\n                }\n                iVar8 = iVar8 + 1;\n              }\n            }\n            else {\n              if (0x7fffffff - iVar8 < iVar3) {\n                return 0x7fffffff;\n              }\n              iVar8 = iVar8 + iVar3;\n            }\n            param_1 = param_1 + lVar5;\n            iVar3 = mbsinit(local_40);\n          } while (iVar3 == 0);\n        }\n      } while (param_1 < pbVar1);\n    }\n  }\n  return iVar8;\n}\n\n",
            "funcName": "FUN_0040d3c0"
        },
        {
            "funcStartAddr": "0x40d580",
            "funcEndAddr": "0x40d5a3",
            "decompiledFuncCode": "\nvoid FUN_0040d580(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  FUN_0040d3c0(param_1,sVar1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_0040d580"
        },
        {
            "funcStartAddr": "0x40d5b0",
            "funcEndAddr": "0x40d5f0",
            "decompiledFuncCode": "\nlong FUN_0040d5b0(void)\n\n{\n  int iVar1;\n  cpu_set_t cStack_88;\n  \n  iVar1 = sched_getaffinity(0,0x80,&cStack_88);\n  if (iVar1 == 0) {\n    iVar1 = __sched_cpucount(0x80,&cStack_88);\n    if ((long)iVar1 != 0) {\n      return (long)iVar1;\n    }\n  }\n  return 0;\n}\n\n",
            "funcName": "FUN_0040d5b0"
        },
        {
            "funcStartAddr": "0x40d600",
            "funcEndAddr": "0x40d6e0",
            "decompiledFuncCode": "\nulong FUN_0040d600(byte *param_1)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  ulong uVar3;\n  byte bVar4;\n  byte *local_10 [2];\n  \n  bVar4 = *param_1;\n  if (bVar4 == 0) {\n    return 0;\n  }\n  uVar2 = (uint)(char)bVar4;\n  if (uVar2 < 0x21) {\n    uVar3 = 0x100003e00U >> ((ulong)bVar4 & 0x3f) & 1;\n    while (uVar3 != 0) {\n      param_1 = param_1 + 1;\n      bVar4 = *param_1;\n      if (bVar4 == 0) {\n        return 0;\n      }\n      uVar2 = (uint)(char)bVar4;\n      if (0x20 < uVar2) break;\n      uVar3 = 1L << (bVar4 & 0x3f) & 0x100003e00;\n    }\n  }\n  if (9 < uVar2 - 0x30) {\n    return 0;\n  }\n  local_10[0] = (byte *)0x0;\n  uVar3 = strtoul((char *)param_1,(char **)local_10,10);\n  if (local_10[0] != (byte *)0x0) {\n    bVar4 = *local_10[0];\n    if (bVar4 == 0) {\n      return uVar3;\n    }\n    if (bVar4 < 0x21) {\n      uVar1 = 0x100003e00U >> ((ulong)bVar4 & 0x3f) & 1;\n      while (uVar1 != 0) {\n        local_10[0] = local_10[0] + 1;\n        bVar4 = *local_10[0];\n        if (bVar4 == 0) {\n          return uVar3;\n        }\n        if (0x20 < bVar4) break;\n        uVar1 = 1L << (bVar4 & 0x3f) & 0x100003e00;\n      }\n    }\n    if (bVar4 == 0x2c) {\n      return uVar3;\n    }\n  }\n  return 0;\n}\n\n",
            "funcName": "FUN_0040d600"
        },
        {
            "funcStartAddr": "0x40d6f0",
            "funcEndAddr": "0x40d81d",
            "decompiledFuncCode": "\nulong FUN_0040d6f0(int param_1)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  if (param_1 == 2) {\n    pcVar2 = getenv(\"OMP_NUM_THREADS\");\n    if (pcVar2 != (char *)0x0) {\n      uVar1 = 0xffffffffffffffff;\n      uVar3 = FUN_0040d600(pcVar2);\n      pcVar2 = getenv(\"OMP_THREAD_LIMIT\");\n      if ((pcVar2 != (char *)0x0) && (uVar1 = FUN_0040d600(pcVar2), uVar1 == 0)) {\n        uVar1 = 0xffffffffffffffff;\n      }\n      if (uVar3 != 0) {\n        if (uVar1 <= uVar3) {\n          uVar3 = uVar1;\n        }\n        return uVar3;\n      }\n      goto LAB_0040d782;\n    }\n    pcVar2 = getenv(\"OMP_THREAD_LIMIT\");\n    if ((pcVar2 != (char *)0x0) && (uVar1 = FUN_0040d600(pcVar2), uVar1 != 0)) goto LAB_0040d782;\n  }\n  else if (param_1 != 1) {\n    uVar1 = sysconf(0x53);\n    if ((uVar1 == 1) && (uVar1 = FUN_0040d5b0(), uVar1 == 0)) {\n      return 1;\n    }\n    if (0 < (long)uVar1) {\n      return uVar1;\n    }\n    return 1;\n  }\n  uVar1 = 0xffffffffffffffff;\nLAB_0040d782:\n  uVar3 = FUN_0040d5b0();\n  if (uVar3 == 0) {\n    uVar4 = sysconf(0x54);\n    uVar3 = 1;\n    if ((0 < (long)uVar4) && (uVar3 = uVar1, uVar4 <= uVar1)) {\n      uVar3 = uVar4;\n    }\n    return uVar3;\n  }\n  if (uVar1 < uVar3) {\n    uVar3 = uVar1;\n  }\n  return uVar3;\n}\n\n",
            "funcName": "FUN_0040d6f0"
        },
        {
            "funcStartAddr": "0x40d840",
            "funcEndAddr": "0x40d8ee",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\ndouble FUN_0040d840(void)\n\n{\n  int iVar1;\n  long lVar2;\n  double dVar3;\n  double dVar4;\n  sysinfo local_78;\n  \n  lVar2 = sysconf(0x55);\n  dVar3 = (double)lVar2;\n  lVar2 = sysconf(0x1e);\n  if ((dVar3 < 0.0) || (dVar4 = (double)lVar2, dVar4 < 0.0)) {\n    iVar1 = sysinfo(&local_78);\n    if (iVar1 != 0) {\n      return _DAT_00416bf8;\n    }\n    if ((long)local_78.totalram < 0) {\n      dVar3 = (double)(local_78.totalram >> 1 | (ulong)((uint)local_78.totalram & 1));\n      dVar3 = dVar3 + dVar3;\n    }\n    else {\n      dVar3 = (double)local_78.totalram;\n    }\n    dVar4 = (double)(ulong)local_78.mem_unit;\n  }\n  return dVar3 * dVar4;\n}\n\n",
            "funcName": "FUN_0040d840"
        },
        {
            "funcStartAddr": "0x40d900",
            "funcEndAddr": "0x40d9ed",
            "decompiledFuncCode": "\ndouble FUN_0040d900(void)\n\n{\n  int iVar1;\n  long lVar2;\n  double dVar3;\n  double dVar4;\n  sysinfo local_78;\n  \n  lVar2 = sysconf(0x56);\n  dVar3 = (double)lVar2;\n  lVar2 = sysconf(0x1e);\n  if ((0.0 <= dVar3) && (dVar4 = (double)lVar2, 0.0 <= dVar4)) goto LAB_0040d98e;\n  iVar1 = sysinfo(&local_78);\n  if (iVar1 != 0) {\n    dVar3 = (double)FUN_0040d840();\n    return dVar3 * DAT_00416a30;\n  }\n  if ((long)local_78.freeram < 0) {\n    dVar3 = (double)(local_78.freeram >> 1 | (ulong)((uint)local_78.freeram & 1));\n    dVar3 = dVar3 + dVar3;\n    if ((long)local_78.bufferram < 0) goto LAB_0040d9db;\nLAB_0040d974:\n    dVar4 = (double)local_78.bufferram;\n  }\n  else {\n    dVar3 = (double)local_78.freeram;\n    if (-1 < (long)local_78.bufferram) goto LAB_0040d974;\nLAB_0040d9db:\n    dVar4 = (double)(local_78.bufferram >> 1 | (ulong)((uint)local_78.bufferram & 1));\n    dVar4 = dVar4 + dVar4;\n  }\n  dVar3 = dVar3 + dVar4;\n  dVar4 = (double)(ulong)local_78.mem_unit;\nLAB_0040d98e:\n  return dVar3 * dVar4;\n}\n\n",
            "funcName": "FUN_0040d900"
        },
        {
            "funcStartAddr": "0x40da00",
            "funcEndAddr": "0x40dbb8",
            "decompiledFuncCode": "\nint FUN_0040da00(undefined8 *param_1,uint param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  uint uVar3;\n  int *piVar4;\n  \n  uVar1 = *param_1;\n  if (-1 < DAT_0061cbc0) {\n    iVar2 = pipe2((int *)param_1,param_2);\n    if ((-1 < iVar2) || (piVar4 = __errno_location(), *piVar4 != 0x26)) {\n      DAT_0061cbc0 = 1;\n      return iVar2;\n    }\n    DAT_0061cbc0 = -1;\n  }\n  if ((param_2 & 0xfff7f7ff) == 0) {\n    iVar2 = pipe((int *)param_1);\n    if (-1 < iVar2) {\n      if (((param_2 & 0x800) == 0) ||\n         ((((uVar3 = FUN_00412000(*(undefined4 *)((long)param_1 + 4),3,0), -1 < (int)uVar3 &&\n            (iVar2 = FUN_00412000(*(undefined4 *)((long)param_1 + 4),4,uVar3 | 0x800), iVar2 != -1))\n           && (uVar3 = FUN_00412000(*(undefined4 *)param_1,3,0), -1 < (int)uVar3)) &&\n          (iVar2 = FUN_00412000(*(undefined4 *)param_1,4,uVar3 | 0x800), iVar2 != -1)))) {\n        if ((param_2 & 0x80000) == 0) {\n          return 0;\n        }\n        uVar3 = FUN_00412000(*(undefined4 *)((long)param_1 + 4),1,0);\n        if (((-1 < (int)uVar3) &&\n            (iVar2 = FUN_00412000(*(undefined4 *)((long)param_1 + 4),2,uVar3 | 1), iVar2 != -1)) &&\n           ((uVar3 = FUN_00412000(*(undefined4 *)param_1,1,0), -1 < (int)uVar3 &&\n            (iVar2 = FUN_00412000(*(undefined4 *)param_1,2,uVar3 | 1), iVar2 != -1)))) {\n          return 0;\n        }\n      }\n      piVar4 = __errno_location();\n      iVar2 = *piVar4;\n      close(*(int *)param_1);\n      close(*(int *)((long)param_1 + 4));\n      *param_1 = uVar1;\n      *piVar4 = iVar2;\n    }\n  }\n  else {\n    piVar4 = __errno_location();\n    *piVar4 = 0x16;\n  }\n  return -1;\n}\n\n",
            "funcName": "FUN_0040da00"
        },
        {
            "funcStartAddr": "0x40dbe0",
            "funcEndAddr": "0x40dc48",
            "decompiledFuncCode": "\nulong FUN_0040dbe0(void)\n\n{\n  char *__nptr;\n  ulong uVar1;\n  ulong uVar2;\n  char *local_10;\n  \n  uVar2 = 0x31069;\n  __nptr = getenv(\"_POSIX2_VERSION\");\n  if ((__nptr != (char *)0x0) && (*__nptr != '\\0')) {\n    uVar1 = strtol(__nptr,&local_10,10);\n    if (*local_10 == '\\0') {\n      if (-0x80000001 < (long)uVar1) {\n        uVar2 = 0x7fffffff;\n        if ((long)uVar1 < 0x80000000) {\n          uVar2 = uVar1;\n        }\n        return uVar2 & 0xffffffff;\n      }\n      uVar2 = 0x80000000;\n    }\n  }\n  return uVar2;\n}\n\n",
            "funcName": "FUN_0040dbe0"
        },
        {
            "funcStartAddr": "0x40dc60",
            "funcEndAddr": "0x40dcf9",
            "decompiledFuncCode": "\nvoid FUN_0040dc60(byte *param_1)\n\n{\n  byte *pbVar1;\n  char *pcVar2;\n  long lVar3;\n  ulong uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  \n  bVar10 = 0;\n  if (param_1 == (byte *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr((char *)param_1,0x2f);\n  if (pcVar2 != (char *)0x0) {\n    pbVar1 = (byte *)(pcVar2 + 1);\n    uVar4 = (long)pbVar1 - (long)param_1;\n    bVar7 = uVar4 < 6;\n    bVar9 = uVar4 == 6;\n    if (6 < (long)uVar4) {\n      lVar3 = 7;\n      pbVar5 = (byte *)(pcVar2 + -6);\n      pbVar6 = (byte *)\"/.libs/\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar9 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      bVar8 = false;\n      bVar7 = (!bVar7 && !bVar9) == bVar7;\n      if (bVar7) {\n        lVar3 = 3;\n        pbVar5 = pbVar1;\n        pbVar6 = &DAT_00416c50;\n        do {\n          if (lVar3 == 0) break;\n          lVar3 = lVar3 + -1;\n          bVar8 = *pbVar5 < *pbVar6;\n          bVar7 = *pbVar5 == *pbVar6;\n          pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n          pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        } while (bVar7);\n        param_1 = pbVar1;\n        if ((!bVar8 && !bVar7) == bVar8) {\n          param_1 = (byte *)(pcVar2 + 4);\n          program_invocation_short_name = param_1;\n        }\n      }\n    }\n  }\n  DAT_0061cbc8 = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_0040dc60"
        },
        {
            "funcStartAddr": "0x40dd00",
            "funcEndAddr": "0x40dddf",
            "decompiledFuncCode": "\nchar * FUN_0040dd00(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte *pbVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    pbVar3 = (byte *)FUN_00413750();\n    if ((*pbVar3 & 0xdf) == 0x55) {\n      if (((((pbVar3[1] & 0xdf) != 0x54) || ((pbVar3[2] & 0xdf) != 0x46)) || (pbVar3[3] != 0x2d)) ||\n         ((pbVar3[4] != 0x38 || (pbVar3[5] != 0)))) {\nLAB_0040ddd8:\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_00416c61;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_00416c56;\n      }\n    }\n    else {\n      if (((((*pbVar3 & 0xdf) != 0x47) || ((pbVar3[1] & 0xdf) != 0x42)) || (pbVar3[2] != 0x31)) ||\n         (((pbVar3[3] != 0x38 || (pbVar3[4] != 0x30)) ||\n          ((pbVar3[5] != 0x33 || ((pbVar3[6] != 0x30 || (pbVar3[7] != 0)))))))) goto LAB_0040ddd8;\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_00416c5d;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_00416c5a;\n      }\n    }\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_0040dd00"
        },
        {
            "funcStartAddr": "0x40de00",
            "funcEndAddr": "0x40ef33",
            "decompiledFuncCode": "\nulong FUN_0040de00(undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                  uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  ulong uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ulong uVar9;\n  ushort **ppuVar10;\n  long lVar11;\n  char *pcVar12;\n  byte bVar13;\n  char cVar14;\n  ulong uVar15;\n  ulong uVar16;\n  byte bVar17;\n  uint uVar18;\n  ulong uVar19;\n  bool bVar20;\n  ulong uVar21;\n  ulong uVar22;\n  bool bVar23;\n  bool bVar24;\n  bool bVar25;\n  bool bVar26;\n  size_t local_a0;\n  char *local_78;\n  ulong local_70;\n  bool local_5c;\n  bool local_5b;\n  wint_t local_44;\n  mbstate_t local_40 [2];\n  \n  sVar8 = __ctype_get_mb_cur_max();\n  uVar18 = param_6 & 2;\n  local_5c = uVar18 != 0;\n  uVar9 = param_2;\n  switch(param_5) {\n  case 0:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = false;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar18 != 0) {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = false;\n      local_a0 = 1;\n      local_78 = \"\\'\";\n      break;\n    }\n    bVar6 = false;\nLAB_0040ea51:\n    if (param_2 != 0) {\n      bVar3 = false;\n      local_5b = false;\n      bVar2 = true;\n      local_70 = 0;\n      goto LAB_0040e686;\n    }\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 1;\n    param_5 = 2;\n    local_70 = 0;\n    local_5b = false;\n    local_5c = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 3:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 4:\n    if (uVar18 == 0) {\n      bVar6 = true;\n      goto LAB_0040ea51;\n    }\n  case 1:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 5:\n    if (uVar18 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      local_5b = false;\n      local_70 = 0;\n      bVar2 = true;\n      bVar3 = false;\n      local_5c = false;\n      uVar15 = 1;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    else {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 5;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\\"\";\n    break;\n  case 7:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = true;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      param_8 = (char *)FUN_0040dd00(&DAT_00416c65,param_5);\n      param_9 = (char *)FUN_0040dd00(\"\\'\");\n    }\n    uVar15 = 0;\n    if (uVar18 == 0) {\n      cVar14 = *param_8;\n      while (cVar14 != '\\0') {\n        if (uVar15 < param_2) {\n          param_1[uVar15] = cVar14;\n        }\n        uVar15 = uVar15 + 1;\n        cVar14 = param_8[uVar15];\n      }\n    }\n    local_a0 = strlen(param_9);\n    bVar2 = true;\n    bVar3 = false;\n    local_78 = param_9;\n    local_5b = false;\n    local_70 = 0;\n    bVar6 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\nLAB_0040de98:\n  uVar22 = 0;\n  bVar5 = local_5b;\nLAB_0040dea8:\n  bVar23 = param_4 != uVar22;\n  if (param_4 == 0xffffffffffffffff) {\n    bVar23 = param_3[uVar22] != '\\0';\n  }\n  bVar26 = bVar6;\n  if (!bVar23) goto LAB_0040e628;\n  bVar20 = (bool)(param_5 != 2 & bVar6);\n  __s1 = (byte *)(param_3 + uVar22);\n  uVar16 = uVar15;\n  bVar4 = bVar3;\n  if (bVar20) {\n    if (local_a0 == 0) {\nLAB_0040e5a0:\n      uVar19 = (ulong)*__s1;\n      switch(uVar19) {\n      case 0:\n        goto switchD_0040e5b2_caseD_0;\n      default:\n        bVar20 = false;\n        goto switchD_0040e41e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_0040e2b5;\n      case 8:\n        bVar17 = 0x62;\n        break;\n      case 9:\nswitchD_0040e5b2_caseD_9:\n        bVar17 = 0x74;\n        break;\n      case 10:\nswitchD_0040e5b2_caseD_a:\n        bVar17 = 0x6e;\n        break;\n      case 0xb:\nswitchD_0040e5b2_caseD_b:\n        bVar17 = 0x76;\n        goto LAB_0040e2b5;\n      case 0xc:\nswitchD_0040e5b2_caseD_c:\n        bVar17 = 0x66;\nLAB_0040e2b5:\n        if (local_5c) {\n          bVar25 = false;\n          goto LAB_0040e208;\n        }\nLAB_0040e2c0:\n        bVar23 = false;\n        goto LAB_0040e07b;\n      case 0xd:\n        bVar20 = false;\nswitchD_0040df98_caseD_d:\n        bVar25 = param_5 == 2;\n        uVar19 = 0xd;\n        bVar13 = 0x72;\n        goto LAB_0040e1d0;\n      case 0x20:\n        bVar25 = false;\nLAB_0040e5fa:\n        uVar19 = 0x20;\n        goto LAB_0040e5c2;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar20 = false;\nswitchD_0040df98_caseD_21:\n        bVar25 = false;\n        goto LAB_0040e1db;\n      case 0x23:\n      case 0x7e:\n        bVar26 = false;\nLAB_0040e5da:\n        if (uVar22 == 0) {\n          bVar25 = false;\n          bVar23 = bVar20;\n          bVar20 = bVar26;\n          goto LAB_0040dfe8;\n        }\n        bVar23 = false;\n        goto LAB_0040dfff;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar25 = false;\nLAB_0040e5c2:\n        bVar24 = false;\n        bVar23 = bVar20;\n        bVar20 = bVar25;\n        goto LAB_0040e001;\n      case 0x27:\n        bVar20 = false;\n        goto switchD_0040e41e_caseD_27;\n      case 0x3f:\n        bVar20 = false;\n        goto switchD_0040e41e_caseD_3f;\n      case 0x5c:\n        bVar20 = false;\n        goto switchD_0040df98_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        bVar20 = false;\n        goto switchD_0040e41e_caseD_7b;\n      }\n      bVar25 = false;\n      bVar23 = false;\n      goto joined_r0x0040e1f7;\n    }\n    if ((param_4 == 0xffffffffffffffff) && (1 < local_a0)) {\n      param_4 = strlen(param_3);\n    }\n    if ((param_4 < uVar22 + local_a0) || (iVar7 = memcmp(__s1,local_78,local_a0), iVar7 != 0))\n    goto LAB_0040e5a0;\n    if (!local_5c) {\n      uVar19 = (ulong)*__s1;\n      bVar25 = bVar20;\n      switch(uVar19) {\n      case 0:\n        goto switchD_0040df98_caseD_0;\n      default:\n        goto switchD_0040e41e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_0040e2c0;\n      case 8:\n        bVar25 = false;\n        bVar23 = false;\n        bVar17 = 0x62;\n        break;\n      case 9:\n        goto switchD_0040e5b2_caseD_9;\n      case 10:\n        goto switchD_0040e5b2_caseD_a;\n      case 0xb:\n        goto switchD_0040e5b2_caseD_b;\n      case 0xc:\n        goto switchD_0040e5b2_caseD_c;\n      case 0xd:\n        goto switchD_0040df98_caseD_d;\n      case 0x20:\n        goto LAB_0040e5fa;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        goto switchD_0040df98_caseD_21;\n      case 0x23:\n      case 0x7e:\n        bVar26 = bVar20;\n        goto LAB_0040e5da;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto LAB_0040e5c2;\n      case 0x27:\n        goto switchD_0040e41e_caseD_27;\n      case 0x3f:\n        goto switchD_0040e41e_caseD_3f;\n      case 0x5c:\n        goto switchD_0040df98_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        goto switchD_0040e41e_caseD_7b;\n      }\n      goto LAB_0040e042;\n    }\n    goto LAB_0040e21a;\n  }\n  uVar19 = (ulong)*__s1;\n  switch(uVar19) {\n  case 0:\n    if (bVar6) {\nswitchD_0040e5b2_caseD_0:\n      if (!local_5c) {\n        bVar20 = false;\nswitchD_0040df98_caseD_0:\n        bVar26 = param_5 == 2;\n        bVar24 = (bool)((bVar3 ^ 1U) & bVar26);\n        if (bVar24) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar16 = uVar15 + 3;\n          bVar3 = bVar24;\n          if (uVar9 <= uVar15 + 3) {\n            uVar16 = uVar15 + 4;\n            bVar23 = false;\n            bVar17 = 0x30;\n            bVar4 = bVar24;\n            goto LAB_0040e0f8;\n          }\nLAB_0040e33a:\n          param_1[uVar16] = 0x5c;\n          uVar15 = uVar16;\n        }\n        else if (uVar15 < uVar9) goto LAB_0040e33a;\n        uVar16 = uVar15 + 1;\n        bVar24 = bVar23;\n        if (param_5 == 2) {\n          bVar17 = 0x30;\n          bVar23 = false;\n          bVar4 = bVar3;\n          goto LAB_0040e0f8;\n        }\n        uVar19 = 0x30;\n        if ((uVar22 + 1 < param_4) && ((byte)(param_3[uVar22 + 1] - 0x30U) < 10)) {\n          if (uVar16 < uVar9) {\n            param_1[uVar16] = 0x30;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x30;\n          }\n          uVar16 = uVar15 + 3;\n          uVar19 = 0x30;\n        }\nLAB_0040e379:\n        bVar17 = (byte)uVar19;\n        bVar23 = false;\n        uVar15 = uVar16;\n        bVar4 = bVar3;\n        if ((bool)(bVar6 ^ 1U | bVar26)) goto LAB_0040e0f8;\n        goto LAB_0040e001;\n      }\n      bVar26 = param_5 == 2;\n      goto LAB_0040e20c;\n    }\n    if ((param_6 & 1) == 0) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0;\n      bVar23 = false;\n      bVar20 = false;\n      goto LAB_0040dfe8;\n    }\n    uVar22 = uVar22 + 1;\n    goto LAB_0040dea8;\n  default:\nswitchD_0040e41e_caseD_1:\n    bVar25 = bVar6;\n    if (sVar8 != 1) {\n      local_40[0] = (mbstate_t)0x0;\n      if (param_4 == 0xffffffffffffffff) {\n        param_4 = strlen(param_3);\n      }\n      uVar21 = 0;\n      do {\n        uVar1 = uVar22 + uVar21;\n        lVar11 = FUN_00412fb0(&local_44,param_3 + uVar1,param_4 - uVar1,local_40);\n        if (lVar11 == 0) break;\n        if (lVar11 == -1) {\n          bVar23 = false;\n          goto LAB_0040ed2a;\n        }\n        if (lVar11 == -2) {\n          if ((param_4 <= uVar1) || (param_3[uVar1] == '\\0')) goto LAB_0040ee67;\n          goto LAB_0040ee57;\n        }\n        if (((param_5 == 2) && (local_5c)) && (lVar11 != 1)) {\n          pcVar12 = param_3 + uVar1 + 1;\n          do {\n            if (((byte)(*pcVar12 + 0xa5U) < 0x22) &&\n               ((1L << (*pcVar12 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n              param_5 = 2;\n              goto LAB_0040e20c;\n            }\n            pcVar12 = pcVar12 + 1;\n          } while (param_3 + uVar1 + lVar11 != pcVar12);\n        }\n        iVar7 = iswprint(local_44);\n        if (iVar7 == 0) {\n          bVar23 = false;\n        }\n        uVar21 = uVar21 + lVar11;\n        iVar7 = mbsinit(local_40);\n      } while (iVar7 == 0);\n      bVar25 = (bool)((bVar23 ^ 1U) & bVar6);\n      goto LAB_0040ed2a;\n    }\n    ppuVar10 = __ctype_b_loc();\n    uVar21 = 1;\n    bVar25 = ((*ppuVar10)[uVar19] & 0x4000) == 0;\n    bVar23 = !bVar25;\n    bVar25 = (bool)(bVar25 & bVar6);\n    goto LAB_0040e3f4;\n  case 7:\n    bVar25 = param_5 == 2;\n    uVar19 = 7;\n    bVar13 = 0x61;\n    break;\n  case 8:\n    bVar25 = param_5 == 2;\n    uVar19 = 8;\n    bVar13 = 0x62;\n    break;\n  case 9:\n    uVar19 = 9;\n    bVar13 = 0x74;\n    goto LAB_0040e432;\n  case 10:\n    uVar19 = 10;\n    bVar13 = 0x6e;\n    goto LAB_0040e432;\n  case 0xb:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xb;\n    bVar13 = 0x76;\n    break;\n  case 0xc:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xc;\n    bVar13 = 0x66;\n    break;\n  case 0xd:\n    uVar19 = 0xd;\n    bVar13 = 0x72;\nLAB_0040e432:\n    bVar25 = param_5 == 2;\n    bVar20 = (bool)(local_5c & bVar25);\n    if (bVar20) {\nLAB_0040e44a:\n      param_5 = 2;\n      goto LAB_0040e20c;\n    }\n    break;\n  case 0x20:\n    uVar19 = 0x20;\n    goto LAB_0040dfd6;\n  case 0x21:\n  case 0x22:\n  case 0x24:\n  case 0x26:\n  case 0x28:\n  case 0x29:\n  case 0x2a:\n  case 0x3b:\n  case 0x3c:\n  case 0x3d:\n  case 0x3e:\n  case 0x5b:\n  case 0x5e:\n  case 0x60:\n  case 0x7c:\n    bVar23 = false;\nLAB_0040dfd6:\n    bVar25 = param_5 == 2;\n    if ((local_5c) && (bVar25)) goto LAB_0040e44a;\n    goto LAB_0040dfe8;\n  case 0x23:\n  case 0x7e:\nLAB_0040dfcd:\n    bVar25 = param_5 == 2;\n    if (uVar22 == 0) goto LAB_0040dfd6;\n    goto LAB_0040e1db;\n  case 0x25:\n  case 0x2b:\n  case 0x2c:\n  case 0x2d:\n  case 0x2e:\n  case 0x2f:\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x3a:\n  case 0x41:\n  case 0x42:\n  case 0x43:\n  case 0x44:\n  case 0x45:\n  case 0x46:\n  case 0x47:\n  case 0x48:\n  case 0x49:\n  case 0x4a:\n  case 0x4b:\n  case 0x4c:\n  case 0x4d:\n  case 0x4e:\n  case 0x4f:\n  case 0x50:\n  case 0x51:\n  case 0x52:\n  case 0x53:\n  case 0x54:\n  case 0x55:\n  case 0x56:\n  case 0x57:\n  case 0x58:\n  case 0x59:\n  case 0x5a:\n  case 0x5d:\n  case 0x5f:\n  case 0x61:\n  case 0x62:\n  case 99:\n  case 100:\n  case 0x65:\n  case 0x66:\n  case 0x67:\n  case 0x68:\n  case 0x69:\n  case 0x6a:\n  case 0x6b:\n  case 0x6c:\n  case 0x6d:\n  case 0x6e:\n  case 0x6f:\n  case 0x70:\n  case 0x71:\n  case 0x72:\n  case 0x73:\n  case 0x74:\n  case 0x75:\n  case 0x76:\n  case 0x77:\n  case 0x78:\n  case 0x79:\n  case 0x7a:\n    goto switchD_0040e41e_caseD_25;\n  case 0x27:\nswitchD_0040e41e_caseD_27:\n    bVar5 = bVar23;\n    if (param_5 != 2) {\n      bVar25 = false;\n      uVar19 = 0x27;\n      goto LAB_0040dfe8;\n    }\n    if (!local_5c) {\n      if ((uVar9 == 0) || (uVar19 = 0, uVar21 = uVar9, local_70 != 0)) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x5c;\n        }\n        uVar19 = uVar9;\n        uVar21 = local_70;\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x27;\n        }\n      }\n      uVar16 = uVar15 + 3;\n      bVar17 = 0x27;\n      uVar9 = uVar19;\n      local_70 = uVar21;\n      bVar24 = false;\n      bVar4 = false;\n      goto LAB_0040e0f8;\n    }\n    goto LAB_0040e20c;\n  case 0x3f:\nswitchD_0040e41e_caseD_3f:\n    if (param_5 == 2) {\n      if (!local_5c) {\n        bVar17 = 0x3f;\n        bVar24 = false;\n        bVar23 = false;\n        goto LAB_0040e0f8;\n      }\n      goto LAB_0040e20c;\n    }\n    if (param_5 != 5) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0x3f;\n      bVar23 = false;\n      goto LAB_0040dfe8;\n    }\n    if (((((param_6 & 4) != 0) && (uVar21 = uVar22 + 2, uVar21 < param_4)) &&\n        (param_3[uVar22 + 1] == '?')) &&\n       ((uVar19 = (ulong)(byte)param_3[uVar21], (byte)param_3[uVar21] < 0x3f &&\n        ((0x7000a38200000000U >> (uVar19 & 0x3f) & 1) != 0)))) {\n      if (!local_5c) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x3f;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x22;\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x22;\n        }\n        if (uVar15 + 3 < uVar9) {\n          param_1[uVar15 + 3] = 0x3f;\n        }\n        uVar16 = uVar15 + 4;\n        bVar26 = false;\n        uVar22 = uVar21;\n        bVar24 = false;\n        goto LAB_0040e379;\n      }\n      goto LAB_0040e21a;\n    }\n    bVar25 = false;\n    uVar19 = 0x3f;\n    bVar23 = false;\n    goto LAB_0040dfe8;\n  case 0x5c:\n    if (param_5 != 2) {\nswitchD_0040df98_caseD_5c:\n      uVar19 = 0x5c;\n      bVar17 = 0x5c;\n      bVar13 = 0x5c;\n      bVar25 = (bool)(bVar6 & local_5c & local_a0 != 0);\n      if (!bVar25) break;\n      uVar22 = uVar22 + 1;\n      bVar23 = false;\n      goto LAB_0040e114;\n    }\n    if (local_5c) goto LAB_0040e20c;\n    uVar22 = uVar22 + 1;\n    bVar23 = false;\n    bVar17 = 0x5c;\n    goto LAB_0040e114;\n  case 0x7b:\n  case 0x7d:\nswitchD_0040e41e_caseD_7b:\n    bVar24 = param_4 != 1;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar24 = param_3[1] != '\\0';\n    }\n    bVar25 = param_5 == 2;\n    if (!bVar24) goto LAB_0040dfcd;\n    goto LAB_0040e1db;\n  }\nLAB_0040e1d0:\n  if (!bVar6) {\nLAB_0040e1db:\n    bVar23 = false;\n    goto LAB_0040dfe8;\n  }\n  bVar23 = false;\n  bVar17 = bVar13;\n  goto joined_r0x0040e1f7;\nLAB_0040e628:\n  if ((uVar15 == 0) && ((bool)(local_5c & param_5 == 2))) {\n    param_5 = 2;\nLAB_0040e20c:\n    if (bVar26) {\n      param_5 = 4;\n    }\nLAB_0040e21a:\n    uVar9 = FUN_0040de00(param_1,uVar9,param_3,param_4,param_5,param_6 & 0xfffffffd,0,param_8,\n                         param_9);\n    return uVar9;\n  }\n  bVar26 = (bool)(param_5 == 2 & (local_5c ^ 1U));\n  bVar23 = (bool)(local_5c ^ 1U);\n  if ((!bVar26) || (bVar23 = bVar26, !bVar5)) {\nLAB_0040eefd:\n    uVar22 = uVar15;\n    if (((local_78 != (char *)0x0) && (bVar23)) && (cVar14 = *local_78, cVar14 != '\\0')) {\n      do {\n        if (uVar22 < uVar9) {\n          param_1[uVar22] = cVar14;\n        }\n        uVar22 = uVar22 + 1;\n        cVar14 = local_78[uVar22 - uVar15];\n      } while (cVar14 != '\\0');\n    }\n    if (uVar22 < uVar9) {\n      param_1[uVar22] = 0;\n    }\n    return uVar22;\n  }\n  if (bVar2) {\n    uVar9 = FUN_0040de00(param_1,local_70,param_3,param_4,5,param_6,param_7,param_8,param_9);\n    return uVar9;\n  }\n  local_5b = uVar9 == 0 && local_70 != 0;\n  param_2 = local_70;\n  bVar23 = bVar5;\n  if (uVar9 != 0 || local_70 == 0) goto LAB_0040eefd;\nLAB_0040e686:\n  *param_1 = 0x27;\n  param_5 = 2;\n  uVar15 = 1;\n  local_78 = \"\\'\";\n  local_a0 = 1;\n  local_5c = false;\n  uVar9 = param_2;\n  goto LAB_0040de98;\n  while (__s1[uVar21] != 0) {\nLAB_0040ee57:\n    uVar21 = uVar21 + 1;\n    if (param_4 <= uVar22 + uVar21) break;\n  }\nLAB_0040ee67:\n  bVar23 = false;\nLAB_0040ed2a:\n  if (1 < uVar21) {\nLAB_0040e8ee:\n    bVar26 = false;\n    uVar21 = uVar21 + uVar22;\n    uVar16 = uVar22;\n    do {\n      bVar17 = (byte)uVar19;\n      if (bVar25) {\n        bVar26 = param_5 == 2;\n        if (local_5c) goto LAB_0040e20c;\n        bVar26 = (bool)(bVar26 & (bVar4 ^ 1U));\n        if (bVar26) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar15 = uVar15 + 3;\n          bVar4 = bVar26;\n        }\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x5c;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = (char)(uVar19 >> 6) + '0';\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = ((byte)(uVar19 >> 3) & 7) + 0x30;\n        }\n        uVar22 = uVar16 + 1;\n        uVar15 = uVar15 + 3;\n        bVar17 = (bVar17 & 7) + 0x30;\n        bVar26 = bVar25;\n        if (uVar21 <= uVar22) goto LAB_0040e08d;\n      }\n      else {\n        bVar3 = (bool)((bVar26 ^ 1U) & bVar4);\n        if (bVar20) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x5c;\n          }\n          uVar15 = uVar15 + 1;\n        }\n        uVar22 = uVar16 + 1;\n        if (uVar21 <= uVar22) goto LAB_0040e114;\n        if (bVar3) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x27;\n          }\n          uVar15 = uVar15 + 2;\n          bVar20 = false;\n          bVar4 = false;\n        }\n        else {\n          bVar20 = false;\n        }\n      }\n      uVar16 = uVar16 + 1;\n      if (uVar15 < uVar9) {\n        param_1[uVar15] = bVar17;\n      }\n      uVar19 = (ulong)(byte)param_3[uVar16];\n      uVar15 = uVar15 + 1;\n    } while( true );\n  }\nLAB_0040e3f4:\n  if (bVar25) {\n    bVar23 = false;\n    bVar25 = bVar6;\n    goto LAB_0040e8ee;\n  }\nswitchD_0040e41e_caseD_25:\n  bVar25 = param_5 == 2;\nLAB_0040dfe8:\n  bVar17 = (byte)uVar19;\n  bVar24 = (bool)((bVar6 ^ 1U | bVar25) ^ 1 | local_5c);\n  bVar26 = bVar20;\n  if (bVar24) {\nLAB_0040dfff:\n    bVar24 = false;\n    bVar20 = bVar26;\nLAB_0040e001:\n    bVar17 = (byte)uVar19;\n    uVar16 = uVar15;\n    bVar4 = bVar3;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar19 >> 5) * 4) >> (bVar17 & 0x1f) & 1) == 0))\n    goto LAB_0040e0f8;\n    bVar25 = param_5 == 2;\n  }\n  else {\nLAB_0040e0f8:\n    bVar25 = param_5 == 2;\n    uVar15 = uVar16;\n    bVar3 = bVar4;\n    if (!bVar20) {\n      uVar22 = uVar22 + 1;\n      bVar3 = (bool)((bVar24 ^ 1U) & bVar4);\nLAB_0040e114:\n      if (bVar3) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x27;\n        }\n        uVar15 = uVar15 + 2;\n        bVar4 = false;\n      }\n      goto LAB_0040e08d;\n    }\n  }\njoined_r0x0040e1f7:\n  if (local_5c) {\nLAB_0040e208:\n    bVar26 = (bool)(bVar6 & bVar25);\n    goto LAB_0040e20c;\n  }\nLAB_0040e042:\n  bVar25 = (bool)((bVar3 ^ 1U) & bVar25);\n  if (bVar25) {\n    if (uVar15 < uVar9) {\n      param_1[uVar15] = 0x27;\n    }\n    if (uVar15 + 1 < uVar9) {\n      param_1[uVar15 + 1] = 0x24;\n    }\n    if (uVar15 + 2 < uVar9) {\n      param_1[uVar15 + 2] = 0x27;\n    }\n    uVar15 = uVar15 + 3;\n    bVar3 = bVar25;\n  }\nLAB_0040e07b:\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = 0x5c;\n  }\n  uVar15 = uVar15 + 1;\n  uVar22 = uVar22 + 1;\n  bVar4 = bVar3;\nLAB_0040e08d:\n  bVar3 = bVar4;\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = bVar17;\n  }\n  uVar15 = uVar15 + 1;\n  if (!bVar23) {\n    bVar2 = false;\n  }\n  goto LAB_0040dea8;\n}\n\n",
            "funcName": "FUN_0040de00"
        },
        {
            "funcStartAddr": "0x40f030",
            "funcEndAddr": "0x40f1cb",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_0040f030(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  ulong uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  undefined4 *puVar8;\n  ulong uVar9;\n  undefined *__ptr;\n  ulong *puVar10;\n  \n  piVar7 = __errno_location();\n  iVar1 = *piVar7;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  puVar8 = (undefined4 *)PTR_DAT_0061c558;\n  if (DAT_0061c570 <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00411460();\n    }\n    if (PTR_DAT_0061c558 == &DAT_0061c560) {\n      puVar8 = (undefined4 *)FUN_00411270(0);\n      uVar6 = PTR_DAT_0061c568._4_4_;\n      uVar5 = PTR_DAT_0061c568._0_4_;\n      uVar3 = _UNK_0061c564;\n      PTR_DAT_0061c558 = (undefined *)puVar8;\n      *puVar8 = _DAT_0061c560;\n      puVar8[1] = uVar3;\n      puVar8[2] = uVar5;\n      puVar8[3] = uVar6;\n    }\n    else {\n      puVar8 = (undefined4 *)FUN_00411270(PTR_DAT_0061c558);\n      PTR_DAT_0061c558 = (undefined *)puVar8;\n    }\n    memset(puVar8 + (long)DAT_0061c570 * 4,0,(long)((param_1 + 1) - DAT_0061c570) << 4);\n    DAT_0061c570 = param_1 + 1;\n  }\n  uVar2 = param_4[1];\n  puVar10 = (ulong *)(puVar8 + (long)param_1 * 4);\n  uVar4 = *puVar10;\n  __ptr = (undefined *)puVar10[1];\n  uVar9 = FUN_0040de00(__ptr,uVar4,param_2,param_3,*param_4,uVar2 | 1,param_4 + 2,\n                       *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar4 <= uVar9) {\n    uVar9 = uVar9 + 1;\n    *puVar10 = uVar9;\n    if (__ptr != &DAT_0061cbe0) {\n      free(__ptr);\n    }\n    __ptr = (undefined *)FUN_00411210(uVar9);\n    uVar3 = *param_4;\n    puVar10[1] = (ulong)__ptr;\n    FUN_0040de00(__ptr,uVar9,param_2,param_3,uVar3,uVar2 | 1,param_4 + 2,\n                 *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar7 = iVar1;\n  return __ptr;\n}\n\n",
            "funcName": "FUN_0040f030"
        },
        {
            "funcStartAddr": "0x40f1d0",
            "funcEndAddr": "0x40f204",
            "decompiledFuncCode": "\nvoid FUN_0040f1d0(undefined *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0061cce0;\n  }\n  FUN_00411410(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_0040f1d0"
        },
        {
            "funcStartAddr": "0x40f210",
            "funcEndAddr": "0x40f21f",
            "decompiledFuncCode": "\nundefined4 FUN_0040f210(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0061cce0;\n  }\n  return *param_1;\n}\n\n",
            "funcName": "FUN_0040f210"
        },
        {
            "funcStartAddr": "0x40f220",
            "funcEndAddr": "0x40f22f",
            "decompiledFuncCode": "\nvoid FUN_0040f220(undefined4 *param_1,undefined4 param_2)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0061cce0;\n  }\n  *param_1 = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_0040f220"
        },
        {
            "funcStartAddr": "0x40f230",
            "funcEndAddr": "0x40f263",
            "decompiledFuncCode": "\nuint FUN_0040f230(undefined *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0061cce0;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n",
            "funcName": "FUN_0040f230"
        },
        {
            "funcStartAddr": "0x40f270",
            "funcEndAddr": "0x40f283",
            "decompiledFuncCode": "\nundefined4 FUN_0040f270(undefined *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0061cce0;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n",
            "funcName": "FUN_0040f270"
        },
        {
            "funcStartAddr": "0x40f290",
            "funcEndAddr": "0x40f2bb",
            "decompiledFuncCode": "\nvoid FUN_0040f290(undefined4 *param_1,long param_2,long param_3)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0061cce0;\n  }\n  *param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)(param_1 + 10) = param_2;\n    *(long *)(param_1 + 0xc) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f290"
        },
        {
            "funcStartAddr": "0x40f2c0",
            "funcEndAddr": "0x40f332",
            "decompiledFuncCode": "\nvoid FUN_0040f2c0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined4 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (param_5 == (undefined4 *)0x0) {\n    param_5 = (undefined4 *)&DAT_0061cce0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  FUN_0040de00(param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5 + 2,\n               *(undefined8 *)(param_5 + 10),*(undefined8 *)(param_5 + 0xc));\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_0040f2c0"
        },
        {
            "funcStartAddr": "0x40f340",
            "funcEndAddr": "0x40f421",
            "decompiledFuncCode": "\nundefined8 FUN_0040f340(undefined8 param_1,undefined8 param_2,long *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if (param_4 == (undefined4 *)0x0) {\n    param_4 = (undefined4 *)&DAT_0061cce0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | param_4[1];\n  lVar3 = FUN_0040de00(0,0,param_1,param_2,*param_4,uVar5,param_4 + 2,*(undefined8 *)(param_4 + 10),\n                       *(undefined8 *)(param_4 + 0xc));\n  uVar4 = FUN_00411210(lVar3 + 1);\n  FUN_0040de00(uVar4,lVar3 + 1,param_1,param_2,*param_4,uVar5,param_4 + 2,\n               *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n",
            "funcName": "FUN_0040f340"
        },
        {
            "funcStartAddr": "0x40f430",
            "funcEndAddr": "0x40f43a",
            "decompiledFuncCode": "\nvoid FUN_0040f430(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_0040f340(param_1,param_2,0,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_0040f430"
        },
        {
            "funcStartAddr": "0x40f440",
            "funcEndAddr": "0x40f4d5",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040f440(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = PTR_DAT_0061c558;\n  if (1 < DAT_0061c570) {\n    ppvVar2 = (void **)(PTR_DAT_0061c558 + 0x18);\n    ppvVar1 = (void **)(PTR_DAT_0061c558 + (ulong)(DAT_0061c570 - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined **)(__ptr_00 + 8) != &DAT_0061cbe0) {\n    free(*(undefined **)(__ptr_00 + 8));\n    _DAT_0061c560 = 0x100;\n    PTR_DAT_0061c568 = &DAT_0061cbe0;\n  }\n  if (__ptr_00 != &DAT_0061c560) {\n    free(__ptr_00);\n    PTR_DAT_0061c558 = &DAT_0061c560;\n  }\n  DAT_0061c570 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_0040f440"
        },
        {
            "funcStartAddr": "0x40f4e0",
            "funcEndAddr": "0x40f4f1",
            "decompiledFuncCode": "\nvoid FUN_0040f4e0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0040f030(param_1,param_2,0xffffffffffffffff,&DAT_0061cce0);\n  return;\n}\n\n",
            "funcName": "FUN_0040f4e0"
        },
        {
            "funcStartAddr": "0x40f500",
            "funcEndAddr": "0x40f50a",
            "decompiledFuncCode": "\nvoid FUN_0040f500(void)\n\n{\n  FUN_0040f030();\n  return;\n}\n\n",
            "funcName": "FUN_0040f500"
        },
        {
            "funcStartAddr": "0x40f510",
            "funcEndAddr": "0x40f526",
            "decompiledFuncCode": "\nvoid FUN_0040f510(undefined8 param_1)\n\n{\n  FUN_0040f030(0,param_1,0xffffffffffffffff,&DAT_0061cce0);\n  return;\n}\n\n",
            "funcName": "FUN_0040f510"
        },
        {
            "funcStartAddr": "0x40f530",
            "funcEndAddr": "0x40f542",
            "decompiledFuncCode": "\nvoid FUN_0040f530(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0040f030(0,param_1,param_2,&DAT_0061cce0);\n  return;\n}\n\n",
            "funcName": "FUN_0040f530"
        },
        {
            "funcStartAddr": "0x40f550",
            "funcEndAddr": "0x40f5b8",
            "decompiledFuncCode": "\nvoid FUN_0040f550(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_0040f030(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f550"
        },
        {
            "funcStartAddr": "0x40f5c0",
            "funcEndAddr": "0x40f624",
            "decompiledFuncCode": "\nvoid FUN_0040f5c0(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_0040f030(param_1,param_3,param_4,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f5c0"
        },
        {
            "funcStartAddr": "0x40f630",
            "funcEndAddr": "0x40f63c",
            "decompiledFuncCode": "\nvoid FUN_0040f630(undefined4 param_1,undefined8 param_2)\n\n{\n  FUN_0040f550(0,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_0040f630"
        },
        {
            "funcStartAddr": "0x40f640",
            "funcEndAddr": "0x40f64f",
            "decompiledFuncCode": "\nvoid FUN_0040f640(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_0040f5c0(0,param_1,param_2,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_0040f640"
        },
        {
            "funcStartAddr": "0x40f650",
            "funcEndAddr": "0x40f6c0",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040f650(undefined8 param_1,undefined8 param_2,byte param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  \n  local_18 = DAT_0061cd10;\n  local_48 = _DAT_0061cce0;\n  uStack_40 = uRam000000000061cce8;\n  local_38 = _DAT_0061ccf0;\n  uStack_30 = uRam000000000061ccf8;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_3 >> 5) * 4);\n  local_28 = _DAT_0061cd00;\n  uStack_20 = uRam000000000061cd08;\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_3 & 0x1f)) & 1) << (param_3 & 0x1f) ^ uVar2;\n  FUN_0040f030(0,param_1,param_2,&local_48);\n  return;\n}\n\n",
            "funcName": "FUN_0040f650"
        },
        {
            "funcStartAddr": "0x40f6c0",
            "funcEndAddr": "0x40f6cd",
            "decompiledFuncCode": "\nvoid FUN_0040f6c0(undefined8 param_1,char param_2)\n\n{\n  FUN_0040f650(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n",
            "funcName": "FUN_0040f6c0"
        },
        {
            "funcStartAddr": "0x40f6d0",
            "funcEndAddr": "0x40f6e1",
            "decompiledFuncCode": "\nvoid FUN_0040f6d0(undefined8 param_1)\n\n{\n  FUN_0040f650(param_1,0xffffffffffffffff,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_0040f6d0"
        },
        {
            "funcStartAddr": "0x40f6f0",
            "funcEndAddr": "0x40f6fa",
            "decompiledFuncCode": "\nvoid FUN_0040f6f0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0040f650(param_1,param_2,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_0040f6f0"
        },
        {
            "funcStartAddr": "0x40f700",
            "funcEndAddr": "0x40f76e",
            "decompiledFuncCode": "\nvoid FUN_0040f700(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_40 = 0x400000000000000;\n    local_44 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_0040f030(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f700"
        },
        {
            "funcStartAddr": "0x40f770",
            "funcEndAddr": "0x40f7dc",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040f770(undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5\n                 )\n\n{\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  \n  uStack_40 = uRam000000000061cce8;\n  local_38 = _DAT_0061ccf0;\n  uStack_30 = uRam000000000061ccf8;\n  local_28 = _DAT_0061cd00;\n  lStack_20 = uRam000000000061cd08;\n  local_18 = DAT_0061cd10;\n  local_48 = CONCAT44((int)((ulong)_DAT_0061cce0 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_0040f030(param_1,param_4,param_5,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f770"
        },
        {
            "funcStartAddr": "0x40f7e0",
            "funcEndAddr": "0x40f7e9",
            "decompiledFuncCode": "\nvoid FUN_0040f7e0(void)\n\n{\n  FUN_0040f770();\n  return;\n}\n\n",
            "funcName": "FUN_0040f7e0"
        },
        {
            "funcStartAddr": "0x40f7f0",
            "funcEndAddr": "0x40f807",
            "decompiledFuncCode": "\nvoid FUN_0040f7f0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_0040f770(0,param_1,param_2,param_3,0xffffffffffffffff);\n  return;\n}\n\n",
            "funcName": "FUN_0040f7f0"
        },
        {
            "funcStartAddr": "0x40f810",
            "funcEndAddr": "0x40f823",
            "decompiledFuncCode": "\nvoid FUN_0040f810(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_0040f770(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
            "funcName": "FUN_0040f810"
        },
        {
            "funcStartAddr": "0x40f830",
            "funcEndAddr": "0x40f83a",
            "decompiledFuncCode": "\nvoid FUN_0040f830(void)\n\n{\n  FUN_0040f030();\n  return;\n}\n\n",
            "funcName": "FUN_0040f830"
        },
        {
            "funcStartAddr": "0x40f840",
            "funcEndAddr": "0x40f852",
            "decompiledFuncCode": "\nvoid FUN_0040f840(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0040f030(0,param_1,param_2,&DAT_0061c520);\n  return;\n}\n\n",
            "funcName": "FUN_0040f840"
        },
        {
            "funcStartAddr": "0x40f860",
            "funcEndAddr": "0x40f871",
            "decompiledFuncCode": "\nvoid FUN_0040f860(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0040f030(param_1,param_2,0xffffffffffffffff,&DAT_0061c520);\n  return;\n}\n\n",
            "funcName": "FUN_0040f860"
        },
        {
            "funcStartAddr": "0x40f880",
            "funcEndAddr": "0x40f896",
            "decompiledFuncCode": "\nvoid FUN_0040f880(undefined8 param_1)\n\n{\n  FUN_0040f030(0,param_1,0xffffffffffffffff,&DAT_0061c520);\n  return;\n}\n\n",
            "funcName": "FUN_0040f880"
        },
        {
            "funcStartAddr": "0x40f8a0",
            "funcEndAddr": "0x40f8f8",
            "decompiledFuncCode": "\nvoid FUN_0040f8a0(long param_1)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (param_1 != 0) {\n    uVar1 = FUN_0040f880();\n    piVar2 = __errno_location();\n    if (*piVar2 == 0) {\n      uVar3 = dcgettext(0,\"%s: end of file\",5);\n    }\n    else {\n      uVar3 = dcgettext(0,\"%s: read error\",5);\n    }\n                    /* WARNING: Subroutine does not return */\n    error(DAT_0061c518,*piVar2,uVar3,uVar1);\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040f8a0"
        },
        {
            "funcStartAddr": "0x40f900",
            "funcEndAddr": "0x40fbdc",
            "decompiledFuncCode": "\nFILE ** FUN_0040f900(FILE *param_1,ulong param_2)\n\n{\n  int __fd;\n  uint uVar1;\n  FILE *pFVar2;\n  FILE **ppFVar3;\n  FILE **ppFVar4;\n  size_t __n;\n  ulong uVar5;\n  ulong uVar6;\n  long lVar7;\n  timeval *ptVar8;\n  undefined *puVar9;\n  ulong uVar10;\n  byte bVar11;\n  __uid_t local_48;\n  undefined4 uStack_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  \n  bVar11 = 0;\n  if (param_2 == 0) {\n    ppFVar3 = (FILE **)FUN_00411210(0x1038);\n    *ppFVar3 = (FILE *)0x0;\n    ppFVar3[1] = (FILE *)FUN_0040f8a0;\n    ppFVar3[2] = (FILE *)0x0;\n    return ppFVar3;\n  }\n  if (param_1 != (FILE *)0x0) {\n    pFVar2 = (FILE *)FUN_004136b0(param_1,&DAT_004179c4);\n    if (pFVar2 != (FILE *)0x0) {\n      ppFVar3 = (FILE **)FUN_00411210(0x1038);\n      *ppFVar3 = pFVar2;\n      __n = 0x1000;\n      if (param_2 < 0x1001) {\n        __n = param_2;\n      }\n      ppFVar3[1] = (FILE *)FUN_0040f8a0;\n      ppFVar3[2] = param_1;\n      setvbuf(pFVar2,(char *)(ppFVar3 + 3),0,__n);\n      return ppFVar3;\n    }\n    return (FILE **)0x0;\n  }\n  ppFVar4 = (FILE **)FUN_00411210(0x1038);\n  *ppFVar4 = (FILE *)0x0;\n  ppFVar3 = ppFVar4 + 4;\n  ppFVar4[1] = (FILE *)FUN_0040f8a0;\n  ppFVar4[2] = (FILE *)0x0;\n  ppFVar4[3] = (FILE *)0x0;\n  __fd = open(\"/dev/urandom\",0);\n  if (__fd < 0) {\n    uVar5 = 0x14;\n    gettimeofday((timeval *)&local_48,(__timezone_ptr_t)0x0);\n    *(__uid_t *)(ppFVar4 + 4) = local_48;\n    *(undefined4 *)((long)ppFVar4 + 0x24) = uStack_44;\n    *(undefined4 *)(ppFVar4 + 5) = uStack_40;\n    *(undefined4 *)((long)ppFVar4 + 0x2c) = uStack_3c;\n    local_48 = getpid();\n    *(__uid_t *)(ppFVar4 + 6) = local_48;\n  }\n  else {\n    if (0x800 < param_2) {\n      param_2 = 0x800;\n    }\n    pFVar2 = (FILE *)__read_chk(__fd,ppFVar3,param_2,0x1018);\n    close(__fd);\n    if (0x7ff < (long)pFVar2) goto LAB_0040fa08;\n    if ((long)pFVar2 < 0) {\n      pFVar2 = param_1;\n    }\n    uVar5 = 0x800 - (long)pFVar2;\n    if (0x10 < uVar5) {\n      uVar5 = 0x10;\n    }\n    lVar7 = (long)&pFVar2->_flags + uVar5;\n    gettimeofday((timeval *)&local_48,(__timezone_ptr_t)0x0);\n    ptVar8 = (timeval *)&local_48;\n    puVar9 = (undefined *)((long)ppFVar3 + (long)pFVar2);\n    for (uVar5 = uVar5 & 0xffffffff; uVar5 != 0; uVar5 = uVar5 - 1) {\n      *puVar9 = *(undefined *)&ptVar8->tv_sec;\n      ptVar8 = (timeval *)((long)ptVar8 + (ulong)bVar11 * -2 + 1);\n      puVar9 = puVar9 + (ulong)bVar11 * -2 + 1;\n    }\n    if (0x7ff < lVar7) goto LAB_0040fa08;\n    uVar10 = 0x800 - lVar7;\n    if (4 < uVar10) {\n      uVar10 = 4;\n    }\n    local_48 = getpid();\n    uVar5 = uVar10 + lVar7;\n    ptVar8 = (timeval *)&local_48;\n    puVar9 = (undefined *)((long)ppFVar3 + lVar7);\n    for (uVar10 = uVar10 & 0xffffffff; uVar10 != 0; uVar10 = uVar10 - 1) {\n      *puVar9 = *(undefined *)&ptVar8->tv_sec;\n      ptVar8 = (timeval *)((long)ptVar8 + (ulong)bVar11 * -2 + 1);\n      puVar9 = puVar9 + (ulong)bVar11 * -2 + 1;\n    }\n    if (0x7ff < uVar5) goto LAB_0040fa08;\n  }\n  uVar10 = 0x800 - uVar5;\n  if (4 < uVar10) {\n    uVar10 = 4;\n  }\n  local_48 = getppid();\n  if ((uint)uVar10 != 0) {\n    uVar1 = 0;\n    do {\n      uVar6 = (ulong)uVar1;\n      uVar1 = uVar1 + 1;\n      *(undefined *)((long)ppFVar3 + uVar6 + uVar5) = *(undefined *)((long)&local_48 + uVar6);\n    } while (uVar1 < (uint)uVar10);\n  }\n  uVar10 = uVar10 + uVar5;\n  if (uVar10 < 0x800) {\n    uVar5 = 0x800 - uVar10;\n    if (4 < uVar5) {\n      uVar5 = 4;\n    }\n    local_48 = getuid();\n    if ((uint)uVar5 != 0) {\n      uVar1 = 0;\n      do {\n        uVar6 = (ulong)uVar1;\n        uVar1 = uVar1 + 1;\n        *(undefined *)((long)ppFVar3 + uVar6 + uVar10) = *(undefined *)((long)&local_48 + uVar6);\n      } while (uVar1 < (uint)uVar5);\n    }\n    uVar10 = uVar10 + uVar5;\n    if (uVar10 < 0x800) {\n      local_48 = getgid();\n      uVar5 = 0x800 - uVar10;\n      if (4 < uVar5) {\n        uVar5 = 4;\n      }\n      if ((uint)uVar5 != 0) {\n        uVar1 = 0;\n        do {\n          uVar6 = (ulong)uVar1;\n          uVar1 = uVar1 + 1;\n          *(undefined *)((long)ppFVar3 + uVar6 + uVar10) = *(undefined *)((long)&local_48 + uVar6);\n        } while (uVar1 < (uint)uVar5);\n      }\n    }\n  }\nLAB_0040fa08:\n  FUN_00410070(ppFVar3);\n  return ppFVar4;\n}\n\n",
            "funcName": "FUN_0040f900"
        },
        {
            "funcStartAddr": "0x40fbf0",
            "funcEndAddr": "0x40fbf5",
            "decompiledFuncCode": "\nvoid FUN_0040fbf0(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 8) = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_0040fbf0"
        },
        {
            "funcStartAddr": "0x40fc00",
            "funcEndAddr": "0x40fc05",
            "decompiledFuncCode": "\nvoid FUN_0040fc00(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x10) = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_0040fc00"
        },
        {
            "funcStartAddr": "0x40fc10",
            "funcEndAddr": "0x40fd52",
            "decompiledFuncCode": "\nvoid FUN_0040fc10(FILE **param_1,void *param_2,FILE *param_3)\n\n{\n  FILE **ppFVar1;\n  int *piVar2;\n  size_t sVar3;\n  int iVar4;\n  void *__dest;\n  FILE **__src;\n  FILE *pFVar5;\n  \n  pFVar5 = *param_1;\n  if (pFVar5 != (FILE *)0x0) {\n    piVar2 = __errno_location();\n    while( true ) {\n      sVar3 = fread_unlocked(param_2,1,(size_t)param_3,pFVar5);\n      iVar4 = *piVar2;\n      param_2 = (void *)((long)param_2 + sVar3);\n      param_3 = (FILE *)((long)param_3 - sVar3);\n      if (param_3 == (FILE *)0x0) break;\n      pFVar5 = param_1[2];\n      if ((*(byte *)&(*param_1)->_flags & 0x20) == 0) {\n        iVar4 = 0;\n      }\n      *piVar2 = iVar4;\n      (*(code *)param_1[1])(pFVar5);\n      pFVar5 = *param_1;\n    }\n    return;\n  }\n  pFVar5 = param_1[3];\n  __src = param_1 + 0x107;\n  ppFVar1 = param_1 + 4;\n  __dest = param_2;\n  if (param_3 <= pFVar5) {\n    __src = (FILE **)((long)__src + (0x800 - (long)pFVar5));\n    goto LAB_0040fd25;\n  }\n  do {\n    param_2 = (void *)((long)__dest + (long)pFVar5);\n    param_3 = (FILE *)((long)param_3 - (long)pFVar5);\n    memcpy(__dest,(void *)((0x800 - (long)pFVar5) + (long)__src),(size_t)pFVar5);\n    if (((ulong)param_2 & 7) == 0) goto LAB_0040fd0b;\n    pFVar5 = (FILE *)0x800;\n    FUN_0040fdc0(ppFVar1,__src);\n    __dest = param_2;\n  } while ((FILE *)0x800 < param_3);\n  goto LAB_0040fd1f;\nLAB_0040fd0b:\n  while ((FILE *)0x7ff < param_3) {\n    FUN_0040fdc0(ppFVar1,param_2);\n    param_3 = (FILE *)&param_3[-10]._fileno;\n    param_2 = (void *)((long)param_2 + 0x800);\n    if (param_3 == (FILE *)0x0) {\n      param_1[3] = (FILE *)0x0;\n      return;\n    }\n  }\n  FUN_0040fdc0(ppFVar1,__src);\nLAB_0040fd1f:\n  pFVar5 = (FILE *)0x800;\nLAB_0040fd25:\n  memcpy(param_2,__src,(size_t)param_3);\n  param_1[3] = (FILE *)((long)pFVar5 - (long)param_3);\n  return;\n}\n\n",
            "funcName": "FUN_0040fc10"
        },
        {
            "funcStartAddr": "0x40fd70",
            "funcEndAddr": "0x40fdb1",
            "decompiledFuncCode": "\nint FUN_0040fd70(FILE **param_1)\n\n{\n  FILE *__stream;\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  __stream = *param_1;\n  __explicit_bzero_chk(param_1,0x1038,0xffffffffffffffff);\n  free(param_1);\n  if (__stream == (FILE *)0x0) {\n    return 0;\n  }\n  iVar1 = fileno(__stream);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(__stream);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00411fe7;\n    }\n    iVar1 = FUN_00412140(__stream);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(__stream);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00411fe7:\n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_0040fd70"
        },
        {
            "funcStartAddr": "0x40fdc0",
            "funcEndAddr": "0x410065",
            "decompiledFuncCode": "\nvoid FUN_0040fdc0(long *param_1,long *param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  ulong uVar3;\n  long lVar4;\n  long *plVar5;\n  long lVar6;\n  \n  lVar6 = param_1[0x102];\n  uVar3 = param_1[0x100];\n  param_1[0x102] = lVar6 + 1;\n  lVar6 = param_1[0x101] + lVar6 + 1;\n  plVar1 = param_1;\n  plVar5 = param_2;\n  do {\n    lVar4 = *plVar1;\n    uVar3 = ~(uVar3 ^ uVar3 << 0x15) + plVar1[0x80];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    *plVar1 = lVar6;\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8)) + lVar4;\n    *plVar5 = lVar4;\n    lVar6 = plVar1[1];\n    uVar3 = (uVar3 ^ uVar3 >> 5) + plVar1[0x81];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar1[1] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar5[1] = lVar6;\n    lVar4 = plVar1[2];\n    uVar3 = (uVar3 * 0x1000 ^ uVar3) + plVar1[0x82];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    plVar1[2] = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    plVar5[2] = lVar4;\n    lVar6 = plVar1[3];\n    uVar3 = (uVar3 ^ uVar3 >> 0x21) + plVar1[0x83];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar2 = plVar1 + 4;\n    plVar1[3] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar5[3] = lVar6;\n    plVar1 = plVar2;\n    plVar5 = plVar5 + 4;\n  } while (plVar2 != param_1 + 0x80);\n  plVar1 = param_2 + 0x80;\n  do {\n    lVar4 = *plVar2;\n    uVar3 = ~(uVar3 ^ uVar3 << 0x15) + plVar2[-0x80];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    *plVar2 = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    *plVar1 = lVar4;\n    lVar6 = plVar2[1];\n    uVar3 = (uVar3 ^ uVar3 >> 5) + plVar2[-0x7f];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar2[1] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar1[1] = lVar6;\n    lVar4 = plVar2[2];\n    uVar3 = (uVar3 * 0x1000 ^ uVar3) + plVar2[-0x7e];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    plVar2[2] = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    plVar1[2] = lVar4;\n    lVar6 = plVar2[3];\n    uVar3 = (uVar3 ^ uVar3 >> 0x21) + plVar2[-0x7d];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar5 = plVar2 + 4;\n    plVar2[3] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar1[3] = lVar6;\n    plVar2 = plVar5;\n    plVar1 = plVar1 + 4;\n  } while (plVar5 != param_1 + 0x100);\n  param_1[0x100] = uVar3;\n  param_1[0x101] = lVar6;\n  return;\n}\n\n",
            "funcName": "FUN_0040fdc0"
        },
        {
            "funcStartAddr": "0x410070",
            "funcEndAddr": "0x4102a4",
            "decompiledFuncCode": "\nvoid FUN_00410070(ulong *param_1)\n\n{\n  ulong *puVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong *puVar4;\n  ulong uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  ulong uVar8;\n  long lVar9;\n  ulong uVar10;\n  ulong uVar11;\n  long lVar12;\n  ulong uVar13;\n  ulong uVar14;\n  \n  uVar3 = 0x98f5704f6c44c0ab;\n  uVar7 = 0x82f053db8355e0ce;\n  uVar13 = 0xb29b2e824a595524;\n  uVar14 = 0xae985bf2cbfc89ed;\n  uVar11 = 0x8c0ea5053d4712a0;\n  uVar10 = 0xb9f8b322c73ac862;\n  uVar8 = 0x647c4677a2884b7c;\n  uVar5 = 0x48fe4a0fa5a09315;\n  puVar1 = param_1;\n  do {\n    lVar9 = uVar8 + (*puVar1 - (uVar7 + puVar1[4]));\n    uVar6 = uVar5 + puVar1[5] ^ uVar3 + puVar1[7] >> 9;\n    uVar10 = uVar10 + (puVar1[1] - uVar6);\n    uVar5 = uVar14 + puVar1[6] ^ lVar9 * 0x200;\n    lVar12 = uVar11 + (puVar1[2] - uVar5);\n    uVar3 = uVar3 + puVar1[7] + lVar9 ^ uVar10 >> 0x17;\n    uVar13 = uVar13 + (puVar1[3] - uVar3);\n    uVar8 = lVar9 + uVar10 ^ lVar12 * 0x8000;\n    lVar9 = (uVar7 + puVar1[4]) - uVar8;\n    *puVar1 = uVar8;\n    uVar10 = uVar10 + lVar12 ^ uVar13 >> 0xe;\n    uVar6 = uVar6 - uVar10;\n    puVar1[1] = uVar10;\n    uVar11 = lVar12 + uVar13 ^ lVar9 * 0x100000;\n    lVar12 = uVar5 - uVar11;\n    puVar1[2] = uVar11;\n    puVar2 = puVar1 + 8;\n    uVar13 = uVar13 + lVar9 ^ uVar6 >> 0x11;\n    uVar5 = uVar6 + lVar12;\n    uVar3 = uVar3 - uVar13;\n    puVar1[3] = uVar13;\n    uVar7 = lVar12 * 0x4000 ^ lVar9 + uVar6;\n    uVar14 = lVar12 + uVar3;\n    puVar1[5] = uVar5;\n    puVar1[4] = uVar7;\n    puVar1[6] = uVar14;\n    puVar1[7] = uVar3;\n    puVar1 = puVar2;\n    puVar4 = param_1;\n  } while (param_1 + 0x100 != puVar2);\n  do {\n    lVar9 = (uVar8 + *puVar4) - (uVar7 + puVar4[4]);\n    uVar6 = uVar5 + puVar4[5] ^ uVar3 + puVar4[7] >> 9;\n    uVar5 = (uVar10 + puVar4[1]) - uVar6;\n    uVar14 = uVar14 + puVar4[6] ^ lVar9 * 0x200;\n    lVar12 = (uVar11 + puVar4[2]) - uVar14;\n    uVar3 = uVar3 + puVar4[7] + lVar9 ^ uVar5 >> 0x17;\n    uVar13 = (uVar13 + puVar4[3]) - uVar3;\n    uVar8 = lVar9 + uVar5 ^ lVar12 * 0x8000;\n    lVar9 = (uVar7 + puVar4[4]) - uVar8;\n    *puVar4 = uVar8;\n    uVar10 = uVar5 + lVar12 ^ uVar13 >> 0xe;\n    uVar6 = uVar6 - uVar10;\n    puVar4[1] = uVar10;\n    uVar11 = lVar12 + uVar13 ^ lVar9 * 0x100000;\n    lVar12 = uVar14 - uVar11;\n    puVar4[2] = uVar11;\n    puVar1 = puVar4 + 8;\n    uVar13 = uVar13 + lVar9 ^ uVar6 >> 0x11;\n    uVar5 = uVar6 + lVar12;\n    uVar3 = uVar3 - uVar13;\n    puVar4[3] = uVar13;\n    uVar7 = lVar12 * 0x4000 ^ lVar9 + uVar6;\n    uVar14 = lVar12 + uVar3;\n    puVar4[5] = uVar5;\n    puVar4[4] = uVar7;\n    puVar4[6] = uVar14;\n    puVar4[7] = uVar3;\n    puVar4 = puVar1;\n  } while (param_1 + 0x100 != puVar1);\n  param_1[0x102] = 0;\n  param_1[0x101] = 0;\n  param_1[0x100] = 0;\n  return;\n}\n\n",
            "funcName": "FUN_00410070"
        },
        {
            "funcStartAddr": "0x4102b0",
            "funcEndAddr": "0x41038f",
            "decompiledFuncCode": "\nvoid FUN_004102b0(long *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long *plVar5;\n  \n  lVar1 = param_1[6];\n  lVar2 = param_1[5];\n  if (lVar1 == lVar2) {\n    *(byte *)(param_1 + 0xd) = *(byte *)(param_1 + 0xd) | 2;\n  }\n  uVar3 = param_1[7];\n  uVar4 = lVar1 + param_1[9] & ~param_1[9];\n  param_1[6] = uVar4;\n  if (uVar3 - param_1[4] < uVar4 - param_1[4]) {\n    param_1[6] = uVar3;\n    uVar4 = uVar3;\n  }\n  param_1[5] = uVar4;\n  plVar5 = (long *)param_1[0x11];\n  if ((ulong)(param_1[0x12] - (long)plVar5) < 8) {\n    _obstack_newchunk(param_1 + 0xe,8);\n    plVar5 = (long *)param_1[0x11];\n  }\n  *plVar5 = lVar2;\n  plVar5 = (long *)param_1[0x1c];\n  param_1[0x11] = param_1[0x11] + 8;\n  if ((ulong)(param_1[0x1d] - (long)plVar5) < 8) {\n    _obstack_newchunk(param_1 + 0x19,8);\n    plVar5 = (long *)param_1[0x1c];\n  }\n  *plVar5 = (lVar1 - lVar2) + -1;\n  param_1[0x1c] = param_1[0x1c] + 8;\n  *param_1 = *param_1 + 1;\n  return;\n}\n\n",
            "funcName": "FUN_004102b0"
        },
        {
            "funcStartAddr": "0x4103a0",
            "funcEndAddr": "0x410407",
            "decompiledFuncCode": "\nvoid FUN_004103a0(undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  _obstack_begin(param_1 + 3,0,0,malloc,free);\n  _obstack_begin(param_1 + 0xe,0,0,malloc,free);\n  *(byte *)(param_1 + 0x23) = *(byte *)(param_1 + 0x23) & 0xfe;\n  param_1[0x20] = malloc;\n  param_1[0x21] = free;\n  FUN_00413270(param_1 + 0x19,0,0);\n  return;\n}\n\n",
            "funcName": "FUN_004103a0"
        },
        {
            "funcStartAddr": "0x410410",
            "funcEndAddr": "0x410439",
            "decompiledFuncCode": "\nvoid FUN_00410410(long param_1)\n\n{\n  _obstack_free(param_1 + 0x18,0);\n  _obstack_free(param_1 + 0x70,0);\n  _obstack_free(param_1 + 200,0);\n  return;\n}\n\n",
            "funcName": "FUN_00410410"
        },
        {
            "funcStartAddr": "0x410440",
            "funcEndAddr": "0x41063b",
            "decompiledFuncCode": "\nulong FUN_00410440(FILE *param_1,long param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  int iVar3;\n  undefined *puVar4;\n  ulong uVar5;\n  undefined4 extraout_var;\n  undefined8 *puVar6;\n  \n  do {\n    iVar3 = fgetc(param_1);\n    while( true ) {\n      if (iVar3 == -1) {\n        puVar4 = *(undefined **)(param_2 + 0x30);\n        if (puVar4 != *(undefined **)(param_2 + 0x28)) {\n          if (puVar4 == *(undefined **)(param_2 + 0x38)) {\n            _obstack_newchunk(param_2 + 0x18,1);\n            puVar4 = *(undefined **)(param_2 + 0x30);\n          }\n          *(undefined **)(param_2 + 0x30) = puVar4 + 1;\n          *puVar4 = 0;\n          FUN_004102b0(param_2);\n        }\n        puVar6 = *(undefined8 **)(param_2 + 0x88);\n        if ((ulong)(*(long *)(param_2 + 0x90) - (long)puVar6) < 8) {\n          _obstack_newchunk(param_2 + 0x70,8);\n          puVar6 = *(undefined8 **)(param_2 + 0x88);\n        }\n        *puVar6 = 0;\n        lVar1 = *(long *)(param_2 + 0x88) + 8;\n        *(long *)(param_2 + 0x88) = lVar1;\n        if (lVar1 == *(long *)(param_2 + 0x80)) {\n          *(byte *)(param_2 + 0xc0) = *(byte *)(param_2 + 0xc0) | 2;\n        }\n        uVar5 = lVar1 + *(ulong *)(param_2 + 0xa0) & ~*(ulong *)(param_2 + 0xa0);\n        uVar2 = *(ulong *)(param_2 + 0x90);\n        *(ulong *)(param_2 + 0x88) = uVar5;\n        if (uVar2 - *(long *)(param_2 + 0x78) < uVar5 - *(long *)(param_2 + 0x78)) {\n          *(ulong *)(param_2 + 0x88) = uVar2;\n          uVar5 = uVar2;\n        }\n        *(long *)(param_2 + 8) = *(long *)(param_2 + 0x80);\n        lVar1 = *(long *)(param_2 + 0xd8);\n        *(ulong *)(param_2 + 0x80) = uVar5;\n        if (*(long *)(param_2 + 0xe0) == lVar1) {\n          *(byte *)(param_2 + 0x118) = *(byte *)(param_2 + 0x118) | 2;\n        }\n        uVar5 = *(long *)(param_2 + 0xe0) + *(ulong *)(param_2 + 0xf8) & ~*(ulong *)(param_2 + 0xf8)\n        ;\n        uVar2 = *(ulong *)(param_2 + 0xe8);\n        *(ulong *)(param_2 + 0xe0) = uVar5;\n        if (uVar2 - *(long *)(param_2 + 0xd0) < uVar5 - *(long *)(param_2 + 0xd0)) {\n          *(ulong *)(param_2 + 0xe0) = uVar2;\n          uVar5 = uVar2;\n        }\n        *(ulong *)(param_2 + 0xd8) = uVar5;\n        *(long *)(param_2 + 0x10) = lVar1;\n        iVar3 = ferror(param_1);\n        return CONCAT44(extraout_var,iVar3) & 0xffffffffffffff00 | (ulong)(iVar3 == 0);\n      }\n      puVar4 = *(undefined **)(param_2 + 0x30);\n      if (*(undefined **)(param_2 + 0x38) == puVar4) {\n        _obstack_newchunk(param_2 + 0x18,1);\n        puVar4 = *(undefined **)(param_2 + 0x30);\n        *(undefined **)(param_2 + 0x30) = puVar4 + 1;\n        *puVar4 = (char)iVar3;\n      }\n      else {\n        *(undefined **)(param_2 + 0x30) = puVar4 + 1;\n        *puVar4 = (char)iVar3;\n      }\n      if (iVar3 != 0) break;\n      FUN_004102b0(param_2);\n      iVar3 = fgetc(param_1);\n    }\n  } while( true );\n}\n\n",
            "funcName": "FUN_00410440"
        },
        {
            "funcStartAddr": "0x410660",
            "funcEndAddr": "0x410674",
            "decompiledFuncCode": "\nvoid FUN_00410660(char *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(param_1);\n  FUN_00410c20(iVar1);\n  return;\n}\n\n",
            "funcName": "FUN_00410660"
        },
        {
            "funcStartAddr": "0x410680",
            "funcEndAddr": "0x410692",
            "decompiledFuncCode": "\nvoid FUN_00410680(char *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = mkostemp(param_1,param_2);\n  FUN_00413640(iVar1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00410680"
        },
        {
            "funcStartAddr": "0x4106a0",
            "funcEndAddr": "0x410ba0",
            "decompiledFuncCode": "\nuint FUN_004106a0(byte *param_1,byte *param_2,uint param_3,uint param_4)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  byte *pbVar4;\n  byte bVar5;\n  int iVar6;\n  byte bVar7;\n  byte *pbVar8;\n  ulong uVar9;\n  uint uVar10;\n  ulong uVar11;\n  uint uVar12;\n  \n  uVar3 = (uint)*param_1;\n  bVar7 = *param_2;\n  uVar10 = (uint)bVar7;\n  bVar5 = (byte)param_3;\n  if (*param_1 == 0x2d) {\n    do {\n      do {\n        param_1 = param_1 + 1;\n        bVar1 = *param_1;\n        uVar3 = (uint)bVar1;\n      } while (bVar1 == 0x30);\n      uVar12 = (uint)bVar1;\n    } while (param_4 == bVar1);\n    if (bVar7 != 0x2d) {\n      if (param_3 == bVar1) {\n        do {\n          param_1 = param_1 + 1;\n          bVar1 = *param_1;\n        } while (bVar1 == 0x30);\n      }\n      if (bVar1 - 0x30 < 10) {\n        return 0xffffffff;\n      }\n      while (((char)uVar10 == '0' || (param_4 == uVar10))) {\n        param_2 = param_2 + 1;\n        uVar10 = (uint)*param_2;\n      }\n      if (param_3 == uVar10) {\n        do {\n          param_2 = param_2 + 1;\n        } while (*param_2 == 0x30);\n        uVar10 = (uint)*param_2;\n      }\n      return -(uint)(uVar10 - 0x30 < 10);\n    }\n    do {\n      do {\n        param_2 = param_2 + 1;\n        bVar7 = *param_2;\n      } while (bVar7 == 0x30);\n      uVar2 = (uint)bVar7;\n    } while (param_4 == bVar7);\n    do {\n      pbVar8 = param_2;\n      if (((char)uVar3 != (char)uVar2) || (9 < uVar2 - 0x30)) goto LAB_00410978;\n      do {\n        param_1 = param_1 + 1;\n        uVar12 = (uint)*param_1;\n        uVar3 = (uint)*param_1;\n      } while (param_4 == uVar3);\n      do {\n        uVar2 = (uint)pbVar8[1];\n        param_2 = pbVar8 + 1;\n        if (param_4 != uVar2) break;\n        pbVar8 = pbVar8 + 2;\n        uVar2 = (uint)*pbVar8;\n        param_2 = pbVar8;\n      } while (param_4 == uVar2);\n    } while( true );\n  }\n  if (bVar7 != 0x2d) {\n    while (((char)uVar3 == '0' || (param_4 == uVar3))) {\n      param_1 = param_1 + 1;\n      uVar3 = (uint)*param_1;\n    }\n    if (bVar7 != 0x30) goto LAB_0041078e;\n    do {\n      do {\n        param_2 = param_2 + 1;\n        uVar10 = (uint)*param_2;\n      } while (*param_2 == 0x30);\nLAB_0041078e:\n    } while (param_4 == uVar10);\n    do {\n      pbVar8 = param_2;\n      if (((char)uVar3 != (char)uVar10) || (9 < uVar10 - 0x30)) goto LAB_004108f0;\n      do {\n        param_1 = param_1 + 1;\n        uVar3 = (uint)*param_1;\n      } while (param_4 == uVar3);\n      do {\n        uVar10 = (uint)pbVar8[1];\n        param_2 = pbVar8 + 1;\n        if (param_4 != uVar10) break;\n        pbVar8 = pbVar8 + 2;\n        uVar10 = (uint)*pbVar8;\n        param_2 = pbVar8;\n      } while (param_4 == uVar10);\n    } while( true );\n  }\n  do {\n    do {\n      param_2 = param_2 + 1;\n      bVar7 = *param_2;\n      uVar10 = (uint)bVar7;\n    } while (bVar7 == 0x30);\n  } while (param_4 == bVar7);\n  if (param_3 == bVar7) {\n    do {\n      uVar10 = (uint)param_2[1];\n      if (param_2[1] != 0x30) break;\n      param_2 = param_2 + 2;\n      uVar10 = (uint)*param_2;\n    } while (*param_2 == 0x30);\n  }\n  if (uVar10 - 0x30 < 10) {\n    return 1;\n  }\n  while (((char)uVar3 == '0' || (param_4 == uVar3))) {\n    param_1 = param_1 + 1;\n    uVar3 = (uint)*param_1;\n  }\n  if (param_3 == uVar3) {\n    do {\n      param_1 = param_1 + 1;\n    } while (*param_1 == 0x30);\n    uVar3 = (uint)*param_1;\n  }\n  goto LAB_004108be;\nLAB_00410978:\n  if ((param_3 == uVar12) && (9 < uVar2 - 0x30)) {\nLAB_00410abd:\n    if (bVar5 == *pbVar8) {\n      if (bVar5 == *param_1) {\n        do {\n          pbVar8 = pbVar8 + 1;\n          param_1 = param_1 + 1;\n          bVar7 = *pbVar8;\n          bVar5 = *param_1;\n          uVar10 = (int)(char)bVar7 - 0x30;\n          if (bVar7 != bVar5) {\n            uVar3 = (int)(char)bVar5 - 0x30;\n            if (uVar10 < 10) {\n              if (9 < uVar3) goto LAB_00410bb4;\n              return (int)(char)bVar7 - (int)(char)bVar5;\n            }\n            if (uVar3 < 10) goto LAB_00410adc;\n            return 0;\n          }\n        } while (uVar10 < 10);\n        return 0;\n      }\n      do {\n        pbVar8 = pbVar8 + 1;\nLAB_00410bb4:\n        uVar3 = (uint)(char)*pbVar8;\n      } while (*pbVar8 == 0x30);\nLAB_004108be:\n      return (uint)(uVar3 - 0x30 < 10);\n    }\n    if (bVar5 != *param_1) {\n      return 0;\n    }\n    do {\n      param_1 = param_1 + 1;\nLAB_00410adc:\n      bVar7 = *param_1;\n    } while (bVar7 == 0x30);\n    goto LAB_00410a5f;\n  }\n  if (param_3 == uVar2) {\n    if (9 < uVar12 - 0x30) goto LAB_00410abd;\n    uVar10 = param_3 - 0x30;\n    uVar2 = param_3 - uVar12;\nLAB_004109a2:\n    uVar11 = 0;\n    do {\n      do {\n        param_1 = param_1 + 1;\n      } while (param_4 == *param_1);\n      uVar11 = uVar11 + 1;\n    } while (*param_1 - 0x30 < 10);\n    if (9 < uVar10) {\n      return -(uint)(uVar11 != 0);\n    }\n  }\n  else {\n    uVar10 = uVar2 - 0x30;\n    uVar2 = uVar2 - uVar12;\n    if (uVar12 - 0x30 < 10) goto LAB_004109a2;\n    uVar11 = 0;\n    if (9 < uVar10) {\n      return 0;\n    }\n  }\n  uVar9 = 0;\n  do {\n    do {\n      pbVar8 = pbVar8 + 1;\n    } while (param_4 == *pbVar8);\n    uVar9 = uVar9 + 1;\n  } while (*pbVar8 - 0x30 < 10);\n  if (uVar9 != uVar11) {\n    return (-(uint)(uVar11 < uVar9) & 2) - 1;\n  }\n  goto LAB_004109f0;\nLAB_004108f0:\n  if ((param_3 == uVar3) && (9 < uVar10 - 0x30)) {\nLAB_00410a2e:\n    if (bVar5 == *param_1) {\n      iVar6 = (int)(char)param_1[1];\n      pbVar4 = pbVar8;\n      if (bVar5 != *pbVar8) {\n        pbVar8 = param_1 + 1;\nLAB_00410b37:\n        while ((char)iVar6 == '0') {\n          pbVar8 = pbVar8 + 1;\n          iVar6 = (int)(char)*pbVar8;\n        }\n        return (uint)(iVar6 - 0x30U < 10);\n      }\n      while( true ) {\n        pbVar4 = pbVar4 + 1;\n        bVar7 = *pbVar4;\n        bVar5 = (byte)iVar6;\n        pbVar8 = param_1 + 1;\n        uVar10 = (int)(char)bVar5 - 0x30;\n        if (bVar7 != bVar5) break;\n        if (9 < uVar10) {\n          return 0;\n        }\n        iVar6 = (int)(char)param_1[2];\n        param_1 = pbVar8;\n      }\n      uVar3 = (int)(char)bVar7 - 0x30;\n      if (uVar10 < 10) {\n        if (uVar3 < 10) {\n          return (int)(char)bVar5 - (int)(char)bVar7;\n        }\n        goto LAB_00410b37;\n      }\n      if (9 < uVar3) {\n        return 0;\n      }\n    }\n    else {\n      if (bVar5 != *pbVar8) {\n        return 0;\n      }\n      pbVar4 = pbVar8 + 1;\n      bVar7 = pbVar8[1];\n    }\n    while (bVar7 == 0x30) {\n      pbVar4 = pbVar4 + 1;\n      bVar7 = *pbVar4;\n    }\nLAB_00410a5f:\n    return -(uint)((int)(char)bVar7 - 0x30U < 10);\n  }\n  if (param_3 == uVar10) {\n    if (9 < uVar3 - 0x30) goto LAB_00410a2e;\n    uVar2 = uVar3 - param_3;\n    uVar10 = param_3 - 0x30;\nLAB_00410916:\n    uVar11 = 0;\n    do {\n      do {\n        param_1 = param_1 + 1;\n      } while (param_4 == *param_1);\n      uVar11 = uVar11 + 1;\n    } while (*param_1 - 0x30 < 10);\n    if (9 < uVar10) {\n      return (uint)(uVar11 != 0);\n    }\n  }\n  else {\n    uVar2 = uVar3 - uVar10;\n    uVar10 = uVar10 - 0x30;\n    if (uVar3 - 0x30 < 10) goto LAB_00410916;\n    uVar11 = 0;\n    if (9 < uVar10) {\n      return 0;\n    }\n  }\n  uVar9 = 0;\n  do {\n    do {\n      pbVar8 = pbVar8 + 1;\n    } while (param_4 == *pbVar8);\n    uVar9 = uVar9 + 1;\n  } while (*pbVar8 - 0x30 < 10);\n  if (uVar9 != uVar11) {\n    return -(uint)(uVar11 < uVar9) | 1;\n  }\nLAB_004109f0:\n  if (uVar9 == 0) {\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
            "funcName": "FUN_004106a0"
        },
        {
            "funcStartAddr": "0x410c20",
            "funcEndAddr": "0x410c6c",
            "decompiledFuncCode": "\nuint FUN_00410c20(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  \n  if (2 < param_1) {\n    return param_1;\n  }\n  uVar2 = FUN_00413ea0();\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  close(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00410c20"
        },
        {
            "funcStartAddr": "0x410c70",
            "funcEndAddr": "0x411014",
            "decompiledFuncCode": "\nundefined8\nFUN_00410c70(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5,\n            undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_004179da,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e1);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00410eec;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_00410eec:\n    __fprintf_chk(param_1,1,uVar7,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[1];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar1 = param_5[2];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_00410f89;\n  case 7:\n    uVar1 = param_5[2];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    local_58 = param_5[1];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_00410f89:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_58,uVar1,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00410d6a;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_00410d6a:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_50,local_58,uVar6,uVar5,uVar4,uVar1,local_48);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00410c70"
        },
        {
            "funcStartAddr": "0x411050",
            "funcEndAddr": "0x411070",
            "decompiledFuncCode": "\nvoid FUN_00411050(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  FUN_00410c70();\n  return;\n}\n\n",
            "funcName": "FUN_00411050"
        },
        {
            "funcStartAddr": "0x411070",
            "funcEndAddr": "0x4110c9",
            "decompiledFuncCode": "\nvoid FUN_00411070(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long local_58 [11];\n  \n  lVar4 = 0;\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_58[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_58[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_00410c70();\n  return;\n}\n\n",
            "funcName": "FUN_00411070"
        },
        {
            "funcStartAddr": "0x4110d0",
            "funcEndAddr": "0x411188",
            "decompiledFuncCode": "\nvoid FUN_004110d0(void)\n\n{\n  long lVar1;\n  undefined8 in_R8;\n  ulong uVar2;\n  undefined8 in_R9;\n  long lVar3;\n  long *plVar4;\n  long local_88 [10];\n  long local_38 [4];\n  long local_18 [3];\n  \n  local_18[0] = in_R8;\n  plVar4 = (long *)&stack0x00000008;\n  uVar2 = 0x20;\n  local_18[1] = in_R9;\n  lVar3 = 0;\n  do {\n    if ((uint)uVar2 < 0x30) {\n      lVar1 = *(long *)((long)local_38 + uVar2);\n      local_88[lVar3] = lVar1;\n      uVar2 = (ulong)((uint)uVar2 + 8);\n    }\n    else {\n      lVar1 = *plVar4;\n      local_88[lVar3] = lVar1;\n      plVar4 = plVar4 + 1;\n    }\n  } while ((lVar1 != 0) && (lVar3 = lVar3 + 1, lVar3 != 10));\n  FUN_00410c70();\n  return;\n}\n\n",
            "funcName": "FUN_004110d0"
        },
        {
            "funcStartAddr": "0x411190",
            "funcEndAddr": "0x411204",
            "decompiledFuncCode": "\nvoid FUN_00411190(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n",
            "funcName": "FUN_00411190"
        },
        {
            "funcStartAddr": "0x411210",
            "funcEndAddr": "0x41122a",
            "decompiledFuncCode": "\nvoid FUN_00411210(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00411460();\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00411210"
        },
        {
            "funcStartAddr": "0x411230",
            "funcEndAddr": "0x411251",
            "decompiledFuncCode": "\nvoid FUN_00411230(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    FUN_00411210();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_00411230"
        },
        {
            "funcStartAddr": "0x411260",
            "funcEndAddr": "0x411262",
            "decompiledFuncCode": "\nvoid thunk_FUN_00411210(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00411460();\n  }\n  return;\n}\n\n",
            "funcName": "thunk_411260"
        },
        {
            "funcStartAddr": "0x411270",
            "funcEndAddr": "0x4112a0",
            "decompiledFuncCode": "\nvoid * FUN_00411270(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00411460();\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "FUN_00411270"
        },
        {
            "funcStartAddr": "0x4112b0",
            "funcEndAddr": "0x4112d1",
            "decompiledFuncCode": "\nvoid FUN_004112b0(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    FUN_00411270();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_004112b0"
        },
        {
            "funcStartAddr": "0x4112e0",
            "funcEndAddr": "0x411358",
            "decompiledFuncCode": "\nvoid FUN_004112e0(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar2 = *param_2;\n  if (param_1 == 0) {\n    if (uVar2 == 0) {\n      uVar2 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar3 = (ulong)(SUB168(ZEXT816(uVar2) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar2) * ZEXT816(param_3),0) < 0) || (uVar3 != 0)) goto LAB_0041133b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar3 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar2) {\nLAB_0041133b:\n                    /* WARNING: Subroutine does not return */\n      FUN_00411460(param_1,param_2,uVar3);\n    }\n    uVar2 = (uVar2 >> 1) + 1 + uVar2;\n  }\n  *param_2 = uVar2;\n  FUN_00411270(param_1,uVar2 * param_3);\n  return;\n}\n\n",
            "funcName": "FUN_004112e0"
        },
        {
            "funcStartAddr": "0x411370",
            "funcEndAddr": "0x4113ba",
            "decompiledFuncCode": "\nvoid FUN_00411370(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = *param_2;\n  if (param_1 == 0) {\n    if (uVar1 == 0) {\n      *param_2 = 0x80;\n      FUN_00411270(0,0x80);\n      return;\n    }\n    if ((long)uVar1 < 0) goto LAB_004113ba;\n  }\n  else {\n    if (0x5555555555555553 < uVar1) {\nLAB_004113ba:\n                    /* WARNING: Subroutine does not return */\n      FUN_00411460();\n    }\n    uVar1 = (uVar1 >> 1) + 1 + uVar1;\n  }\n  *param_2 = uVar1;\n  FUN_00411270(param_1,uVar1);\n  return;\n}\n\n",
            "funcName": "FUN_00411370"
        },
        {
            "funcStartAddr": "0x4113c0",
            "funcEndAddr": "0x4113d7",
            "decompiledFuncCode": "\nvoid FUN_004113c0(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_00411210();\n  memset(__s,0,param_1);\n  return;\n}\n\n",
            "funcName": "FUN_004113c0"
        },
        {
            "funcStartAddr": "0x4113e0",
            "funcEndAddr": "0x41140e",
            "decompiledFuncCode": "\nvoid FUN_004113e0(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00411460();\n}\n\n",
            "funcName": "FUN_004113e0"
        },
        {
            "funcStartAddr": "0x411410",
            "funcEndAddr": "0x411438",
            "decompiledFuncCode": "\nvoid FUN_00411410(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)FUN_00411210(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00411410"
        },
        {
            "funcStartAddr": "0x411440",
            "funcEndAddr": "0x411453",
            "decompiledFuncCode": "\nvoid FUN_00411440(char *param_1)\n\n{\n  void *__dest;\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  __dest = (void *)FUN_00411210(sVar1 + 1);\n  memcpy(__dest,param_1,sVar1 + 1);\n  return;\n}\n\n",
            "funcName": "FUN_00411440"
        },
        {
            "funcStartAddr": "0x411460",
            "funcEndAddr": "0x41148c",
            "decompiledFuncCode": "\nvoid FUN_00411460(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n  error(DAT_0061c518,0,&DAT_00416abc,uVar1);\n}\n\n",
            "funcName": "FUN_00411460"
        },
        {
            "funcStartAddr": "0x4114a0",
            "funcEndAddr": "0x4114d7",
            "decompiledFuncCode": "\nvoid FUN_004114a0(undefined4 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"string comparison failed\",5);\n                    /* WARNING: Subroutine does not return */\n  error(0,param_1,uVar1);\n}\n\n",
            "funcName": "FUN_004114a0"
        },
        {
            "funcStartAddr": "0x411560",
            "funcEndAddr": "0x4115b0",
            "decompiledFuncCode": "\nundefined4 FUN_00411560(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  \n  uVar1 = FUN_00413d80();\n  piVar2 = __errno_location();\n  if (*piVar2 == 0) {\n    return uVar1;\n  }\n  FUN_004114a0(*piVar2,param_1,param_2,param_3,param_4);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00411560"
        },
        {
            "funcStartAddr": "0x4115c0",
            "funcEndAddr": "0x411612",
            "decompiledFuncCode": "\nundefined4 FUN_004115c0(undefined8 param_1,long param_2,undefined8 param_3,long param_4)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  \n  uVar1 = FUN_00413e30();\n  piVar2 = __errno_location();\n  if (*piVar2 == 0) {\n    return uVar1;\n  }\n  FUN_004114a0(*piVar2,param_1,param_2 + -1,param_3,param_4 + -1);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_004115c0"
        },
        {
            "funcStartAddr": "0x411620",
            "funcEndAddr": "0x41166a",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 FUN_00411620(void)\n\n{\n  uint *puVar1;\n  undefined8 uVar2;\n  undefined local_18 [16];\n  \n  local_18 = FUN_00413580();\n  puVar1 = (uint *)__errno_location();\n  do {\n    *puVar1 = 0;\n    uVar2 = FUN_00413140(local_18,0);\n    if ((int)uVar2 == 0) {\n      return uVar2;\n    }\n  } while ((*puVar1 & 0xfffffffb) == 0);\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_00411620"
        },
        {
            "funcStartAddr": "0x411680",
            "funcEndAddr": "0x411a2c",
            "decompiledFuncCode": "\nulong FUN_00411680(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint uVar9;\n  int iVar10;\n  ulong uVar11;\n  byte bVar12;\n  uint uVar13;\n  ulong uVar14;\n  int iVar15;\n  int iVar16;\n  byte *local_40 [2];\n  \n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoul\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = local_40;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar12 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar12 * 2 + 1) & 0x20) != 0) {\n    pbVar5 = pbVar5 + 1;\n    bVar12 = *pbVar5;\n  }\n  if (bVar12 == 0x2d) {\n    return 4;\n  }\n  uVar6 = strtoul((char *)param_1,(char **)param_2,param_3);\n  pbVar5 = *param_2;\n  if (pbVar5 == param_1) {\n    if ((param_5 == (char *)0x0) || (bVar12 = *param_1, bVar12 == 0)) {\n      return 4;\n    }\n    uVar14 = 0;\n    uVar6 = 1;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) {\n      return 4;\n    }\n  }\n  else {\n    if (*piVar3 == 0) {\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = 1;\n      if (*piVar3 != 0x22) {\n        return 4;\n      }\n    }\n    uVar13 = (uint)uVar14;\n    if ((param_5 == (char *)0x0) || (bVar12 = *pbVar5, bVar12 == 0)) goto LAB_00411720;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) goto switchD_004117fc_caseD_1;\n  }\n  uVar13 = (uint)uVar14;\n  uVar9 = bVar12 - 0x45;\n  bVar8 = (byte)uVar9;\n  if (((bVar8 < 0x30) && ((0x814400308945U >> ((ulong)uVar9 & 0x3f) & 1) != 0)) &&\n     (pcVar7 = strchr(param_5,0x30), pcVar7 != (char *)0x0)) {\n    bVar1 = pbVar5[1];\n    if (bVar1 != 0x44) {\n      if (bVar1 == 0x69) {\n        uVar11 = 0x400;\n        iVar15 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n        goto LAB_004117ea;\n      }\n      if (bVar1 != 0x42) {\n                    /* WARNING: Could not recover jumptable at 0x004117d9. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar6 = (*(code *)(&PTR_LAB_00417e10)[bVar8])();\n        return uVar6;\n      }\n    }\n    iVar15 = 2;\n    uVar11 = 1000;\n  }\n  else {\n    iVar15 = 1;\n    uVar11 = 0x400;\n  }\nLAB_004117ea:\n  iVar10 = (int)uVar11;\n  switch(bVar12 - 0x42 & 0xff) {\n  case 0:\n    if (uVar6 >> 0x36 == 0) {\n      uVar6 = uVar6 << 10;\n      break;\n    }\n    goto LAB_00411857;\n  default:\nswitchD_004117fc_caseD_1:\n    *param_4 = uVar6;\n    return (ulong)(uVar13 | 2);\n  case 3:\n    iVar16 = 6;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_004118e4;\n  case 5:\n  case 0x25:\n    uVar11 = (ulong)iVar10;\n    if (((SUB168(ZEXT816(uVar6) * ZEXT816(uVar11) >> 0x40,0) != 0) ||\n        (auVar2 = (ZEXT816(uVar6) * ZEXT816(uVar11) & (undefined  [16])0xffffffffffffffff) *\n                  ZEXT816(uVar11), SUB168(auVar2 >> 0x40,0) != 0)) ||\n       (auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816(uVar11),\n       uVar6 = SUB168(auVar2,0), SUB168(auVar2 >> 0x40,0) != 0)) {\n      uVar6 = 0xffffffffffffffff;\n      uVar14 = 1;\n    }\n    break;\n  case 9:\n  case 0x29:\n    auVar2 = ZEXT816(uVar6) * ZEXT816(uVar11);\n    goto joined_r0x0041181c;\n  case 0xb:\n  case 0x2b:\n    auVar2 = ZEXT816(uVar6) * ZEXT816((ulong)(long)iVar10);\n    if (SUB168(auVar2 >> 0x40,0) != 0) goto LAB_00411857;\n    auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816((ulong)(long)iVar10);\njoined_r0x0041181c:\n    uVar6 = SUB168(auVar2,0);\n    if (SUB168(auVar2 >> 0x40,0) != 0) {\nLAB_00411857:\n      uVar14 = 1;\n      uVar6 = 0xffffffffffffffff;\n    }\n    break;\n  case 0xe:\n    iVar16 = 5;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_004118e4;\n  case 0x12:\n  case 0x32:\n    iVar16 = 4;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_004118e4;\n  case 0x17:\n    iVar16 = 8;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_004118e4;\n  case 0x18:\n    iVar16 = 7;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\nLAB_004118e4:\n    uVar14 = (ulong)(uVar13 | uVar9);\n    break;\n  case 0x20:\n    if (uVar6 >> 0x37 != 0) goto LAB_00411857;\n    uVar6 = uVar6 << 9;\n    break;\n  case 0x21:\n    break;\n  case 0x35:\n    if ((long)uVar6 < 0) goto LAB_00411857;\n    uVar6 = uVar6 * 2;\n  }\n  *param_2 = pbVar5 + iVar15;\n  if (pbVar5[iVar15] != 0) {\n    uVar14 = (ulong)((uint)uVar14 | 2);\n  }\nLAB_00411720:\n  *param_4 = uVar6;\n  return uVar14;\n}\n\n",
            "funcName": "FUN_00411680"
        },
        {
            "funcStartAddr": "0x411ab0",
            "funcEndAddr": "0x411b2c",
            "decompiledFuncCode": "\nvoid FUN_00411ab0(int param_1,int param_2,undefined param_3,long param_4,undefined8 param_5)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined1 *puVar3;\n  undefined *puVar4;\n  undefined local_2a;\n  undefined local_29;\n  \n  uVar1 = DAT_0061c518;\n  if (param_1 - 1U < 4) {\n    if (param_2 < 0) {\n      puVar4 = &local_2a;\n      puVar3 = &DAT_00418149 + -(long)param_2;\n      local_29 = 0;\n      local_2a = param_3;\n    }\n    else {\n      puVar3 = &DAT_00418149;\n      puVar4 = *(undefined **)(param_4 + (long)param_2 * 0x20);\n    }\n    uVar2 = dcgettext(0,(&PTR_s__s_s_argument___s__too_large_004181c0)[param_1 - 1U],5);\n                    /* WARNING: Subroutine does not return */\n    error(uVar1,0,uVar2,puVar3,puVar4,param_5);\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00411ab0"
        },
        {
            "funcStartAddr": "0x411b40",
            "funcEndAddr": "0x411eee",
            "decompiledFuncCode": "\nulong FUN_00411b40(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint uVar9;\n  int iVar10;\n  ulong uVar11;\n  byte bVar12;\n  uint uVar13;\n  ulong uVar14;\n  int iVar15;\n  int iVar16;\n  byte *local_40 [2];\n  \n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = local_40;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar12 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar12 * 2 + 1) & 0x20) != 0) {\n    pbVar5 = pbVar5 + 1;\n    bVar12 = *pbVar5;\n  }\n  if (bVar12 == 0x2d) {\n    return 4;\n  }\n  uVar6 = __strtoul_internal(param_1,param_2,param_3,0);\n  pbVar5 = *param_2;\n  if (pbVar5 == param_1) {\n    if ((param_5 == (char *)0x0) || (bVar12 = *param_1, bVar12 == 0)) {\n      return 4;\n    }\n    uVar14 = 0;\n    uVar6 = 1;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) {\n      return 4;\n    }\n  }\n  else {\n    if (*piVar3 == 0) {\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = 1;\n      if (*piVar3 != 0x22) {\n        return 4;\n      }\n    }\n    uVar13 = (uint)uVar14;\n    if ((param_5 == (char *)0x0) || (bVar12 = *pbVar5, bVar12 == 0)) goto LAB_00411be2;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) goto switchD_00411ccc_caseD_1;\n  }\n  uVar13 = (uint)uVar14;\n  uVar9 = bVar12 - 0x45;\n  bVar8 = (byte)uVar9;\n  if (((bVar8 < 0x30) && ((0x814400308945U >> ((ulong)uVar9 & 0x3f) & 1) != 0)) &&\n     (pcVar7 = strchr(param_5,0x30), pcVar7 != (char *)0x0)) {\n    bVar1 = pbVar5[1];\n    if (bVar1 != 0x44) {\n      if (bVar1 == 0x69) {\n        uVar11 = 0x400;\n        iVar15 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n        goto LAB_00411cba;\n      }\n      if (bVar1 != 0x42) {\n                    /* WARNING: Could not recover jumptable at 0x00411ca1. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar6 = (*(code *)(&PTR_LAB_004181e0)[bVar8])();\n        return uVar6;\n      }\n    }\n    iVar15 = 2;\n    uVar11 = 1000;\n  }\n  else {\n    iVar15 = 1;\n    uVar11 = 0x400;\n  }\nLAB_00411cba:\n  iVar10 = (int)uVar11;\n  switch(bVar12 - 0x42 & 0xff) {\n  case 0:\n    if (uVar6 >> 0x36 == 0) {\n      uVar6 = uVar6 << 10;\n      break;\n    }\n    goto LAB_00411d27;\n  default:\nswitchD_00411ccc_caseD_1:\n    *param_4 = uVar6;\n    return (ulong)(uVar13 | 2);\n  case 3:\n    iVar16 = 6;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00411db4;\n  case 5:\n  case 0x25:\n    uVar11 = (ulong)iVar10;\n    if (((SUB168(ZEXT816(uVar6) * ZEXT816(uVar11) >> 0x40,0) != 0) ||\n        (auVar2 = (ZEXT816(uVar6) * ZEXT816(uVar11) & (undefined  [16])0xffffffffffffffff) *\n                  ZEXT816(uVar11), SUB168(auVar2 >> 0x40,0) != 0)) ||\n       (auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816(uVar11),\n       uVar6 = SUB168(auVar2,0), SUB168(auVar2 >> 0x40,0) != 0)) {\n      uVar6 = 0xffffffffffffffff;\n      uVar14 = 1;\n    }\n    break;\n  case 9:\n  case 0x29:\n    auVar2 = ZEXT816(uVar6) * ZEXT816(uVar11);\n    goto joined_r0x00411cec;\n  case 0xb:\n  case 0x2b:\n    auVar2 = ZEXT816(uVar6) * ZEXT816((ulong)(long)iVar10);\n    if (SUB168(auVar2 >> 0x40,0) != 0) goto LAB_00411d27;\n    auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816((ulong)(long)iVar10);\njoined_r0x00411cec:\n    uVar6 = SUB168(auVar2,0);\n    if (SUB168(auVar2 >> 0x40,0) != 0) {\nLAB_00411d27:\n      uVar14 = 1;\n      uVar6 = 0xffffffffffffffff;\n    }\n    break;\n  case 0xe:\n    iVar16 = 5;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00411db4;\n  case 0x12:\n  case 0x32:\n    iVar16 = 4;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00411db4;\n  case 0x17:\n    iVar16 = 8;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00411db4;\n  case 0x18:\n    iVar16 = 7;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\nLAB_00411db4:\n    uVar14 = (ulong)(uVar13 | uVar9);\n    break;\n  case 0x20:\n    if (uVar6 >> 0x37 != 0) goto LAB_00411d27;\n    uVar6 = uVar6 << 9;\n    break;\n  case 0x21:\n    break;\n  case 0x35:\n    if ((long)uVar6 < 0) goto LAB_00411d27;\n    uVar6 = uVar6 * 2;\n  }\n  *param_2 = pbVar5 + iVar15;\n  if (pbVar5[iVar15] != 0) {\n    uVar14 = (ulong)((uint)uVar14 | 2);\n  }\nLAB_00411be2:\n  *param_4 = uVar6;\n  return uVar14;\n}\n\n",
            "funcName": "FUN_00411b40"
        },
        {
            "funcStartAddr": "0x411f80",
            "funcEndAddr": "0x411ff8",
            "decompiledFuncCode": "\nint FUN_00411f80(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00411fe7;\n    }\n    iVar1 = FUN_00412140(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00411fe7:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_00411f80"
        },
        {
            "funcStartAddr": "0x412000",
            "funcEndAddr": "0x41212c",
            "decompiledFuncCode": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint FUN_00412000(ulong param_1,int param_2,ulong param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  int *piVar4;\n  \n  if (param_2 != 0x406) {\n    iVar1 = fcntl((int)param_1,param_2,param_3);\n    return iVar1;\n  }\n  if (DAT_0061cd18 < 0) {\n    iVar1 = FUN_00412000(param_1,0,param_3 & 0xffffffff);\n    if (iVar1 < 0) {\n      return iVar1;\n    }\n    if (DAT_0061cd18 != -1) {\n      return iVar1;\n    }\n  }\n  else {\n    iVar1 = fcntl((int)param_1,0x406);\n    if ((-1 < iVar1) || (piVar4 = __errno_location(), *piVar4 != 0x16)) {\n      DAT_0061cd18 = 1;\n      return iVar1;\n    }\n    iVar1 = FUN_00412000(param_1 & 0xffffffff,0,param_3 & 0xffffffff);\n    if (iVar1 < 0) {\n      return iVar1;\n    }\n    DAT_0061cd18 = -1;\n  }\n  uVar2 = fcntl(iVar1,1);\n  if ((-1 < (int)uVar2) && (iVar3 = fcntl(iVar1,2,(ulong)(uVar2 | 1)), iVar3 != -1)) {\n    return iVar1;\n  }\n  piVar4 = __errno_location();\n  iVar3 = *piVar4;\n  close(iVar1);\n  *piVar4 = iVar3;\n  return -1;\n}\n\n",
            "funcName": "FUN_00412000"
        },
        {
            "funcStartAddr": "0x412140",
            "funcEndAddr": "0x41217b",
            "decompiledFuncCode": "\nvoid FUN_00412140(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if ((iVar1 != 0) && ((param_1->_flags & 0x100U) != 0)) {\n      FUN_00412180(param_1,0,1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00412140"
        },
        {
            "funcStartAddr": "0x412180",
            "funcEndAddr": "0x4121d6",
            "decompiledFuncCode": "\nulong FUN_00412180(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  uint uVar1;\n  int __fd;\n  ulong uVar2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    __fd = fileno(param_1);\n    uVar2 = lseek(__fd,param_2,param_3);\n    if (uVar2 != 0xffffffffffffffff) {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = uVar2;\n      uVar2 = 0;\n    }\n    return uVar2;\n  }\n  uVar1 = fseeko(param_1,param_2,param_3);\n  return (ulong)uVar1;\n}\n\n",
            "funcName": "FUN_00412180"
        },
        {
            "funcStartAddr": "0x4121e0",
            "funcEndAddr": "0x4122b5",
            "decompiledFuncCode": "\nvoid FUN_004121e0(long param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  iVar1 = param_2[0xb];\n  iVar2 = *param_2;\n  iVar3 = param_2[0xc];\n  iVar8 = iVar1;\n  iVar9 = iVar2;\n  while (iVar3 < iVar9) {\n    while( true ) {\n      if (iVar3 <= iVar8) goto LAB_0041225c;\n      iVar10 = iVar9 - iVar3;\n      iVar7 = iVar3 - iVar8;\n      if (iVar10 <= iVar7) break;\n      lVar6 = (long)iVar8;\n      iVar9 = iVar9 - iVar7;\n      puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n      do {\n        uVar4 = *puVar5;\n        *puVar5 = puVar5[iVar9 - lVar6];\n        puVar5[iVar9 - lVar6] = uVar4;\n        puVar5 = puVar5 + 1;\n      } while ((undefined8 *)(param_1 + 8 + ((ulong)(iVar7 - 1) + lVar6) * 8) != puVar5);\n      if (iVar9 <= iVar3) goto LAB_0041225c;\n    }\n    lVar6 = (long)iVar8;\n    puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n    do {\n      uVar4 = *puVar5;\n      *puVar5 = puVar5[iVar3 - lVar6];\n      puVar5[iVar3 - lVar6] = uVar4;\n      puVar5 = puVar5 + 1;\n    } while (puVar5 != (undefined8 *)(param_1 + 8 + ((ulong)(iVar10 - 1) + lVar6) * 8));\n    iVar8 = iVar8 + iVar10;\n  }\nLAB_0041225c:\n  param_2[0xc] = iVar2;\n  param_2[0xb] = iVar1 + (iVar2 - iVar3);\n  return;\n}\n\n",
            "funcName": "FUN_004121e0"
        },
        {
            "funcStartAddr": "0x4122c0",
            "funcEndAddr": "0x4128be",
            "decompiledFuncCode": "\nint FUN_004122c0(int param_1,undefined8 *param_2,char *param_3,char **param_4,undefined4 *param_5,\n                int param_6,int *param_7,int param_8,undefined8 param_9)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  char **ppcVar12;\n  char *pcVar13;\n  char *__s1;\n  FILE *__stream;\n  ulong uVar14;\n  size_t sVar15;\n  char *__s1_00;\n  long lVar16;\n  char *local_70;\n  uint local_44;\n  \n  pcVar13 = *(char **)(param_7 + 8);\n  cVar1 = *pcVar13;\n  pcVar11 = pcVar13;\n  if ((cVar1 == '=') || (cVar1 == '\\0')) {\n    sVar15 = 0;\n  }\n  else {\n    do {\n      pcVar11 = pcVar11 + 1;\n      if (*pcVar11 == '\\0') break;\n    } while (*pcVar11 != '=');\n    sVar15 = (long)pcVar11 - (long)pcVar13;\n  }\n  uVar14 = 0;\n  __s1 = *param_4;\n  ppcVar10 = param_4;\n  __s1_00 = __s1;\n  if (__s1 != (char *)0x0) {\n    while( true ) {\n      iVar5 = strncmp(__s1_00,pcVar13,sVar15);\n      if ((iVar5 == 0) && (sVar7 = strlen(__s1_00), sVar7 == sVar15)) goto LAB_004124e0;\n      ppcVar10 = ppcVar10 + 4;\n      __s1_00 = *ppcVar10;\n      iVar5 = (int)uVar14 + 1;\n      if (__s1_00 == (char *)0x0) break;\n      uVar14 = (ulong)iVar5;\n    }\n    lVar16 = 0;\n    ppcVar10 = (char **)0x0;\n    local_44 = 0xffffffff;\n    bVar3 = false;\n    bVar4 = false;\n    local_70 = (char *)0x0;\n    ppcVar12 = param_4;\n    do {\n      iVar6 = strncmp(__s1,pcVar13,sVar15);\n      if (iVar6 == 0) {\n        if (ppcVar10 == (char **)0x0) {\n          local_44 = (uint)lVar16;\n          ppcVar10 = ppcVar12;\n        }\n        else if (((((param_6 != 0) || (*(int *)(ppcVar10 + 1) != *(int *)(ppcVar12 + 1))) ||\n                  (ppcVar10[2] != ppcVar12[2])) ||\n                 (*(int *)(ppcVar10 + 3) != *(int *)(ppcVar12 + 3))) && (!bVar3)) {\n          if (param_8 == 0) {\n            bVar3 = true;\n            if (local_70 == (char *)0x0) goto LAB_00412420;\n          }\n          else if (local_70 == (char *)0x0) {\n            local_70 = (char *)calloc((long)iVar5,1);\n            if (local_70 == (char *)0x0) {\n              bVar3 = true;\n              goto LAB_00412420;\n            }\n            bVar4 = true;\n            local_70[(int)local_44] = '\\x01';\n          }\n          local_70[lVar16] = '\\x01';\n        }\n      }\nLAB_00412420:\n      ppcVar12 = ppcVar12 + 4;\n      __s1 = *ppcVar12;\n      lVar16 = lVar16 + 1;\n    } while (__s1 != (char *)0x0);\n    if ((local_70 != (char *)0x0) || (bVar3)) {\n      if (param_8 != 0) {\n        if (bVar3) {\n          uVar2 = *param_2;\n          uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous\\n\",5);\n          __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n        else {\n          flockfile(stderr);\n          uVar2 = *(undefined8 *)(param_7 + 8);\n          uVar8 = *param_2;\n          uVar9 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous; possibilities:\",5);\n          __fprintf_chk(stderr,1,uVar9,uVar8,param_9,uVar2);\n          pcVar13 = local_70;\n          __stream = stderr;\n          do {\n            if (*pcVar13 != '\\0') {\n              __fprintf_chk(__stream,1,\" \\'%s%s\\'\",param_9,*param_4);\n              __stream = stderr;\n            }\n            pcVar13 = pcVar13 + 1;\n            param_4 = param_4 + 4;\n          } while (local_70 + uVar14 + 1 != pcVar13);\n          fputc(10,__stream);\n          funlockfile(stderr);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n      }\n      if (bVar4) {\n        free(local_70);\n      }\n      sVar15 = strlen(pcVar13);\n      *(char **)(param_7 + 8) = pcVar13 + sVar15;\n      *param_7 = *param_7 + 1;\n      param_7[2] = 0;\n      return 0x3f;\n    }\n    if (ppcVar10 != (char **)0x0) {\n      uVar14 = (ulong)local_44;\nLAB_004124e0:\n      iVar6 = *param_7;\n      *(undefined8 *)(param_7 + 8) = 0;\n      iVar5 = iVar6 + 1;\n      *param_7 = iVar5;\n      if (*pcVar11 == '\\0') {\n        if (*(int *)(ppcVar10 + 1) == 1) {\n          if (param_1 <= iVar5) {\n            if (param_8 != 0) {\n              pcVar13 = *ppcVar10;\n              uVar2 = *param_2;\n              uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' requires an argument\\n\",5);\n              __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n            }\n            param_7[2] = *(int *)(ppcVar10 + 3);\n            return (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          *param_7 = iVar6 + 2;\n          *(undefined8 *)(param_7 + 4) = param_2[iVar5];\n        }\n      }\n      else {\n        if (*(int *)(ppcVar10 + 1) == 0) {\n          if (param_8 != 0) {\n            pcVar13 = *ppcVar10;\n            uVar2 = *param_2;\n            uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' doesn\\'t allow an argument\\n\",5);\n            __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          }\n          param_7[2] = *(int *)(ppcVar10 + 3);\n          return 0x3f;\n        }\n        *(char **)(param_7 + 4) = pcVar11 + 1;\n      }\n      if (param_5 != (undefined4 *)0x0) {\n        *param_5 = (int)uVar14;\n      }\n      if ((int *)ppcVar10[2] == (int *)0x0) {\n        return *(int *)(ppcVar10 + 3);\n      }\n      *(int *)ppcVar10[2] = *(int *)(ppcVar10 + 3);\n      return 0;\n    }\n  }\n  if (((param_6 != 0) && (*(char *)(param_2[*param_7] + 1) != '-')) &&\n     (pcVar11 = strchr(param_3,(int)cVar1), pcVar11 != (char *)0x0)) {\n    return -1;\n  }\n  if (param_8 != 0) {\n    uVar2 = *param_2;\n    uVar8 = dcgettext(0,\"%s: unrecognized option \\'%s%s\\'\\n\",5);\n    __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n  }\n  *(undefined8 *)(param_7 + 8) = 0;\n  *param_7 = *param_7 + 1;\n  param_7[2] = 0;\n  return 0x3f;\n}\n\n",
            "funcName": "FUN_004122c0"
        },
        {
            "funcStartAddr": "0x4128e0",
            "funcEndAddr": "0x412e47",
            "decompiledFuncCode": "\nuint FUN_004128e0(uint param_1,undefined8 *param_2,char *param_3,long param_4,undefined8 param_5,\n                 ulong param_6,uint *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long lVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  uint uVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  undefined1 *puVar15;\n  \n  bVar14 = 0;\n  uVar3 = param_7[1];\n  if ((int)param_1 < 1) {\n    return 0xffffffff;\n  }\n  uVar11 = *param_7;\n  *(undefined8 *)(param_7 + 4) = 0;\n  if (uVar11 == 0) {\n    *param_7 = 1;\n    uVar11 = 1;\nLAB_0041292a:\n    param_7[0xc] = uVar11;\n    param_7[0xb] = uVar11;\n    *(undefined8 *)(param_7 + 8) = 0;\n    if (*param_3 == '-') {\n      param_7[10] = 2;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else if (*param_3 == '+') {\n      param_7[10] = 0;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else {\n      pbVar8 = (byte *)0x0;\n      if (param_8 == 0) {\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        param_6 = param_6 & 0xffffffff;\n        if (pcVar4 == (char *)0x0) {\n          param_7[10] = 1;\n          pbVar8 = *(byte **)(param_7 + 8);\n          goto LAB_00412a2d;\n        }\n        pbVar8 = *(byte **)(param_7 + 8);\n      }\n      param_7[10] = 0;\n    }\nLAB_00412a2d:\n    param_7[6] = 1;\n    cVar2 = *param_3;\nLAB_00412a38:\n    if (cVar2 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 == (byte *)0x0) goto LAB_004129a8;\nLAB_00412a4c:\n    if (*pbVar8 == 0) goto LAB_004129a8;\n  }\n  else {\n    if (param_7[6] == 0) goto LAB_0041292a;\n    cVar2 = *param_3;\n    pbVar8 = *(byte **)(param_7 + 8);\n    if ((cVar2 - 0x2bU & 0xfd) != 0) goto LAB_00412a38;\n    pcVar4 = param_3 + 1;\n    param_3 = param_3 + 1;\n    if (*pcVar4 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 != (byte *)0x0) goto LAB_00412a4c;\nLAB_004129a8:\n    uVar11 = *param_7;\n    if (param_7[0xc] != uVar11 && (int)uVar11 <= (int)param_7[0xc]) {\n      param_7[0xc] = uVar11;\n    }\n    if ((int)uVar11 < (int)param_7[0xb]) {\n      param_7[0xb] = uVar11;\n    }\n    if (param_7[10] == 1) {\n      uVar7 = param_7[0xc];\n      if (param_7[0xb] == uVar7) {\n        if (uVar11 != uVar7) {\n          param_7[0xb] = uVar11;\n          uVar7 = uVar11;\n        }\n      }\n      else if (uVar11 != uVar7) {\n        FUN_004121e0(param_2,param_7);\n        param_6 = param_6 & 0xffffffff;\n        uVar7 = *param_7;\n      }\n      uVar11 = uVar7;\n      uVar7 = uVar11;\n      if ((int)uVar11 < (int)param_1) {\n        lVar6 = (long)(int)uVar11;\n        do {\n          if ((*(char *)param_2[lVar6] == '-') && (((char *)param_2[lVar6])[1] != '\\0')) {\n            uVar11 = *param_7;\n            uVar7 = (uint)lVar6;\n            break;\n          }\n          uVar11 = (uint)lVar6 + 1;\n          lVar6 = lVar6 + 1;\n          *param_7 = uVar11;\n          uVar7 = uVar11;\n        } while ((int)lVar6 < (int)param_1);\n      }\n      param_7[0xc] = uVar7;\n    }\n    bVar12 = param_1 < uVar11;\n    bVar13 = param_1 == uVar11;\n    if (bVar13) {\n      param_1 = param_7[0xc];\n      uVar11 = param_7[0xb];\nLAB_00412b16:\n      if (uVar11 != param_1) {\n        *param_7 = uVar11;\n      }\n      return 0xffffffff;\n    }\n    lVar6 = 3;\n    pbVar8 = (byte *)param_2[(int)uVar11];\n    pbVar9 = pbVar8;\n    pbVar10 = &DAT_00418149;\n    do {\n      if (lVar6 == 0) break;\n      lVar6 = lVar6 + -1;\n      bVar12 = *pbVar9 < *pbVar10;\n      bVar13 = *pbVar9 == *pbVar10;\n      pbVar9 = pbVar9 + (ulong)bVar14 * -2 + 1;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n    if ((!bVar12 && !bVar13) == bVar12) {\n      uVar11 = uVar11 + 1;\n      *param_7 = uVar11;\n      if (param_7[0xb] == param_7[0xc]) {\n        param_7[0xb] = uVar11;\n      }\n      else {\n        bVar12 = uVar11 != param_7[0xc];\n        uVar11 = param_7[0xb];\n        if (bVar12) {\n          FUN_004121e0(param_2,param_7);\n          uVar11 = param_7[0xb];\n        }\n      }\n      param_7[0xc] = param_1;\n      *param_7 = param_1;\n      goto LAB_00412b16;\n    }\n    if ((*pbVar8 != 0x2d) || (bVar14 = pbVar8[1], bVar14 == 0)) {\n      if (param_7[10] == 0) {\n        return 0xffffffff;\n      }\n      *(byte **)(param_7 + 4) = pbVar8;\n      *param_7 = uVar11 + 1;\n      return 1;\n    }\n    if (param_4 != 0) {\n      if (bVar14 == 0x2d) {\n        *(byte **)(param_7 + 8) = pbVar8 + 2;\n        puVar15 = &DAT_00418149;\n        goto LAB_00412c75;\n      }\n      if ((int)param_6 != 0) {\n        if (pbVar8[2] == 0) {\n          pcVar4 = strchr(param_3,(int)(char)bVar14);\n          param_6 = param_6 & 0xffffffff;\n          if (pcVar4 != (char *)0x0) goto LAB_00412c20;\n        }\n        *(byte **)(param_7 + 8) = pbVar8 + 1;\n        uVar11 = FUN_004122c0(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,\n                              &DAT_0041814a);\n        if (uVar11 != 0xffffffff) {\n          return uVar11;\n        }\n        pbVar8 = (byte *)param_2[(int)*param_7];\n      }\n    }\nLAB_00412c20:\n    pbVar8 = pbVar8 + 1;\n  }\n  pbVar9 = pbVar8 + 1;\n  *(byte **)(param_7 + 8) = pbVar9;\n  bVar14 = *pbVar8;\n  uVar11 = (uint)(char)bVar14;\n  pcVar4 = strchr(param_3,uVar11);\n  if (pbVar8[1] == 0) {\n    *param_7 = *param_7 + 1;\n  }\n  if (((byte)(bVar14 - 0x3a) < 2) || (pcVar4 == (char *)0x0)) {\n    if (uVar3 != 0) {\n      uVar1 = *param_2;\n      uVar5 = dcgettext(0,\"%s: invalid option -- \\'%c\\'\\n\",5);\n      __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n    }\n    param_7[2] = uVar11;\n    return 0x3f;\n  }\n  if (((*pcVar4 != 'W') || (param_4 == 0)) || (pcVar4[1] != ';')) {\n    if (pcVar4[1] == ':') {\n      if (pcVar4[2] == ':') {\n        if (pbVar8[1] == 0) {\n          *(undefined8 *)(param_7 + 4) = 0;\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = *param_7 + 1;\n        }\n      }\n      else {\n        uVar7 = *param_7;\n        if (pbVar8[1] == 0) {\n          if (param_1 == uVar7) {\n            if (uVar3 != 0) {\n              uVar1 = *param_2;\n              uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n              __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n            }\n            param_7[2] = uVar11;\n            uVar11 = (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          else {\n            uVar1 = param_2[(int)uVar7];\n            *param_7 = uVar7 + 1;\n            *(undefined8 *)(param_7 + 4) = uVar1;\n          }\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = uVar7 + 1;\n        }\n      }\n      *(undefined8 *)(param_7 + 8) = 0;\n      return uVar11;\n    }\n    return uVar11;\n  }\n  if (pbVar8[1] == 0) {\n    if (*param_7 == param_1) {\n      if (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n        __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n      }\n      param_7[2] = uVar11;\n      return (uint)(*param_3 != ':') * 5 + 0x3a;\n    }\n    pbVar9 = (byte *)param_2[(int)*param_7];\n  }\n  *(byte **)(param_7 + 8) = pbVar9;\n  param_6 = 0;\n  *(undefined8 *)(param_7 + 4) = 0;\n  puVar15 = &DAT_00418635;\nLAB_00412c75:\n  uVar3 = FUN_004122c0(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,puVar15);\n  return uVar3;\n}\n\n",
            "funcName": "FUN_004128e0"
        },
        {
            "funcStartAddr": "0x412eb0",
            "funcEndAddr": "0x412f06",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00412eb0(void)\n\n{\n  DAT_0061cd20 = DAT_0061c578._4_4_;\n  _DAT_0061cd24 = (undefined4)DAT_0061c578;\n  FUN_004128e0();\n  DAT_0061c578._4_4_ = DAT_0061cd20;\n  DAT_0061cd60 = DAT_0061cd30;\n  _DAT_0061c574 = DAT_0061cd28;\n  return;\n}\n\n",
            "funcName": "FUN_00412eb0"
        },
        {
            "funcStartAddr": "0x412f10",
            "funcEndAddr": "0x412f28",
            "decompiledFuncCode": "\nvoid FUN_00412f10(void)\n\n{\n  FUN_00412eb0();\n  return;\n}\n\n",
            "funcName": "FUN_00412f10"
        },
        {
            "funcStartAddr": "0x412f30",
            "funcEndAddr": "0x412f43",
            "decompiledFuncCode": "\nvoid FUN_00412f30(void)\n\n{\n  FUN_00412eb0();\n  return;\n}\n\n",
            "funcName": "FUN_00412f30"
        },
        {
            "funcStartAddr": "0x412f50",
            "funcEndAddr": "0x412f65",
            "decompiledFuncCode": "\nvoid FUN_00412f50(void)\n\n{\n  FUN_004128e0();\n  return;\n}\n\n",
            "funcName": "FUN_00412f50"
        },
        {
            "funcStartAddr": "0x412f70",
            "funcEndAddr": "0x412f86",
            "decompiledFuncCode": "\nvoid FUN_00412f70(void)\n\n{\n  FUN_00412eb0();\n  return;\n}\n\n",
            "funcName": "FUN_00412f70"
        },
        {
            "funcStartAddr": "0x412f90",
            "funcEndAddr": "0x412fa8",
            "decompiledFuncCode": "\nvoid FUN_00412f90(void)\n\n{\n  FUN_004128e0();\n  return;\n}\n\n",
            "funcName": "FUN_00412f90"
        },
        {
            "funcStartAddr": "0x412fb0",
            "funcEndAddr": "0x41301f",
            "decompiledFuncCode": "\nsize_t FUN_00412fb0(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  wchar_t local_1c;\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = 1;\n    param_2 = (byte *)0x416571;\n  }\n  else {\n    if (param_3 == 0) {\n      return 0xfffffffffffffffe;\n    }\n    if (param_1 != (wchar_t *)0x0) goto LAB_00412fd4;\n  }\n  param_1 = &local_1c;\nLAB_00412fd4:\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (cVar1 = FUN_0040bd10(0), cVar1 == '\\0')) {\n    sVar2 = 1;\n    *param_1 = (uint)*param_2;\n  }\n  return sVar2;\n}\n\n",
            "funcName": "FUN_00412fb0"
        },
        {
            "funcStartAddr": "0x413030",
            "funcEndAddr": "0x413113",
            "decompiledFuncCode": "\nulong * FUN_00413030(ulong *param_1,char param_2,ulong param_3)\n\n{\n  char cVar1;\n  ulong uVar2;\n  ulong *puVar3;\n  ulong uVar4;\n  \n  if (param_3 == 0) {\n    return (ulong *)0x0;\n  }\n  if (((ulong)param_1 & 7) == 0) {\nLAB_00413070:\n    uVar4 = (long)(int)(uint)CONCAT11(param_2,param_2) |\n            (long)(int)(uint)CONCAT11(param_2,param_2) << 0x10;\n    uVar4 = uVar4 | uVar4 << 0x20;\n    if (7 < param_3) {\n      uVar2 = *param_1 ^ uVar4;\n      for (uVar2 = ~uVar2 & uVar2 + 0xfefefefefefefeff; (uVar2 & 0x8080808080808080) == 0;\n          uVar2 = ~uVar2 & uVar2 + 0xfefefefefefefeff) {\n        param_3 = param_3 - 8;\n        param_1 = param_1 + 1;\n        if (param_3 < 8) {\n          if (param_3 == 0) {\n            return (ulong *)0x0;\n          }\n          break;\n        }\n        uVar2 = *param_1 ^ uVar4;\n      }\n    }\n    if (param_2 != *(char *)param_1) {\n      puVar3 = (ulong *)((long)param_1 + param_3);\n      do {\n        param_1 = (ulong *)((long)param_1 + 1);\n        if (param_1 == puVar3) {\n          return (ulong *)0x0;\n        }\n      } while (*(char *)param_1 != param_2);\n    }\n  }\n  else {\n    cVar1 = *(char *)param_1;\n    while (param_2 != cVar1) {\n      param_1 = (ulong *)((long)param_1 + 1);\n      param_3 = param_3 - 1;\n      if (param_3 == 0) {\n        return (ulong *)0x0;\n      }\n      if (((ulong)param_1 & 7) == 0) goto LAB_00413070;\n      cVar1 = *(char *)param_1;\n    }\n  }\n  return param_1;\n}\n\n",
            "funcName": "FUN_00413030"
        },
        {
            "funcStartAddr": "0x413140",
            "funcEndAddr": "0x4131d9",
            "decompiledFuncCode": "\nint FUN_00413140(long *param_1,timespec *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  timespec local_28;\n  \n  local_28.tv_nsec = param_1[1];\n  if ((ulong)local_28.tv_nsec < 1000000000) {\n    lVar3 = *param_1;\n    while (0x1fa400 < lVar3) {\n      local_28.tv_sec = 0x1fa400;\n      lVar3 = lVar3 + -0x1fa400;\n      iVar1 = nanosleep(&local_28,param_2);\n      if (iVar1 != 0) {\n        if (param_2 == (timespec *)0x0) {\n          return iVar1;\n        }\n        param_2->tv_sec = param_2->tv_sec + lVar3;\n        return iVar1;\n      }\n      local_28.tv_nsec = 0;\n    }\n    local_28.tv_sec = lVar3;\n    iVar1 = nanosleep(&local_28,param_2);\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = 0x16;\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
            "funcName": "FUN_00413140"
        },
        {
            "funcStartAddr": "0x4131f0",
            "funcEndAddr": "0x41322b",
            "decompiledFuncCode": "\nvoid FUN_004131f0(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  __fprintf_chk(stderr,1,\"%s\\n\",uVar1);\n                    /* WARNING: Subroutine does not return */\n  exit(DAT_0061c518);\n}\n\n",
            "funcName": "FUN_004131f0"
        },
        {
            "funcStartAddr": "0x413230",
            "funcEndAddr": "0x413245",
            "decompiledFuncCode": "\nvoid FUN_00413230(long param_1,undefined8 param_2)\n\n{\n  if ((*(byte *)(param_1 + 0x50) & 1) != 0) {\n                    /* WARNING: Could not recover jumptable at 0x0041323e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(param_1 + 0x38))(*(undefined8 *)(param_1 + 0x48));\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00413243. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(param_1 + 0x38))(param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00413230"
        },
        {
            "funcStartAddr": "0x413250",
            "funcEndAddr": "0x413265",
            "decompiledFuncCode": "\nvoid FUN_00413250(long param_1,undefined8 param_2)\n\n{\n  if ((*(byte *)(param_1 + 0x50) & 1) != 0) {\n                    /* WARNING: Could not recover jumptable at 0x0041325e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(param_1 + 0x40))(*(undefined8 *)(param_1 + 0x48));\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00413263. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(param_1 + 0x40))(param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00413250"
        },
        {
            "funcStartAddr": "0x413270",
            "funcEndAddr": "0x4132fd",
            "decompiledFuncCode": "\nundefined8 FUN_00413270(long *param_1,long param_2,long param_3,long param_4,long param_5)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  long *plVar4;\n  long lVar5;\n  \n  if (param_3 == 0) {\n    lVar5 = 0xf;\n    param_3 = 0x10;\n  }\n  else {\n    lVar5 = param_3 + -1;\n  }\n  param_1[6] = lVar5;\n  if (param_2 == 0) {\n    param_2 = 0xfe0;\n  }\n  *param_1 = param_2;\n  plVar4 = param_1;\n  plVar1 = (long *)FUN_00413230();\n  param_1[1] = (long)plVar1;\n  if (plVar1 != (long *)0x0) {\n    uVar3 = -param_3 & (long)plVar1 + lVar5 + 0x10;\n    lVar5 = *param_1;\n    param_1[2] = uVar3;\n    param_1[3] = uVar3;\n    *plVar1 = lVar5 + (long)plVar1;\n    param_1[4] = lVar5 + (long)plVar1;\n    plVar1[1] = 0;\n    *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xf9;\n    return 1;\n  }\n  (*(code *)obstack_alloc_failed_handler)();\n  *(byte *)(plVar4 + 10) = *(byte *)(plVar4 + 10) & 0xfe;\n  plVar4[7] = param_4;\n  plVar4[8] = param_5;\n  uVar2 = FUN_00413270();\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00413270"
        },
        {
            "funcStartAddr": "0x413300",
            "funcEndAddr": "0x413311",
            "decompiledFuncCode": "\nvoid _obstack_begin(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                   undefined8 param_5)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) & 0xfe;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  FUN_00413270();\n  return;\n}\n\n",
            "funcName": "obstack_begin"
        },
        {
            "funcStartAddr": "0x413320",
            "funcEndAddr": "0x413335",
            "decompiledFuncCode": "\nvoid _obstack_begin_1(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                     undefined8 param_5,undefined8 param_6)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 1;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  *(undefined8 *)(param_1 + 0x48) = param_6;\n  FUN_00413270();\n  return;\n}\n\n",
            "funcName": "obstack_begin_1"
        },
        {
            "funcStartAddr": "0x413340",
            "funcEndAddr": "0x413439",
            "decompiledFuncCode": "\nulong * _obstack_newchunk(ulong **param_1,ulong param_2)\n\n{\n  ulong *puVar1;\n  ulong **ppuVar2;\n  ulong *puVar3;\n  ulong *puVar4;\n  ulong **ppuVar5;\n  ulong __n;\n  \n  __n = (long)param_1[3] - (long)param_1[2];\n  puVar1 = param_1[1];\n  puVar4 = (ulong *)(param_2 + __n + (long)param_1[6]);\n  puVar3 = (ulong *)((long)puVar4 + (__n >> 3) + 100);\n  if (puVar4 <= *param_1) {\n    puVar4 = *param_1;\n  }\n  if (puVar3 <= puVar4) {\n    puVar3 = puVar4;\n  }\n  ppuVar5 = param_1;\n  if ((CARRY8(param_2,__n) == false) && (CARRY8(param_2 + __n,(ulong)param_1[6]) == false)) {\n    puVar4 = puVar3;\n    ppuVar2 = (ulong **)FUN_00413230();\n    if (ppuVar2 != (ulong **)0x0) {\n      param_1[1] = (ulong *)ppuVar2;\n      ppuVar2[1] = puVar1;\n      param_1[4] = (ulong *)((long)ppuVar2 + (long)puVar3);\n      *ppuVar2 = (ulong *)((long)ppuVar2 + (long)puVar3);\n      puVar4 = (ulong *)((long)(ppuVar2 + 2) + (long)param_1[6] & ~(ulong)param_1[6]);\n      puVar3 = (ulong *)memcpy(puVar4,param_1[2],__n);\n      if ((*(byte *)(param_1 + 10) & 2) == 0) {\n        puVar3 = (ulong *)(~(ulong)param_1[6] & (long)(puVar1 + 2) + (long)param_1[6]);\n        if (param_1[2] == puVar3) {\n          ppuVar2[1] = (ulong *)puVar1[1];\n          puVar3 = (ulong *)FUN_00413250(param_1,puVar1);\n        }\n      }\n      param_1[2] = puVar4;\n      param_1[3] = (ulong *)(__n + (long)puVar4);\n      *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xfd;\n      return puVar3;\n    }\n  }\n  (*(code *)obstack_alloc_failed_handler)();\n  puVar3 = ppuVar5[1];\n  if (puVar3 != (ulong *)0x0) {\n    while ((puVar4 <= puVar3 || ((ulong *)*puVar3 < puVar4))) {\n      puVar3 = (ulong *)puVar3[1];\n      if (puVar3 == (ulong *)0x0) {\n        return (ulong *)0x0;\n      }\n    }\n    return (ulong *)0x1;\n  }\n  return puVar3;\n}\n\n",
            "funcName": "obstack_newchunk"
        },
        {
            "funcStartAddr": "0x413440",
            "funcEndAddr": "0x41346d",
            "decompiledFuncCode": "\nulong * _obstack_allocated_p(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  \n  puVar1 = *(ulong **)(param_1 + 8);\n  if (puVar1 == (ulong *)0x0) {\n    return puVar1;\n  }\n  while ((param_2 <= puVar1 || ((ulong *)*puVar1 < param_2))) {\n    puVar1 = (ulong *)puVar1[1];\n    if (puVar1 == (ulong *)0x0) {\n      return (ulong *)0x0;\n    }\n  }\n  return (ulong *)0x1;\n}\n\n",
            "funcName": "obstack_allocated_p"
        },
        {
            "funcStartAddr": "0x413480",
            "funcEndAddr": "0x4134e0",
            "decompiledFuncCode": "\nvoid _obstack_free(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  ulong *puVar2;\n  \n  puVar1 = *(ulong **)(param_1 + 8);\n  while( true ) {\n    if (puVar1 == (ulong *)0x0) {\n      if (param_2 == (ulong *)0x0) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    if ((puVar1 < param_2) && (puVar2 = (ulong *)*puVar1, param_2 <= puVar2)) break;\n    puVar1 = (ulong *)puVar1[1];\n    FUN_00413250(param_1);\n    *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 2;\n  }\n  *(ulong **)(param_1 + 0x18) = param_2;\n  *(ulong **)(param_1 + 0x10) = param_2;\n  *(ulong **)(param_1 + 0x20) = puVar2;\n  *(ulong **)(param_1 + 8) = puVar1;\n  return;\n}\n\n",
            "funcName": "obstack_free"
        },
        {
            "funcStartAddr": "0x4134f0",
            "funcEndAddr": "0x413514",
            "decompiledFuncCode": "\nlong _obstack_memory_used(long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  long *plVar3;\n  \n  plVar3 = *(long **)(param_1 + 8);\n  lVar1 = 0;\n  if (plVar3 == (long *)0x0) {\n    return 0;\n  }\n  do {\n    lVar2 = *plVar3 - (long)plVar3;\n    plVar3 = (long *)plVar3[1];\n    lVar1 = lVar1 + lVar2;\n  } while (plVar3 != (long *)0x0);\n  return lVar1;\n}\n\n",
            "funcName": "obstack_memory_used"
        },
        {
            "funcStartAddr": "0x413520",
            "funcEndAddr": "0x41357c",
            "decompiledFuncCode": "\nulong FUN_00413520(uint *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  uVar1 = *param_1;\n  uVar3 = FUN_00411f80(param_1);\n  if ((uVar1 & 0x20) == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_00413520"
        },
        {
            "funcStartAddr": "0x413580",
            "funcEndAddr": "0x41362b",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined  [16] FUN_00413580(double param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  double dVar3;\n  \n  if (param_1 <= _DAT_00418640) {\n    return ZEXT816(0x8000000000000000);\n  }\n  if (DAT_00416a48 <= param_1) {\n    return CONCAT88(999999999,0x7fffffffffffffff);\n  }\n  dVar3 = (param_1 - (double)(long)param_1) * _DAT_00418648;\n  lVar2 = (long)dVar3;\n  lVar2 = (ulong)((double)lVar2 < dVar3) + lVar2;\n  lVar1 = lVar2 / 1000000000 + (long)param_1;\n  lVar2 = lVar2 % 1000000000;\n  if (-1 < lVar2) {\n    return CONCAT88(lVar2,lVar1);\n  }\n  return CONCAT88(lVar2 + 1000000000,lVar1 + -1);\n}\n\n",
            "funcName": "FUN_00413580"
        },
        {
            "funcStartAddr": "0x413640",
            "funcEndAddr": "0x41368c",
            "decompiledFuncCode": "\nuint FUN_00413640(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  \n  if (2 < param_1) {\n    return param_1;\n  }\n  uVar2 = FUN_00413690();\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  close(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00413640"
        },
        {
            "funcStartAddr": "0x413690",
            "funcEndAddr": "0x4136aa",
            "decompiledFuncCode": "\nvoid FUN_00413690(undefined8 param_1,uint param_2)\n\n{\n  param_2 = param_2 & 0x80000;\n  if (param_2 != 0) {\n    param_2 = 0x406;\n  }\n  FUN_00412000(param_1,param_2,3);\n  return;\n}\n\n",
            "funcName": "FUN_00413690"
        },
        {
            "funcStartAddr": "0x4136b0",
            "funcEndAddr": "0x413739",
            "decompiledFuncCode": "\nFILE * FUN_004136b0(char *param_1,char *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  FILE *__stream;\n  FILE *pFVar4;\n  int *piVar5;\n  \n  __stream = fopen(param_1,param_2);\n  pFVar4 = __stream;\n  if ((__stream != (FILE *)0x0) && (uVar1 = fileno(__stream), uVar1 < 3)) {\n    iVar2 = FUN_00413ea0(uVar1);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      pFVar4 = (FILE *)0x0;\n      iVar2 = *piVar5;\n      FUN_00411f80(__stream);\n      *piVar5 = iVar2;\n    }\n    else {\n      iVar3 = FUN_00411f80(__stream);\n      if ((iVar3 == 0) && (pFVar4 = fdopen(iVar2,param_2), pFVar4 != (FILE *)0x0)) {\n        return pFVar4;\n      }\n      piVar5 = __errno_location();\n      iVar3 = *piVar5;\n      close(iVar2);\n      *piVar5 = iVar3;\n      pFVar4 = (FILE *)0x0;\n    }\n  }\n  return pFVar4;\n}\n\n",
            "funcName": "FUN_004136b0"
        },
        {
            "funcStartAddr": "0x413750",
            "funcEndAddr": "0x413ca4",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * FUN_00413750(void)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  char *__s1;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  size_t __n;\n  char *__file;\n  FILE *__stream;\n  byte *pbVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  ulong uVar12;\n  undefined8 *puVar13;\n  char *__ptr;\n  bool bVar14;\n  long local_d0;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined auStack_80 [8];\n  undefined8 local_78;\n  \n  __s1 = nl_langinfo(0xe);\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  if (DAT_0061cd58 != (char *)0x0) goto LAB_0041378a;\n  pcVar7 = getenv(\"CHARSETALIASDIR\");\n  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\\0')) {\n    sVar6 = 0x73;\n    sVar5 = 0x65;\n    __n = 100;\n    pcVar7 = \n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\"\n    ;\nLAB_00413875:\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      __file[__n] = '/';\n      goto LAB_00413896;\n    }\n  }\n  else {\n    __n = strlen(pcVar7);\n    if (__n == 0) {\n      sVar6 = 0xe;\n    }\n    else {\n      if (pcVar7[__n - 1] != '/') {\n        sVar6 = __n + 0xf;\n        sVar5 = __n + 1;\n        goto LAB_00413875;\n      }\n      sVar6 = __n + 0xe;\n    }\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      sVar5 = __n;\nLAB_00413896:\n      puVar13 = (undefined8 *)(__file + sVar5);\n      *puVar13 = 0x2e74657372616863;\n      *(undefined2 *)((long)puVar13 + 0xc) = 0x73;\n      *(undefined4 *)(puVar13 + 1) = 0x61696c61;\n      iVar2 = open(__file,0);\n      if (-1 < iVar2) {\n        __stream = fdopen(iVar2,\"r\");\n        local_d0 = 0;\n        if (__stream != (FILE *)0x0) {\n          pcVar7 = (char *)0x0;\nLAB_00413930:\n          pbVar8 = (byte *)__stream->_IO_read_ptr;\n          if (__stream->_IO_read_end <= pbVar8) goto LAB_00413abc;\n          do {\n            __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n            uVar4 = (uint)*pbVar8;\n            __ptr = pcVar7;\n            while( true ) {\n              pcVar7 = __ptr;\n              if ((uVar4 - 9 < 2) || (uVar4 == 0x20)) goto LAB_00413930;\n              if (uVar4 == 0x23) goto LAB_00413b21;\n              ungetc(uVar4,__stream);\n              iVar2 = fscanf(__stream,\"%50s %50s\",&local_b8,&local_78);\n              puVar13 = &local_b8;\n              if (iVar2 < 2) goto LAB_00413acf;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              lVar11 = (long)puVar13 +\n                       ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_b8);\n              puVar13 = &local_78;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              local_c0 = (long)puVar13 +\n                         ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_78);\n              lVar9 = lVar11 + local_c0;\n              if (local_d0 == 0) {\n                pcVar7 = (char *)malloc(lVar9 + 3);\n              }\n              else {\n                lVar9 = lVar9 + local_d0;\n                pcVar7 = (char *)realloc(__ptr,lVar9 + 3);\n              }\n              local_d0 = lVar9 + 2;\n              if (pcVar7 == (char *)0x0) {\n                pcVar7 = \"\";\n                free(__ptr);\n                FUN_00411f80(__stream);\n                goto LAB_004138d4;\n              }\n              uVar12 = lVar11 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (-2 - lVar11) + (local_d0 - local_c0));\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_b8;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 2));\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_b8;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 4));\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_b8._4_4_,(undefined4)local_b8);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 8));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_b8 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              uVar12 = local_c0 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (local_d0 - local_c0) + -1);\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_78;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 6);\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_78;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 4);\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_78._4_4_,(undefined4)local_78);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)auStack_80 + (uVar12 & 0xffffffff));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_78 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              pbVar8 = (byte *)__stream->_IO_read_ptr;\n              if (pbVar8 < __stream->_IO_read_end) break;\nLAB_00413abc:\n              uVar4 = __uflow(__stream);\n              __ptr = pcVar7;\n              if (uVar4 == 0xffffffff) goto LAB_00413acf;\n            }\n          } while( true );\n        }\n        close(iVar2);\n      }\n      goto LAB_004138ce;\n    }\n  }\n  DAT_0061cd58 = \"\";\nLAB_0041378a:\n  cVar1 = *DAT_0061cd58;\n  pcVar7 = DAT_0061cd58;\n  do {\n    if (cVar1 == '\\0') {\nLAB_004137e4:\n      if (*__s1 == '\\0') {\n        __s1 = \"ASCII\";\n      }\n      return __s1;\n    }\n    iVar2 = strcmp(__s1,pcVar7);\n    if ((iVar2 == 0) || ((cVar1 == '*' && (pcVar7[1] == '\\0')))) {\n      sVar6 = strlen(pcVar7);\n      __s1 = pcVar7 + sVar6 + 1;\n      goto LAB_004137e4;\n    }\n    sVar6 = strlen(pcVar7);\n    sVar5 = strlen(pcVar7 + sVar6 + 1);\n    pcVar7 = pcVar7 + sVar6 + 1 + sVar5 + 1;\n    cVar1 = *pcVar7;\n  } while( true );\nLAB_00413b21:\n  do {\n    pbVar8 = (byte *)__stream->_IO_read_ptr;\n    if (pbVar8 < __stream->_IO_read_end) {\n      __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n      uVar4 = (uint)*pbVar8;\n      bVar14 = true;\n    }\n    else {\n      uVar4 = __uflow(__stream);\n      bVar14 = uVar4 != 0xffffffff;\n    }\n  } while ((uVar4 != 10) && (bVar14));\n  if (uVar4 == 0xffffffff) goto LAB_00413acf;\n  goto LAB_00413930;\nLAB_00413acf:\n  FUN_00411f80(__stream);\n  if (local_d0 == 0) {\nLAB_004138ce:\n    pcVar7 = \"\";\n  }\n  else {\n    pcVar7[local_d0] = '\\0';\n  }\nLAB_004138d4:\n  free(__file);\n  DAT_0061cd58 = pcVar7;\n  goto LAB_0041378a;\n}\n\n",
            "funcName": "FUN_00413750"
        },
        {
            "funcStartAddr": "0x413cc0",
            "funcEndAddr": "0x413d61",
            "decompiledFuncCode": "\nint FUN_00413cc0(char *param_1,long param_2,char *param_3,long param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  size_t sVar4;\n  \n  piVar2 = __errno_location();\n  while( true ) {\n    *piVar2 = 0;\n    iVar1 = strcoll(param_1,param_3);\n    if (iVar1 != 0) {\n      return iVar1;\n    }\n    sVar3 = strlen(param_1);\n    sVar4 = strlen(param_3);\n    param_1 = param_1 + sVar3 + 1;\n    param_3 = param_3 + sVar4 + 1;\n    param_4 = param_4 - (sVar4 + 1);\n    param_2 = param_2 - (sVar3 + 1);\n    if (param_2 == 0) break;\n    if (param_4 == 0) {\n      return 1;\n    }\n  }\n  return -(uint)(param_4 != 0);\n}\n\n",
            "funcName": "FUN_00413cc0"
        },
        {
            "funcStartAddr": "0x413d80",
            "funcEndAddr": "0x413e1e",
            "decompiledFuncCode": "\nundefined4 FUN_00413d80(void *param_1,size_t param_2,void *param_3,size_t param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined uVar3;\n  undefined uVar4;\n  int iVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  \n  if ((param_2 == param_4) && (iVar5 = memcmp(param_1,param_3,param_2), iVar5 == 0)) {\n    piVar7 = __errno_location();\n    *piVar7 = 0;\n    return 0;\n  }\n  puVar1 = (undefined *)((long)param_1 + param_2);\n  puVar2 = (undefined *)((long)param_3 + param_4);\n  uVar3 = *puVar1;\n  uVar4 = *puVar2;\n  *puVar1 = 0;\n  *puVar2 = 0;\n  uVar6 = FUN_00413cc0(param_1,param_2 + 1,param_3,param_4 + 1);\n  *puVar1 = uVar3;\n  *puVar2 = uVar4;\n  return uVar6;\n}\n\n",
            "funcName": "FUN_00413d80"
        },
        {
            "funcStartAddr": "0x413e30",
            "funcEndAddr": "0x413e8d",
            "decompiledFuncCode": "\nundefined8 FUN_00413e30(void *param_1,size_t param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (param_2 == param_4) {\n    iVar1 = memcmp(param_1,param_3,param_2);\n    if (iVar1 == 0) {\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      return 0;\n    }\n  }\n  uVar3 = FUN_00413cc0(param_1,param_2,param_3,param_4);\n  return uVar3;\n}\n\n",
            "funcName": "FUN_00413e30"
        },
        {
            "funcStartAddr": "0x413ea0",
            "funcEndAddr": "0x413eae",
            "decompiledFuncCode": "\nvoid FUN_00413ea0(undefined8 param_1)\n\n{\n  FUN_00412000(param_1,0,3);\n  return;\n}\n\n",
            "funcName": "FUN_00413ea0"
        },
        {
            "funcStartAddr": "0x413eb0",
            "funcEndAddr": "0x413f0d",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00413ee3) */\n/* WARNING: Removing unreachable block (ram,0x00413ee8) */\n\nvoid FUN_00413eb0(void)\n\n{\n  __DT_INIT();\n  return;\n}\n\n",
            "funcName": "FUN_00413eb0"
        },
        {
            "funcStartAddr": "0x413f10",
            "funcEndAddr": "0x413f11",
            "decompiledFuncCode": "\nvoid FUN_00413f10(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_00413f10"
        },
        {
            "funcStartAddr": "0x413f20",
            "funcEndAddr": "0x413f38",
            "decompiledFuncCode": "\nvoid FUN_00413f20(undefined8 param_1)\n\n{\n  __cxa_atexit(param_1,0,DAT_0061c3e8);\n  return;\n}\n\n",
            "funcName": "FUN_00413f20"
        },
        {
            "funcStartAddr": "0x413f38",
            "funcEndAddr": "0x413f58",
            "decompiledFuncCode": "\nundefined8 FUN_00413f38(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  code **ppcVar1;\n  \n  for (ppcVar1 = (code **)&DAT_0061be20; *ppcVar1 != (code *)0xffffffffffffffff;\n      ppcVar1 = ppcVar1 + -1) {\n    (**ppcVar1)();\n  }\n  return param_3;\n}\n\n",
            "funcName": "FUN_00413f38"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_sort.elf",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}