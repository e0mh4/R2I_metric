{
    "funcCount": 133,
    "funcInfo": [
        {
            "funcStartAddr": "0x402075",
            "funcEndAddr": "0x40207a",
            "decompiledFuncCode": "\nvoid FUN_00402075(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402075"
        },
        {
            "funcStartAddr": "0x40207a",
            "funcEndAddr": "0x40207f",
            "decompiledFuncCode": "\nvoid FUN_0040207a(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040207a"
        },
        {
            "funcStartAddr": "0x40207f",
            "funcEndAddr": "0x402084",
            "decompiledFuncCode": "\nvoid FUN_0040207f(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_0040207f"
        },
        {
            "funcStartAddr": "0x402084",
            "funcEndAddr": "0x402089",
            "decompiledFuncCode": "\nvoid FUN_00402084(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402084"
        },
        {
            "funcStartAddr": "0x402089",
            "funcEndAddr": "0x40208e",
            "decompiledFuncCode": "\nvoid FUN_00402089(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00402089"
        },
        {
            "funcStartAddr": "0x4020a0",
            "funcEndAddr": "0x4028e8",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nbyte FUN_004020a0(int param_1,undefined8 *param_2)\n\n{\n  byte *__file;\n  size_t __n;\n  ulong uVar1;\n  byte bVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  long lVar6;\n  byte *__ptr;\n  void *pvVar7;\n  char *pcVar8;\n  size_t sVar9;\n  int *piVar10;\n  char *pcVar11;\n  undefined8 uVar12;\n  long lVar13;\n  char *pcVar14;\n  byte *pbVar15;\n  byte *pbVar16;\n  byte **ppbVar17;\n  undefined uVar18;\n  undefined uVar19;\n  bool bVar20;\n  byte bVar21;\n  undefined auVar22 [16];\n  undefined8 uStack_a8;\n  byte **local_a0;\n  int local_98;\n  int local_94;\n  void *local_90;\n  byte *local_88;\n  byte *local_80;\n  void *local_78;\n  byte *local_70;\n  void *local_68;\n  byte **local_60;\n  undefined local_58 [16];\n  undefined local_48 [8];\n  undefined8 uStack_40;\n  \n  bVar21 = 0;\n  local_58 = (undefined  [16])0x0;\n  _local_48 = (undefined  [16])0x0;\n  FUN_004051c0(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\n                 \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\"\n                );\n  textdomain(\"coreutils\");\n  FUN_0040a210(FUN_004042c0);\n  local_58 = CONCAT88(3,local_58._0_8_);\n  _local_48 = CONCAT88(uStack_40,0xffffffffffffffff);\n  pcVar8 = (char *)0x0;\nLAB_00402120:\n  pcVar14 = pcVar8;\n  iVar3 = FUN_004099c0(param_1,param_2,\"fn:s:uvxz\",&PTR_s_exact_0040b420,0);\n  pcVar8 = DAT_0060f540;\n  if (iVar3 == -1) {\n    lVar6 = (long)DAT_0060f35c;\n    param_1 = param_1 - DAT_0060f35c;\n    if (param_1 == 0) {\n      uVar12 = dcgettext(0,\"missing file operand\",5);\n      error(0,0,uVar12);\n      goto LAB_0040289b;\n    }\n    DAT_0060f398 = FUN_00406e30(pcVar14,0xffffffffffffffff);\n    if (DAT_0060f398 != 0) {\n      FUN_0040a210();\n      if (param_1 < 1) {\n        uStack_a8 = 0x100000000000000;\n      }\n      else {\n        ppbVar17 = (byte **)(param_2 + lVar6);\n        uStack_a8 = CONCAT17(1,(undefined7)uStack_a8);\n        local_a0 = (byte **)(param_2 + (ulong)(param_1 - 1) + lVar6 + 1);\n        local_94 = iVar3;\n        do {\n          uVar18 = 0;\n          uVar19 = 1;\n          uVar12 = FUN_00406c60(0,3,*ppbVar17);\n          __ptr = (byte *)FUN_00408470(uVar12);\n          lVar6 = DAT_0060f398;\n          __file = *ppbVar17;\n          lVar13 = 2;\n          pbVar15 = __file;\n          pbVar16 = &DAT_0040ccb2;\n          do {\n            if (lVar13 == 0) break;\n            lVar13 = lVar13 + -1;\n            uVar18 = *pbVar15 < *pbVar16;\n            uVar19 = *pbVar15 == *pbVar16;\n            pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;\n            pbVar16 = pbVar16 + (ulong)bVar21 * -2 + 1;\n          } while ((bool)uVar19);\n          if ((!(bool)uVar18 && !(bool)uVar19) == (bool)uVar18) {\n            uVar4 = FUN_00408a90(1,3);\n            if ((int)uVar4 < 0) {\n              uVar12 = dcgettext(0,\"%s: fcntl failed\",5);\n              piVar10 = __errno_location();\n              error(0,*piVar10,uVar12,__ptr);\n              bVar2 = 0;\n            }\n            else if ((uVar4 & 0x400) == 0) {\n              bVar2 = FUN_004033d0(1,__ptr,lVar6,local_58);\n            }\n            else {\n              uVar12 = dcgettext(0,\"%s: cannot shred append-only file descriptor\",5);\n              error(0,0,uVar12,__ptr);\n              bVar2 = 0;\n            }\n            uStack_a8 = uStack_a8 & 0xffffffffffffff | (ulong)(uStack_a8._7_1_ & bVar2) << 0x38;\n          }\n          else {\n            iVar3 = FUN_004044d0(__file,0x101);\n            if ((iVar3 < 0) &&\n               ((((piVar10 = __errno_location(), *piVar10 != 0xd || (local_58[0] == '\\0')) ||\n                 (iVar3 = chmod((char *)__file,0x80), iVar3 != 0)) ||\n                (iVar3 = FUN_004044d0(__file,0x101), iVar3 < 0)))) {\n              uVar12 = dcgettext(0,\"%s: failed to open for writing\",5);\n              bVar2 = 0;\n              error(0,*piVar10,uVar12,__ptr);\n            }\n            else {\n              bVar2 = FUN_004033d0(iVar3,__ptr,lVar6,local_58);\n              iVar3 = close(iVar3);\n              if (iVar3 == 0) {\n                if ((bVar2 != 0) && ((int)uStack_40 != 0)) {\n                  pvVar7 = (void *)FUN_00408470(__file);\n                  local_78 = pvVar7;\n                  pcVar8 = (char *)FUN_00404440(pvVar7);\n                  local_68 = (void *)FUN_00404360(pvVar7);\n                  uVar12 = FUN_00406c60(0,3,local_68);\n                  local_90 = (void *)FUN_00408470(uVar12);\n                  local_98 = local_94;\n                  if ((int)uStack_40 == 3) {\n                    local_98 = FUN_004044d0(local_68,0x10900);\n                  }\n                  if (uStack_40._4_1_ != '\\0') {\n                    uVar12 = dcgettext(0,\"%s: removing\",5);\n                    error(0,0,uVar12,__ptr);\n                  }\n                  if ((int)uStack_40 != 1) {\n                    sVar9 = FUN_004044a0(pcVar8);\n                    pvVar7 = local_78;\n                    local_88 = (byte *)((ulong)local_88 & 0xffffffffffffff00 | (ulong)bVar2);\n                    local_80 = __file + ((long)pcVar8 - (long)local_78);\n                    local_70 = __ptr;\n                    local_60 = ppbVar17;\nLAB_00402626:\n                    __n = sVar9;\n                    sVar9 = __n - 1;\n                    __ptr = local_70;\n                    ppbVar17 = local_60;\n                    if (sVar9 != 0xffffffffffffffff) {\n                      memset(pcVar8,0x30,__n);\n                      pcVar8[__n] = '\\0';\n                      while (iVar3 = FUN_00407a00(0xffffff9c,__file,0xffffff9c,pvVar7,1), iVar3 != 0\n                            ) {\n                        piVar10 = __errno_location();\n                        if (*piVar10 != 0x11) goto LAB_00402626;\n                        pcVar14 = pcVar8 + sVar9;\n                        while( true ) {\n                          pcVar11 = strchr(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.\"\n                                           ,(int)*pcVar14);\n                          if (pcVar11 == (char *)0x0) goto LAB_004028ac;\n                          if (pcVar11[1] != '\\0') break;\n                          *pcVar14 = '0';\n                          bVar20 = pcVar8 == pcVar14;\n                          pcVar14 = pcVar14 + -1;\n                          if (bVar20) goto LAB_00402626;\n                        }\n                        *pcVar14 = pcVar11[1];\n                      }\n                      if ((-1 < local_98) && (iVar3 = FUN_00402a60(local_98,local_90), iVar3 != 0))\n                      {\n                        bVar2 = 0;\n                      }\n                      if (uStack_40._4_1_ != '\\0') {\n                        local_88 = local_70;\n                        if ((char)local_88 == '\\0') {\n                          local_88 = __file;\n                        }\n                        uVar12 = dcgettext(0,\"%s: renamed to %s\",5);\n                        error(0,0,uVar12,local_88,pvVar7);\n                        local_88 = (byte *)((ulong)local_88 & 0xffffffffffffff00);\n                      }\n                      memcpy(local_80,pcVar8,__n + 1);\n                      goto LAB_00402626;\n                    }\n                  }\n                  iVar3 = unlink((char *)__file);\n                  if (iVar3 == 0) {\n                    if (uStack_40._4_1_ != '\\0') {\n                      uVar12 = dcgettext(0,\"%s: removed\",5);\n                      error(0,0,uVar12,__ptr);\n                    }\n                  }\n                  else {\n                    bVar2 = 0;\n                    uVar12 = dcgettext(0,\"%s: failed to remove\",5);\n                    piVar10 = __errno_location();\n                    error(0,*piVar10,uVar12,__ptr);\n                  }\n                  iVar3 = local_98;\n                  if (-1 < local_98) {\n                    iVar5 = FUN_00402a60(local_98,local_90);\n                    if (iVar5 != 0) {\n                      bVar2 = 0;\n                    }\n                    iVar3 = close(iVar3);\n                    if (iVar3 != 0) {\n                      bVar2 = 0;\n                      uVar12 = dcgettext(0,\"%s: failed to close\",5);\n                      piVar10 = __errno_location();\n                      error(0,*piVar10,uVar12,local_90);\n                    }\n                  }\n                  free(local_78);\n                  free(local_68);\n                  free(local_90);\n                }\n              }\n              else {\n                bVar2 = 0;\n                uVar12 = dcgettext(0,\"%s: failed to close\",5);\n                piVar10 = __errno_location();\n                error(0,*piVar10,uVar12,__ptr);\n              }\n            }\n            uStack_a8 = uStack_a8 & 0xffffffffffffff | (ulong)(uStack_a8._7_1_ & bVar2) << 0x38;\n          }\n          ppbVar17 = ppbVar17 + 1;\n          free(__ptr);\n        } while (local_a0 != ppbVar17);\n      }\n      return uStack_a8._7_1_ ^ 1;\n    }\n    uVar12 = FUN_00406c60(0,3,pcVar14);\n    piVar10 = __errno_location();\n    error(1,*piVar10,&DAT_0040b61c,uVar12);\n    goto LAB_004028f2;\n  }\n  if (iVar3 == 0x73) {\n    uVar12 = dcgettext(0,\"invalid file size\",5);\n    uVar12 = FUN_004084d0(DAT_0060f540,0,0,0x7fffffffffffffff,\"cbBkKMGTPEZY0\",uVar12,0);\n    _local_48 = CONCAT88(uStack_40,uVar12);\n    pcVar8 = pcVar14;\n    goto LAB_00402120;\n  }\n  if (iVar3 < 0x74) {\n    if (iVar3 == -0x82) goto LAB_004028a5;\n    if (-0x82 < iVar3) {\n      if (iVar3 == 0x66) {\n        local_58 = CONCAT151(local_58._1_15_,1);\n        pcVar8 = pcVar14;\n      }\n      else {\n        if (iVar3 != 0x6e) goto LAB_0040289b;\n        dcgettext(0,\"invalid number of passes\",5);\n        uVar12 = FUN_004085a0(DAT_0060f540,0,0x3fffffffffffffff,\"\");\n        local_58 = CONCAT88(uVar12,local_58._0_8_);\n        pcVar8 = pcVar14;\n      }\n      goto LAB_00402120;\n    }\n    if (iVar3 == -0x83) {\n      FUN_00408100(stdout,\"shred\",\"GNU coreutils\",PTR_DAT_0060f2d0,\"Colin Plumb\",0);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  }\n  else {\n    if (iVar3 == 0x78) {\n      _local_48 = CONCAT113(1,_local_48);\n      pcVar8 = pcVar14;\n      goto LAB_00402120;\n    }\n    if (0x78 < iVar3) {\n      if (iVar3 == 0x7a) {\n        pcVar8 = pcVar14;\n      }\n      else {\n        if (iVar3 != 0x80) goto LAB_0040289b;\n        if ((pcVar14 != (char *)0x0) && (iVar3 = strcmp(pcVar14,DAT_0060f540), iVar3 != 0)) {\nLAB_004028f2:\n          uVar12 = dcgettext(0,\"multiple random sources specified\",5);\n          auVar22 = error(1,0,uVar12);\n          uVar1 = uStack_a8;\n          uStack_a8 = SUB168(auVar22,0);\n          (*(code *)PTR___libc_start_main_0060eff0)\n                    (FUN_004020a0,uVar1,&local_a0,FUN_0040a1a0,FUN_0040a200,\n                     SUB168(auVar22 >> 0x40,0),&uStack_a8);\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n      }\n      goto LAB_00402120;\n    }\n    if (iVar3 == 0x75) {\n      if (DAT_0060f540 == (char *)0x0) {\n        _local_48 = CONCAT48(3,local_48);\n        pcVar8 = pcVar14;\n      }\n      else {\n        lVar6 = FUN_004041e0(\"--remove\",DAT_0060f540,&PTR_s_unlink_0040b5a0,&DAT_0040b580);\n        _local_48 = CONCAT48(*(undefined4 *)(&DAT_0040b580 + lVar6 * 4),local_48);\n        pcVar8 = pcVar14;\n      }\n      goto LAB_00402120;\n    }\n    if (iVar3 == 0x76) {\n      _local_48 = CONCAT112(1,_local_48);\n      pcVar8 = pcVar14;\n      goto LAB_00402120;\n    }\n  }\nLAB_0040289b:\n  FUN_00403ac0(1);\nLAB_004028a5:\n  FUN_00403ac0(0);\nLAB_004028ac:\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"p\",\"src/shred.c\",0x40a,\"incname\");\n}\n\n",
            "funcName": "FUN_004020a0"
        },
        {
            "funcStartAddr": "0x402920",
            "funcEndAddr": "0x40294b",
            "decompiledFuncCode": "\nvoid FUN_00402920(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_0060eff0)\n            (FUN_004020a0,unaff_retaddr,&stack0x00000008,FUN_0040a1a0,FUN_0040a200,param_3,auStack_8\n            );\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "FUN_00402920"
        },
        {
            "funcStartAddr": "0x40294b",
            "funcEndAddr": "0x40296a",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402958) */\n/* WARNING: Removing unreachable block (ram,0x00402962) */\n\nvoid FUN_0040294b(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040294b"
        },
        {
            "funcStartAddr": "0x40296a",
            "funcEndAddr": "0x4029a1",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402999) */\n\nvoid FUN_0040296a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040296a"
        },
        {
            "funcStartAddr": "0x4029a1",
            "funcEndAddr": "0x4029f8",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x004029d6) */\n\nvoid FUN_004029a1(void)\n\n{\n  if (DAT_0060f388 != '\\0') {\n    return;\n  }\n  FUN_0040294b();\n  DAT_0060f388 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_004029a1"
        },
        {
            "funcStartAddr": "0x4029f8",
            "funcEndAddr": "0x4029fd",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402999) */\n\nvoid thunk_FUN_0040296a(void)\n\n{\n  return;\n}\n\n",
            "funcName": "thunk_4029f8"
        },
        {
            "funcStartAddr": "0x402a00",
            "funcEndAddr": "0x402a0c",
            "decompiledFuncCode": "\nvoid FUN_00402a00(void)\n\n{\n  FUN_00406f90(DAT_0060f398);\n  return;\n}\n\n",
            "funcName": "FUN_00402a00"
        },
        {
            "funcStartAddr": "0x402a10",
            "funcEndAddr": "0x402a59",
            "decompiledFuncCode": "\nvoid FUN_00402a10(ulong param_1,char param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = FUN_00408a90(param_1,3);\n  if (0 < (int)uVar1) {\n    uVar2 = uVar1 & 0xffffbfff;\n    if (param_2 != '\\0') {\n      uVar2 = uVar1 | 0x4000;\n    }\n    if (uVar2 != uVar1) {\n      FUN_00408a90(param_1 & 0xffffffff,4);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00402a10"
        },
        {
            "funcStartAddr": "0x402a60",
            "funcEndAddr": "0x402b17",
            "decompiledFuncCode": "\nundefined8 FUN_00402a60(int param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  iVar1 = fdatasync(param_1);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    iVar1 = *piVar2;\n    if ((1 < iVar1 - 0x15U) && (iVar1 != 9)) {\n      uVar3 = dcgettext(0,\"%s: fdatasync failed\",5);\n      error(0,iVar1,uVar3,param_2);\n      *piVar2 = iVar1;\n      return 0xffffffff;\n    }\n    iVar1 = fsync(param_1);\n    if (iVar1 != 0) {\n      iVar1 = *piVar2;\n      if ((1 < iVar1 - 0x15U) && (iVar1 != 9)) {\n        uVar3 = dcgettext(0,\"%s: fsync failed\",5);\n        error(0,iVar1,uVar3,param_2);\n        *piVar2 = iVar1;\n        return 0xffffffff;\n      }\n      sync();\n    }\n  }\n  return 0;\n}\n\n",
            "funcName": "FUN_00402a60"
        },
        {
            "funcStartAddr": "0x402b20",
            "funcEndAddr": "0x403389",
            "decompiledFuncCode": "\nundefined8\nFUN_00402b20(int param_1,long param_2,undefined8 param_3,ulong *param_4,uint param_5,\n            undefined8 param_6,undefined8 param_7,long param_8)\n\n{\n  long lVar1;\n  ushort uVar2;\n  int iVar3;\n  uint uVar4;\n  void *__ptr;\n  __off_t _Var5;\n  int *piVar6;\n  undefined8 uVar7;\n  ssize_t sVar8;\n  undefined8 uVar9;\n  char *__s2;\n  char *pcVar10;\n  time_t tVar11;\n  char cVar12;\n  bool bVar13;\n  uint uVar14;\n  ulong uVar15;\n  undefined *__src;\n  undefined4 uVar16;\n  ulong uVar17;\n  size_t __n;\n  ulong uVar18;\n  ulong uVar19;\n  ulong local_858;\n  undefined8 local_850;\n  ulong local_838;\n  char *local_810;\n  time_t local_808;\n  long local_800;\n  undefined4 local_7ef;\n  undefined2 local_7eb;\n  undefined local_7e9;\n  char local_7e8 [656];\n  undefined local_558 [656];\n  undefined2 local_2c8 [2];\n  undefined4 local_2c4;\n  \n  uVar19 = *param_4;\n  iVar3 = getpagesize();\n  if ((int)param_5 < 1) {\nLAB_00403000:\n    local_838 = 0x10000;\n    uVar17 = 0x10002;\n  }\n  else {\n    uVar14 = param_5 & 0xfff;\n    uVar4 = uVar14 << 0xc | uVar14;\n    cVar12 = (char)(uVar4 >> 4);\n    if (((char)(uVar4 >> 8) == cVar12) && (cVar12 == (char)uVar14)) goto LAB_00403000;\n    local_838 = 0xf000;\n    uVar17 = 0xf000;\n  }\n  lVar1 = (long)iVar3 - 1;\n  __ptr = (void *)FUN_00408240(uVar17 + lVar1);\n  uVar15 = lVar1 + (long)__ptr;\n  __src = (undefined *)(uVar15 - uVar15 % (ulong)(long)iVar3);\n  bVar13 = 0 < (long)uVar19 && uVar19 < local_838;\n  if (0 >= (long)uVar19 || uVar19 >= local_838) {\n    FUN_00402a10(param_1);\n  }\n  if ((*(uint *)(param_2 + 0x18) & 0xf000) != 0x2000) {\nLAB_00402bde:\n    _Var5 = lseek(param_1,0,0);\n    if (_Var5 < 1) {\n      if (_Var5 == 0) goto joined_r0x00402c54;\n      piVar6 = __errno_location();\n    }\n    else {\n      piVar6 = __errno_location();\n      *piVar6 = 0x16;\n    }\n    uVar7 = dcgettext(0,\"%s: cannot rewind\",5);\n    iVar3 = *piVar6;\nLAB_00402c18:\n    error(0,iVar3,uVar7,param_3);\nLAB_00402c26:\n    free(__ptr);\n    return 0xffffffff;\n  }\n  local_2c8[0] = 6;\n  local_2c4 = 1;\n  iVar3 = ioctl(param_1,0x40086d01,local_2c8);\n  if (iVar3 != 0) goto LAB_00402bde;\njoined_r0x00402c54:\n  if ((int)param_5 < 0) {\n    local_7ef = 0x646e6172;\n    local_7eb = 0x6d6f;\n    local_7e9 = 0;\n    goto joined_r0x0040312a;\n  }\n  uVar4 = (param_5 & 0xfff) << 0xc | param_5 & 0xfff;\n  uVar2 = (ushort)uVar4;\n  *(ushort *)(__src + 1) = uVar2 << 8 | uVar2 >> 8;\n  *__src = (char)(uVar4 >> 4);\n  if ((uVar19 < uVar17) && (-1 < (long)uVar19)) {\n    uVar15 = uVar19 >> 1;\n    uVar17 = uVar19;\n    if (2 < uVar15) goto LAB_00402c9d;\n    uVar18 = 3;\n  }\n  else {\n    uVar15 = uVar17 >> 1;\nLAB_00402c9d:\n    __n = 3;\n    do {\n      uVar18 = __n * 2;\n      memcpy(__src + __n,__src,__n);\n      __n = uVar18;\n    } while (uVar18 <= uVar15);\n  }\n  if (uVar18 < uVar17) {\n    memcpy(__src + uVar18,__src,uVar17 - uVar18);\n    if ((param_5 & 0x1000) != 0) goto LAB_004031b1;\n  }\n  else if (((param_5 & 0x1000) != 0) && (uVar17 != 0)) {\nLAB_004031b1:\n    uVar15 = 0;\n    do {\n      __src[uVar15] = __src[uVar15] + -0x80;\n      uVar15 = uVar15 + 0x200;\n    } while (uVar15 < uVar17);\n  }\n  __sprintf_chk(&local_7ef,1,7,\"%02x%02x%02x\",*__src,__src[1],__src[2]);\njoined_r0x0040312a:\n  if (param_8 != 0) {\n    uVar7 = dcgettext(0,\"%s: pass %lu/%lu (%s)...\",5);\n    error(0,0,uVar7,param_3,param_7,param_8,&local_7ef);\n    tVar11 = time((time_t *)0x0);\n    local_800 = tVar11 + 5;\n  }\n  local_810 = \"\";\n  local_850 = 0;\n  local_808 = 0;\n  local_858 = 0;\nLAB_00402d37:\n  do {\n    uVar17 = local_838;\n    if (((-1 < (long)uVar19) && (uVar15 = uVar19 - local_858, uVar15 < local_838)) &&\n       ((uVar15 == 0 || (uVar17 = uVar15, (long)uVar19 < (long)local_858)))) {\n      iVar3 = FUN_00402a60(param_1,param_3);\n      if (iVar3 == 0) {\n        free(__ptr);\n        return local_850;\n      }\n      piVar6 = __errno_location();\n      if (*piVar6 == 5) {\n        free(__ptr);\n        return 1;\n      }\n      goto LAB_00402c26;\n    }\n    if ((int)param_5 < 0) {\n      FUN_00407360(param_6,__src,uVar17);\n    }\n    uVar15 = 0;\n    do {\n      while (sVar8 = write(param_1,__src + uVar15,uVar17 - uVar15), 0 < sVar8) {\n        uVar15 = uVar15 + sVar8;\nLAB_00402d8b:\n        if (uVar17 <= uVar15) goto LAB_00402e61;\n      }\n      if ((long)uVar19 < 0) {\n        if (sVar8 != 0) {\n          piVar6 = __errno_location();\n          iVar3 = *piVar6;\n          if (iVar3 != 0x1c) {\n            if ((!bVar13) && (iVar3 == 0x16)) goto LAB_00403048;\n            uVar7 = FUN_00405170(local_858 + uVar15,local_2c8);\n            uVar9 = dcgettext(0,\"%s: error writing at offset %s\",5);\n            error(0,iVar3,uVar9,param_3,uVar7);\n            goto LAB_00402c26;\n          }\n        }\n        if (0x7fffffffffffffff - local_858 < uVar15) goto LAB_004032d0;\n        uVar19 = uVar15 + local_858;\n        *param_4 = uVar19;\n        local_858 = uVar19;\n        if (param_8 == 0) goto LAB_00402d37;\n        goto LAB_00403287;\n      }\n      piVar6 = __errno_location();\n      iVar3 = *piVar6;\n      if ((!bVar13) && (iVar3 == 0x16)) {\nLAB_00403048:\n        FUN_00402a10(param_1,0);\n        bVar13 = true;\n        goto LAB_00402d8b;\n      }\n      uVar7 = FUN_00405170(local_858 + uVar15,local_2c8);\n      uVar9 = dcgettext(0,\"%s: error writing at offset %s\",5);\n      error(0,iVar3,uVar9,param_3,uVar7);\n      if ((iVar3 != 5) || (uVar17 <= (uVar15 | 0x1ff))) goto LAB_00402c26;\n      uVar15 = (uVar15 | 0x1ff) + 1;\n      _Var5 = lseek(param_1,local_858 + uVar15,0);\n      if (_Var5 == -1) {\n        uVar7 = dcgettext(0,\"%s: lseek failed\",5);\n        error(0,*piVar6,uVar7,param_3);\n        goto LAB_00402c26;\n      }\n      local_850 = 1;\n    } while (uVar15 < uVar17);\nLAB_00402e61:\n    if (0x7fffffffffffffff - local_858 < uVar15) goto LAB_004032d0;\n    local_858 = uVar15 + local_858;\n  } while (param_8 == 0);\n  if (uVar19 == local_858) {\nLAB_00403287:\n    if ((*local_810 == '\\0') && (local_808 = time((time_t *)0x0), local_808 < local_800))\n    goto LAB_00402d37;\n    __s2 = (char *)FUN_004045e0(local_858,local_558,0x1b2,1,1);\n  }\n  else {\n    local_808 = time((time_t *)0x0);\n    if (local_808 < local_800) goto LAB_00402d37;\n    __s2 = (char *)FUN_004045e0(local_858,local_558,0x1b2,1,1);\n    iVar3 = strcmp(local_810,__s2);\n    if (iVar3 == 0) goto LAB_00402d37;\n  }\n  if ((long)uVar19 < 0) {\n    uVar7 = dcgettext(0,\"%s: pass %lu/%lu (%s)...%s\",5);\n    error(0,0,uVar7,param_3,param_7,param_8,&local_7ef,__s2);\n  }\n  else {\n    uVar16 = 100;\n    if (uVar19 != 0) {\n      if (local_858 < 0x28f5c28f5c28f5d) {\n        uVar16 = (undefined4)((local_858 * 100) / uVar19);\n      }\n      else {\n        uVar16 = (undefined4)\n                 (local_858 /\n                 (ulong)(((long)(SUB168(SEXT816(-0x5c28f5c28f5c28f5) * SEXT816((long)uVar19) >> 0x40\n                                        ,0) + uVar19) >> 6) - ((long)uVar19 >> 0x3f)));\n      }\n    }\n    pcVar10 = (char *)FUN_004045e0(uVar19,local_2c8,0x1b0,1,1);\n    if (uVar19 == local_858) {\n      __s2 = pcVar10;\n    }\n    uVar7 = dcgettext(0,\"%s: pass %lu/%lu (%s)...%s/%s %d%%\",5);\n    error(0,0,uVar7,param_3,param_7,param_8,&local_7ef,__s2,pcVar10,uVar16);\n  }\n  __strcpy_chk(local_7e8,__s2,0x28c);\n  local_800 = local_808 + 5;\n  iVar3 = FUN_00402a60(param_1,param_3);\n  if (iVar3 == 0) {\n    local_810 = local_7e8;\n  }\n  else {\n    piVar6 = __errno_location();\n    if (*piVar6 != 5) goto LAB_00402c26;\n    local_810 = local_7e8;\n    local_850 = 1;\n  }\n  goto LAB_00402d37;\nLAB_004032d0:\n  uVar7 = dcgettext(0,\"%s: file too large\",5);\n  iVar3 = 0;\n  goto LAB_00402c18;\n}\n\n",
            "funcName": "FUN_00402b20"
        },
        {
            "funcStartAddr": "0x4033d0",
            "funcEndAddr": "0x403a84",
            "decompiledFuncCode": "\nchar FUN_004033d0(int param_1,undefined8 param_2,undefined8 param_3,long param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  void *pvVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  long lVar7;\n  __off_t _Var8;\n  bool bVar9;\n  ulong uVar10;\n  int *piVar11;\n  int *piVar12;\n  int *__src;\n  ulong uVar13;\n  long local_118;\n  long local_108;\n  long local_100;\n  ulong local_f8;\n  long local_f0;\n  char local_e5;\n  long local_d0;\n  stat local_c8;\n  \n  local_100 = 0;\n  if (*(char *)(param_4 + 0x1c) != '\\0') {\n    local_100 = (ulong)*(byte *)(param_4 + 0x1e) + *(long *)(param_4 + 8);\n  }\n  iVar1 = __fxstat(1,param_1,&local_c8);\n  if (iVar1 != 0) {\n    uVar5 = dcgettext(0,\"%s: fstat failed\",5);\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar5,param_2);\n    return false;\n  }\n  uVar2 = local_c8.st_mode & 0xf000;\n  if (uVar2 == 0x2000) {\n    iVar1 = isatty(param_1);\n    if (iVar1 != 0) goto LAB_00403560;\n    uVar2 = local_c8.st_mode & 0xf000;\n  }\n  bVar9 = uVar2 == 0xc000 || uVar2 == 0x1000;\n  if (uVar2 == 0xc000 || uVar2 == 0x1000) {\nLAB_00403560:\n    uVar5 = dcgettext(0,\"%s: invalid file type\",5);\n    error(0,0,uVar5,param_2);\n    return false;\n  }\n  if ((uVar2 == 0x8000) && (local_c8.st_size < 0)) {\n    uVar5 = dcgettext(0,\"%s: file has negative size\",5);\n    error(0,0,uVar5,param_2);\n    return bVar9;\n  }\n  if (((long)(*(ulong *)(param_4 + 8) << 2) < 0) || (*(ulong *)(param_4 + 8) >> 0x3e != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00408490();\n  }\n  piVar3 = (int *)FUN_00408240();\n  local_108 = *(long *)(param_4 + 0x10);\n  if (local_108 == -1) {\n    if ((local_c8.st_mode & 0xf000) != 0x8000) {\n      _Var8 = lseek(param_1,0,2);\n      if (_Var8 < 1) {\n        local_f8 = *(ulong *)(param_4 + 8);\n      }\n      else {\n        local_f8 = *(ulong *)(param_4 + 8);\n        local_108 = _Var8;\n      }\n      local_f0 = 0;\n      if (local_f8 == 0) {\n        uVar5 = FUN_00406e60(param_3);\n        uVar10 = 0;\n        local_e5 = '\\x01';\n        goto LAB_00403795;\n      }\n      goto LAB_004034d1;\n    }\n    local_e5 = *(char *)(param_4 + 0x1d);\n    local_f8 = *(ulong *)(param_4 + 8);\n    local_108 = local_c8.st_size;\n    if (local_e5 != '\\0') {\n      local_f0 = 0;\n      if (local_f8 == 0) {\n        uVar5 = FUN_00406e60(param_3);\n        goto LAB_00403785;\n      }\n      goto LAB_004034d1;\n    }\n    if (0x1fffffffffffffff < local_c8.st_blksize - 1U) {\n      local_c8.st_blksize = 0x200;\n    }\n    if ((local_c8.st_blksize <= local_c8.st_size) ||\n       (local_f0 = local_c8.st_size, local_c8.st_size == 0)) {\n      local_f0 = 0;\n    }\n    if (local_c8.st_size % local_c8.st_blksize != 0) {\n      local_c8.st_blksize = local_c8.st_blksize - local_c8.st_size % local_c8.st_blksize;\n      if (0x7fffffffffffffff - local_c8.st_size <= local_c8.st_blksize) {\n        local_c8.st_blksize = 0x7fffffffffffffff - local_c8.st_size;\n      }\n      local_108 = local_c8.st_size + local_c8.st_blksize;\n    }\n  }\n  else {\n    local_f8 = *(ulong *)(param_4 + 8);\n    if ((local_c8.st_mode & 0xf000) != 0x8000) {\n      local_f0 = 0;\n      if (local_f8 == 0) {\nLAB_0040398b:\n        uVar5 = FUN_00406e60(param_3);\n        local_e5 = '\\x01';\n        goto LAB_00403785;\n      }\n      goto LAB_004034d1;\n    }\n    local_f0 = local_c8.st_size;\n    if (0x1fffffffffffffff < local_c8.st_blksize - 1U) {\n      local_c8.st_blksize = 0x200;\n    }\n    if (local_108 < local_c8.st_blksize) {\n      local_c8.st_blksize = local_108;\n    }\n    if (local_c8.st_blksize <= local_c8.st_size) {\n      if (local_f8 == 0) goto LAB_0040398b;\n      local_f0 = 0;\n      goto LAB_004034d1;\n    }\n  }\n  if (local_f8 != 0) {\nLAB_004034d1:\n    local_118 = 0;\n    iVar1 = -2;\n    piVar12 = (int *)&DAT_0040b340;\n    uVar10 = local_f8;\n    piVar11 = piVar3;\n    do {\n      if (iVar1 == 0) {\n        iVar1 = -2;\n        piVar12 = &DAT_0040b344;\nLAB_0040350b:\n        uVar13 = (ulong)-iVar1;\n        if (uVar10 <= uVar13) {\n          local_118 = local_118 + uVar10;\n          goto LAB_00403858;\n        }\n        local_118 = local_118 + uVar13;\n      }\n      else {\n        __src = piVar12 + 1;\n        piVar12 = __src;\n        if (iVar1 < 0) goto LAB_0040350b;\n        uVar13 = (ulong)iVar1;\n        if (uVar10 < uVar13) goto LAB_004037d0;\n        piVar12 = __src + uVar13;\n        pvVar4 = memcpy(piVar11,__src,uVar13 * 4);\n        piVar11 = (int *)((long)pvVar4 + uVar13 * 4);\n      }\n      uVar10 = uVar10 - uVar13;\n      iVar1 = *piVar12;\n    } while( true );\n  }\n  goto LAB_004036e8;\nLAB_004037d0:\n  if ((1 < uVar10) && (uVar13 <= uVar10 * 3)) {\n    do {\n      if ((uVar10 == uVar13) || (uVar6 = FUN_00406e70(param_3), piVar12 = piVar11, uVar6 < uVar10))\n      {\n        piVar12 = piVar11 + 1;\n        *piVar11 = *__src;\n        uVar10 = uVar10 - 1;\n        if (uVar10 == 0) goto LAB_00403858;\n      }\n      uVar13 = uVar13 - 1;\n      piVar11 = piVar12;\n      __src = __src + 1;\n    } while( true );\n  }\n  local_118 = local_118 + uVar10;\nLAB_00403858:\n  uVar6 = 0;\n  uVar10 = local_118 - 1;\n  local_118 = local_f8 - local_118;\n  uVar13 = uVar10;\n  do {\n    while (iVar1 = piVar3[uVar6], uVar10 < uVar13) {\n      uVar13 = uVar13 - uVar10;\n      lVar7 = FUN_00406e70(param_3,(local_118 + -1) - uVar6);\n      lVar7 = lVar7 + uVar6;\n      piVar3[uVar6] = piVar3[lVar7];\n      uVar6 = uVar6 + 1;\n      piVar3[lVar7] = iVar1;\n      if (uVar6 == local_f8) goto LAB_004036e8;\n    }\n    piVar3[local_118] = iVar1;\n    local_118 = local_118 + 1;\n    piVar3[uVar6] = -1;\n    uVar6 = uVar6 + 1;\n    uVar13 = (uVar13 + (local_f8 - 1)) - uVar10;\n  } while (uVar6 != local_f8);\nLAB_004036e8:\n  uVar5 = FUN_00406e60(param_3);\n  if (local_f0 == 0) {\n    local_e5 = '\\x01';\n    goto LAB_00403785;\n  }\n  local_d0 = local_f0;\n  uVar10 = *(ulong *)(param_4 + 8);\n  local_e5 = '\\x01';\n  lVar7 = 0;\n  while( true ) {\n    uVar13 = 0;\n    while (uVar13 < *(byte *)(param_4 + 0x1e) + uVar10) {\n      iVar1 = 0;\n      if (uVar13 < uVar10) {\n        iVar1 = piVar3[uVar13];\n      }\n      uVar13 = uVar13 + 1;\n      iVar1 = FUN_00402b20(param_1,&local_c8,param_2,&local_d0,iVar1,uVar5,uVar13,lVar7);\n      if (iVar1 != 0) {\n        local_e5 = bVar9;\n        if (iVar1 < 0) goto LAB_004037bd;\n        local_e5 = '\\0';\n      }\n      uVar10 = *(ulong *)(param_4 + 8);\n    }\nLAB_00403785:\n    if (local_108 == 0) break;\n    uVar10 = *(ulong *)(param_4 + 8);\nLAB_00403795:\n    local_d0 = local_108;\n    local_108 = 0;\n    lVar7 = local_100;\n  }\n  if (((*(int *)(param_4 + 0x18) != 0) && (iVar1 = ftruncate(param_1,0), iVar1 != 0)) &&\n     ((local_c8.st_mode & 0xf000) == 0x8000)) {\n    uVar5 = dcgettext(0,\"%s: error truncating\",5);\n    piVar11 = __errno_location();\n    error(0,*piVar11,uVar5,param_2);\n    local_e5 = bVar9;\n  }\nLAB_004037bd:\n  free(piVar3);\n  return local_e5;\n}\n\n",
            "funcName": "FUN_004033d0"
        },
        {
            "funcStartAddr": "0x403ac0",
            "funcEndAddr": "0x403f0d",
            "decompiledFuncCode": "\nvoid FUN_00403ac0(int param_1)\n\n{\n  FILE *pFVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  byte **ppbVar6;\n  char *pcVar8;\n  long lVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  byte *local_88;\n  char *local_80;\n  byte *local_78 [5];\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char *local_38;\n  char *local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  byte **ppbVar7;\n  \n  uVar5 = DAT_0060f3b0;\n  bVar14 = 0;\n  if (param_1 != 0) {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar5);\n    goto LAB_00403aff;\n  }\n  uVar3 = dcgettext(0,\"Usage: %s [OPTION]... FILE...\\n\",5);\n  __printf_chk(1,uVar3,uVar5);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"Overwrite the specified FILE(s) repeatedly, in order to make it harder\\nfor even very expensive hardware probing to recover the data.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"\\nIf FILE is -, shred standard output.\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  uVar5 = dcgettext(0,\n                    \"  -f, --force    change permissions to allow writing if necessary\\n  -n, --iterations=N  overwrite N times instead of the default (%d)\\n      --random-source=FILE  get random bytes from FILE\\n  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\\n\"\n                    ,5);\n  __printf_chk(1,uVar5,3);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"  -u             deallocate and remove file after overwriting\\n      --remove[=HOW]  like -u but give control on HOW to delete;  See below\\n  -v, --verbose  show progress\\n  -x, --exact    do not round file sizes up to the next full block;\\n                   this is the default for non-regular files\\n  -z, --zero     add a final overwrite with zeros to hide shredding\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"\\nDelete FILE(s) if --remove (-u) is specified.  The default is not to remove\\nthe files because it is common to operate on device files like /dev/hda,\\nand those files usually should not be removed.\\nThe optional HOW parameter indicates how to remove a directory entry:\\n\\'unlink\\' => use a standard unlink call.\\n\\'wipe\\' => also first obfuscate bytes in the name.\\n\\'wipesync\\' => also sync each obfuscated byte to disk.\\nThe default mode is \\'wipesync\\', but note it can be expensive.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"CAUTION: Note that shred relies on a very important assumption:\\nthat the file system overwrites data in place.  This is the traditional\\nway to do things, but many modern file system designs do not satisfy this\\nassumption.  The following are examples of file systems on which shred is\\nnot effective, or is not guaranteed to be effective in all file system modes:\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"* log-structured or journaled file systems, such as those supplied with\\nAIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\\n\\n* file systems that write redundant data and carry on even if some writes\\nfail, such as RAID-based file systems\\n\\n* file systems that make snapshots, such as Network Appliance\\'s NFS server\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"* file systems that cache in temporary locations, such as NFS\\nversion 3 clients\\n\\n* compressed file systems\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"In the case of ext3 file systems, the above disclaimer applies\\n(and shred is thus of limited effectiveness) only in data=journal mode,\\nwhich journals file data in addition to just metadata.  In both the\\ndata=ordered (default) and data=writeback modes, shred works as usual.\\nExt3 journaling modes can be changed by adding the data=something option\\nto the mount options for a particular file system in the /etc/fstab file,\\nas documented in the mount man page (man mount).\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  pFVar1 = stdout;\n  pcVar4 = (char *)dcgettext(0,\n                             \"In addition, file system backups and remote mirrors may contain copies\\nof the file that cannot be removed, and that will allow a shredded file\\nto be recovered later.\\n\"\n                             ,5);\n  fputs_unlocked(pcVar4,pFVar1);\n  local_88 = &DAT_0040a35e;\n  local_80 = \"test invocation\";\n  local_78[0] = (byte *)0x40a3d8;\n  local_78[1] = (byte *)0x40a370;\n  local_78[2] = (byte *)0x40a386;\n  local_78[3] = (byte *)0x40a390;\n  local_78[4] = (byte *)0x40a39f;\n  local_50 = \"sha2 utilities\";\n  local_48 = \"sha384sum\";\n  local_40 = \"sha2 utilities\";\n  local_38 = \"sha512sum\";\n  local_30 = \"sha2 utilities\";\n  local_28 = 0;\n  local_20 = 0;\n  ppbVar6 = &local_88;\n  do {\n    ppbVar7 = ppbVar6;\n    ppbVar6 = ppbVar7 + 2;\n    pbVar11 = *ppbVar6;\n    bVar12 = false;\n    bVar13 = pbVar11 == (byte *)0x0;\n    if (bVar13) break;\n    lVar9 = 6;\n    pbVar10 = (byte *)\"shred\";\n    do {\n      if (lVar9 == 0) break;\n      lVar9 = lVar9 + -1;\n      bVar12 = *pbVar10 < *pbVar11;\n      bVar13 = *pbVar10 == *pbVar11;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n      pbVar11 = pbVar11 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n  } while ((!bVar12 && !bVar13) != bVar12);\n  pcVar4 = (char *)ppbVar7[3];\n  if ((byte *)pcVar4 == (byte *)0x0) {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar2 = strncmp(pcVar4,\"en_\",3);\n      if (iVar2 != 0) {\n        pcVar4 = \"shred\";\n        goto LAB_00403ee3;\n      }\n    }\n    pcVar4 = \"shred\";\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar8 = \" invocation\";\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"shred\");\n  }\n  else {\n    uVar5 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar5,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar8 = setlocale(5,(char *)0x0);\n    if (pcVar8 != (char *)0x0) {\n      iVar2 = strncmp(pcVar8,\"en_\",3);\n      if (iVar2 != 0) {\nLAB_00403ee3:\n        uVar5 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar5,\"shred\");\n      }\n    }\n    pcVar8 = \" invocation\";\n    uVar5 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    __printf_chk(1,uVar5,\"https://www.gnu.org/software/coreutils/\",\"shred\");\n    if (pcVar4 != \"shred\") {\n      pcVar8 = \"\";\n    }\n  }\n  uVar5 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  __printf_chk(1,uVar5,pcVar4,pcVar8);\nLAB_00403aff:\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
            "funcName": "FUN_00403ac0"
        },
        {
            "funcStartAddr": "0x403f10",
            "funcEndAddr": "0x403f1a",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00403b06) */\n/* WARNING: Removing unreachable block (ram,0x00403d70) */\n/* WARNING: Removing unreachable block (ram,0x00403d7c) */\n/* WARNING: Removing unreachable block (ram,0x00403d86) */\n/* WARNING: Removing unreachable block (ram,0x00403d88) */\n/* WARNING: Removing unreachable block (ram,0x00403d92) */\n/* WARNING: Removing unreachable block (ram,0x00403e5f) */\n/* WARNING: Removing unreachable block (ram,0x00403e8e) */\n/* WARNING: Removing unreachable block (ram,0x00403ede) */\n/* WARNING: Removing unreachable block (ram,0x00403ea4) */\n/* WARNING: Removing unreachable block (ram,0x00403dab) */\n/* WARNING: Removing unreachable block (ram,0x00403dda) */\n/* WARNING: Removing unreachable block (ram,0x00403ee3) */\n/* WARNING: Removing unreachable block (ram,0x00403df4) */\n/* WARNING: Removing unreachable block (ram,0x00403e30) */\n/* WARNING: Removing unreachable block (ram,0x00403e34) */\n\nvoid FUN_00403f10(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = DAT_0060f3b0;\n  uVar2 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n  __fprintf_chk(stderr,1,uVar2,uVar1);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
            "funcName": "FUN_00403f10"
        },
        {
            "funcStartAddr": "0x403f20",
            "funcEndAddr": "0x404023",
            "decompiledFuncCode": "\nlong FUN_00403f20(char *param_1,char **param_2,void *param_3,size_t param_4)\n\n{\n  bool bVar1;\n  long lVar2;\n  int iVar3;\n  size_t __n;\n  size_t sVar4;\n  long lVar5;\n  void *__s2;\n  char *__s1;\n  long local_58;\n  \n  __n = strlen(param_1);\n  __s1 = *param_2;\n  local_58 = -1;\n  lVar2 = local_58;\n  if (__s1 != (char *)0x0) {\n    bVar1 = false;\n    lVar2 = 0;\n    __s2 = param_3;\nLAB_00403fb7:\n    do {\n      lVar5 = lVar2;\n      iVar3 = strncmp(__s1,param_1,__n);\n      if (iVar3 == 0) {\n        sVar4 = strlen(__s1);\n        if (sVar4 == __n) {\n          return lVar5;\n        }\n        if (local_58 == -1) {\n          __s2 = (void *)((long)__s2 + param_4);\n          __s1 = param_2[lVar5 + 1];\n          lVar2 = lVar5 + 1;\n          local_58 = lVar5;\n          if (__s1 == (char *)0x0) break;\n          goto LAB_00403fb7;\n        }\n        if (param_3 == (void *)0x0) {\n          bVar1 = true;\n        }\n        else {\n          iVar3 = memcmp((void *)(local_58 * param_4 + (long)param_3),__s2,param_4);\n          if (iVar3 != 0) {\n            bVar1 = true;\n          }\n        }\n      }\n      __s2 = (void *)((long)__s2 + param_4);\n      __s1 = param_2[lVar5 + 1];\n      lVar2 = lVar5 + 1;\n    } while (__s1 != (char *)0x0);\n    lVar2 = -2;\n    if (!bVar1) {\n      lVar2 = local_58;\n    }\n  }\n  local_58 = lVar2;\n  return local_58;\n}\n\n",
            "funcName": "FUN_00403f20"
        },
        {
            "funcStartAddr": "0x404040",
            "funcEndAddr": "0x4040ac",
            "decompiledFuncCode": "\nvoid FUN_00404040(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_3 == -1) {\n    uVar1 = dcgettext(0,\"invalid argument %s for %s\",5);\n  }\n  else {\n    uVar1 = dcgettext(0,\"ambiguous argument %s for %s\",5);\n  }\n  uVar2 = FUN_00406dc0(1,param_1);\n  uVar3 = FUN_00406ab0(0,8,param_2);\n  error(0,0,uVar1,uVar3,uVar2);\n  return;\n}\n\n",
            "funcName": "FUN_00404040"
        },
        {
            "funcStartAddr": "0x4040c0",
            "funcEndAddr": "0x4041cf",
            "decompiledFuncCode": "\nvoid FUN_004040c0(long *param_1,void *param_2,size_t param_3)\n\n{\n  FILE *__stream;\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long lVar4;\n  void *__s2;\n  long lVar5;\n  void *__s1;\n  \n  __stream = stderr;\n  __s1 = (void *)0x0;\n  pcVar2 = (char *)dcgettext(0,\"Valid arguments are:\",5);\n  lVar4 = 0;\n  fputs_unlocked(pcVar2,__stream);\n  lVar5 = *param_1;\n  while (lVar5 != 0) {\n    while ((__s2 = param_2, lVar4 == 0 || (iVar1 = memcmp(__s1,__s2,param_3), iVar1 != 0))) {\n      lVar4 = lVar4 + 1;\n      uVar3 = FUN_00406de0(lVar5);\n      __fprintf_chk(stderr,1,\"\\n  - %s\",uVar3);\n      lVar5 = param_1[lVar4];\n      param_2 = (void *)((long)__s2 + param_3);\n      __s1 = __s2;\n      if (lVar5 == 0) goto LAB_00404190;\n    }\n    lVar4 = lVar4 + 1;\n    param_2 = (void *)((long)__s2 + param_3);\n    uVar3 = FUN_00406de0(lVar5);\n    __fprintf_chk(stderr,1,&DAT_0040b61a,uVar3);\n    lVar5 = param_1[lVar4];\n  }\nLAB_00404190:\n  pcVar2 = stderr->_IO_write_ptr;\n  if (pcVar2 < stderr->_IO_write_end) {\n    stderr->_IO_write_ptr = pcVar2 + 1;\n    *pcVar2 = '\\n';\n    return;\n  }\n  __overflow(stderr,10);\n  return;\n}\n\n",
            "funcName": "FUN_004040c0"
        },
        {
            "funcStartAddr": "0x4041e0",
            "funcEndAddr": "0x40424d",
            "decompiledFuncCode": "\nlong FUN_004041e0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,code *param_6)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_00403f20(param_2,param_3,param_4,param_5);\n  if (lVar1 < 0) {\n    FUN_00404040(param_1,param_2,lVar1);\n    FUN_004040c0(param_3,param_4,param_5);\n    (*param_6)();\n    lVar1 = -1;\n  }\n  return lVar1;\n}\n\n",
            "funcName": "FUN_004041e0"
        },
        {
            "funcStartAddr": "0x404250",
            "funcEndAddr": "0x40429c",
            "decompiledFuncCode": "\nlong FUN_00404250(void *param_1,long *param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = *param_2;\n  if (lVar2 != 0) {\n    param_2 = param_2 + 1;\n    do {\n      iVar1 = memcmp(param_1,param_3,param_4);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = *param_2;\n      param_3 = (void *)((long)param_3 + param_4);\n      param_2 = param_2 + 1;\n    } while (lVar2 != 0);\n  }\n  return lVar2;\n}\n\n",
            "funcName": "FUN_00404250"
        },
        {
            "funcStartAddr": "0x4042a0",
            "funcEndAddr": "0x4042a8",
            "decompiledFuncCode": "\nvoid FUN_004042a0(undefined8 param_1)\n\n{\n  DAT_0060f3a8 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_004042a0"
        },
        {
            "funcStartAddr": "0x4042b0",
            "funcEndAddr": "0x4042b8",
            "decompiledFuncCode": "\nvoid FUN_004042b0(undefined param_1)\n\n{\n  DAT_0060f3a0 = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_004042b0"
        },
        {
            "funcStartAddr": "0x4042c0",
            "funcEndAddr": "0x40435e",
            "decompiledFuncCode": "\nvoid FUN_004042c0(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = FUN_00409ac0(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((DAT_0060f3a0 == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (DAT_0060f3a8 == 0) {\n        error(0,*piVar2,&DAT_0040b61c,uVar3);\n      }\n      else {\n        uVar4 = FUN_00406c30();\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n      goto LAB_0040433e;\n    }\n  }\n  iVar1 = FUN_00409ac0(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_0040433e:\n                    /* WARNING: Subroutine does not return */\n  _exit(DAT_0060f2e0);\n}\n\n",
            "funcName": "FUN_004042c0"
        },
        {
            "funcStartAddr": "0x404360",
            "funcEndAddr": "0x404378",
            "decompiledFuncCode": "\nvoid FUN_00404360(void)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_004043e0();\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00408490();\n}\n\n",
            "funcName": "FUN_00404360"
        },
        {
            "funcStartAddr": "0x404380",
            "funcEndAddr": "0x4043d8",
            "decompiledFuncCode": "\nulong FUN_00404380(char *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  cVar1 = *param_1;\n  lVar2 = FUN_00404440();\n  uVar3 = lVar2 - (long)param_1;\n  if (((cVar1 == '/') < uVar3) && (*(char *)(lVar2 + -1) == '/')) {\n    do {\n      uVar4 = uVar3 - 1;\n      if ((cVar1 == '/') == uVar4) {\n        return uVar4;\n      }\n      lVar2 = uVar3 - 2;\n      uVar3 = uVar4;\n    } while (param_1[lVar2] == '/');\n    return uVar4;\n  }\n  return uVar3;\n}\n\n",
            "funcName": "FUN_00404380"
        },
        {
            "funcStartAddr": "0x4043e0",
            "funcEndAddr": "0x40443a",
            "decompiledFuncCode": "\nundefined * FUN_004043e0(void *param_1)\n\n{\n  size_t __n;\n  undefined *__dest;\n  \n  __n = FUN_00404380();\n  __dest = (undefined *)malloc(__n + 1 + (ulong)(__n == 0));\n  if (__dest != (undefined *)0x0) {\n    __dest = (undefined *)memcpy(__dest,param_1,__n);\n    if (__n == 0) {\n      *__dest = 0x2e;\n      __n = 1;\n    }\n    __dest[__n] = 0;\n  }\n  return __dest;\n}\n\n",
            "funcName": "FUN_004043e0"
        },
        {
            "funcStartAddr": "0x404440",
            "funcEndAddr": "0x404492",
            "decompiledFuncCode": "\nchar * FUN_00404440(char *param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  while (cVar3 == '/') {\n    param_1 = param_1 + 1;\n    cVar3 = *param_1;\n  }\n  if (cVar3 != '\\0') {\n    bVar1 = false;\n    pcVar2 = param_1;\n    do {\n      while (cVar3 == '/') {\n        pcVar2 = pcVar2 + 1;\n        cVar3 = *pcVar2;\n        bVar1 = true;\n        if (cVar3 == '\\0') {\n          return param_1;\n        }\n      }\n      if (bVar1) {\n        bVar1 = false;\n        param_1 = pcVar2;\n      }\n      pcVar2 = pcVar2 + 1;\n      cVar3 = *pcVar2;\n    } while (cVar3 != '\\0');\n  }\n  return param_1;\n}\n\n",
            "funcName": "FUN_00404440"
        },
        {
            "funcStartAddr": "0x4044a0",
            "funcEndAddr": "0x4044c7",
            "decompiledFuncCode": "\nvoid FUN_004044a0(char *param_1)\n\n{\n  long lVar1;\n  size_t sVar2;\n  \n  sVar2 = strlen(param_1);\n  if (1 < sVar2) {\n    while (lVar1 = sVar2 - 1, sVar2 = sVar2 - 1, param_1[lVar1] == '/') {\n      if (sVar2 == 1) {\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "funcName": "FUN_004044a0"
        },
        {
            "funcStartAddr": "0x4044d0",
            "funcEndAddr": "0x404516",
            "decompiledFuncCode": "\nvoid FUN_004044d0(char *param_1,uint param_2,ulong param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  if ((param_2 & 0x40) != 0) {\n    uVar2 = param_3 & 0xffffffff;\n  }\n  iVar1 = open(param_1,param_2,uVar2);\n  FUN_00407c50(iVar1);\n  return;\n}\n\n",
            "funcName": "FUN_004044d0"
        },
        {
            "funcStartAddr": "0x404520",
            "funcEndAddr": "0x4045c8",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00404578) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00404520(int param_1)\n\n{\n  ulong uVar1;\n  float10 fVar2;\n  float10 param_7;\n  \n  if ((float10)_DAT_0040b6c4 <= param_7) {\n    uVar1 = (long)ROUND(param_7 - (float10)_DAT_0040b6c4) ^ 0x8000000000000000;\n  }\n  else {\n    uVar1 = (ulong)ROUND(param_7);\n  }\n  fVar2 = (float10)uVar1;\n  if ((long)uVar1 < 0) {\n    fVar2 = fVar2 + (float10)_DAT_0040b6c8;\n  }\n  if (((param_1 == 0) && (param_7 != fVar2)) && ((long)(uVar1 + 1) < 0)) {\n    return;\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00404520"
        },
        {
            "funcStartAddr": "0x4045e0",
            "funcEndAddr": "0x404f45",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * FUN_004045e0(ulong param_1,char *param_2,uint param_3,ulong param_4,ulong param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  char cVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  lconv *plVar9;\n  ulong uVar10;\n  size_t sVar11;\n  size_t __n;\n  ulong uVar12;\n  long lVar13;\n  uint uVar14;\n  uint uVar15;\n  uint uVar16;\n  ulong uVar17;\n  ulong uVar18;\n  uint uVar19;\n  ulong uVar20;\n  char *__s;\n  undefined8 *__dest;\n  undefined8 *puVar21;\n  undefined8 *puVar22;\n  byte *pbVar23;\n  bool bVar24;\n  float10 fVar25;\n  float10 fVar26;\n  float10 fVar27;\n  undefined8 *local_a8;\n  undefined local_68 [56];\n  \n  uVar5 = param_3 & 0x20;\n  uVar14 = param_3 & 3;\n  uVar6 = (-(uint)(uVar5 == 0) & 0xffffffe8) + 0x400;\n  plVar9 = localeconv();\n  puVar21 = (undefined8 *)plVar9->decimal_point;\n  uVar10 = strlen((char *)puVar21);\n  bVar24 = 0xf < uVar10 - 1;\n  if (bVar24) {\n    puVar21 = (undefined8 *)0x40a2b3;\n  }\n  pbVar23 = (byte *)plVar9->grouping;\n  __s = plVar9->thousands_sep;\n  if (bVar24) {\n    uVar10 = 1;\n  }\n  sVar11 = strlen(__s);\n  if (0x10 < sVar11) {\n    __s = \"\";\n  }\n  local_a8 = (undefined8 *)(param_2 + 0x287);\n  uVar15 = (uint)uVar10;\n  if (param_4 < param_5) {\n    if (param_4 != 0) {\n      auVar3 = ZEXT816(param_5) / ZEXT816(param_4);\n      if (param_5 % param_4 == 0) {\n        uVar17 = SUB168(ZEXT816(param_1) / (auVar3 & (undefined  [16])0xffffffffffffffff),0);\n        auVar2 = ZEXT816((ulong)(SUB168(ZEXT816(param_1) %\n                                        (auVar3 & (undefined  [16])0xffffffffffffffff),0) * 10));\n        uVar18 = SUB168(auVar2 % (auVar3 & (undefined  [16])0xffffffffffffffff),0) * 2;\n        uVar8 = SUB164(auVar2 / (auVar3 & (undefined  [16])0xffffffffffffffff),0);\n        uVar12 = (ulong)uVar8;\n        if (uVar18 < SUB168(auVar3,0)) {\n          uVar19 = (uint)(uVar18 != 0);\n        }\n        else {\n          uVar19 = (SUB168(auVar3,0) < uVar18) + 2;\n        }\n        goto joined_r0x00404978;\n      }\n    }\nLAB_004046c5:\n    fVar25 = (float10)param_4;\n    if ((long)param_4 < 0) {\n      fVar25 = fVar25 + (float10)_DAT_0040b6c8;\n    }\n    if ((long)param_5 < 0) {\n      fVar25 = fVar25 / ((float10)param_5 + (float10)_DAT_0040b6c8);\n      if ((long)param_1 < 0) goto LAB_004048d8;\nLAB_00404702:\n      fVar25 = (float10)param_1 * fVar25;\n      if ((param_3 & 0x10) != 0) goto LAB_0040470f;\nLAB_00404820:\n      if ((uVar14 != 1) && (fVar25 < _DAT_0040b6d0)) {\n        FUN_00404520();\n        uVar10 = SUB108(fVar25,0);\n      }\n      __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\",uVar10);\n      uVar16 = 0xffffffff;\n      __n = strlen(param_2);\n      sVar11 = __n;\n    }\n    else {\n      fVar25 = fVar25 / (float10)param_5;\n      if (-1 < (long)param_1) goto LAB_00404702;\nLAB_004048d8:\n      fVar25 = ((float10)param_1 + (float10)_DAT_0040b6c8) * fVar25;\n      if ((param_3 & 0x10) == 0) goto LAB_00404820;\nLAB_0040470f:\n      uVar16 = 0;\n      fVar27 = (float10)uVar6;\n      do {\n        fVar26 = fVar27;\n        uVar16 = uVar16 + 1;\n        fVar27 = fVar26 * (float10)uVar6;\n        if (fVar25 < fVar27) break;\n      } while (uVar16 != 8);\n      fVar25 = fVar25 / fVar26;\n      uVar17 = uVar10 + 2 + (ulong)(uVar5 == 0);\n      if (uVar14 == 1) {\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.1Lf\");\n        __n = strlen(param_2);\n        if (__n <= uVar17) goto LAB_00404c48;\n      }\n      else {\n        if (fVar25 < _DAT_0040b6d0) {\n          FUN_00404520();\n        }\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.1Lf\");\n        __n = strlen(param_2);\n        if (__n <= uVar17) {\nLAB_00404c48:\n          if (((param_3 & 8) == 0) || (param_2[__n - 1] != '0')) {\n            sVar11 = __n - (uVar10 + 1);\n            goto LAB_00404870;\n          }\n          if (uVar14 == 1) goto LAB_004047e6;\n        }\n        if (fVar25 * (float10)_DAT_0040b6cc < _DAT_0040b6d0) {\n          FUN_00404520(uVar14);\n        }\n      }\nLAB_004047e6:\n      __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\");\n      __n = strlen(param_2);\n      sVar11 = __n;\n    }\nLAB_00404870:\n    puVar22 = (undefined8 *)((long)local_a8 - __n);\n    memmove(puVar22,param_2,__n);\n    __dest = (undefined8 *)(sVar11 + (long)puVar22);\n  }\n  else {\n    if ((param_4 % param_5 != 0) ||\n       (uVar17 = SUB168(ZEXT816(param_4) / ZEXT816(param_5),0) * param_1,\n       SUB168(ZEXT816(uVar17) /\n              (ZEXT816(param_4) / ZEXT816(param_5) & (undefined  [16])0xffffffffffffffff),0) !=\n       param_1)) goto LAB_004046c5;\n    uVar19 = 0;\n    uVar12 = 0;\n    uVar8 = 0;\njoined_r0x00404978:\n    puVar22 = local_a8;\n    if ((param_3 & 0x10) == 0) {\n      uVar16 = 0xffffffff;\nLAB_00404991:\n      if (uVar14 != 1) goto LAB_004049a0;\n      __dest = local_a8;\n      if (5 < (int)(uVar8 + (((uint)uVar17 & 1) + uVar19 != 0))) goto LAB_004049b1;\nLAB_004049e3:\n      do {\n        puVar22 = (undefined8 *)((long)puVar22 + -1);\n        *(char *)puVar22 = (char)uVar17 + (char)(uVar17 / 10) * -10 + '0';\n        bVar24 = 9 < uVar17;\n        uVar17 = uVar17 / 10;\n      } while (bVar24);\n    }\n    else {\n      uVar8 = (uint)uVar12;\n      uVar20 = (ulong)uVar6;\n      uVar16 = 0;\n      uVar18 = uVar17;\n      if (uVar17 < uVar20) goto LAB_00404991;\n      while( true ) {\n        uVar17 = uVar18 / uVar20;\n        uVar7 = (int)uVar12 + (int)(uVar18 % uVar20) * 10;\n        uVar12 = uVar7 / uVar20;\n        uVar8 = (uint)uVar12;\n        uVar7 = ((int)uVar19 >> 1) + (uVar7 % uVar6) * 2;\n        uVar19 = uVar19 + uVar7;\n        if (uVar7 < uVar6) {\n          uVar19 = (uint)(uVar19 != 0);\n        }\n        else {\n          uVar19 = (uVar6 < uVar19) + 2;\n        }\n        uVar16 = uVar16 + 1;\n        if (uVar17 < uVar20) break;\n        uVar18 = uVar17;\n        if (uVar16 == 8) goto LAB_00404991;\n      }\n      if (9 < uVar17) goto LAB_00404991;\n      if (uVar14 == 1) {\n        bVar24 = 2 < (uVar8 & 1) + uVar19;\n      }\n      else {\n        bVar24 = uVar19 != 0 && uVar14 == 0;\n      }\n      if (bVar24) {\n        uVar8 = uVar8 + 1;\n        if (uVar8 != 10) goto LAB_00404e48;\n        uVar17 = uVar17 + 1;\n        if (uVar17 == 10) goto LAB_00404dfe;\n        uVar19 = 0;\nLAB_00404db7:\n        if ((param_3 & 8) != 0) goto LAB_00404e00;\n        cVar4 = '0';\n      }\n      else {\n        if (uVar8 == 0) goto LAB_00404db7;\nLAB_00404e48:\n        cVar4 = (char)uVar8 + '0';\n      }\n      param_2[0x286] = cVar4;\n      uVar12 = uVar10 & 0xffffffff;\n      puVar22 = (undefined8 *)(param_2 + (0x286 - uVar10));\n      if (uVar15 < 8) {\n        if ((uVar10 & 4) == 0) {\n          if (((int)uVar12 != 0) &&\n             (*(undefined *)puVar22 = *(undefined *)puVar21, (uVar10 & 2) != 0)) {\n            *(undefined2 *)((long)puVar22 + (uVar12 - 2)) =\n                 *(undefined2 *)((long)puVar21 + (uVar12 - 2));\n          }\n        }\n        else {\n          *(undefined4 *)puVar22 = *(undefined4 *)puVar21;\n          *(undefined4 *)((long)puVar22 + (uVar12 - 4)) =\n               *(undefined4 *)((long)puVar21 + (uVar12 - 4));\n        }\n      }\n      else {\n        *puVar22 = *puVar21;\n        *(undefined8 *)((long)puVar22 + ((uVar10 & 0xffffffff) - 8)) =\n             *(undefined8 *)((long)puVar21 + ((uVar10 & 0xffffffff) - 8));\n        lVar13 = (long)puVar22 - ((ulong)(puVar22 + 1) & 0xfffffffffffffff8);\n        uVar8 = (int)lVar13 + uVar15 & 0xfffffff8;\n        if (7 < uVar8) {\n          uVar19 = 0;\n          do {\n            uVar12 = (ulong)uVar19;\n            uVar19 = uVar19 + 8;\n            *(undefined8 *)(((ulong)(puVar22 + 1) & 0xfffffffffffffff8) + uVar12) =\n                 *(undefined8 *)((long)puVar21 + (uVar12 - lVar13));\n          } while (uVar19 < uVar8);\n        }\n      }\nLAB_00404dfe:\n      uVar19 = 0;\nLAB_00404e00:\n      __dest = puVar22;\n      if (uVar14 == 1) goto LAB_004049e3;\n      uVar8 = 0;\nLAB_004049a0:\n      __dest = puVar22;\n      if ((uVar14 != 0) || ((int)(uVar19 + uVar8) < 1)) goto LAB_004049e3;\nLAB_004049b1:\n      uVar17 = uVar17 + 1;\n      __dest = puVar22;\n      if ((((param_3 & 0x10) == 0) || (uVar6 != uVar17)) || (uVar16 == 8)) goto LAB_004049e3;\n      uVar16 = uVar16 + 1;\n      if ((param_3 & 8) == 0) {\n        *(undefined *)((long)puVar22 + -1) = 0x30;\n        puVar22 = (undefined8 *)((long)puVar22 + ~uVar10);\n        uVar17 = uVar10 & 0xffffffff;\n        if (uVar15 < 8) {\n          if ((uVar10 & 4) == 0) {\n            if (((int)uVar17 != 0) &&\n               (*(undefined *)puVar22 = *(undefined *)puVar21, (uVar10 & 2) != 0)) {\n              *(undefined2 *)((long)puVar22 + (uVar17 - 2)) =\n                   *(undefined2 *)((long)puVar21 + (uVar17 - 2));\n            }\n          }\n          else {\n            *(undefined4 *)puVar22 = *(undefined4 *)puVar21;\n            *(undefined4 *)((long)puVar22 + (uVar17 - 4)) =\n                 *(undefined4 *)((long)puVar21 + (uVar17 - 4));\n          }\n        }\n        else {\n          *puVar22 = *puVar21;\n          *(undefined8 *)((long)puVar22 + ((uVar10 & 0xffffffff) - 8)) =\n               *(undefined8 *)((long)puVar21 + ((uVar10 & 0xffffffff) - 8));\n          lVar13 = (long)puVar22 - ((ulong)(puVar22 + 1) & 0xfffffffffffffff8);\n          uVar14 = (int)lVar13 + uVar15 & 0xfffffff8;\n          if (7 < uVar14) {\n            uVar15 = 0;\n            do {\n              uVar10 = (ulong)uVar15;\n              uVar15 = uVar15 + 8;\n              *(undefined8 *)(((ulong)(puVar22 + 1) & 0xfffffffffffffff8) + uVar10) =\n                   *(undefined8 *)((long)puVar21 + (uVar10 - lVar13));\n            } while (uVar15 < uVar14);\n          }\n        }\n      }\n      *(undefined *)((long)puVar22 + -1) = 0x31;\n      __dest = puVar22;\n      puVar22 = (undefined8 *)((long)puVar22 + -1);\n    }\n  }\n  if ((param_3 & 4) != 0) {\n    sVar11 = strlen(__s);\n    uVar17 = (long)__dest - (long)puVar22;\n    __memcpy_chk(local_68,puVar22,uVar17,0x29);\n    uVar10 = 0xffffffffffffffff;\n    while( true ) {\n      bVar1 = *pbVar23;\n      if (bVar1 != 0) {\n        uVar10 = (ulong)bVar1;\n        if (0x7e < bVar1) {\n          uVar10 = uVar17;\n        }\n        pbVar23 = pbVar23 + 1;\n      }\n      if (uVar17 < uVar10) break;\n      puVar22 = (undefined8 *)((long)__dest - uVar10);\n      uVar17 = uVar17 - uVar10;\n      memcpy(puVar22,local_68 + uVar17,uVar10);\n      if (uVar17 == 0) goto LAB_00404895;\n      __dest = (undefined8 *)((long)puVar22 - sVar11);\n      memcpy(__dest,__s,sVar11);\n    }\n    puVar22 = (undefined8 *)((long)__dest - uVar17);\n    memcpy(puVar22,local_68,uVar17);\n  }\nLAB_00404895:\n  if ((param_3 & 0x80) == 0) goto LAB_004048b8;\n  if (uVar16 == 0xffffffff) {\n    if (param_5 < 2) {\n      uVar16 = 0;\n      goto LAB_004048a5;\n    }\n    uVar16 = 1;\n    uVar10 = 1;\n    do {\n      uVar10 = uVar10 * uVar6;\n      if (param_5 <= uVar10) break;\n      uVar16 = uVar16 + 1;\n    } while (uVar16 != 8);\n    if ((param_3 & 0x40) != 0) goto LAB_00404b21;\nLAB_00404b40:\n    if ((uVar5 == 0) && (uVar16 == 1)) {\n      *(undefined *)local_a8 = 0x6b;\n      puVar21 = (undefined8 *)((long)local_a8 + 1);\n      if ((param_3 & 0x100) == 0) {\nLAB_00404d73:\n        local_a8 = (undefined8 *)((long)local_a8 + 1);\n        goto LAB_004048b8;\n      }\n    }\n    else {\n      *(undefined *)local_a8 = (&UNK_0040b6b8)[(int)uVar16];\n      if ((param_3 & 0x100) == 0) goto LAB_00404d73;\n      puVar21 = (undefined8 *)((long)local_a8 + 1);\n      if (uVar5 != 0) {\n        *(undefined *)((long)local_a8 + 1) = 0x69;\n        puVar21 = (undefined8 *)((long)local_a8 + 2);\n      }\n    }\n  }\n  else {\nLAB_004048a5:\n    if ((param_3 & 0x100 | uVar16) == 0) goto LAB_004048b8;\n    if ((param_3 & 0x40) != 0) {\nLAB_00404b21:\n      local_a8 = (undefined8 *)(param_2 + 0x288);\n      param_2[0x287] = ' ';\n    }\n    if (uVar16 != 0) goto LAB_00404b40;\n    puVar21 = local_a8;\n    if ((param_3 & 0x100) == 0) goto LAB_004048b8;\n  }\n  local_a8 = (undefined8 *)((long)puVar21 + 1);\n  *(undefined *)puVar21 = 0x42;\nLAB_004048b8:\n  *(undefined *)local_a8 = 0;\n  return puVar22;\n}\n\n",
            "funcName": "FUN_004045e0"
        },
        {
            "funcStartAddr": "0x404fb0",
            "funcEndAddr": "0x405141",
            "decompiledFuncCode": "\nchar * FUN_00404fb0(char *param_1,uint *param_2,long *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  long lVar4;\n  uint uVar5;\n  char *local_30 [2];\n  \n  if (((param_1 == (char *)0x0) && (param_1 = getenv(\"BLOCK_SIZE\"), param_1 == (char *)0x0)) &&\n     (param_1 = getenv(\"BLOCKSIZE\"), param_1 == (char *)0x0)) {\n    pcVar3 = getenv(\"POSIXLY_CORRECT\");\n    if (pcVar3 == (char *)0x0) {\n      *param_3 = 0x400;\n      *param_2 = 0;\n    }\n    else {\n      *param_3 = 0x200;\n      pcVar3 = (char *)0x0;\n      *param_2 = 0;\n    }\n  }\n  else {\n    uVar5 = 0;\n    if (*param_1 == '\\'') {\n      param_1 = param_1 + 1;\n      uVar5 = 4;\n    }\n    iVar2 = FUN_00403f20(param_1,&PTR_s_human_readable_0040b6a0,&DAT_0040b690,4);\n    if (iVar2 < 0) {\n      pcVar3 = (char *)FUN_004085d0(param_1,local_30,0,param_3,\"eEgGkKmMpPtTyYzZ0\");\n      if ((int)pcVar3 == 0) {\n        cVar1 = *param_1;\n        while (9 < (byte)(cVar1 - 0x30U)) {\n          if (param_1 == local_30[0]) {\n            if (local_30[0][-1] == 'B') {\n              uVar5 = uVar5 | 0x180;\n              if (local_30[0][-2] != 'i') break;\n            }\n            else {\n              uVar5 = uVar5 | 0x80;\n            }\n            uVar5 = uVar5 | 0x20;\n            break;\n          }\n          param_1 = param_1 + 1;\n          cVar1 = *param_1;\n        }\n        lVar4 = *param_3;\n        *param_2 = uVar5;\n      }\n      else {\n        *param_2 = 0;\n        lVar4 = *param_3;\n      }\n      if (lVar4 == 0) {\n        pcVar3 = getenv(\"POSIXLY_CORRECT\");\n        *param_3 = (ulong)(-(uint)(pcVar3 == (char *)0x0) & 0x200) + 0x200;\n        return (char *)0x4;\n      }\n    }\n    else {\n      *param_3 = 1;\n      pcVar3 = (char *)0x0;\n      *param_2 = uVar5 | *(uint *)(&DAT_0040b690 + (long)iVar2 * 4);\n    }\n  }\n  return pcVar3;\n}\n\n",
            "funcName": "FUN_00404fb0"
        },
        {
            "funcStartAddr": "0x405170",
            "funcEndAddr": "0x4051b4",
            "decompiledFuncCode": "\nchar * FUN_00405170(ulong param_1,long param_2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)(param_2 + 0x14);\n  *(undefined *)(param_2 + 0x14) = 0;\n  do {\n    pcVar2 = pcVar2 + -1;\n    *pcVar2 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_00405170"
        },
        {
            "funcStartAddr": "0x4051c0",
            "funcEndAddr": "0x405259",
            "decompiledFuncCode": "\nvoid FUN_004051c0(byte *param_1)\n\n{\n  byte *pbVar1;\n  char *pcVar2;\n  long lVar3;\n  ulong uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  \n  bVar10 = 0;\n  if (param_1 == (byte *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr((char *)param_1,0x2f);\n  if (pcVar2 != (char *)0x0) {\n    pbVar1 = (byte *)(pcVar2 + 1);\n    uVar4 = (long)pbVar1 - (long)param_1;\n    bVar7 = uVar4 < 6;\n    bVar9 = uVar4 == 6;\n    if (6 < (long)uVar4) {\n      lVar3 = 7;\n      pbVar5 = (byte *)(pcVar2 + -6);\n      pbVar6 = (byte *)\"/.libs/\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar5 < *pbVar6;\n        bVar9 = *pbVar5 == *pbVar6;\n        pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n        pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n      } while (bVar9);\n      bVar8 = false;\n      bVar7 = (!bVar7 && !bVar9) == bVar7;\n      if (bVar7) {\n        lVar3 = 3;\n        pbVar5 = pbVar1;\n        pbVar6 = &DAT_0040b720;\n        do {\n          if (lVar3 == 0) break;\n          lVar3 = lVar3 + -1;\n          bVar8 = *pbVar5 < *pbVar6;\n          bVar7 = *pbVar5 == *pbVar6;\n          pbVar5 = pbVar5 + (ulong)bVar10 * -2 + 1;\n          pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n        } while (bVar7);\n        param_1 = pbVar1;\n        if ((!bVar8 && !bVar7) == bVar8) {\n          param_1 = (byte *)(pcVar2 + 4);\n          program_invocation_short_name = param_1;\n        }\n      }\n    }\n  }\n  DAT_0060f3b0 = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n",
            "funcName": "FUN_004051c0"
        },
        {
            "funcStartAddr": "0x405260",
            "funcEndAddr": "0x40533f",
            "decompiledFuncCode": "\nchar * FUN_00405260(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  byte *pbVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    pbVar3 = (byte *)FUN_00409c20();\n    if ((*pbVar3 & 0xdf) == 0x55) {\n      if (((((pbVar3[1] & 0xdf) != 0x54) || ((pbVar3[2] & 0xdf) != 0x46)) || (pbVar3[3] != 0x2d)) ||\n         ((pbVar3[4] != 0x38 || (pbVar3[5] != 0)))) {\nLAB_00405338:\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_0040b731;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_0040b726;\n      }\n    }\n    else {\n      if (((((*pbVar3 & 0xdf) != 0x47) || ((pbVar3[1] & 0xdf) != 0x42)) || (pbVar3[2] != 0x31)) ||\n         (((pbVar3[3] != 0x38 || (pbVar3[4] != 0x30)) ||\n          ((pbVar3[5] != 0x33 || ((pbVar3[6] != 0x30 || (pbVar3[7] != 0)))))))) goto LAB_00405338;\n      cVar1 = *pcVar2;\n      pcVar2 = &DAT_0040b72d;\n      if (cVar1 != '`') {\n        pcVar2 = &DAT_0040b72a;\n      }\n    }\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "FUN_00405260"
        },
        {
            "funcStartAddr": "0x405360",
            "funcEndAddr": "0x406493",
            "decompiledFuncCode": "\nulong FUN_00405360(undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                  uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  ulong uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ulong uVar9;\n  ushort **ppuVar10;\n  long lVar11;\n  char *pcVar12;\n  byte bVar13;\n  char cVar14;\n  ulong uVar15;\n  ulong uVar16;\n  byte bVar17;\n  uint uVar18;\n  ulong uVar19;\n  bool bVar20;\n  ulong uVar21;\n  ulong uVar22;\n  bool bVar23;\n  bool bVar24;\n  bool bVar25;\n  bool bVar26;\n  size_t local_a0;\n  char *local_78;\n  ulong local_70;\n  bool local_5c;\n  bool local_5b;\n  wint_t local_44;\n  mbstate_t local_40 [2];\n  \n  sVar8 = __ctype_get_mb_cur_max();\n  uVar18 = param_6 & 2;\n  local_5c = uVar18 != 0;\n  uVar9 = param_2;\n  switch(param_5) {\n  case 0:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = false;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar18 != 0) {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = false;\n      local_a0 = 1;\n      local_78 = \"\\'\";\n      break;\n    }\n    bVar6 = false;\nLAB_00405fb1:\n    if (param_2 != 0) {\n      bVar3 = false;\n      local_5b = false;\n      bVar2 = true;\n      local_70 = 0;\n      goto LAB_00405be6;\n    }\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 1;\n    param_5 = 2;\n    local_70 = 0;\n    local_5b = false;\n    local_5c = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 3:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 4:\n    if (uVar18 == 0) {\n      bVar6 = true;\n      goto LAB_00405fb1;\n    }\n  case 1:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 2;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = false;\n    local_a0 = 1;\n    local_78 = \"\\'\";\n    break;\n  case 5:\n    if (uVar18 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      local_5b = false;\n      local_70 = 0;\n      bVar2 = true;\n      bVar3 = false;\n      local_5c = false;\n      uVar15 = 1;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    else {\n      bVar2 = true;\n      bVar3 = false;\n      uVar15 = 0;\n      local_5b = false;\n      local_70 = 0;\n      local_5c = true;\n      bVar6 = true;\n      local_a0 = 1;\n      local_78 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    param_5 = 5;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = true;\n    bVar6 = true;\n    local_a0 = 1;\n    local_78 = \"\\\"\";\n    break;\n  case 7:\n    bVar2 = true;\n    bVar3 = false;\n    uVar15 = 0;\n    local_5b = false;\n    local_70 = 0;\n    local_5c = false;\n    bVar6 = true;\n    local_a0 = 0;\n    local_78 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      param_8 = (char *)FUN_00405260(&DAT_0040b735,param_5);\n      param_9 = (char *)FUN_00405260(&DAT_0040ccaf);\n    }\n    uVar15 = 0;\n    if (uVar18 == 0) {\n      cVar14 = *param_8;\n      while (cVar14 != '\\0') {\n        if (uVar15 < param_2) {\n          param_1[uVar15] = cVar14;\n        }\n        uVar15 = uVar15 + 1;\n        cVar14 = param_8[uVar15];\n      }\n    }\n    local_a0 = strlen(param_9);\n    bVar2 = true;\n    bVar3 = false;\n    local_78 = param_9;\n    local_5b = false;\n    local_70 = 0;\n    bVar6 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\nLAB_004053f8:\n  uVar22 = 0;\n  bVar5 = local_5b;\nLAB_00405408:\n  bVar23 = param_4 != uVar22;\n  if (param_4 == 0xffffffffffffffff) {\n    bVar23 = param_3[uVar22] != '\\0';\n  }\n  bVar26 = bVar6;\n  if (!bVar23) goto LAB_00405b88;\n  bVar20 = (bool)(param_5 != 2 & bVar6);\n  __s1 = (byte *)(param_3 + uVar22);\n  uVar16 = uVar15;\n  bVar4 = bVar3;\n  if (bVar20) {\n    if (local_a0 == 0) {\nLAB_00405b00:\n      uVar19 = (ulong)*__s1;\n      switch(uVar19) {\n      case 0:\n        goto switchD_00405b12_caseD_0;\n      default:\n        bVar20 = false;\n        goto switchD_0040597e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_00405815;\n      case 8:\n        bVar17 = 0x62;\n        break;\n      case 9:\nswitchD_00405b12_caseD_9:\n        bVar17 = 0x74;\n        break;\n      case 10:\nswitchD_00405b12_caseD_a:\n        bVar17 = 0x6e;\n        break;\n      case 0xb:\nswitchD_00405b12_caseD_b:\n        bVar17 = 0x76;\n        goto LAB_00405815;\n      case 0xc:\nswitchD_00405b12_caseD_c:\n        bVar17 = 0x66;\nLAB_00405815:\n        if (local_5c) {\n          bVar25 = false;\n          goto LAB_00405768;\n        }\nLAB_00405820:\n        bVar23 = false;\n        goto LAB_004055db;\n      case 0xd:\n        bVar20 = false;\nswitchD_004054f8_caseD_d:\n        bVar25 = param_5 == 2;\n        uVar19 = 0xd;\n        bVar13 = 0x72;\n        goto LAB_00405730;\n      case 0x20:\n        bVar25 = false;\nLAB_00405b5a:\n        uVar19 = 0x20;\n        goto LAB_00405b22;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar20 = false;\nswitchD_004054f8_caseD_21:\n        bVar25 = false;\n        goto LAB_0040573b;\n      case 0x23:\n      case 0x7e:\n        bVar26 = false;\nLAB_00405b3a:\n        if (uVar22 == 0) {\n          bVar25 = false;\n          bVar23 = bVar20;\n          bVar20 = bVar26;\n          goto LAB_00405548;\n        }\n        bVar23 = false;\n        goto LAB_0040555f;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar25 = false;\nLAB_00405b22:\n        bVar24 = false;\n        bVar23 = bVar20;\n        bVar20 = bVar25;\n        goto LAB_00405561;\n      case 0x27:\n        bVar20 = false;\n        goto switchD_0040597e_caseD_27;\n      case 0x3f:\n        bVar20 = false;\n        goto switchD_0040597e_caseD_3f;\n      case 0x5c:\n        bVar20 = false;\n        goto switchD_004054f8_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        bVar20 = false;\n        goto switchD_0040597e_caseD_7b;\n      }\n      bVar25 = false;\n      bVar23 = false;\n      goto joined_r0x00405757;\n    }\n    if ((param_4 == 0xffffffffffffffff) && (1 < local_a0)) {\n      param_4 = strlen(param_3);\n    }\n    if ((param_4 < uVar22 + local_a0) || (iVar7 = memcmp(__s1,local_78,local_a0), iVar7 != 0))\n    goto LAB_00405b00;\n    if (!local_5c) {\n      uVar19 = (ulong)*__s1;\n      bVar25 = bVar20;\n      switch(uVar19) {\n      case 0:\n        goto switchD_004054f8_caseD_0;\n      default:\n        goto switchD_0040597e_caseD_1;\n      case 7:\n        bVar17 = 0x61;\n        goto LAB_00405820;\n      case 8:\n        bVar25 = false;\n        bVar23 = false;\n        bVar17 = 0x62;\n        break;\n      case 9:\n        goto switchD_00405b12_caseD_9;\n      case 10:\n        goto switchD_00405b12_caseD_a;\n      case 0xb:\n        goto switchD_00405b12_caseD_b;\n      case 0xc:\n        goto switchD_00405b12_caseD_c;\n      case 0xd:\n        goto switchD_004054f8_caseD_d;\n      case 0x20:\n        goto LAB_00405b5a;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        goto switchD_004054f8_caseD_21;\n      case 0x23:\n      case 0x7e:\n        bVar26 = bVar20;\n        goto LAB_00405b3a;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto LAB_00405b22;\n      case 0x27:\n        goto switchD_0040597e_caseD_27;\n      case 0x3f:\n        goto switchD_0040597e_caseD_3f;\n      case 0x5c:\n        goto switchD_004054f8_caseD_5c;\n      case 0x7b:\n      case 0x7d:\n        goto switchD_0040597e_caseD_7b;\n      }\n      goto LAB_004055a2;\n    }\n    goto LAB_0040577a;\n  }\n  uVar19 = (ulong)*__s1;\n  switch(uVar19) {\n  case 0:\n    if (bVar6) {\nswitchD_00405b12_caseD_0:\n      if (!local_5c) {\n        bVar20 = false;\nswitchD_004054f8_caseD_0:\n        bVar26 = param_5 == 2;\n        bVar24 = (bool)((bVar3 ^ 1U) & bVar26);\n        if (bVar24) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar16 = uVar15 + 3;\n          bVar3 = bVar24;\n          if (uVar9 <= uVar15 + 3) {\n            uVar16 = uVar15 + 4;\n            bVar23 = false;\n            bVar17 = 0x30;\n            bVar4 = bVar24;\n            goto LAB_00405658;\n          }\nLAB_0040589a:\n          param_1[uVar16] = 0x5c;\n          uVar15 = uVar16;\n        }\n        else if (uVar15 < uVar9) goto LAB_0040589a;\n        uVar16 = uVar15 + 1;\n        bVar24 = bVar23;\n        if (param_5 == 2) {\n          bVar17 = 0x30;\n          bVar23 = false;\n          bVar4 = bVar3;\n          goto LAB_00405658;\n        }\n        uVar19 = 0x30;\n        if ((uVar22 + 1 < param_4) && ((byte)(param_3[uVar22 + 1] - 0x30U) < 10)) {\n          if (uVar16 < uVar9) {\n            param_1[uVar16] = 0x30;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x30;\n          }\n          uVar16 = uVar15 + 3;\n          uVar19 = 0x30;\n        }\nLAB_004058d9:\n        bVar17 = (byte)uVar19;\n        bVar23 = false;\n        uVar15 = uVar16;\n        bVar4 = bVar3;\n        if ((bool)(bVar6 ^ 1U | bVar26)) goto LAB_00405658;\n        goto LAB_00405561;\n      }\n      bVar26 = param_5 == 2;\n      goto LAB_0040576c;\n    }\n    if ((param_6 & 1) == 0) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0;\n      bVar23 = false;\n      bVar20 = false;\n      goto LAB_00405548;\n    }\n    uVar22 = uVar22 + 1;\n    goto LAB_00405408;\n  default:\nswitchD_0040597e_caseD_1:\n    bVar25 = bVar6;\n    if (sVar8 != 1) {\n      local_40[0] = (mbstate_t)0x0;\n      if (param_4 == 0xffffffffffffffff) {\n        param_4 = strlen(param_3);\n      }\n      uVar21 = 0;\n      do {\n        uVar1 = uVar22 + uVar21;\n        lVar11 = FUN_00409a40(&local_44,param_3 + uVar1,param_4 - uVar1,local_40);\n        if (lVar11 == 0) break;\n        if (lVar11 == -1) {\n          bVar23 = false;\n          goto LAB_0040628a;\n        }\n        if (lVar11 == -2) {\n          if ((param_4 <= uVar1) || (param_3[uVar1] == '\\0')) goto LAB_004063c7;\n          goto LAB_004063b7;\n        }\n        if (((param_5 == 2) && (local_5c)) && (lVar11 != 1)) {\n          pcVar12 = param_3 + uVar1 + 1;\n          do {\n            if (((byte)(*pcVar12 + 0xa5U) < 0x22) &&\n               ((1L << (*pcVar12 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n              param_5 = 2;\n              goto LAB_0040576c;\n            }\n            pcVar12 = pcVar12 + 1;\n          } while (param_3 + uVar1 + lVar11 != pcVar12);\n        }\n        iVar7 = iswprint(local_44);\n        if (iVar7 == 0) {\n          bVar23 = false;\n        }\n        uVar21 = uVar21 + lVar11;\n        iVar7 = mbsinit(local_40);\n      } while (iVar7 == 0);\n      bVar25 = (bool)((bVar23 ^ 1U) & bVar6);\n      goto LAB_0040628a;\n    }\n    ppuVar10 = __ctype_b_loc();\n    uVar21 = 1;\n    bVar25 = ((*ppuVar10)[uVar19] & 0x4000) == 0;\n    bVar23 = !bVar25;\n    bVar25 = (bool)(bVar25 & bVar6);\n    goto LAB_00405954;\n  case 7:\n    bVar25 = param_5 == 2;\n    uVar19 = 7;\n    bVar13 = 0x61;\n    break;\n  case 8:\n    bVar25 = param_5 == 2;\n    uVar19 = 8;\n    bVar13 = 0x62;\n    break;\n  case 9:\n    uVar19 = 9;\n    bVar13 = 0x74;\n    goto LAB_00405992;\n  case 10:\n    uVar19 = 10;\n    bVar13 = 0x6e;\n    goto LAB_00405992;\n  case 0xb:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xb;\n    bVar13 = 0x76;\n    break;\n  case 0xc:\n    bVar25 = param_5 == 2;\n    uVar19 = 0xc;\n    bVar13 = 0x66;\n    break;\n  case 0xd:\n    uVar19 = 0xd;\n    bVar13 = 0x72;\nLAB_00405992:\n    bVar25 = param_5 == 2;\n    bVar20 = (bool)(local_5c & bVar25);\n    if (bVar20) {\nLAB_004059aa:\n      param_5 = 2;\n      goto LAB_0040576c;\n    }\n    break;\n  case 0x20:\n    uVar19 = 0x20;\n    goto LAB_00405536;\n  case 0x21:\n  case 0x22:\n  case 0x24:\n  case 0x26:\n  case 0x28:\n  case 0x29:\n  case 0x2a:\n  case 0x3b:\n  case 0x3c:\n  case 0x3d:\n  case 0x3e:\n  case 0x5b:\n  case 0x5e:\n  case 0x60:\n  case 0x7c:\n    bVar23 = false;\nLAB_00405536:\n    bVar25 = param_5 == 2;\n    if ((local_5c) && (bVar25)) goto LAB_004059aa;\n    goto LAB_00405548;\n  case 0x23:\n  case 0x7e:\nLAB_0040552d:\n    bVar25 = param_5 == 2;\n    if (uVar22 == 0) goto LAB_00405536;\n    goto LAB_0040573b;\n  case 0x25:\n  case 0x2b:\n  case 0x2c:\n  case 0x2d:\n  case 0x2e:\n  case 0x2f:\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x3a:\n  case 0x41:\n  case 0x42:\n  case 0x43:\n  case 0x44:\n  case 0x45:\n  case 0x46:\n  case 0x47:\n  case 0x48:\n  case 0x49:\n  case 0x4a:\n  case 0x4b:\n  case 0x4c:\n  case 0x4d:\n  case 0x4e:\n  case 0x4f:\n  case 0x50:\n  case 0x51:\n  case 0x52:\n  case 0x53:\n  case 0x54:\n  case 0x55:\n  case 0x56:\n  case 0x57:\n  case 0x58:\n  case 0x59:\n  case 0x5a:\n  case 0x5d:\n  case 0x5f:\n  case 0x61:\n  case 0x62:\n  case 99:\n  case 100:\n  case 0x65:\n  case 0x66:\n  case 0x67:\n  case 0x68:\n  case 0x69:\n  case 0x6a:\n  case 0x6b:\n  case 0x6c:\n  case 0x6d:\n  case 0x6e:\n  case 0x6f:\n  case 0x70:\n  case 0x71:\n  case 0x72:\n  case 0x73:\n  case 0x74:\n  case 0x75:\n  case 0x76:\n  case 0x77:\n  case 0x78:\n  case 0x79:\n  case 0x7a:\n    goto switchD_0040597e_caseD_25;\n  case 0x27:\nswitchD_0040597e_caseD_27:\n    bVar5 = bVar23;\n    if (param_5 != 2) {\n      bVar25 = false;\n      uVar19 = 0x27;\n      goto LAB_00405548;\n    }\n    if (!local_5c) {\n      if ((uVar9 == 0) || (uVar19 = 0, uVar21 = uVar9, local_70 != 0)) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x5c;\n        }\n        uVar19 = uVar9;\n        uVar21 = local_70;\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x27;\n        }\n      }\n      uVar16 = uVar15 + 3;\n      bVar17 = 0x27;\n      uVar9 = uVar19;\n      local_70 = uVar21;\n      bVar24 = false;\n      bVar4 = false;\n      goto LAB_00405658;\n    }\n    goto LAB_0040576c;\n  case 0x3f:\nswitchD_0040597e_caseD_3f:\n    if (param_5 == 2) {\n      if (!local_5c) {\n        bVar17 = 0x3f;\n        bVar24 = false;\n        bVar23 = false;\n        goto LAB_00405658;\n      }\n      goto LAB_0040576c;\n    }\n    if (param_5 != 5) {\n      bVar25 = param_5 == 2;\n      uVar19 = 0x3f;\n      bVar23 = false;\n      goto LAB_00405548;\n    }\n    if (((((param_6 & 4) != 0) && (uVar21 = uVar22 + 2, uVar21 < param_4)) &&\n        (param_3[uVar22 + 1] == '?')) &&\n       ((uVar19 = (ulong)(byte)param_3[uVar21], (byte)param_3[uVar21] < 0x3f &&\n        ((0x7000a38200000000U >> (uVar19 & 0x3f) & 1) != 0)))) {\n      if (!local_5c) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x3f;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x22;\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = 0x22;\n        }\n        if (uVar15 + 3 < uVar9) {\n          param_1[uVar15 + 3] = 0x3f;\n        }\n        uVar16 = uVar15 + 4;\n        bVar26 = false;\n        uVar22 = uVar21;\n        bVar24 = false;\n        goto LAB_004058d9;\n      }\n      goto LAB_0040577a;\n    }\n    bVar25 = false;\n    uVar19 = 0x3f;\n    bVar23 = false;\n    goto LAB_00405548;\n  case 0x5c:\n    if (param_5 != 2) {\nswitchD_004054f8_caseD_5c:\n      uVar19 = 0x5c;\n      bVar17 = 0x5c;\n      bVar13 = 0x5c;\n      bVar25 = (bool)(bVar6 & local_5c & local_a0 != 0);\n      if (!bVar25) break;\n      uVar22 = uVar22 + 1;\n      bVar23 = false;\n      goto LAB_00405674;\n    }\n    if (local_5c) goto LAB_0040576c;\n    uVar22 = uVar22 + 1;\n    bVar23 = false;\n    bVar17 = 0x5c;\n    goto LAB_00405674;\n  case 0x7b:\n  case 0x7d:\nswitchD_0040597e_caseD_7b:\n    bVar24 = param_4 != 1;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar24 = param_3[1] != '\\0';\n    }\n    bVar25 = param_5 == 2;\n    if (!bVar24) goto LAB_0040552d;\n    goto LAB_0040573b;\n  }\nLAB_00405730:\n  if (!bVar6) {\nLAB_0040573b:\n    bVar23 = false;\n    goto LAB_00405548;\n  }\n  bVar23 = false;\n  bVar17 = bVar13;\n  goto joined_r0x00405757;\nLAB_00405b88:\n  if ((uVar15 == 0) && ((bool)(local_5c & param_5 == 2))) {\n    param_5 = 2;\nLAB_0040576c:\n    if (bVar26) {\n      param_5 = 4;\n    }\nLAB_0040577a:\n    uVar9 = FUN_00405360(param_1,uVar9,param_3,param_4,param_5,param_6 & 0xfffffffd,0,param_8,\n                         param_9);\n    return uVar9;\n  }\n  bVar26 = (bool)(param_5 == 2 & (local_5c ^ 1U));\n  bVar23 = (bool)(local_5c ^ 1U);\n  if ((!bVar26) || (bVar23 = bVar26, !bVar5)) {\nLAB_0040645d:\n    uVar22 = uVar15;\n    if (((local_78 != (char *)0x0) && (bVar23)) && (cVar14 = *local_78, cVar14 != '\\0')) {\n      do {\n        if (uVar22 < uVar9) {\n          param_1[uVar22] = cVar14;\n        }\n        uVar22 = uVar22 + 1;\n        cVar14 = local_78[uVar22 - uVar15];\n      } while (cVar14 != '\\0');\n    }\n    if (uVar22 < uVar9) {\n      param_1[uVar22] = 0;\n    }\n    return uVar22;\n  }\n  if (bVar2) {\n    uVar9 = FUN_00405360(param_1,local_70,param_3,param_4,5,param_6,param_7,param_8,param_9);\n    return uVar9;\n  }\n  local_5b = uVar9 == 0 && local_70 != 0;\n  param_2 = local_70;\n  bVar23 = bVar5;\n  if (uVar9 != 0 || local_70 == 0) goto LAB_0040645d;\nLAB_00405be6:\n  *param_1 = 0x27;\n  param_5 = 2;\n  uVar15 = 1;\n  local_78 = \"\\'\";\n  local_a0 = 1;\n  local_5c = false;\n  uVar9 = param_2;\n  goto LAB_004053f8;\n  while (__s1[uVar21] != 0) {\nLAB_004063b7:\n    uVar21 = uVar21 + 1;\n    if (param_4 <= uVar22 + uVar21) break;\n  }\nLAB_004063c7:\n  bVar23 = false;\nLAB_0040628a:\n  if (1 < uVar21) {\nLAB_00405e4e:\n    bVar26 = false;\n    uVar21 = uVar21 + uVar22;\n    uVar16 = uVar22;\n    do {\n      bVar17 = (byte)uVar19;\n      if (bVar25) {\n        bVar26 = param_5 == 2;\n        if (local_5c) goto LAB_0040576c;\n        bVar26 = (bool)(bVar26 & (bVar4 ^ 1U));\n        if (bVar26) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x24;\n          }\n          if (uVar15 + 2 < uVar9) {\n            param_1[uVar15 + 2] = 0x27;\n          }\n          uVar15 = uVar15 + 3;\n          bVar4 = bVar26;\n        }\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x5c;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = (char)(uVar19 >> 6) + '0';\n        }\n        if (uVar15 + 2 < uVar9) {\n          param_1[uVar15 + 2] = ((byte)(uVar19 >> 3) & 7) + 0x30;\n        }\n        uVar22 = uVar16 + 1;\n        uVar15 = uVar15 + 3;\n        bVar17 = (bVar17 & 7) + 0x30;\n        bVar26 = bVar25;\n        if (uVar21 <= uVar22) goto LAB_004055ed;\n      }\n      else {\n        bVar3 = (bool)((bVar26 ^ 1U) & bVar4);\n        if (bVar20) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x5c;\n          }\n          uVar15 = uVar15 + 1;\n        }\n        uVar22 = uVar16 + 1;\n        if (uVar21 <= uVar22) goto LAB_00405674;\n        if (bVar3) {\n          if (uVar15 < uVar9) {\n            param_1[uVar15] = 0x27;\n          }\n          if (uVar15 + 1 < uVar9) {\n            param_1[uVar15 + 1] = 0x27;\n          }\n          uVar15 = uVar15 + 2;\n          bVar20 = false;\n          bVar4 = false;\n        }\n        else {\n          bVar20 = false;\n        }\n      }\n      uVar16 = uVar16 + 1;\n      if (uVar15 < uVar9) {\n        param_1[uVar15] = bVar17;\n      }\n      uVar19 = (ulong)(byte)param_3[uVar16];\n      uVar15 = uVar15 + 1;\n    } while( true );\n  }\nLAB_00405954:\n  if (bVar25) {\n    bVar23 = false;\n    bVar25 = bVar6;\n    goto LAB_00405e4e;\n  }\nswitchD_0040597e_caseD_25:\n  bVar25 = param_5 == 2;\nLAB_00405548:\n  bVar17 = (byte)uVar19;\n  bVar24 = (bool)((bVar6 ^ 1U | bVar25) ^ 1 | local_5c);\n  bVar26 = bVar20;\n  if (bVar24) {\nLAB_0040555f:\n    bVar24 = false;\n    bVar20 = bVar26;\nLAB_00405561:\n    bVar17 = (byte)uVar19;\n    uVar16 = uVar15;\n    bVar4 = bVar3;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar19 >> 5) * 4) >> (bVar17 & 0x1f) & 1) == 0))\n    goto LAB_00405658;\n    bVar25 = param_5 == 2;\n  }\n  else {\nLAB_00405658:\n    bVar25 = param_5 == 2;\n    uVar15 = uVar16;\n    bVar3 = bVar4;\n    if (!bVar20) {\n      uVar22 = uVar22 + 1;\n      bVar3 = (bool)((bVar24 ^ 1U) & bVar4);\nLAB_00405674:\n      if (bVar3) {\n        if (uVar15 < uVar9) {\n          param_1[uVar15] = 0x27;\n        }\n        if (uVar15 + 1 < uVar9) {\n          param_1[uVar15 + 1] = 0x27;\n        }\n        uVar15 = uVar15 + 2;\n        bVar4 = false;\n      }\n      goto LAB_004055ed;\n    }\n  }\njoined_r0x00405757:\n  if (local_5c) {\nLAB_00405768:\n    bVar26 = (bool)(bVar6 & bVar25);\n    goto LAB_0040576c;\n  }\nLAB_004055a2:\n  bVar25 = (bool)((bVar3 ^ 1U) & bVar25);\n  if (bVar25) {\n    if (uVar15 < uVar9) {\n      param_1[uVar15] = 0x27;\n    }\n    if (uVar15 + 1 < uVar9) {\n      param_1[uVar15 + 1] = 0x24;\n    }\n    if (uVar15 + 2 < uVar9) {\n      param_1[uVar15 + 2] = 0x27;\n    }\n    uVar15 = uVar15 + 3;\n    bVar3 = bVar25;\n  }\nLAB_004055db:\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = 0x5c;\n  }\n  uVar15 = uVar15 + 1;\n  uVar22 = uVar22 + 1;\n  bVar4 = bVar3;\nLAB_004055ed:\n  bVar3 = bVar4;\n  if (uVar15 < uVar9) {\n    param_1[uVar15] = bVar17;\n  }\n  uVar15 = uVar15 + 1;\n  if (!bVar23) {\n    bVar2 = false;\n  }\n  goto LAB_00405408;\n}\n\n",
            "funcName": "FUN_00405360"
        },
        {
            "funcStartAddr": "0x406590",
            "funcEndAddr": "0x40672b",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_00406590(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  ulong uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  undefined4 *puVar8;\n  ulong uVar9;\n  undefined *__ptr;\n  ulong *puVar10;\n  \n  piVar7 = __errno_location();\n  iVar1 = *piVar7;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  puVar8 = (undefined4 *)PTR_DAT_0060f338;\n  if (DAT_0060f350 <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00408490();\n    }\n    if (PTR_DAT_0060f338 == &DAT_0060f340) {\n      puVar8 = (undefined4 *)FUN_004082a0(0);\n      uVar6 = PTR_DAT_0060f348._4_4_;\n      uVar5 = PTR_DAT_0060f348._0_4_;\n      uVar3 = _UNK_0060f344;\n      PTR_DAT_0060f338 = (undefined *)puVar8;\n      *puVar8 = _DAT_0060f340;\n      puVar8[1] = uVar3;\n      puVar8[2] = uVar5;\n      puVar8[3] = uVar6;\n    }\n    else {\n      puVar8 = (undefined4 *)FUN_004082a0(PTR_DAT_0060f338);\n      PTR_DAT_0060f338 = (undefined *)puVar8;\n    }\n    memset(puVar8 + (long)DAT_0060f350 * 4,0,(long)((param_1 + 1) - DAT_0060f350) << 4);\n    DAT_0060f350 = param_1 + 1;\n  }\n  uVar2 = param_4[1];\n  puVar10 = (ulong *)(puVar8 + (long)param_1 * 4);\n  uVar4 = *puVar10;\n  __ptr = (undefined *)puVar10[1];\n  uVar9 = FUN_00405360(__ptr,uVar4,param_2,param_3,*param_4,uVar2 | 1,param_4 + 2,\n                       *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar4 <= uVar9) {\n    uVar9 = uVar9 + 1;\n    *puVar10 = uVar9;\n    if (__ptr != &DAT_0060f3c0) {\n      free(__ptr);\n    }\n    __ptr = (undefined *)FUN_00408240(uVar9);\n    uVar3 = *param_4;\n    puVar10[1] = (ulong)__ptr;\n    FUN_00405360(__ptr,uVar9,param_2,param_3,uVar3,uVar2 | 1,param_4 + 2,\n                 *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar7 = iVar1;\n  return __ptr;\n}\n\n",
            "funcName": "FUN_00406590"
        },
        {
            "funcStartAddr": "0x406730",
            "funcEndAddr": "0x406764",
            "decompiledFuncCode": "\nvoid FUN_00406730(undefined *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060f4c0;\n  }\n  FUN_00408440(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_00406730"
        },
        {
            "funcStartAddr": "0x406770",
            "funcEndAddr": "0x40677f",
            "decompiledFuncCode": "\nundefined4 FUN_00406770(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060f4c0;\n  }\n  return *param_1;\n}\n\n",
            "funcName": "FUN_00406770"
        },
        {
            "funcStartAddr": "0x406780",
            "funcEndAddr": "0x40678f",
            "decompiledFuncCode": "\nvoid FUN_00406780(undefined4 *param_1,undefined4 param_2)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060f4c0;\n  }\n  *param_1 = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_00406780"
        },
        {
            "funcStartAddr": "0x406790",
            "funcEndAddr": "0x4067c3",
            "decompiledFuncCode": "\nuint FUN_00406790(undefined *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060f4c0;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n",
            "funcName": "FUN_00406790"
        },
        {
            "funcStartAddr": "0x4067d0",
            "funcEndAddr": "0x4067e3",
            "decompiledFuncCode": "\nundefined4 FUN_004067d0(undefined *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_0060f4c0;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n",
            "funcName": "FUN_004067d0"
        },
        {
            "funcStartAddr": "0x4067f0",
            "funcEndAddr": "0x40681b",
            "decompiledFuncCode": "\nvoid FUN_004067f0(undefined4 *param_1,long param_2,long param_3)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_0060f4c0;\n  }\n  *param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)(param_1 + 10) = param_2;\n    *(long *)(param_1 + 0xc) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_004067f0"
        },
        {
            "funcStartAddr": "0x406820",
            "funcEndAddr": "0x406892",
            "decompiledFuncCode": "\nvoid FUN_00406820(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined4 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (param_5 == (undefined4 *)0x0) {\n    param_5 = (undefined4 *)&DAT_0060f4c0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  FUN_00405360(param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5 + 2,\n               *(undefined8 *)(param_5 + 10),*(undefined8 *)(param_5 + 0xc));\n  *piVar2 = iVar1;\n  return;\n}\n\n",
            "funcName": "FUN_00406820"
        },
        {
            "funcStartAddr": "0x4068a0",
            "funcEndAddr": "0x406981",
            "decompiledFuncCode": "\nundefined8 FUN_004068a0(undefined8 param_1,undefined8 param_2,long *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if (param_4 == (undefined4 *)0x0) {\n    param_4 = (undefined4 *)&DAT_0060f4c0;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | param_4[1];\n  lVar3 = FUN_00405360(0,0,param_1,param_2,*param_4,uVar5,param_4 + 2,*(undefined8 *)(param_4 + 10),\n                       *(undefined8 *)(param_4 + 0xc));\n  uVar4 = FUN_00408240(lVar3 + 1);\n  FUN_00405360(uVar4,lVar3 + 1,param_1,param_2,*param_4,uVar5,param_4 + 2,\n               *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n",
            "funcName": "FUN_004068a0"
        },
        {
            "funcStartAddr": "0x406990",
            "funcEndAddr": "0x40699a",
            "decompiledFuncCode": "\nvoid FUN_00406990(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_004068a0(param_1,param_2,0,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00406990"
        },
        {
            "funcStartAddr": "0x4069a0",
            "funcEndAddr": "0x406a35",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_004069a0(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = PTR_DAT_0060f338;\n  if (1 < DAT_0060f350) {\n    ppvVar2 = (void **)(PTR_DAT_0060f338 + 0x18);\n    ppvVar1 = (void **)(PTR_DAT_0060f338 + (ulong)(DAT_0060f350 - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined **)(__ptr_00 + 8) != &DAT_0060f3c0) {\n    free(*(undefined **)(__ptr_00 + 8));\n    _DAT_0060f340 = 0x100;\n    PTR_DAT_0060f348 = &DAT_0060f3c0;\n  }\n  if (__ptr_00 != &DAT_0060f340) {\n    free(__ptr_00);\n    PTR_DAT_0060f338 = &DAT_0060f340;\n  }\n  DAT_0060f350 = 1;\n  return;\n}\n\n",
            "funcName": "FUN_004069a0"
        },
        {
            "funcStartAddr": "0x406a40",
            "funcEndAddr": "0x406a51",
            "decompiledFuncCode": "\nvoid FUN_00406a40(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00406590(param_1,param_2,0xffffffffffffffff,&DAT_0060f4c0);\n  return;\n}\n\n",
            "funcName": "FUN_00406a40"
        },
        {
            "funcStartAddr": "0x406a60",
            "funcEndAddr": "0x406a6a",
            "decompiledFuncCode": "\nvoid FUN_00406a60(void)\n\n{\n  FUN_00406590();\n  return;\n}\n\n",
            "funcName": "FUN_00406a60"
        },
        {
            "funcStartAddr": "0x406a70",
            "funcEndAddr": "0x406a86",
            "decompiledFuncCode": "\nvoid FUN_00406a70(undefined8 param_1)\n\n{\n  FUN_00406590(0,param_1,0xffffffffffffffff,&DAT_0060f4c0);\n  return;\n}\n\n",
            "funcName": "FUN_00406a70"
        },
        {
            "funcStartAddr": "0x406a90",
            "funcEndAddr": "0x406aa2",
            "decompiledFuncCode": "\nvoid FUN_00406a90(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00406590(0,param_1,param_2,&DAT_0060f4c0);\n  return;\n}\n\n",
            "funcName": "FUN_00406a90"
        },
        {
            "funcStartAddr": "0x406ab0",
            "funcEndAddr": "0x406b18",
            "decompiledFuncCode": "\nvoid FUN_00406ab0(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00406590(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00406ab0"
        },
        {
            "funcStartAddr": "0x406b20",
            "funcEndAddr": "0x406b84",
            "decompiledFuncCode": "\nvoid FUN_00406b20(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_44 = 0;\n    local_40 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00406590(param_1,param_3,param_4,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00406b20"
        },
        {
            "funcStartAddr": "0x406b90",
            "funcEndAddr": "0x406b9c",
            "decompiledFuncCode": "\nvoid FUN_00406b90(undefined4 param_1,undefined8 param_2)\n\n{\n  FUN_00406ab0(0,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00406b90"
        },
        {
            "funcStartAddr": "0x406ba0",
            "funcEndAddr": "0x406baf",
            "decompiledFuncCode": "\nvoid FUN_00406ba0(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00406b20(0,param_1,param_2,param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00406ba0"
        },
        {
            "funcStartAddr": "0x406bb0",
            "funcEndAddr": "0x406c20",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00406bb0(undefined8 param_1,undefined8 param_2,byte param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  \n  local_18 = DAT_0060f4f0;\n  local_48 = _DAT_0060f4c0;\n  uStack_40 = uRam000000000060f4c8;\n  local_38 = _DAT_0060f4d0;\n  uStack_30 = uRam000000000060f4d8;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_3 >> 5) * 4);\n  local_28 = _DAT_0060f4e0;\n  uStack_20 = uRam000000000060f4e8;\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_3 & 0x1f)) & 1) << (param_3 & 0x1f) ^ uVar2;\n  FUN_00406590(0,param_1,param_2,&local_48);\n  return;\n}\n\n",
            "funcName": "FUN_00406bb0"
        },
        {
            "funcStartAddr": "0x406c20",
            "funcEndAddr": "0x406c2d",
            "decompiledFuncCode": "\nvoid FUN_00406c20(undefined8 param_1,char param_2)\n\n{\n  FUN_00406bb0(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00406c20"
        },
        {
            "funcStartAddr": "0x406c30",
            "funcEndAddr": "0x406c41",
            "decompiledFuncCode": "\nvoid FUN_00406c30(undefined8 param_1)\n\n{\n  FUN_00406bb0(param_1,0xffffffffffffffff,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_00406c30"
        },
        {
            "funcStartAddr": "0x406c50",
            "funcEndAddr": "0x406c5a",
            "decompiledFuncCode": "\nvoid FUN_00406c50(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00406bb0(param_1,param_2,0x3a);\n  return;\n}\n\n",
            "funcName": "FUN_00406c50"
        },
        {
            "funcStartAddr": "0x406c60",
            "funcEndAddr": "0x406cce",
            "decompiledFuncCode": "\nvoid FUN_00406c60(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  if (param_2 != 10) {\n    local_40 = 0x400000000000000;\n    local_44 = 0;\n    local_38 = 0;\n    local_30 = 0;\n    local_28 = 0;\n    local_20 = 0;\n    local_18 = 0;\n    local_48 = param_2;\n    FUN_00406590(param_1,param_3,0xffffffffffffffff,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00406c60"
        },
        {
            "funcStartAddr": "0x406cd0",
            "funcEndAddr": "0x406d3c",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00406cd0(undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5\n                 )\n\n{\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  \n  uStack_40 = uRam000000000060f4c8;\n  local_38 = _DAT_0060f4d0;\n  uStack_30 = uRam000000000060f4d8;\n  local_28 = _DAT_0060f4e0;\n  lStack_20 = uRam000000000060f4e8;\n  local_18 = DAT_0060f4f0;\n  local_48 = CONCAT44((int)((ulong)_DAT_0060f4c0 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_00406590(param_1,param_4,param_5,&local_48);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00406cd0"
        },
        {
            "funcStartAddr": "0x406d40",
            "funcEndAddr": "0x406d49",
            "decompiledFuncCode": "\nvoid FUN_00406d40(void)\n\n{\n  FUN_00406cd0();\n  return;\n}\n\n",
            "funcName": "FUN_00406d40"
        },
        {
            "funcStartAddr": "0x406d50",
            "funcEndAddr": "0x406d67",
            "decompiledFuncCode": "\nvoid FUN_00406d50(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_00406cd0(0,param_1,param_2,param_3,0xffffffffffffffff);\n  return;\n}\n\n",
            "funcName": "FUN_00406d50"
        },
        {
            "funcStartAddr": "0x406d70",
            "funcEndAddr": "0x406d83",
            "decompiledFuncCode": "\nvoid FUN_00406d70(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_00406cd0(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
            "funcName": "FUN_00406d70"
        },
        {
            "funcStartAddr": "0x406d90",
            "funcEndAddr": "0x406d9a",
            "decompiledFuncCode": "\nvoid FUN_00406d90(void)\n\n{\n  FUN_00406590();\n  return;\n}\n\n",
            "funcName": "FUN_00406d90"
        },
        {
            "funcStartAddr": "0x406da0",
            "funcEndAddr": "0x406db2",
            "decompiledFuncCode": "\nvoid FUN_00406da0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00406590(0,param_1,param_2,&DAT_0060f300);\n  return;\n}\n\n",
            "funcName": "FUN_00406da0"
        },
        {
            "funcStartAddr": "0x406dc0",
            "funcEndAddr": "0x406dd1",
            "decompiledFuncCode": "\nvoid FUN_00406dc0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00406590(param_1,param_2,0xffffffffffffffff,&DAT_0060f300);\n  return;\n}\n\n",
            "funcName": "FUN_00406dc0"
        },
        {
            "funcStartAddr": "0x406de0",
            "funcEndAddr": "0x406df6",
            "decompiledFuncCode": "\nvoid FUN_00406de0(undefined8 param_1)\n\n{\n  FUN_00406590(0,param_1,0xffffffffffffffff,&DAT_0060f300);\n  return;\n}\n\n",
            "funcName": "FUN_00406de0"
        },
        {
            "funcStartAddr": "0x406e00",
            "funcEndAddr": "0x406e23",
            "decompiledFuncCode": "\nvoid FUN_00406e00(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)FUN_00408240(0x18);\n  *puVar1 = param_1;\n  puVar1[2] = 0;\n  puVar1[1] = 0;\n  return;\n}\n\n",
            "funcName": "FUN_00406e00"
        },
        {
            "funcStartAddr": "0x406e30",
            "funcEndAddr": "0x406e5f",
            "decompiledFuncCode": "\nlong * FUN_00406e30(void)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  lVar1 = FUN_00407050();\n  plVar2 = (long *)0x0;\n  if (lVar1 != 0) {\n    plVar2 = (long *)FUN_00408240(0x18);\n    *plVar2 = lVar1;\n    plVar2[2] = 0;\n    plVar2[1] = 0;\n  }\n  return plVar2;\n}\n\n",
            "funcName": "FUN_00406e30"
        },
        {
            "funcStartAddr": "0x406e60",
            "funcEndAddr": "0x406e64",
            "decompiledFuncCode": "\nundefined8 FUN_00406e60(undefined8 *param_1)\n\n{\n  return *param_1;\n}\n\n",
            "funcName": "FUN_00406e60"
        },
        {
            "funcStartAddr": "0x406e70",
            "funcEndAddr": "0x406f5b",
            "decompiledFuncCode": "\nulong FUN_00406e70(undefined8 *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  long lVar7;\n  ulong uVar8;\n  ulong uVar9;\n  byte local_40 [16];\n  \n  uVar1 = param_2 + 1;\n  uVar3 = *param_1;\n  uVar9 = param_1[1];\n  uVar8 = param_1[2];\n  while( true ) {\n    uVar4 = uVar9;\n    if (uVar8 < param_2) {\n      lVar7 = 0;\n      uVar4 = uVar8;\n      do {\n        lVar7 = lVar7 + 1;\n        uVar4 = uVar4 * 0x100 + 0xff;\n      } while (uVar4 < param_2);\n      FUN_00407360(uVar3,local_40,lVar7);\n      pbVar5 = local_40;\n      do {\n        bVar2 = *pbVar5;\n        pbVar5 = pbVar5 + 1;\n        uVar8 = uVar8 * 0x100 + 0xff;\n        uVar9 = uVar9 * 0x100 + (ulong)bVar2;\n        uVar4 = uVar9;\n      } while (uVar8 < param_2);\n    }\n    if (uVar8 == param_2) break;\n    uVar6 = (uVar8 - param_2) % uVar1;\n    uVar9 = uVar4 % uVar1;\n    if (uVar4 <= uVar8 - uVar6) {\n      param_1[1] = uVar4 / uVar1;\n      param_1[2] = (uVar8 - param_2) / uVar1;\n      return uVar9;\n    }\n    uVar8 = uVar6 - 1;\n  }\n  param_1[2] = 0;\n  param_1[1] = 0;\n  return uVar4;\n}\n\n",
            "funcName": "FUN_00406e70"
        },
        {
            "funcStartAddr": "0x406f70",
            "funcEndAddr": "0x406f8e",
            "decompiledFuncCode": "\nvoid FUN_00406f70(void *param_1)\n\n{\n  __explicit_bzero_chk(param_1,0x18,0xffffffffffffffff);\n  free(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00406f70"
        },
        {
            "funcStartAddr": "0x406f90",
            "funcEndAddr": "0x406fe1",
            "decompiledFuncCode": "\nundefined4 FUN_00406f90(undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int *piVar3;\n  \n  uVar2 = FUN_004074c0(*param_1);\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  __explicit_bzero_chk(param_1,0x18,0xffffffffffffffff);\n  free(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00406f90"
        },
        {
            "funcStartAddr": "0x406ff0",
            "funcEndAddr": "0x40704d",
            "decompiledFuncCode": "\nvoid FUN_00406ff0(long param_1)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (param_1 != 0) {\n    uVar1 = FUN_00406de0();\n    piVar2 = __errno_location();\n    if (*piVar2 == 0) {\n      uVar3 = dcgettext(0,\"%s: end of file\",5);\n    }\n    else {\n      uVar3 = dcgettext(0,\"%s: read error\",5);\n    }\n    error(DAT_0060f2e0,*piVar2,uVar3,uVar1);\n    FUN_00402089();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00406ff0"
        },
        {
            "funcStartAddr": "0x407050",
            "funcEndAddr": "0x40732c",
            "decompiledFuncCode": "\nFILE ** FUN_00407050(FILE *param_1,ulong param_2)\n\n{\n  int __fd;\n  uint uVar1;\n  FILE *pFVar2;\n  FILE **ppFVar3;\n  FILE **ppFVar4;\n  size_t __n;\n  ulong uVar5;\n  ulong uVar6;\n  long lVar7;\n  timeval *ptVar8;\n  undefined *puVar9;\n  ulong uVar10;\n  byte bVar11;\n  __uid_t local_48;\n  undefined4 uStack_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  \n  bVar11 = 0;\n  if (param_2 == 0) {\n    ppFVar3 = (FILE **)FUN_00408240(0x1038);\n    *ppFVar3 = (FILE *)0x0;\n    ppFVar3[1] = (FILE *)FUN_00406ff0;\n    ppFVar3[2] = (FILE *)0x0;\n    return ppFVar3;\n  }\n  if (param_1 != (FILE *)0x0) {\n    pFVar2 = (FILE *)FUN_00409b20(param_1,&DAT_0040c4a4);\n    if (pFVar2 != (FILE *)0x0) {\n      ppFVar3 = (FILE **)FUN_00408240(0x1038);\n      *ppFVar3 = pFVar2;\n      __n = 0x1000;\n      if (param_2 < 0x1001) {\n        __n = param_2;\n      }\n      ppFVar3[1] = (FILE *)FUN_00406ff0;\n      ppFVar3[2] = param_1;\n      setvbuf(pFVar2,(char *)(ppFVar3 + 3),0,__n);\n      return ppFVar3;\n    }\n    return (FILE **)0x0;\n  }\n  ppFVar4 = (FILE **)FUN_00408240(0x1038);\n  *ppFVar4 = (FILE *)0x0;\n  ppFVar3 = ppFVar4 + 4;\n  ppFVar4[1] = (FILE *)FUN_00406ff0;\n  ppFVar4[2] = (FILE *)0x0;\n  ppFVar4[3] = (FILE *)0x0;\n  __fd = open(\"/dev/urandom\",0);\n  if (__fd < 0) {\n    uVar5 = 0x14;\n    gettimeofday((timeval *)&local_48,(__timezone_ptr_t)0x0);\n    *(__uid_t *)(ppFVar4 + 4) = local_48;\n    *(undefined4 *)((long)ppFVar4 + 0x24) = uStack_44;\n    *(undefined4 *)(ppFVar4 + 5) = uStack_40;\n    *(undefined4 *)((long)ppFVar4 + 0x2c) = uStack_3c;\n    local_48 = getpid();\n    *(__uid_t *)(ppFVar4 + 6) = local_48;\n  }\n  else {\n    if (0x800 < param_2) {\n      param_2 = 0x800;\n    }\n    pFVar2 = (FILE *)__read_chk(__fd,ppFVar3,param_2,0x1018);\n    close(__fd);\n    if (0x7ff < (long)pFVar2) goto LAB_00407158;\n    if ((long)pFVar2 < 0) {\n      pFVar2 = param_1;\n    }\n    uVar5 = 0x800 - (long)pFVar2;\n    if (0x10 < uVar5) {\n      uVar5 = 0x10;\n    }\n    lVar7 = (long)&pFVar2->_flags + uVar5;\n    gettimeofday((timeval *)&local_48,(__timezone_ptr_t)0x0);\n    ptVar8 = (timeval *)&local_48;\n    puVar9 = (undefined *)((long)ppFVar3 + (long)pFVar2);\n    for (uVar5 = uVar5 & 0xffffffff; uVar5 != 0; uVar5 = uVar5 - 1) {\n      *puVar9 = *(undefined *)&ptVar8->tv_sec;\n      ptVar8 = (timeval *)((long)ptVar8 + (ulong)bVar11 * -2 + 1);\n      puVar9 = puVar9 + (ulong)bVar11 * -2 + 1;\n    }\n    if (0x7ff < lVar7) goto LAB_00407158;\n    uVar10 = 0x800 - lVar7;\n    if (4 < uVar10) {\n      uVar10 = 4;\n    }\n    local_48 = getpid();\n    uVar5 = uVar10 + lVar7;\n    ptVar8 = (timeval *)&local_48;\n    puVar9 = (undefined *)((long)ppFVar3 + lVar7);\n    for (uVar10 = uVar10 & 0xffffffff; uVar10 != 0; uVar10 = uVar10 - 1) {\n      *puVar9 = *(undefined *)&ptVar8->tv_sec;\n      ptVar8 = (timeval *)((long)ptVar8 + (ulong)bVar11 * -2 + 1);\n      puVar9 = puVar9 + (ulong)bVar11 * -2 + 1;\n    }\n    if (0x7ff < uVar5) goto LAB_00407158;\n  }\n  uVar10 = 0x800 - uVar5;\n  if (4 < uVar10) {\n    uVar10 = 4;\n  }\n  local_48 = getppid();\n  if ((uint)uVar10 != 0) {\n    uVar1 = 0;\n    do {\n      uVar6 = (ulong)uVar1;\n      uVar1 = uVar1 + 1;\n      *(undefined *)((long)ppFVar3 + uVar6 + uVar5) = *(undefined *)((long)&local_48 + uVar6);\n    } while (uVar1 < (uint)uVar10);\n  }\n  uVar10 = uVar10 + uVar5;\n  if (uVar10 < 0x800) {\n    uVar5 = 0x800 - uVar10;\n    if (4 < uVar5) {\n      uVar5 = 4;\n    }\n    local_48 = getuid();\n    if ((uint)uVar5 != 0) {\n      uVar1 = 0;\n      do {\n        uVar6 = (ulong)uVar1;\n        uVar1 = uVar1 + 1;\n        *(undefined *)((long)ppFVar3 + uVar6 + uVar10) = *(undefined *)((long)&local_48 + uVar6);\n      } while (uVar1 < (uint)uVar5);\n    }\n    uVar10 = uVar10 + uVar5;\n    if (uVar10 < 0x800) {\n      local_48 = getgid();\n      uVar5 = 0x800 - uVar10;\n      if (4 < uVar5) {\n        uVar5 = 4;\n      }\n      if ((uint)uVar5 != 0) {\n        uVar1 = 0;\n        do {\n          uVar6 = (ulong)uVar1;\n          uVar1 = uVar1 + 1;\n          *(undefined *)((long)ppFVar3 + uVar6 + uVar10) = *(undefined *)((long)&local_48 + uVar6);\n        } while (uVar1 < (uint)uVar5);\n      }\n    }\n  }\nLAB_00407158:\n  FUN_004077c0(ppFVar3);\n  return ppFVar4;\n}\n\n",
            "funcName": "FUN_00407050"
        },
        {
            "funcStartAddr": "0x407340",
            "funcEndAddr": "0x407345",
            "decompiledFuncCode": "\nvoid FUN_00407340(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 8) = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_00407340"
        },
        {
            "funcStartAddr": "0x407350",
            "funcEndAddr": "0x407355",
            "decompiledFuncCode": "\nvoid FUN_00407350(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x10) = param_2;\n  return;\n}\n\n",
            "funcName": "FUN_00407350"
        },
        {
            "funcStartAddr": "0x407360",
            "funcEndAddr": "0x4074a2",
            "decompiledFuncCode": "\nvoid FUN_00407360(FILE **param_1,void *param_2,FILE *param_3)\n\n{\n  FILE **ppFVar1;\n  int *piVar2;\n  size_t sVar3;\n  int iVar4;\n  void *__dest;\n  FILE **__src;\n  FILE *pFVar5;\n  \n  pFVar5 = *param_1;\n  if (pFVar5 != (FILE *)0x0) {\n    piVar2 = __errno_location();\n    while( true ) {\n      sVar3 = fread_unlocked(param_2,1,(size_t)param_3,pFVar5);\n      iVar4 = *piVar2;\n      param_2 = (void *)((long)param_2 + sVar3);\n      param_3 = (FILE *)((long)param_3 - sVar3);\n      if (param_3 == (FILE *)0x0) break;\n      pFVar5 = param_1[2];\n      if ((*(byte *)&(*param_1)->_flags & 0x20) == 0) {\n        iVar4 = 0;\n      }\n      *piVar2 = iVar4;\n      (*(code *)param_1[1])(pFVar5);\n      pFVar5 = *param_1;\n    }\n    return;\n  }\n  pFVar5 = param_1[3];\n  __src = param_1 + 0x107;\n  ppFVar1 = param_1 + 4;\n  __dest = param_2;\n  if (param_3 <= pFVar5) {\n    __src = (FILE **)((long)__src + (0x800 - (long)pFVar5));\n    goto LAB_00407475;\n  }\n  do {\n    param_2 = (void *)((long)__dest + (long)pFVar5);\n    param_3 = (FILE *)((long)param_3 - (long)pFVar5);\n    memcpy(__dest,(void *)((0x800 - (long)pFVar5) + (long)__src),(size_t)pFVar5);\n    if (((ulong)param_2 & 7) == 0) goto LAB_0040745b;\n    pFVar5 = (FILE *)0x800;\n    FUN_00407510(ppFVar1,__src);\n    __dest = param_2;\n  } while ((FILE *)0x800 < param_3);\n  goto LAB_0040746f;\nLAB_0040745b:\n  while ((FILE *)0x7ff < param_3) {\n    FUN_00407510(ppFVar1,param_2);\n    param_3 = (FILE *)&param_3[-10]._fileno;\n    param_2 = (void *)((long)param_2 + 0x800);\n    if (param_3 == (FILE *)0x0) {\n      param_1[3] = (FILE *)0x0;\n      return;\n    }\n  }\n  FUN_00407510(ppFVar1,__src);\nLAB_0040746f:\n  pFVar5 = (FILE *)0x800;\nLAB_00407475:\n  memcpy(param_2,__src,(size_t)param_3);\n  param_1[3] = (FILE *)((long)pFVar5 - (long)param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00407360"
        },
        {
            "funcStartAddr": "0x4074c0",
            "funcEndAddr": "0x407501",
            "decompiledFuncCode": "\nint FUN_004074c0(FILE **param_1)\n\n{\n  FILE *__stream;\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  __stream = *param_1;\n  __explicit_bzero_chk(param_1,0x1038,0xffffffffffffffff);\n  free(param_1);\n  if (__stream == (FILE *)0x0) {\n    return 0;\n  }\n  iVar1 = fileno(__stream);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(__stream);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00408a77;\n    }\n    iVar1 = FUN_00408bd0(__stream);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(__stream);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00408a77:\n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_004074c0"
        },
        {
            "funcStartAddr": "0x407510",
            "funcEndAddr": "0x4077b5",
            "decompiledFuncCode": "\nvoid FUN_00407510(long *param_1,long *param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  ulong uVar3;\n  long lVar4;\n  long *plVar5;\n  long lVar6;\n  \n  lVar6 = param_1[0x102];\n  uVar3 = param_1[0x100];\n  param_1[0x102] = lVar6 + 1;\n  lVar6 = param_1[0x101] + lVar6 + 1;\n  plVar1 = param_1;\n  plVar5 = param_2;\n  do {\n    lVar4 = *plVar1;\n    uVar3 = ~(uVar3 ^ uVar3 << 0x15) + plVar1[0x80];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    *plVar1 = lVar6;\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8)) + lVar4;\n    *plVar5 = lVar4;\n    lVar6 = plVar1[1];\n    uVar3 = (uVar3 ^ uVar3 >> 5) + plVar1[0x81];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar1[1] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar5[1] = lVar6;\n    lVar4 = plVar1[2];\n    uVar3 = (uVar3 * 0x1000 ^ uVar3) + plVar1[0x82];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    plVar1[2] = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    plVar5[2] = lVar4;\n    lVar6 = plVar1[3];\n    uVar3 = (uVar3 ^ uVar3 >> 0x21) + plVar1[0x83];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar2 = plVar1 + 4;\n    plVar1[3] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar5[3] = lVar6;\n    plVar1 = plVar2;\n    plVar5 = plVar5 + 4;\n  } while (plVar2 != param_1 + 0x80);\n  plVar1 = param_2 + 0x80;\n  do {\n    lVar4 = *plVar2;\n    uVar3 = ~(uVar3 ^ uVar3 << 0x15) + plVar2[-0x80];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    *plVar2 = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    *plVar1 = lVar4;\n    lVar6 = plVar2[1];\n    uVar3 = (uVar3 ^ uVar3 >> 5) + plVar2[-0x7f];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar2[1] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar1[1] = lVar6;\n    lVar4 = plVar2[2];\n    uVar3 = (uVar3 * 0x1000 ^ uVar3) + plVar2[-0x7e];\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)lVar4 & 0x7f8)) + uVar3 + lVar6;\n    plVar2[2] = lVar6;\n    lVar4 = lVar4 + *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar6 >> 8) & 0x7f8));\n    plVar1[2] = lVar4;\n    lVar6 = plVar2[3];\n    uVar3 = (uVar3 ^ uVar3 >> 0x21) + plVar2[-0x7d];\n    lVar4 = *(long *)((long)param_1 + (ulong)((uint)lVar6 & 0x7f8)) + uVar3 + lVar4;\n    plVar5 = plVar2 + 4;\n    plVar2[3] = lVar4;\n    lVar6 = *(long *)((long)param_1 + (ulong)((uint)((ulong)lVar4 >> 8) & 0x7f8)) + lVar6;\n    plVar1[3] = lVar6;\n    plVar2 = plVar5;\n    plVar1 = plVar1 + 4;\n  } while (plVar5 != param_1 + 0x100);\n  param_1[0x100] = uVar3;\n  param_1[0x101] = lVar6;\n  return;\n}\n\n",
            "funcName": "FUN_00407510"
        },
        {
            "funcStartAddr": "0x4077c0",
            "funcEndAddr": "0x4079f4",
            "decompiledFuncCode": "\nvoid FUN_004077c0(ulong *param_1)\n\n{\n  ulong *puVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong *puVar4;\n  ulong uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  ulong uVar8;\n  long lVar9;\n  ulong uVar10;\n  ulong uVar11;\n  long lVar12;\n  ulong uVar13;\n  ulong uVar14;\n  \n  uVar3 = 0x98f5704f6c44c0ab;\n  uVar7 = 0x82f053db8355e0ce;\n  uVar13 = 0xb29b2e824a595524;\n  uVar14 = 0xae985bf2cbfc89ed;\n  uVar11 = 0x8c0ea5053d4712a0;\n  uVar10 = 0xb9f8b322c73ac862;\n  uVar8 = 0x647c4677a2884b7c;\n  uVar5 = 0x48fe4a0fa5a09315;\n  puVar1 = param_1;\n  do {\n    lVar9 = uVar8 + (*puVar1 - (uVar7 + puVar1[4]));\n    uVar6 = uVar5 + puVar1[5] ^ uVar3 + puVar1[7] >> 9;\n    uVar10 = uVar10 + (puVar1[1] - uVar6);\n    uVar5 = uVar14 + puVar1[6] ^ lVar9 * 0x200;\n    lVar12 = uVar11 + (puVar1[2] - uVar5);\n    uVar3 = uVar3 + puVar1[7] + lVar9 ^ uVar10 >> 0x17;\n    uVar13 = uVar13 + (puVar1[3] - uVar3);\n    uVar8 = lVar9 + uVar10 ^ lVar12 * 0x8000;\n    lVar9 = (uVar7 + puVar1[4]) - uVar8;\n    *puVar1 = uVar8;\n    uVar10 = uVar10 + lVar12 ^ uVar13 >> 0xe;\n    uVar6 = uVar6 - uVar10;\n    puVar1[1] = uVar10;\n    uVar11 = lVar12 + uVar13 ^ lVar9 * 0x100000;\n    lVar12 = uVar5 - uVar11;\n    puVar1[2] = uVar11;\n    puVar2 = puVar1 + 8;\n    uVar13 = uVar13 + lVar9 ^ uVar6 >> 0x11;\n    uVar5 = uVar6 + lVar12;\n    uVar3 = uVar3 - uVar13;\n    puVar1[3] = uVar13;\n    uVar7 = lVar12 * 0x4000 ^ lVar9 + uVar6;\n    uVar14 = lVar12 + uVar3;\n    puVar1[5] = uVar5;\n    puVar1[4] = uVar7;\n    puVar1[6] = uVar14;\n    puVar1[7] = uVar3;\n    puVar1 = puVar2;\n    puVar4 = param_1;\n  } while (param_1 + 0x100 != puVar2);\n  do {\n    lVar9 = (uVar8 + *puVar4) - (uVar7 + puVar4[4]);\n    uVar6 = uVar5 + puVar4[5] ^ uVar3 + puVar4[7] >> 9;\n    uVar5 = (uVar10 + puVar4[1]) - uVar6;\n    uVar14 = uVar14 + puVar4[6] ^ lVar9 * 0x200;\n    lVar12 = (uVar11 + puVar4[2]) - uVar14;\n    uVar3 = uVar3 + puVar4[7] + lVar9 ^ uVar5 >> 0x17;\n    uVar13 = (uVar13 + puVar4[3]) - uVar3;\n    uVar8 = lVar9 + uVar5 ^ lVar12 * 0x8000;\n    lVar9 = (uVar7 + puVar4[4]) - uVar8;\n    *puVar4 = uVar8;\n    uVar10 = uVar5 + lVar12 ^ uVar13 >> 0xe;\n    uVar6 = uVar6 - uVar10;\n    puVar4[1] = uVar10;\n    uVar11 = lVar12 + uVar13 ^ lVar9 * 0x100000;\n    lVar12 = uVar14 - uVar11;\n    puVar4[2] = uVar11;\n    puVar1 = puVar4 + 8;\n    uVar13 = uVar13 + lVar9 ^ uVar6 >> 0x11;\n    uVar5 = uVar6 + lVar12;\n    uVar3 = uVar3 - uVar13;\n    puVar4[3] = uVar13;\n    uVar7 = lVar12 * 0x4000 ^ lVar9 + uVar6;\n    uVar14 = lVar12 + uVar3;\n    puVar4[5] = uVar5;\n    puVar4[4] = uVar7;\n    puVar4[6] = uVar14;\n    puVar4[7] = uVar3;\n    puVar4 = puVar1;\n  } while (param_1 + 0x100 != puVar1);\n  param_1[0x102] = 0;\n  param_1[0x101] = 0;\n  param_1[0x100] = 0;\n  return;\n}\n\n",
            "funcName": "FUN_004077c0"
        },
        {
            "funcStartAddr": "0x407a00",
            "funcEndAddr": "0x407c38",
            "decompiledFuncCode": "\nulong FUN_00407a00(uint param_1,char *param_2,uint param_3,char *param_4,uint param_5)\n\n{\n  bool bVar1;\n  int iVar2;\n  uint uVar3;\n  ulong uVar4;\n  int *piVar5;\n  size_t sVar6;\n  size_t sVar7;\n  stat local_158;\n  stat local_c8;\n  \n  uVar4 = syscall(0x13c,(ulong)param_1,param_2,(ulong)param_3,param_4,(ulong)param_5);\n  if (-1 < (int)uVar4) {\n    return uVar4 & 0xffffffff;\n  }\n  piVar5 = __errno_location();\n  bVar1 = (*piVar5 - 0x16U & 0xffffffef) != 0 && *piVar5 != 0x5f;\n  if (bVar1) {\n    return uVar4 & 0xffffffff;\n  }\n  if (param_5 != 0) {\n    if ((param_5 & 0xfffffffe) != 0) {\n      *piVar5 = 0x5f;\n      return 0xffffffff;\n    }\n    iVar2 = __fxstatat(1,param_3,param_4,&local_c8,0x100);\n    if ((iVar2 == 0) || (*piVar5 == 0x4b)) {\n      *piVar5 = 0x11;\n      return 0xffffffff;\n    }\n    if (*piVar5 != 2) {\n      return 0xffffffff;\n    }\n    bVar1 = true;\n  }\n  sVar6 = strlen(param_2);\n  sVar7 = strlen(param_4);\n  if (((sVar6 != 0) && (sVar7 != 0)) && ((param_2[sVar6 - 1] == '/' || (param_4[sVar7 - 1] == '/')))\n     ) {\n    iVar2 = __fxstatat(1,param_1,param_2,&local_158,0x100);\n    if (iVar2 != 0) {\n      return 0xffffffff;\n    }\n    if (bVar1) {\n      if ((local_158.st_mode & 0xf000) != 0x4000) {\n        *piVar5 = 2;\n        return 0xffffffff;\n      }\n    }\n    else {\n      iVar2 = __fxstatat(1,param_3,param_4,&local_c8,0x100);\n      if (iVar2 == 0) {\n        if ((local_c8.st_mode & 0xf000) != 0x4000) {\n          *piVar5 = 0x14;\n          return 0xffffffff;\n        }\n        if ((local_158.st_mode & 0xf000) != 0x4000) {\n          *piVar5 = 0x15;\n          return 0xffffffff;\n        }\n      }\n      else if ((*piVar5 != 2) || ((local_158.st_mode & 0xf000) != 0x4000)) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar3 = renameat(param_1,param_2,param_3,param_4);\n  return (ulong)uVar3;\n}\n\n",
            "funcName": "FUN_00407a00"
        },
        {
            "funcStartAddr": "0x407c50",
            "funcEndAddr": "0x407c9c",
            "decompiledFuncCode": "\nuint FUN_00407c50(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  \n  if (2 < param_1) {\n    return param_1;\n  }\n  uVar2 = FUN_0040a190();\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  close(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n",
            "funcName": "FUN_00407c50"
        },
        {
            "funcStartAddr": "0x407ca0",
            "funcEndAddr": "0x408044",
            "decompiledFuncCode": "\nundefined8\nFUN_00407ca0(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5,\n            undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0040c4ba,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e1);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00407f1c;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar7 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_00407f1c:\n    __fprintf_chk(param_1,1,uVar7,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[1];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar1 = param_5[2];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_00407fb9;\n  case 7:\n    uVar1 = param_5[2];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    local_58 = param_5[1];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_00407fb9:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_58,uVar1,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00407d9a;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_58 = param_5[2];\n    local_50 = param_5[1];\n    uVar1 = param_5[6];\n    uVar4 = param_5[5];\n    uVar5 = param_5[4];\n    uVar6 = param_5[3];\n    uVar7 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_00407d9a:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar7,local_50,local_58,uVar6,uVar5,uVar4,uVar1,local_48);\n  return uVar1;\n}\n\n",
            "funcName": "FUN_00407ca0"
        },
        {
            "funcStartAddr": "0x408080",
            "funcEndAddr": "0x4080a0",
            "decompiledFuncCode": "\nvoid FUN_00408080(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  FUN_00407ca0();\n  return;\n}\n\n",
            "funcName": "FUN_00408080"
        },
        {
            "funcStartAddr": "0x4080a0",
            "funcEndAddr": "0x4080f9",
            "decompiledFuncCode": "\nvoid FUN_004080a0(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long local_58 [11];\n  \n  lVar4 = 0;\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_58[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_58[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_00407ca0();\n  return;\n}\n\n",
            "funcName": "FUN_004080a0"
        },
        {
            "funcStartAddr": "0x408100",
            "funcEndAddr": "0x4081b8",
            "decompiledFuncCode": "\nvoid FUN_00408100(void)\n\n{\n  long lVar1;\n  undefined8 in_R8;\n  ulong uVar2;\n  undefined8 in_R9;\n  long lVar3;\n  long *plVar4;\n  long local_88 [10];\n  long local_38 [4];\n  long local_18 [3];\n  \n  local_18[0] = in_R8;\n  plVar4 = (long *)&stack0x00000008;\n  uVar2 = 0x20;\n  local_18[1] = in_R9;\n  lVar3 = 0;\n  do {\n    if ((uint)uVar2 < 0x30) {\n      lVar1 = *(long *)((long)local_38 + uVar2);\n      local_88[lVar3] = lVar1;\n      uVar2 = (ulong)((uint)uVar2 + 8);\n    }\n    else {\n      lVar1 = *plVar4;\n      local_88[lVar3] = lVar1;\n      plVar4 = plVar4 + 1;\n    }\n  } while ((lVar1 != 0) && (lVar3 = lVar3 + 1, lVar3 != 10));\n  FUN_00407ca0();\n  return;\n}\n\n",
            "funcName": "FUN_00408100"
        },
        {
            "funcStartAddr": "0x4081c0",
            "funcEndAddr": "0x408234",
            "decompiledFuncCode": "\nvoid FUN_004081c0(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n",
            "funcName": "FUN_004081c0"
        },
        {
            "funcStartAddr": "0x408240",
            "funcEndAddr": "0x40825a",
            "decompiledFuncCode": "\nvoid FUN_00408240(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00408490();\n  }\n  return;\n}\n\n",
            "funcName": "FUN_00408240"
        },
        {
            "funcStartAddr": "0x408260",
            "funcEndAddr": "0x408281",
            "decompiledFuncCode": "\nvoid FUN_00408260(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    FUN_00408240();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00408490();\n}\n\n",
            "funcName": "FUN_00408260"
        },
        {
            "funcStartAddr": "0x408290",
            "funcEndAddr": "0x408292",
            "decompiledFuncCode": "\nvoid thunk_FUN_00408240(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00408490();\n  }\n  return;\n}\n\n",
            "funcName": "thunk_408290"
        },
        {
            "funcStartAddr": "0x4082a0",
            "funcEndAddr": "0x4082d0",
            "decompiledFuncCode": "\nvoid * FUN_004082a0(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00408490();\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "FUN_004082a0"
        },
        {
            "funcStartAddr": "0x4082e0",
            "funcEndAddr": "0x408301",
            "decompiledFuncCode": "\nvoid FUN_004082e0(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    FUN_004082a0();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00408490();\n}\n\n",
            "funcName": "FUN_004082e0"
        },
        {
            "funcStartAddr": "0x408310",
            "funcEndAddr": "0x408388",
            "decompiledFuncCode": "\nvoid FUN_00408310(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar2 = *param_2;\n  if (param_1 == 0) {\n    if (uVar2 == 0) {\n      uVar2 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar3 = (ulong)(SUB168(ZEXT816(uVar2) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar2) * ZEXT816(param_3),0) < 0) || (uVar3 != 0)) goto LAB_0040836b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar3 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar2) {\nLAB_0040836b:\n                    /* WARNING: Subroutine does not return */\n      FUN_00408490(param_1,param_2,uVar3);\n    }\n    uVar2 = (uVar2 >> 1) + 1 + uVar2;\n  }\n  *param_2 = uVar2;\n  FUN_004082a0(param_1,uVar2 * param_3);\n  return;\n}\n\n",
            "funcName": "FUN_00408310"
        },
        {
            "funcStartAddr": "0x4083a0",
            "funcEndAddr": "0x4083ea",
            "decompiledFuncCode": "\nvoid FUN_004083a0(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = *param_2;\n  if (param_1 == 0) {\n    if (uVar1 == 0) {\n      *param_2 = 0x80;\n      FUN_004082a0(0,0x80);\n      return;\n    }\n    if ((long)uVar1 < 0) goto LAB_004083ea;\n  }\n  else {\n    if (0x5555555555555553 < uVar1) {\nLAB_004083ea:\n                    /* WARNING: Subroutine does not return */\n      FUN_00408490();\n    }\n    uVar1 = (uVar1 >> 1) + 1 + uVar1;\n  }\n  *param_2 = uVar1;\n  FUN_004082a0(param_1,uVar1);\n  return;\n}\n\n",
            "funcName": "FUN_004083a0"
        },
        {
            "funcStartAddr": "0x4083f0",
            "funcEndAddr": "0x408407",
            "decompiledFuncCode": "\nvoid FUN_004083f0(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_00408240();\n  memset(__s,0,param_1);\n  return;\n}\n\n",
            "funcName": "FUN_004083f0"
        },
        {
            "funcStartAddr": "0x408410",
            "funcEndAddr": "0x40843e",
            "decompiledFuncCode": "\nvoid FUN_00408410(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00408490();\n}\n\n",
            "funcName": "FUN_00408410"
        },
        {
            "funcStartAddr": "0x408440",
            "funcEndAddr": "0x408468",
            "decompiledFuncCode": "\nvoid FUN_00408440(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)FUN_00408240(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n",
            "funcName": "FUN_00408440"
        },
        {
            "funcStartAddr": "0x408470",
            "funcEndAddr": "0x408483",
            "decompiledFuncCode": "\nvoid FUN_00408470(char *param_1)\n\n{\n  void *__dest;\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  __dest = (void *)FUN_00408240(sVar1 + 1);\n  memcpy(__dest,param_1,sVar1 + 1);\n  return;\n}\n\n",
            "funcName": "FUN_00408470"
        },
        {
            "funcStartAddr": "0x408490",
            "funcEndAddr": "0x4084c1",
            "decompiledFuncCode": "\nvoid FUN_00408490(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  error(DAT_0060f2e0,0,&DAT_0040b61c,uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "FUN_00408490"
        },
        {
            "funcStartAddr": "0x4084d0",
            "funcEndAddr": "0x408598",
            "decompiledFuncCode": "\nulong FUN_004084d0(undefined8 param_1,undefined4 param_2,ulong param_3,ulong param_4,\n                  undefined8 param_5,undefined8 param_6,int param_7)\n\n{\n  ulong uVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  ulong local_40 [2];\n  \n  iVar2 = FUN_004085d0(param_1,0,param_2,local_40);\n  uVar1 = local_40[0];\n  if (iVar2 == 0) {\n    if ((param_3 <= local_40[0]) && (local_40[0] <= param_4)) {\n      return local_40[0];\n    }\n    piVar3 = __errno_location();\n    *piVar3 = (-(uint)(uVar1 < 0x40000000) & 0xffffffd7) + 0x4b;\n  }\n  else {\n    piVar3 = __errno_location();\n    if (iVar2 == 1) {\n      *piVar3 = 0x4b;\n    }\n    else if (iVar2 == 3) {\n      *piVar3 = 0;\n    }\n  }\n  uVar4 = FUN_00406de0(param_1);\n  iVar2 = *piVar3;\n  if (iVar2 == 0x16) {\n    iVar2 = 0;\n  }\n  if (param_7 == 0) {\n    param_7 = 1;\n  }\n  error(param_7,iVar2,\"%s: %s\",param_6,uVar4);\n  return local_40[0];\n}\n\n",
            "funcName": "FUN_004084d0"
        },
        {
            "funcStartAddr": "0x4085a0",
            "funcEndAddr": "0x4085c1",
            "decompiledFuncCode": "\nvoid FUN_004085a0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  FUN_004084d0(param_1,10,param_2,param_3,param_4,param_5,param_6);\n  return;\n}\n\n",
            "funcName": "FUN_004085a0"
        },
        {
            "funcStartAddr": "0x4085d0",
            "funcEndAddr": "0x40897e",
            "decompiledFuncCode": "\nulong FUN_004085d0(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint uVar9;\n  int iVar10;\n  ulong uVar11;\n  byte bVar12;\n  uint uVar13;\n  ulong uVar14;\n  int iVar15;\n  int iVar16;\n  byte *local_40 [2];\n  \n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = local_40;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar12 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar12 * 2 + 1) & 0x20) != 0) {\n    pbVar5 = pbVar5 + 1;\n    bVar12 = *pbVar5;\n  }\n  if (bVar12 == 0x2d) {\n    return 4;\n  }\n  uVar6 = __strtoul_internal(param_1,param_2,param_3,0);\n  pbVar5 = *param_2;\n  if (pbVar5 == param_1) {\n    if ((param_5 == (char *)0x0) || (bVar12 = *param_1, bVar12 == 0)) {\n      return 4;\n    }\n    uVar14 = 0;\n    uVar6 = 1;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) {\n      return 4;\n    }\n  }\n  else {\n    if (*piVar3 == 0) {\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = 1;\n      if (*piVar3 != 0x22) {\n        return 4;\n      }\n    }\n    uVar13 = (uint)uVar14;\n    if ((param_5 == (char *)0x0) || (bVar12 = *pbVar5, bVar12 == 0)) goto LAB_00408672;\n    pcVar7 = strchr(param_5,(int)(char)bVar12);\n    if (pcVar7 == (char *)0x0) goto switchD_0040875c_caseD_1;\n  }\n  uVar13 = (uint)uVar14;\n  uVar9 = bVar12 - 0x45;\n  bVar8 = (byte)uVar9;\n  if (((bVar8 < 0x30) && ((0x814400308945U >> ((ulong)uVar9 & 0x3f) & 1) != 0)) &&\n     (pcVar7 = strchr(param_5,0x30), pcVar7 != (char *)0x0)) {\n    bVar1 = pbVar5[1];\n    if (bVar1 != 0x44) {\n      if (bVar1 == 0x69) {\n        uVar11 = 0x400;\n        iVar15 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n        goto LAB_0040874a;\n      }\n      if (bVar1 != 0x42) {\n                    /* WARNING: Could not recover jumptable at 0x00408731. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar6 = (*(code *)(&PTR_LAB_0040c878)[bVar8])();\n        return uVar6;\n      }\n    }\n    iVar15 = 2;\n    uVar11 = 1000;\n  }\n  else {\n    iVar15 = 1;\n    uVar11 = 0x400;\n  }\nLAB_0040874a:\n  iVar10 = (int)uVar11;\n  switch(bVar12 - 0x42 & 0xff) {\n  case 0:\n    if (uVar6 >> 0x36 == 0) {\n      uVar6 = uVar6 << 10;\n      break;\n    }\n    goto LAB_004087b7;\n  default:\nswitchD_0040875c_caseD_1:\n    *param_4 = uVar6;\n    return (ulong)(uVar13 | 2);\n  case 3:\n    iVar16 = 6;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00408844;\n  case 5:\n  case 0x25:\n    uVar11 = (ulong)iVar10;\n    if (((SUB168(ZEXT816(uVar6) * ZEXT816(uVar11) >> 0x40,0) != 0) ||\n        (auVar2 = (ZEXT816(uVar6) * ZEXT816(uVar11) & (undefined  [16])0xffffffffffffffff) *\n                  ZEXT816(uVar11), SUB168(auVar2 >> 0x40,0) != 0)) ||\n       (auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816(uVar11),\n       uVar6 = SUB168(auVar2,0), SUB168(auVar2 >> 0x40,0) != 0)) {\n      uVar6 = 0xffffffffffffffff;\n      uVar14 = 1;\n    }\n    break;\n  case 9:\n  case 0x29:\n    auVar2 = ZEXT816(uVar6) * ZEXT816(uVar11);\n    goto joined_r0x0040877c;\n  case 0xb:\n  case 0x2b:\n    auVar2 = ZEXT816(uVar6) * ZEXT816((ulong)(long)iVar10);\n    if (SUB168(auVar2 >> 0x40,0) != 0) goto LAB_004087b7;\n    auVar2 = (auVar2 & (undefined  [16])0xffffffffffffffff) * ZEXT816((ulong)(long)iVar10);\njoined_r0x0040877c:\n    uVar6 = SUB168(auVar2,0);\n    if (SUB168(auVar2 >> 0x40,0) != 0) {\nLAB_004087b7:\n      uVar14 = 1;\n      uVar6 = 0xffffffffffffffff;\n    }\n    break;\n  case 0xe:\n    iVar16 = 5;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00408844;\n  case 0x12:\n  case 0x32:\n    iVar16 = 4;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00408844;\n  case 0x17:\n    iVar16 = 8;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\n    goto LAB_00408844;\n  case 0x18:\n    iVar16 = 7;\n    uVar9 = 0;\n    do {\n      auVar2 = ZEXT816(uVar6);\n      uVar6 = SUB168(auVar2 * ZEXT816((ulong)(long)iVar10),0);\n      if (SUB168(auVar2 * ZEXT816((ulong)(long)iVar10) >> 0x40,0) != 0) {\n        uVar9 = 1;\n        uVar6 = 0xffffffffffffffff;\n      }\n      iVar16 = iVar16 + -1;\n    } while (iVar16 != 0);\nLAB_00408844:\n    uVar14 = (ulong)(uVar13 | uVar9);\n    break;\n  case 0x20:\n    if (uVar6 >> 0x37 != 0) goto LAB_004087b7;\n    uVar6 = uVar6 << 9;\n    break;\n  case 0x21:\n    break;\n  case 0x35:\n    if ((long)uVar6 < 0) goto LAB_004087b7;\n    uVar6 = uVar6 * 2;\n  }\n  *param_2 = pbVar5 + iVar15;\n  if (pbVar5[iVar15] != 0) {\n    uVar14 = (ulong)((uint)uVar14 | 2);\n  }\nLAB_00408672:\n  *param_4 = uVar6;\n  return uVar14;\n}\n\n",
            "funcName": "FUN_004085d0"
        },
        {
            "funcStartAddr": "0x408a10",
            "funcEndAddr": "0x408a88",
            "decompiledFuncCode": "\nint FUN_00408a10(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00408a77;\n    }\n    iVar1 = FUN_00408bd0(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00408a77:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n",
            "funcName": "FUN_00408a10"
        },
        {
            "funcStartAddr": "0x408a90",
            "funcEndAddr": "0x408bbc",
            "decompiledFuncCode": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint FUN_00408a90(ulong param_1,int param_2,ulong param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  int *piVar4;\n  \n  if (param_2 != 0x406) {\n    iVar1 = fcntl((int)param_1,param_2,param_3);\n    return iVar1;\n  }\n  if (DAT_0060f4f8 < 0) {\n    iVar1 = FUN_00408a90(param_1,0,param_3 & 0xffffffff);\n    if (iVar1 < 0) {\n      return iVar1;\n    }\n    if (DAT_0060f4f8 != -1) {\n      return iVar1;\n    }\n  }\n  else {\n    iVar1 = fcntl((int)param_1,0x406);\n    if ((-1 < iVar1) || (piVar4 = __errno_location(), *piVar4 != 0x16)) {\n      DAT_0060f4f8 = 1;\n      return iVar1;\n    }\n    iVar1 = FUN_00408a90(param_1 & 0xffffffff,0,param_3 & 0xffffffff);\n    if (iVar1 < 0) {\n      return iVar1;\n    }\n    DAT_0060f4f8 = -1;\n  }\n  uVar2 = fcntl(iVar1,1);\n  if ((-1 < (int)uVar2) && (iVar3 = fcntl(iVar1,2,(ulong)(uVar2 | 1)), iVar3 != -1)) {\n    return iVar1;\n  }\n  piVar4 = __errno_location();\n  iVar3 = *piVar4;\n  close(iVar1);\n  *piVar4 = iVar3;\n  return -1;\n}\n\n",
            "funcName": "FUN_00408a90"
        },
        {
            "funcStartAddr": "0x408bd0",
            "funcEndAddr": "0x408c0b",
            "decompiledFuncCode": "\nvoid FUN_00408bd0(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if ((iVar1 != 0) && ((param_1->_flags & 0x100U) != 0)) {\n      FUN_00408c10(param_1,0,1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n",
            "funcName": "FUN_00408bd0"
        },
        {
            "funcStartAddr": "0x408c10",
            "funcEndAddr": "0x408c66",
            "decompiledFuncCode": "\nulong FUN_00408c10(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  uint uVar1;\n  int __fd;\n  ulong uVar2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    __fd = fileno(param_1);\n    uVar2 = lseek(__fd,param_2,param_3);\n    if (uVar2 != 0xffffffffffffffff) {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = uVar2;\n      uVar2 = 0;\n    }\n    return uVar2;\n  }\n  uVar1 = fseeko(param_1,param_2,param_3);\n  return (ulong)uVar1;\n}\n\n",
            "funcName": "FUN_00408c10"
        },
        {
            "funcStartAddr": "0x408c70",
            "funcEndAddr": "0x408d45",
            "decompiledFuncCode": "\nvoid FUN_00408c70(long param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  iVar1 = param_2[0xb];\n  iVar2 = *param_2;\n  iVar3 = param_2[0xc];\n  iVar8 = iVar1;\n  iVar9 = iVar2;\n  while (iVar3 < iVar9) {\n    while( true ) {\n      if (iVar3 <= iVar8) goto LAB_00408cec;\n      iVar10 = iVar9 - iVar3;\n      iVar7 = iVar3 - iVar8;\n      if (iVar10 <= iVar7) break;\n      lVar6 = (long)iVar8;\n      iVar9 = iVar9 - iVar7;\n      puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n      do {\n        uVar4 = *puVar5;\n        *puVar5 = puVar5[iVar9 - lVar6];\n        puVar5[iVar9 - lVar6] = uVar4;\n        puVar5 = puVar5 + 1;\n      } while ((undefined8 *)(param_1 + 8 + ((ulong)(iVar7 - 1) + lVar6) * 8) != puVar5);\n      if (iVar9 <= iVar3) goto LAB_00408cec;\n    }\n    lVar6 = (long)iVar8;\n    puVar5 = (undefined8 *)(param_1 + lVar6 * 8);\n    do {\n      uVar4 = *puVar5;\n      *puVar5 = puVar5[iVar3 - lVar6];\n      puVar5[iVar3 - lVar6] = uVar4;\n      puVar5 = puVar5 + 1;\n    } while (puVar5 != (undefined8 *)(param_1 + 8 + ((ulong)(iVar10 - 1) + lVar6) * 8));\n    iVar8 = iVar8 + iVar10;\n  }\nLAB_00408cec:\n  param_2[0xc] = iVar2;\n  param_2[0xb] = iVar1 + (iVar2 - iVar3);\n  return;\n}\n\n",
            "funcName": "FUN_00408c70"
        },
        {
            "funcStartAddr": "0x408d50",
            "funcEndAddr": "0x40934e",
            "decompiledFuncCode": "\nint FUN_00408d50(int param_1,undefined8 *param_2,char *param_3,char **param_4,undefined4 *param_5,\n                int param_6,int *param_7,int param_8,undefined8 param_9)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  char **ppcVar12;\n  char *pcVar13;\n  char *__s1;\n  FILE *__stream;\n  ulong uVar14;\n  size_t sVar15;\n  char *__s1_00;\n  long lVar16;\n  char *local_70;\n  uint local_44;\n  \n  pcVar13 = *(char **)(param_7 + 8);\n  cVar1 = *pcVar13;\n  pcVar11 = pcVar13;\n  if ((cVar1 == '=') || (cVar1 == '\\0')) {\n    sVar15 = 0;\n  }\n  else {\n    do {\n      pcVar11 = pcVar11 + 1;\n      if (*pcVar11 == '\\0') break;\n    } while (*pcVar11 != '=');\n    sVar15 = (long)pcVar11 - (long)pcVar13;\n  }\n  uVar14 = 0;\n  __s1 = *param_4;\n  ppcVar10 = param_4;\n  __s1_00 = __s1;\n  if (__s1 != (char *)0x0) {\n    while( true ) {\n      iVar5 = strncmp(__s1_00,pcVar13,sVar15);\n      if ((iVar5 == 0) && (sVar7 = strlen(__s1_00), sVar7 == sVar15)) goto LAB_00408f70;\n      ppcVar10 = ppcVar10 + 4;\n      __s1_00 = *ppcVar10;\n      iVar5 = (int)uVar14 + 1;\n      if (__s1_00 == (char *)0x0) break;\n      uVar14 = (ulong)iVar5;\n    }\n    lVar16 = 0;\n    ppcVar10 = (char **)0x0;\n    local_44 = 0xffffffff;\n    bVar3 = false;\n    bVar4 = false;\n    local_70 = (char *)0x0;\n    ppcVar12 = param_4;\n    do {\n      iVar6 = strncmp(__s1,pcVar13,sVar15);\n      if (iVar6 == 0) {\n        if (ppcVar10 == (char **)0x0) {\n          local_44 = (uint)lVar16;\n          ppcVar10 = ppcVar12;\n        }\n        else if (((((param_6 != 0) || (*(int *)(ppcVar10 + 1) != *(int *)(ppcVar12 + 1))) ||\n                  (ppcVar10[2] != ppcVar12[2])) ||\n                 (*(int *)(ppcVar10 + 3) != *(int *)(ppcVar12 + 3))) && (!bVar3)) {\n          if (param_8 == 0) {\n            bVar3 = true;\n            if (local_70 == (char *)0x0) goto LAB_00408eb0;\n          }\n          else if (local_70 == (char *)0x0) {\n            local_70 = (char *)calloc((long)iVar5,1);\n            if (local_70 == (char *)0x0) {\n              bVar3 = true;\n              goto LAB_00408eb0;\n            }\n            bVar4 = true;\n            local_70[(int)local_44] = '\\x01';\n          }\n          local_70[lVar16] = '\\x01';\n        }\n      }\nLAB_00408eb0:\n      ppcVar12 = ppcVar12 + 4;\n      __s1 = *ppcVar12;\n      lVar16 = lVar16 + 1;\n    } while (__s1 != (char *)0x0);\n    if ((local_70 != (char *)0x0) || (bVar3)) {\n      if (param_8 != 0) {\n        if (bVar3) {\n          uVar2 = *param_2;\n          uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous\\n\",5);\n          __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n        else {\n          flockfile(stderr);\n          uVar2 = *(undefined8 *)(param_7 + 8);\n          uVar8 = *param_2;\n          uVar9 = dcgettext(0,\"%s: option \\'%s%s\\' is ambiguous; possibilities:\",5);\n          __fprintf_chk(stderr,1,uVar9,uVar8,param_9,uVar2);\n          pcVar13 = local_70;\n          __stream = stderr;\n          do {\n            if (*pcVar13 != '\\0') {\n              __fprintf_chk(__stream,1,&DAT_0040cca9,param_9,*param_4);\n              __stream = stderr;\n            }\n            pcVar13 = pcVar13 + 1;\n            param_4 = param_4 + 4;\n          } while (local_70 + uVar14 + 1 != pcVar13);\n          fputc(10,__stream);\n          funlockfile(stderr);\n          pcVar13 = *(char **)(param_7 + 8);\n        }\n      }\n      if (bVar4) {\n        free(local_70);\n      }\n      sVar15 = strlen(pcVar13);\n      *(char **)(param_7 + 8) = pcVar13 + sVar15;\n      *param_7 = *param_7 + 1;\n      param_7[2] = 0;\n      return 0x3f;\n    }\n    if (ppcVar10 != (char **)0x0) {\n      uVar14 = (ulong)local_44;\nLAB_00408f70:\n      iVar6 = *param_7;\n      *(undefined8 *)(param_7 + 8) = 0;\n      iVar5 = iVar6 + 1;\n      *param_7 = iVar5;\n      if (*pcVar11 == '\\0') {\n        if (*(int *)(ppcVar10 + 1) == 1) {\n          if (param_1 <= iVar5) {\n            if (param_8 != 0) {\n              pcVar13 = *ppcVar10;\n              uVar2 = *param_2;\n              uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' requires an argument\\n\",5);\n              __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n            }\n            param_7[2] = *(int *)(ppcVar10 + 3);\n            return (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          *param_7 = iVar6 + 2;\n          *(undefined8 *)(param_7 + 4) = param_2[iVar5];\n        }\n      }\n      else {\n        if (*(int *)(ppcVar10 + 1) == 0) {\n          if (param_8 != 0) {\n            pcVar13 = *ppcVar10;\n            uVar2 = *param_2;\n            uVar8 = dcgettext(0,\"%s: option \\'%s%s\\' doesn\\'t allow an argument\\n\",5);\n            __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n          }\n          param_7[2] = *(int *)(ppcVar10 + 3);\n          return 0x3f;\n        }\n        *(char **)(param_7 + 4) = pcVar11 + 1;\n      }\n      if (param_5 != (undefined4 *)0x0) {\n        *param_5 = (int)uVar14;\n      }\n      if ((int *)ppcVar10[2] == (int *)0x0) {\n        return *(int *)(ppcVar10 + 3);\n      }\n      *(int *)ppcVar10[2] = *(int *)(ppcVar10 + 3);\n      return 0;\n    }\n  }\n  if (((param_6 != 0) && (*(char *)(param_2[*param_7] + 1) != '-')) &&\n     (pcVar11 = strchr(param_3,(int)cVar1), pcVar11 != (char *)0x0)) {\n    return -1;\n  }\n  if (param_8 != 0) {\n    uVar2 = *param_2;\n    uVar8 = dcgettext(0,\"%s: unrecognized option \\'%s%s\\'\\n\",5);\n    __fprintf_chk(stderr,1,uVar8,uVar2,param_9,pcVar13);\n  }\n  *(undefined8 *)(param_7 + 8) = 0;\n  *param_7 = *param_7 + 1;\n  param_7[2] = 0;\n  return 0x3f;\n}\n\n",
            "funcName": "FUN_00408d50"
        },
        {
            "funcStartAddr": "0x409370",
            "funcEndAddr": "0x4098d7",
            "decompiledFuncCode": "\nuint FUN_00409370(uint param_1,undefined8 *param_2,char *param_3,long param_4,undefined8 param_5,\n                 ulong param_6,uint *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long lVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  uint uVar11;\n  bool bVar12;\n  bool bVar13;\n  byte bVar14;\n  undefined1 *puVar15;\n  \n  bVar14 = 0;\n  uVar3 = param_7[1];\n  if ((int)param_1 < 1) {\n    return 0xffffffff;\n  }\n  uVar11 = *param_7;\n  *(undefined8 *)(param_7 + 4) = 0;\n  if (uVar11 == 0) {\n    *param_7 = 1;\n    uVar11 = 1;\nLAB_004093ba:\n    param_7[0xc] = uVar11;\n    param_7[0xb] = uVar11;\n    *(undefined8 *)(param_7 + 8) = 0;\n    if (*param_3 == '-') {\n      param_7[10] = 2;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else if (*param_3 == '+') {\n      param_7[10] = 0;\n      param_3 = param_3 + 1;\n      pbVar8 = (byte *)0x0;\n    }\n    else {\n      pbVar8 = (byte *)0x0;\n      if (param_8 == 0) {\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        param_6 = param_6 & 0xffffffff;\n        if (pcVar4 == (char *)0x0) {\n          param_7[10] = 1;\n          pbVar8 = *(byte **)(param_7 + 8);\n          goto LAB_004094bd;\n        }\n        pbVar8 = *(byte **)(param_7 + 8);\n      }\n      param_7[10] = 0;\n    }\nLAB_004094bd:\n    param_7[6] = 1;\n    cVar2 = *param_3;\nLAB_004094c8:\n    if (cVar2 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 == (byte *)0x0) goto LAB_00409438;\nLAB_004094dc:\n    if (*pbVar8 == 0) goto LAB_00409438;\n  }\n  else {\n    if (param_7[6] == 0) goto LAB_004093ba;\n    cVar2 = *param_3;\n    pbVar8 = *(byte **)(param_7 + 8);\n    if ((cVar2 - 0x2bU & 0xfd) != 0) goto LAB_004094c8;\n    pcVar4 = param_3 + 1;\n    param_3 = param_3 + 1;\n    if (*pcVar4 == ':') {\n      uVar3 = 0;\n    }\n    if (pbVar8 != (byte *)0x0) goto LAB_004094dc;\nLAB_00409438:\n    uVar11 = *param_7;\n    if (param_7[0xc] != uVar11 && (int)uVar11 <= (int)param_7[0xc]) {\n      param_7[0xc] = uVar11;\n    }\n    if ((int)uVar11 < (int)param_7[0xb]) {\n      param_7[0xb] = uVar11;\n    }\n    if (param_7[10] == 1) {\n      uVar7 = param_7[0xc];\n      if (param_7[0xb] == uVar7) {\n        if (uVar11 != uVar7) {\n          param_7[0xb] = uVar11;\n          uVar7 = uVar11;\n        }\n      }\n      else if (uVar11 != uVar7) {\n        FUN_00408c70(param_2,param_7);\n        param_6 = param_6 & 0xffffffff;\n        uVar7 = *param_7;\n      }\n      uVar11 = uVar7;\n      uVar7 = uVar11;\n      if ((int)uVar11 < (int)param_1) {\n        lVar6 = (long)(int)uVar11;\n        do {\n          if ((*(char *)param_2[lVar6] == '-') && (((char *)param_2[lVar6])[1] != '\\0')) {\n            uVar11 = *param_7;\n            uVar7 = (uint)lVar6;\n            break;\n          }\n          uVar11 = (uint)lVar6 + 1;\n          lVar6 = lVar6 + 1;\n          *param_7 = uVar11;\n          uVar7 = uVar11;\n        } while ((int)lVar6 < (int)param_1);\n      }\n      param_7[0xc] = uVar7;\n    }\n    bVar12 = param_1 < uVar11;\n    bVar13 = param_1 == uVar11;\n    if (bVar13) {\n      param_1 = param_7[0xc];\n      uVar11 = param_7[0xb];\nLAB_004095a6:\n      if (uVar11 != param_1) {\n        *param_7 = uVar11;\n      }\n      return 0xffffffff;\n    }\n    lVar6 = 3;\n    pbVar8 = (byte *)param_2[(int)uVar11];\n    pbVar9 = pbVar8;\n    pbVar10 = &DAT_0040ccb1;\n    do {\n      if (lVar6 == 0) break;\n      lVar6 = lVar6 + -1;\n      bVar12 = *pbVar9 < *pbVar10;\n      bVar13 = *pbVar9 == *pbVar10;\n      pbVar9 = pbVar9 + (ulong)bVar14 * -2 + 1;\n      pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;\n    } while (bVar13);\n    if ((!bVar12 && !bVar13) == bVar12) {\n      uVar11 = uVar11 + 1;\n      *param_7 = uVar11;\n      if (param_7[0xb] == param_7[0xc]) {\n        param_7[0xb] = uVar11;\n      }\n      else {\n        bVar12 = uVar11 != param_7[0xc];\n        uVar11 = param_7[0xb];\n        if (bVar12) {\n          FUN_00408c70(param_2,param_7);\n          uVar11 = param_7[0xb];\n        }\n      }\n      param_7[0xc] = param_1;\n      *param_7 = param_1;\n      goto LAB_004095a6;\n    }\n    if ((*pbVar8 != 0x2d) || (bVar14 = pbVar8[1], bVar14 == 0)) {\n      if (param_7[10] == 0) {\n        return 0xffffffff;\n      }\n      *(byte **)(param_7 + 4) = pbVar8;\n      *param_7 = uVar11 + 1;\n      return 1;\n    }\n    if (param_4 != 0) {\n      if (bVar14 == 0x2d) {\n        *(byte **)(param_7 + 8) = pbVar8 + 2;\n        puVar15 = &DAT_0040ccb1;\n        goto LAB_00409705;\n      }\n      if ((int)param_6 != 0) {\n        if (pbVar8[2] == 0) {\n          pcVar4 = strchr(param_3,(int)(char)bVar14);\n          param_6 = param_6 & 0xffffffff;\n          if (pcVar4 != (char *)0x0) goto LAB_004096b0;\n        }\n        *(byte **)(param_7 + 8) = pbVar8 + 1;\n        uVar11 = FUN_00408d50(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,\n                              &DAT_0040ccb2);\n        if (uVar11 != 0xffffffff) {\n          return uVar11;\n        }\n        pbVar8 = (byte *)param_2[(int)*param_7];\n      }\n    }\nLAB_004096b0:\n    pbVar8 = pbVar8 + 1;\n  }\n  pbVar9 = pbVar8 + 1;\n  *(byte **)(param_7 + 8) = pbVar9;\n  bVar14 = *pbVar8;\n  uVar11 = (uint)(char)bVar14;\n  pcVar4 = strchr(param_3,uVar11);\n  if (pbVar8[1] == 0) {\n    *param_7 = *param_7 + 1;\n  }\n  if (((byte)(bVar14 - 0x3a) < 2) || (pcVar4 == (char *)0x0)) {\n    if (uVar3 != 0) {\n      uVar1 = *param_2;\n      uVar5 = dcgettext(0,\"%s: invalid option -- \\'%c\\'\\n\",5);\n      __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n    }\n    param_7[2] = uVar11;\n    return 0x3f;\n  }\n  if (((*pcVar4 != 'W') || (param_4 == 0)) || (pcVar4[1] != ';')) {\n    if (pcVar4[1] == ':') {\n      if (pcVar4[2] == ':') {\n        if (pbVar8[1] == 0) {\n          *(undefined8 *)(param_7 + 4) = 0;\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = *param_7 + 1;\n        }\n      }\n      else {\n        uVar7 = *param_7;\n        if (pbVar8[1] == 0) {\n          if (param_1 == uVar7) {\n            if (uVar3 != 0) {\n              uVar1 = *param_2;\n              uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n              __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n            }\n            param_7[2] = uVar11;\n            uVar11 = (uint)(*param_3 != ':') * 5 + 0x3a;\n          }\n          else {\n            uVar1 = param_2[(int)uVar7];\n            *param_7 = uVar7 + 1;\n            *(undefined8 *)(param_7 + 4) = uVar1;\n          }\n        }\n        else {\n          *(byte **)(param_7 + 4) = pbVar9;\n          *param_7 = uVar7 + 1;\n        }\n      }\n      *(undefined8 *)(param_7 + 8) = 0;\n      return uVar11;\n    }\n    return uVar11;\n  }\n  if (pbVar8[1] == 0) {\n    if (*param_7 == param_1) {\n      if (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar5 = dcgettext(0,\"%s: option requires an argument -- \\'%c\\'\\n\",5);\n        __fprintf_chk(stderr,1,uVar5,uVar1,uVar11);\n      }\n      param_7[2] = uVar11;\n      return (uint)(*param_3 != ':') * 5 + 0x3a;\n    }\n    pbVar9 = (byte *)param_2[(int)*param_7];\n  }\n  *(byte **)(param_7 + 8) = pbVar9;\n  param_6 = 0;\n  *(undefined8 *)(param_7 + 4) = 0;\n  puVar15 = &DAT_0040ccd0;\nLAB_00409705:\n  uVar3 = FUN_00408d50(param_1,param_2,param_3,param_4,param_5,param_6,param_7,uVar3,puVar15);\n  return uVar3;\n}\n\n",
            "funcName": "FUN_00409370"
        },
        {
            "funcStartAddr": "0x409940",
            "funcEndAddr": "0x409996",
            "decompiledFuncCode": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00409940(void)\n\n{\n  DAT_0060f500 = DAT_0060f35c;\n  _DAT_0060f504 = DAT_0060f358;\n  FUN_00409370();\n  DAT_0060f35c = DAT_0060f500;\n  DAT_0060f540 = DAT_0060f510;\n  _DAT_0060f354 = DAT_0060f508;\n  return;\n}\n\n",
            "funcName": "FUN_00409940"
        },
        {
            "funcStartAddr": "0x4099a0",
            "funcEndAddr": "0x4099b8",
            "decompiledFuncCode": "\nvoid FUN_004099a0(void)\n\n{\n  FUN_00409940();\n  return;\n}\n\n",
            "funcName": "FUN_004099a0"
        },
        {
            "funcStartAddr": "0x4099c0",
            "funcEndAddr": "0x4099d3",
            "decompiledFuncCode": "\nvoid FUN_004099c0(void)\n\n{\n  FUN_00409940();\n  return;\n}\n\n",
            "funcName": "FUN_004099c0"
        },
        {
            "funcStartAddr": "0x4099e0",
            "funcEndAddr": "0x4099f5",
            "decompiledFuncCode": "\nvoid FUN_004099e0(void)\n\n{\n  FUN_00409370();\n  return;\n}\n\n",
            "funcName": "FUN_004099e0"
        },
        {
            "funcStartAddr": "0x409a00",
            "funcEndAddr": "0x409a16",
            "decompiledFuncCode": "\nvoid FUN_00409a00(void)\n\n{\n  FUN_00409940();\n  return;\n}\n\n",
            "funcName": "FUN_00409a00"
        },
        {
            "funcStartAddr": "0x409a20",
            "funcEndAddr": "0x409a38",
            "decompiledFuncCode": "\nvoid FUN_00409a20(void)\n\n{\n  FUN_00409370();\n  return;\n}\n\n",
            "funcName": "FUN_00409a20"
        },
        {
            "funcStartAddr": "0x409a40",
            "funcEndAddr": "0x409aaf",
            "decompiledFuncCode": "\nsize_t FUN_00409a40(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  wchar_t local_1c;\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = 1;\n    param_2 = (byte *)0x40cccf;\n  }\n  else {\n    if (param_3 == 0) {\n      return 0xfffffffffffffffe;\n    }\n    if (param_1 != (wchar_t *)0x0) goto LAB_00409a64;\n  }\n  param_1 = &local_1c;\nLAB_00409a64:\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (cVar1 = FUN_00409bc0(0), cVar1 == '\\0')) {\n    sVar2 = 1;\n    *param_1 = (uint)*param_2;\n  }\n  return sVar2;\n}\n\n",
            "funcName": "FUN_00409a40"
        },
        {
            "funcStartAddr": "0x409ac0",
            "funcEndAddr": "0x409b1c",
            "decompiledFuncCode": "\nulong FUN_00409ac0(uint *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  uVar1 = *param_1;\n  uVar3 = FUN_00408a10(param_1);\n  if ((uVar1 & 0x20) == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n",
            "funcName": "FUN_00409ac0"
        },
        {
            "funcStartAddr": "0x409b20",
            "funcEndAddr": "0x409ba9",
            "decompiledFuncCode": "\nFILE * FUN_00409b20(char *param_1,char *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  FILE *__stream;\n  FILE *pFVar4;\n  int *piVar5;\n  \n  __stream = fopen(param_1,param_2);\n  pFVar4 = __stream;\n  if ((__stream != (FILE *)0x0) && (uVar1 = fileno(__stream), uVar1 < 3)) {\n    iVar2 = FUN_0040a190(uVar1);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      pFVar4 = (FILE *)0x0;\n      iVar2 = *piVar5;\n      FUN_00408a10(__stream);\n      *piVar5 = iVar2;\n    }\n    else {\n      iVar3 = FUN_00408a10(__stream);\n      if ((iVar3 == 0) && (pFVar4 = fdopen(iVar2,param_2), pFVar4 != (FILE *)0x0)) {\n        return pFVar4;\n      }\n      piVar5 = __errno_location();\n      iVar3 = *piVar5;\n      close(iVar2);\n      *piVar5 = iVar3;\n      pFVar4 = (FILE *)0x0;\n    }\n  }\n  return pFVar4;\n}\n\n",
            "funcName": "FUN_00409b20"
        },
        {
            "funcStartAddr": "0x409bc0",
            "funcEndAddr": "0x409c16",
            "decompiledFuncCode": "\nbool FUN_00409bc0(int param_1)\n\n{\n  bool bVar1;\n  byte *pbVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  pbVar2 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar1 = true;\n  bVar6 = false;\n  bVar8 = pbVar2 == (byte *)0x0;\n  if (!bVar8) {\n    lVar3 = 2;\n    pbVar4 = pbVar2;\n    pbVar5 = &DAT_0040ccd4;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar8 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;\n    } while (bVar8);\n    bVar1 = false;\n    bVar7 = false;\n    bVar6 = (!bVar6 && !bVar8) == bVar6;\n    if (!bVar6) {\n      lVar3 = 6;\n      pbVar4 = (byte *)\"POSIX\";\n      do {\n        if (lVar3 == 0) break;\n        lVar3 = lVar3 + -1;\n        bVar7 = *pbVar2 < *pbVar4;\n        bVar6 = *pbVar2 == *pbVar4;\n        pbVar2 = pbVar2 + (ulong)bVar9 * -2 + 1;\n        pbVar4 = pbVar4 + (ulong)bVar9 * -2 + 1;\n      } while (bVar6);\n      return (!bVar7 && !bVar6) != bVar7;\n    }\n  }\n  return bVar1;\n}\n\n",
            "funcName": "FUN_00409bc0"
        },
        {
            "funcStartAddr": "0x409c20",
            "funcEndAddr": "0x40a174",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * FUN_00409c20(void)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  char *__s1;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  size_t __n;\n  char *__file;\n  FILE *__stream;\n  byte *pbVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  ulong uVar12;\n  undefined8 *puVar13;\n  char *__ptr;\n  bool bVar14;\n  long local_d0;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined auStack_80 [8];\n  undefined8 local_78;\n  \n  __s1 = nl_langinfo(0xe);\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  if (DAT_0060f538 != (char *)0x0) goto LAB_00409c5a;\n  pcVar7 = getenv(\"CHARSETALIASDIR\");\n  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\\0')) {\n    sVar6 = 0x73;\n    sVar5 = 0x65;\n    __n = 100;\n    pcVar7 = \n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\"\n    ;\nLAB_00409d45:\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      __file[__n] = '/';\n      goto LAB_00409d66;\n    }\n  }\n  else {\n    __n = strlen(pcVar7);\n    if (__n == 0) {\n      sVar6 = 0xe;\n    }\n    else {\n      if (pcVar7[__n - 1] != '/') {\n        sVar6 = __n + 0xf;\n        sVar5 = __n + 1;\n        goto LAB_00409d45;\n      }\n      sVar6 = __n + 0xe;\n    }\n    __file = (char *)malloc(sVar6);\n    if (__file != (char *)0x0) {\n      memcpy(__file,pcVar7,__n);\n      sVar5 = __n;\nLAB_00409d66:\n      puVar13 = (undefined8 *)(__file + sVar5);\n      *puVar13 = 0x2e74657372616863;\n      *(undefined2 *)((long)puVar13 + 0xc) = 0x73;\n      *(undefined4 *)(puVar13 + 1) = 0x61696c61;\n      iVar2 = open(__file,0);\n      if (-1 < iVar2) {\n        __stream = fdopen(iVar2,\"r\");\n        local_d0 = 0;\n        if (__stream != (FILE *)0x0) {\n          pcVar7 = (char *)0x0;\nLAB_00409e00:\n          pbVar8 = (byte *)__stream->_IO_read_ptr;\n          if (__stream->_IO_read_end <= pbVar8) goto LAB_00409f8c;\n          do {\n            __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n            uVar4 = (uint)*pbVar8;\n            __ptr = pcVar7;\n            while( true ) {\n              pcVar7 = __ptr;\n              if ((uVar4 - 9 < 2) || (uVar4 == 0x20)) goto LAB_00409e00;\n              if (uVar4 == 0x23) goto LAB_00409ff1;\n              ungetc(uVar4,__stream);\n              iVar2 = fscanf(__stream,\"%50s %50s\",&local_b8,&local_78);\n              puVar13 = &local_b8;\n              if (iVar2 < 2) goto LAB_00409f9f;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              lVar11 = (long)puVar13 +\n                       ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_b8);\n              puVar13 = &local_78;\n              do {\n                puVar10 = puVar13;\n                uVar3 = *(uint *)puVar10 + 0xfefefeff & ~*(uint *)puVar10;\n                uVar4 = uVar3 & 0x80808080;\n                puVar13 = (undefined8 *)((long)puVar10 + 4);\n              } while (uVar4 == 0);\n              bVar14 = (uVar3 & 0x8080) == 0;\n              if (bVar14) {\n                uVar4 = uVar4 >> 0x10;\n              }\n              if (bVar14) {\n                puVar13 = (undefined8 *)((long)puVar10 + 6);\n              }\n              local_c0 = (long)puVar13 +\n                         ((-3 - (ulong)CARRY1((byte)uVar4,(byte)uVar4)) - (long)&local_78);\n              lVar9 = lVar11 + local_c0;\n              if (local_d0 == 0) {\n                pcVar7 = (char *)malloc(lVar9 + 3);\n              }\n              else {\n                lVar9 = lVar9 + local_d0;\n                pcVar7 = (char *)realloc(__ptr,lVar9 + 3);\n              }\n              local_d0 = lVar9 + 2;\n              if (pcVar7 == (char *)0x0) {\n                pcVar7 = \"\";\n                free(__ptr);\n                FUN_00408a10(__stream);\n                goto LAB_00409da4;\n              }\n              uVar12 = lVar11 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (-2 - lVar11) + (local_d0 - local_c0));\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_b8;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 2));\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_b8;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 4));\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_b8._4_4_,(undefined4)local_b8);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)&local_b8 + ((uVar12 & 0xffffffff) - 8));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_b8 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              uVar12 = local_c0 + 1;\n              puVar13 = (undefined8 *)(pcVar7 + (local_d0 - local_c0) + -1);\n              uVar4 = (uint)uVar12;\n              if (uVar4 < 8) {\n                if ((uVar12 & 4) == 0) {\n                  if (uVar4 != 0) {\n                    *(undefined *)puVar13 = (undefined)local_78;\n                    if ((uVar12 & 2) != 0) {\n                      *(undefined2 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 2)) =\n                           *(undefined2 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 6);\n                    }\n                  }\n                }\n                else {\n                  *(undefined4 *)puVar13 = (undefined4)local_78;\n                  *(undefined4 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 4)) =\n                       *(undefined4 *)((long)auStack_80 + (uVar12 & 0xffffffff) + 4);\n                }\n              }\n              else {\n                *puVar13 = CONCAT44(local_78._4_4_,(undefined4)local_78);\n                *(undefined8 *)((long)puVar13 + ((uVar12 & 0xffffffff) - 8)) =\n                     *(undefined8 *)((long)auStack_80 + (uVar12 & 0xffffffff));\n                lVar11 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n                uVar4 = uVar4 + (int)lVar11 & 0xfffffff8;\n                if (7 < uVar4) {\n                  uVar3 = 0;\n                  do {\n                    uVar12 = (ulong)uVar3;\n                    uVar3 = uVar3 + 8;\n                    *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar12) =\n                         *(undefined8 *)((long)&local_78 + (uVar12 - lVar11));\n                  } while (uVar3 < uVar4);\n                }\n              }\n              pbVar8 = (byte *)__stream->_IO_read_ptr;\n              if (pbVar8 < __stream->_IO_read_end) break;\nLAB_00409f8c:\n              uVar4 = __uflow(__stream);\n              __ptr = pcVar7;\n              if (uVar4 == 0xffffffff) goto LAB_00409f9f;\n            }\n          } while( true );\n        }\n        close(iVar2);\n      }\n      goto LAB_00409d9e;\n    }\n  }\n  DAT_0060f538 = \"\";\nLAB_00409c5a:\n  cVar1 = *DAT_0060f538;\n  pcVar7 = DAT_0060f538;\n  do {\n    if (cVar1 == '\\0') {\nLAB_00409cb4:\n      if (*__s1 == '\\0') {\n        __s1 = \"ASCII\";\n      }\n      return __s1;\n    }\n    iVar2 = strcmp(__s1,pcVar7);\n    if ((iVar2 == 0) || ((cVar1 == '*' && (pcVar7[1] == '\\0')))) {\n      sVar6 = strlen(pcVar7);\n      __s1 = pcVar7 + sVar6 + 1;\n      goto LAB_00409cb4;\n    }\n    sVar6 = strlen(pcVar7);\n    sVar5 = strlen(pcVar7 + sVar6 + 1);\n    pcVar7 = pcVar7 + sVar6 + 1 + sVar5 + 1;\n    cVar1 = *pcVar7;\n  } while( true );\nLAB_00409ff1:\n  do {\n    pbVar8 = (byte *)__stream->_IO_read_ptr;\n    if (pbVar8 < __stream->_IO_read_end) {\n      __stream->_IO_read_ptr = (char *)(pbVar8 + 1);\n      uVar4 = (uint)*pbVar8;\n      bVar14 = true;\n    }\n    else {\n      uVar4 = __uflow(__stream);\n      bVar14 = uVar4 != 0xffffffff;\n    }\n  } while ((uVar4 != 10) && (bVar14));\n  if (uVar4 == 0xffffffff) goto LAB_00409f9f;\n  goto LAB_00409e00;\nLAB_00409f9f:\n  FUN_00408a10(__stream);\n  if (local_d0 == 0) {\nLAB_00409d9e:\n    pcVar7 = \"\";\n  }\n  else {\n    pcVar7[local_d0] = '\\0';\n  }\nLAB_00409da4:\n  free(__file);\n  DAT_0060f538 = pcVar7;\n  goto LAB_00409c5a;\n}\n\n",
            "funcName": "FUN_00409c20"
        },
        {
            "funcStartAddr": "0x40a190",
            "funcEndAddr": "0x40a19e",
            "decompiledFuncCode": "\nvoid FUN_0040a190(undefined8 param_1)\n\n{\n  FUN_00408a90(param_1,0,3);\n  return;\n}\n\n",
            "funcName": "FUN_0040a190"
        },
        {
            "funcStartAddr": "0x40a1a0",
            "funcEndAddr": "0x40a1fd",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x0040a1d3) */\n/* WARNING: Removing unreachable block (ram,0x0040a1d8) */\n\nvoid FUN_0040a1a0(void)\n\n{\n  __DT_INIT();\n  return;\n}\n\n",
            "funcName": "FUN_0040a1a0"
        },
        {
            "funcStartAddr": "0x40a200",
            "funcEndAddr": "0x40a201",
            "decompiledFuncCode": "\nvoid FUN_0040a200(void)\n\n{\n  return;\n}\n\n",
            "funcName": "FUN_0040a200"
        },
        {
            "funcStartAddr": "0x40a210",
            "funcEndAddr": "0x40a228",
            "decompiledFuncCode": "\nvoid FUN_0040a210(undefined8 param_1)\n\n{\n  __cxa_atexit(param_1,0,DAT_0060f2c8);\n  return;\n}\n\n",
            "funcName": "FUN_0040a210"
        },
        {
            "funcStartAddr": "0x40a228",
            "funcEndAddr": "0x40a248",
            "decompiledFuncCode": "\nundefined8 FUN_0040a228(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  code **ppcVar1;\n  \n  for (ppcVar1 = (code **)&DAT_0060ee30; *ppcVar1 != (code *)0xffffffffffffffff;\n      ppcVar1 = ppcVar1 + -1) {\n    (**ppcVar1)();\n  }\n  return param_3;\n}\n\n",
            "funcName": "FUN_0040a228"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_shred.elf",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}