{
    "funcInfo": [
        {
            "funcName": "function_401df0",
            "funcStartAddr": "401df0",
            "funcEndAddr": "401df5",
            "decompiledFuncCode": "int64_t function_401df0(void) {\n    // 0x401df0\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401df5",
            "funcStartAddr": "401df5",
            "funcEndAddr": "401dfa",
            "decompiledFuncCode": "int64_t function_401df5(void) {\n    // 0x401df5\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401dfa",
            "funcStartAddr": "401dfa",
            "funcEndAddr": "401dff",
            "decompiledFuncCode": "int64_t function_401dfa(void) {\n    // 0x401dfa\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401dff",
            "funcStartAddr": "401dff",
            "funcEndAddr": "401e04",
            "decompiledFuncCode": "int64_t function_401dff(void) {\n    // 0x401dff\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401e04",
            "funcStartAddr": "401e04",
            "funcEndAddr": "401e09",
            "decompiledFuncCode": "int64_t function_401e04(void) {\n    // 0x401e04\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401e09",
            "funcStartAddr": "401e09",
            "funcEndAddr": "401e0e",
            "decompiledFuncCode": "int64_t function_401e09(void) {\n    // 0x401e09\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_401e10",
            "funcStartAddr": "401e10",
            "funcEndAddr": "4023f2",
            "decompiledFuncCode": "int64_t function_401e10(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    char * exec_argv[1]; // 0x4020f9\n    // 0x401e10\n    function_403060(a2);\n    setlocale(LC_ALL, (char *)&g13);\n    bindtextdomain(\"coreutils\", \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\");\n    textdomain(\"coreutils\");\n    g21 = 125;\n    function_406db0(0x402f00, (int64_t)\"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\", a3);\n    int32_t v1; // 0x401e10\n    int32_t v2; // 0x401e10\n    int32_t result; // 0x401e10\n    int64_t v3; // 0x401e10\n    int64_t set; // bp-176, 0x401e10\n    int32_t act; // bp-184, 0x401e10\n    int64_t oset; // bp-312, 0x401e10\n    int64_t v4; // 0x401fa6\n    int64_t v5; // 0x401fac\n    int64_t * file; // 0x401fb0\n    int64_t v6; // 0x402092\n    int32_t v7; // 0x4020c0\n    int128_t v8; // 0x401e10\n    int32_t * err_num; // 0x4020fe\n    int32_t v9; // 0x402255\n    int32_t v10; // 0x402255\n    uint32_t v11; // 0x402260\n    uint32_t sig_handler; // 0x402269\n    int32_t v12; // 0x402271\n    char * format; // 0x402379\n    int32_t v13; // 0x4022fc\n    int32_t v14; // 0x401f74\n    while (true) {\n        int64_t v15 = function_4062c0(a1 & 0xffffffff, a2, \"+k:s:v\", (char (**)[11])&g2, 0, a6); // 0x401e7a\n        int32_t v16 = v15;\n        switch (v16) {\n            case -1: {\n                // 0x401f74\n                v14 = g29;\n                if ((int32_t)a1 - v14 < 2) {\n                    // 0x401ee9\n                    function_402850(125);\n                    // UNREACHABLE\n                }\n                // 0x401f86\n                g29 = &g30;\n                function_402bf0(*(int64_t *)(8 * (int64_t)v14 + a2));\n                v4 = __asm_movsd(v8);\n                v5 = 8 * (int64_t)g29 + a2;\n                file = (int64_t *)v5;\n                g38 = (int32_t)*file;\n                if (g41 == 0) {\n                    // 0x4022d5\n                    setpgid(0, 0);\n                }\n                // 0x401fc1\n                sigemptyset((struct _TYPEDEF_sigset_t *)&set);\n                act = 0x402680;\n                sigaction(SIGALARM, (struct sigaction *)&act, NULL);\n                sigaction(SIGINT, (struct sigaction *)&act, NULL);\n                sigaction(SIGQUIT, (struct sigaction *)&act, NULL);\n                sigaction(SIGHUP, (struct sigaction *)&act, NULL);\n                sigaction(SIGTERM, (struct sigaction *)&act, NULL);\n                sigaction(g19, (struct sigaction *)&act, NULL);\n                signal(SIGTTIN, SIG_IGN);\n                signal(SIGTTOU, SIG_IGN);\n                sigemptyset((struct _TYPEDEF_sigset_t *)&set);\n                v6 = &act;\n                act = 0x4024e0;\n                sigaction(SIGSTOP, (struct sigaction *)&act, NULL);\n                function_402620(17, v6, 0);\n                v7 = fork();\n                g43 = v7;\n                if (v7 == -1) {\n                    // 0x40230b\n                    error(0, *__errno_location(), dcgettext(NULL, \"fork system call failed\", 5));\n                    // 0x402141\n                    return 125;\n                }\n                if (v7 == 0) {\n                    // 0x4020d8\n                    signal(SIGTTIN, SIG_DFL);\n                    signal(SIGTTOU, SIG_DFL);\n                    exec_argv[0] = (char *)v5;\n                    execvp((char *)*file, exec_argv);\n                    err_num = __errno_location();\n                    function_404c80((int64_t)g38);\n                    error(0, *err_num, dcgettext(NULL, \"failed to run command %s\", 5));\n                    // 0x402141\n                    return *err_num == 2 ? 127 : 126;\n                }\n                // 0x40214f\n                function_402620(14, v6, 0);\n                __asm_movsd_1(v4);\n                function_4024f0(1, v6, 0, (int64_t)&g2);\n                sigemptyset((struct _TYPEDEF_sigset_t *)&act);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGALARM);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGINT);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGQUIT);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGHUP);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGTERM);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, g19);\n                sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGSTOP);\n                if (sigprocmask(SIG_BLOCK, (struct _TYPEDEF_sigset_t *)&act, (struct _TYPEDEF_sigset_t *)&oset) != 0) {\n                    // 0x40220f\n                    error(0, *__errno_location(), dcgettext(NULL, \"warning: sigprocmask\", 5));\n                }\n                // 0x402242\n                v9 = waitpid(g43, &act, WNOHANG);\n                v1 = v9;\n                if (v9 == 0) {\n                    sigsuspend((struct _TYPEDEF_sigset_t *)&oset);\n                    v10 = waitpid(g43, &act, WNOHANG);\n                    v1 = v10;\n                    while (v10 == 0) {\n                        // 0x402238\n                        sigsuspend((struct _TYPEDEF_sigset_t *)&oset);\n                        v10 = waitpid(g43, &act, WNOHANG);\n                        v1 = v10;\n                    }\n                }\n                // 0x40225e\n                if (v1 < 0) {\n                    // 0x4022a1\n                    error(0, *__errno_location(), dcgettext(NULL, \"error waiting for command\", 5));\n                    act = 125;\n                    v2 = 125;\n                } else {\n                    // 0x402260\n                    v11 = act;\n                    sig_handler = v11 % 128;\n                    if (sig_handler != 0) {\n                        if ((char)sig_handler < 1) {\n                            // 0x40233c\n                            error(0, (int32_t)\"unknown status from command (%d)\" ^ (int32_t)\"unknown status from command (%d)\", dcgettext(NULL, \"unknown status from command (%d)\", 5));\n                            act = 1;\n                            v2 = 1;\n                        } else {\n                            // 0x4022ea\n                            v3 = 1;\n                            if ((char)v11 <= -1) {\n                                // 0x40236d\n                                format = dcgettext(NULL, \"the monitored command dumped core\", 5);\n                                error(0, (int32_t)\"the monitored command dumped core\" ^ (int32_t)\"the monitored command dumped core\", format);\n                                v3 = (int64_t)format;\n                            }\n                            // 0x4022ef\n                            if (g44 == 0) {\n                                // 0x402391\n                                if (prctl(PR_SET_DUMPABLE, 0, (int32_t)v3, (int32_t)&g2, 0) != 0) {\n                                    // 0x4023c6\n                                    error(0, *__errno_location(), dcgettext(NULL, \"warning: disabling core dumps failed\", 5));\n                                } else {\n                                    // 0x4023a3\n                                    signal(sig_handler, SIG_DFL);\n                                    function_402620((int64_t)sig_handler, 0, v3);\n                                    raise(sig_handler);\n                                }\n                            }\n                            // 0x4022fc\n                            v13 = sig_handler | 128;\n                            act = v13;\n                            v2 = v13;\n                        }\n                    } else {\n                        // 0x40226e\n                        v12 = v11 / 256 % 256;\n                        act = v12;\n                        v2 = v12;\n                    }\n                }\n                // 0x402278\n                result = v2;\n                if (g44 != 0) {\n                    // 0x402281\n                    result = v2;\n                    if (g40 == 0) {\n                        // 0x40228a\n                        act = 124;\n                        result = 124;\n                    }\n                }\n                // 0x402141\n                return result;\n            }\n            case 115: {\n                // 0x401f30\n                int64_t v17; // bp-344, 0x401e10\n                int32_t v18 = function_402cc0(g58, &v17); // 0x401f41\n                g19 = v18;\n                if (v18 == -1) {\n                    // 0x401ee9\n                    function_402850(125);\n                    // UNREACHABLE\n                }\n                // break -> 0x401e68\n                break;\n            }\n            default: {\n                if (v16 > 115) {\n                    if (v16 == 128) {\n                        // 0x401f58\n                        g41 = 1;\n                    } else {\n                        if (v16 != 129) {\n                            if (v16 != 118) {\n                              lab_0x401ee9:\n                                // 0x401ee9\n                                function_402850(125);\n                                // UNREACHABLE\n                            }\n                            // 0x401f68\n                            g39 = 1;\n                        } else {\n                            // 0x401ea5\n                            g40 = 1;\n                        }\n                    }\n                } else {\n                    if (v16 == -130) {\n                        // 0x4023bf\n                        function_402850(0);\n                        // UNREACHABLE\n                    }\n                    if (v16 != 107) {\n                        if (v16 == -131) {\n                            // 0x401eff\n                            function_405100((int64_t)g33, \"timeout\", \"GNU coreutils\", (int64_t)g20, \"Padraig Brady\", 0);\n                            exit(0);\n                            // UNREACHABLE\n                        }\n                        goto lab_0x401ee9;\n                    }\n                    // 0x401ec0\n                    function_402bf0(g58);\n                    g42 = __asm_movsd(v8);\n                }\n                // break -> 0x401e68\n                break;\n            }\n        }\n    }\n    // 0x401f74\n    v14 = g29;\n    if ((int32_t)a1 - v14 < 2) {\n        // 0x401ee9\n        function_402850(125);\n        // UNREACHABLE\n    }\n    // 0x401f86\n    g29 = &g30;\n    function_402bf0(*(int64_t *)(8 * (int64_t)v14 + a2));\n    v4 = __asm_movsd(v8);\n    v5 = 8 * (int64_t)g29 + a2;\n    file = (int64_t *)v5;\n    g38 = (int32_t)*file;\n    if (g41 == 0) {\n        // 0x4022d5\n        setpgid(0, 0);\n    }\n    // 0x401fc1\n    sigemptyset((struct _TYPEDEF_sigset_t *)&set);\n    act = 0x402680;\n    sigaction(SIGALARM, (struct sigaction *)&act, NULL);\n    sigaction(SIGINT, (struct sigaction *)&act, NULL);\n    sigaction(SIGQUIT, (struct sigaction *)&act, NULL);\n    sigaction(SIGHUP, (struct sigaction *)&act, NULL);\n    sigaction(SIGTERM, (struct sigaction *)&act, NULL);\n    sigaction(g19, (struct sigaction *)&act, NULL);\n    signal(SIGTTIN, SIG_IGN);\n    signal(SIGTTOU, SIG_IGN);\n    sigemptyset((struct _TYPEDEF_sigset_t *)&set);\n    v6 = &act;\n    act = 0x4024e0;\n    sigaction(SIGSTOP, (struct sigaction *)&act, NULL);\n    function_402620(17, v6, 0);\n    v7 = fork();\n    g43 = v7;\n    if (v7 == -1) {\n        // 0x40230b\n        error(0, *__errno_location(), dcgettext(NULL, \"fork system call failed\", 5));\n        // 0x402141\n        return 125;\n    }\n    if (v7 == 0) {\n        // 0x4020d8\n        signal(SIGTTIN, SIG_DFL);\n        signal(SIGTTOU, SIG_DFL);\n        exec_argv[0] = (char *)v5;\n        execvp((char *)*file, exec_argv);\n        err_num = __errno_location();\n        function_404c80((int64_t)g38);\n        error(0, *err_num, dcgettext(NULL, \"failed to run command %s\", 5));\n        // 0x402141\n        return *err_num == 2 ? 127 : 126;\n    }\n    // 0x40214f\n    function_402620(14, v6, 0);\n    __asm_movsd_1(v4);\n    function_4024f0(1, v6, 0, (int64_t)&g2);\n    sigemptyset((struct _TYPEDEF_sigset_t *)&act);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGALARM);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGINT);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGQUIT);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGHUP);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGTERM);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, g19);\n    sigaddset((struct _TYPEDEF_sigset_t *)&act, SIGSTOP);\n    if (sigprocmask(SIG_BLOCK, (struct _TYPEDEF_sigset_t *)&act, (struct _TYPEDEF_sigset_t *)&oset) != 0) {\n        // 0x40220f\n        error(0, *__errno_location(), dcgettext(NULL, \"warning: sigprocmask\", 5));\n    }\n    // 0x402242\n    v9 = waitpid(g43, &act, WNOHANG);\n    v1 = v9;\n    if (v9 == 0) {\n        sigsuspend((struct _TYPEDEF_sigset_t *)&oset);\n        v10 = waitpid(g43, &act, WNOHANG);\n        v1 = v10;\n        while (v10 == 0) {\n            // 0x402238\n            sigsuspend((struct _TYPEDEF_sigset_t *)&oset);\n            v10 = waitpid(g43, &act, WNOHANG);\n            v1 = v10;\n        }\n    }\n    // 0x40225e\n    if (v1 < 0) {\n        // 0x4022a1\n        error(0, *__errno_location(), dcgettext(NULL, \"error waiting for command\", 5));\n        act = 125;\n        v2 = 125;\n    } else {\n        // 0x402260\n        v11 = act;\n        sig_handler = v11 % 128;\n        if (sig_handler != 0) {\n            if ((char)sig_handler < 1) {\n                // 0x40233c\n                error(0, (int32_t)\"unknown status from command (%d)\" ^ (int32_t)\"unknown status from command (%d)\", dcgettext(NULL, \"unknown status from command (%d)\", 5));\n                act = 1;\n                v2 = 1;\n            } else {\n                // 0x4022ea\n                v3 = 1;\n                if ((char)v11 <= -1) {\n                    // 0x40236d\n                    format = dcgettext(NULL, \"the monitored command dumped core\", 5);\n                    error(0, (int32_t)\"the monitored command dumped core\" ^ (int32_t)\"the monitored command dumped core\", format);\n                    v3 = (int64_t)format;\n                }\n                // 0x4022ef\n                if (g44 == 0) {\n                    // 0x402391\n                    if (prctl(PR_SET_DUMPABLE, 0, (int32_t)v3, (int32_t)&g2, 0) != 0) {\n                        // 0x4023c6\n                        error(0, *__errno_location(), dcgettext(NULL, \"warning: disabling core dumps failed\", 5));\n                    } else {\n                        // 0x4023a3\n                        signal(sig_handler, SIG_DFL);\n                        function_402620((int64_t)sig_handler, 0, v3);\n                        raise(sig_handler);\n                    }\n                }\n                // 0x4022fc\n                v13 = sig_handler | 128;\n                act = v13;\n                v2 = v13;\n            }\n        } else {\n            // 0x40226e\n            v12 = v11 / 256 % 256;\n            act = v12;\n            v2 = v12;\n        }\n    }\n    // 0x402278\n    result = v2;\n    if (g44 != 0) {\n        // 0x402281\n        result = v2;\n        if (g40 == 0) {\n            // 0x40228a\n            act = 124;\n            result = 124;\n        }\n    }\n    // 0x402141\n    return result;\n}\n"
        },
        {
            "funcName": "entry_point",
            "funcStartAddr": "402400",
            "funcEndAddr": "40242b",
            "decompiledFuncCode": "int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {\n    // 0x402400\n    int64_t v1; // 0x402400\n    __libc_start_main(0x401e10, (int32_t)a4, (char **)&v1, (void (*)())0x406d40, (void (*)())0x406da0, (void (*)())a3);\n    __asm_hlt();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_40242b",
            "funcStartAddr": "40242b",
            "funcEndAddr": "40244a",
            "decompiledFuncCode": "int64_t function_40242b(void) {\n    // 0x40242b\n    return 0x60b4c8;\n}\n"
        },
        {
            "funcName": "function_40244a",
            "funcStartAddr": "40244a",
            "funcEndAddr": "402481",
            "decompiledFuncCode": "int64_t function_40244a(void) {\n    // 0x40244a\n    return 0;\n}\n"
        },
        {
            "funcName": "function_402481",
            "funcStartAddr": "402481",
            "funcEndAddr": "4024d8",
            "decompiledFuncCode": "int64_t function_402481(void) {\n    // 0x402481\n    if (g36 != 0) {\n        // 0x4024d7\n        int64_t result; // 0x402481\n        return result;\n    }\n    int64_t v1 = g37; // 0x4024b4\n    int64_t result2; // 0x4024c6\n    if (g37 >= ((int64_t)&g16 - (int64_t)&g15 >> 3) - 1) {\n        // 0x4024c6\n        result2 = function_40242b();\n        g36 = 1;\n        return result2;\n    }\n    v1++;\n    while (v1 < ((int64_t)&g16 - (int64_t)&g15 >> 3) - 1) {\n        // 0x4024b6\n        v1++;\n    }\n    // 0x4024aa\n    g37 = v1;\n    // 0x4024c6\n    result2 = function_40242b();\n    g36 = 1;\n    return result2;\n}\n"
        },
        {
            "funcName": "function_4024d8",
            "funcStartAddr": "4024d8",
            "funcEndAddr": "4024dd",
            "decompiledFuncCode": "int64_t function_4024d8(void) {\n    // 0x4024d8\n    return function_40244a();\n}\n"
        },
        {
            "funcName": "function_4024e0",
            "funcStartAddr": "4024e0",
            "funcEndAddr": "4024e1",
            "decompiledFuncCode": "int64_t function_4024e0(void) {\n    // 0x4024e0\n    int64_t result; // 0x4024e0\n    return result;\n}\n"
        },
        {
            "funcName": "function_4024f0",
            "funcStartAddr": "4024f0",
            "funcEndAddr": "402611",
            "decompiledFuncCode": "int64_t function_4024f0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {\n    // 0x4024f0\n    int128_t v1; // 0x4024f0\n    int128_t v2 = v1;\n    int64_t v3 = __asm_movsd(v2); // 0x4024f7\n    function_402fa0(a1, a2, a3, a4);\n    int64_t value = 0; // bp-40, 0x402506\n    bool v4; // 0x4024f0\n    int64_t timerid; // bp-48, 0x4024f0\n    if (timer_create(0, NULL, (int64_t **)&timerid) == 0) {\n        // 0x402590\n        if (timer_settime((int64_t *)timerid, 0, (struct itimerspec *)&value, NULL) == 0) {\n            // 0x402562\n            return 0;\n        }\n        if ((char)a1 != 0) {\n            // 0x4025e8\n            error(0, *__errno_location(), dcgettext(NULL, \"warning: timer_settime\", 5));\n        }\n        // 0x4025ab\n        timer_delete((int64_t *)timerid);\n        v4 = false;\n    } else {\n        // 0x402530\n        v4 = false;\n        if ((char)a1 != 0) {\n            int32_t * err_num = __errno_location(); // 0x402534\n            uint32_t v5 = *err_num; // 0x402539\n            v4 = v5 < 38;\n            if (v5 != 38) {\n                // 0x4025c0\n                error(0, *err_num, dcgettext(NULL, \"warning: timer_create\", 5));\n                v4 = false;\n            }\n        }\n    }\n    int128_t v6 = __asm_movsd_1(v3); // 0x402548\n    __asm_comisd(v6, g3);\n    int32_t seconds = -1; // 0x40255b\n    if (v4) {\n        int64_t v7 = __asm_cvttsd2si(v6); // 0x402570\n        __asm_pxor(v2, v2);\n        __asm_comisd(v6, __asm_cvtsi2sd(v7 & 0xffffffff));\n        seconds = v7;\n    }\n    // 0x402562\n    return alarm(seconds);\n}\n"
        },
        {
            "funcName": "function_402620",
            "funcStartAddr": "402620",
            "funcEndAddr": "40267b",
            "decompiledFuncCode": "int64_t function_402620(int64_t sig_num, int64_t a2, int64_t a3) {\n    // 0x402620\n    int64_t set; // bp-136, 0x402620\n    sigemptyset((struct _TYPEDEF_sigset_t *)&set);\n    sigaddset((struct _TYPEDEF_sigset_t *)&set, (int32_t)sig_num);\n    int32_t v1 = sigprocmask(SIG_UNBLOCK, (struct _TYPEDEF_sigset_t *)&set, NULL); // 0x402643\n    int64_t result = v1; // 0x40264a\n    if (v1 != 0) {\n        // 0x402652\n        error(0, *__errno_location(), dcgettext(NULL, \"warning: sigprocmask\", 5));\n        result = &g60;\n    }\n    // 0x40264c\n    return result;\n}\n"
        },
        {
            "funcName": "function_402680",
            "funcStartAddr": "402680",
            "funcEndAddr": "40284c",
            "decompiledFuncCode": "int64_t function_402680(int64_t a1) {\n    int64_t v1 = a1 & 0xffffffff; // 0x40268d\n    if ((int32_t)a1 == 14) {\n        // 0x40268f\n        g44 = 1;\n        v1 = g19;\n    }\n    // 0x40269f\n    if (g43 == 0) {\n        // 0x402841\n        _exit((int32_t)v1 + 128);\n        // UNREACHABLE\n    }\n    int128_t v2 = __asm_movsd_1(g42); // 0x4026ad\n    __asm_ucomisd(v2, (int64_t)g4);\n    int64_t v3 = __asm_movsd(v2); // 0x4026f0\n    int32_t * v4 = __errno_location(); // 0x4026f6\n    __asm_movsd_1(v3);\n    g19 = 9;\n    int64_t v5; // 0x402680\n    function_4024f0(0, v5, v5, v5);\n    g42 = 0;\n    if (g39 != 0) {\n        // 0x402730\n        int64_t v6; // bp-56, 0x402680\n        if ((int32_t)function_406520(v1, &v6, v5) != 0) {\n            // 0x402800\n            __snprintf_chk((char *)&v6, 19, 1, 19, \"%d\", v1);\n        }\n        // 0x402744\n        function_404c80((int64_t)g38);\n        error(0, (int32_t)\"sending signal %s to command %s\" ^ (int32_t)\"sending signal %s to command %s\", dcgettext(NULL, \"sending signal %s to command %s\", 5));\n    }\n    int32_t sig_handler = v1;\n    if (g43 == 0) {\n        // 0x402788\n        signal(sig_handler, SIG_IGN);\n    }\n    int64_t result = kill(g43, sig_handler); // 0x4026da\n    if (g41 != 0) {\n        // 0x4026e0\n        return result;\n    }\n    // 0x4027a0\n    signal(sig_handler, SIG_IGN);\n    int64_t result2 = kill(0, sig_handler); // 0x4027b0\n    switch (sig_handler) {\n        case 9: {\n        }\n        case 18: {\n            // 0x4026e0\n            return result2;\n        }\n    }\n    if (g43 == 0) {\n        // 0x402830\n        signal(SIGTSTP, SIG_IGN);\n    }\n    // 0x4027cb\n    kill(g43, SIGTSTP);\n    signal(SIGTSTP, SIG_IGN);\n    return kill(0, SIGTSTP);\n}\n"
        },
        {
            "funcName": "function_402850",
            "funcStartAddr": "402850",
            "funcEndAddr": "402bed",
            "decompiledFuncCode": "int64_t function_402850(int64_t a1) {\n    int32_t status = a1; // 0x402866\n    if (status != 0) {\n        // 0x40286a\n        __fprintf_chk(g35, 1, dcgettext(NULL, \"Try '%s --help' for more information.\\n\", 5));\n        // 0x40288f\n        exit(status);\n        // UNREACHABLE\n    }\n    // 0x402896\n    __printf_chk(1, dcgettext(NULL, \"Usage: %s [OPTION] DURATION COMMAND [ARG]...\\n  or:  %s [OPTION]\\n\", 5));\n    fputs_unlocked(dcgettext(NULL, \"Start COMMAND, and kill it if still running after DURATION.\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"\\nMandatory arguments to long options are mandatory for short options too.\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"      --preserve-status\\n                 exit with the same status as COMMAND, even when the\\n                   command times out\\n      --foreground\\n                 when not running timeout directly from a shell prompt,\\n                   allow COMMAND to read from the TTY and get TTY signals;\\n                   in this mode, children of COMMAND will not be timed out\\n  -k, --kill-after=DURATION\\n                 also send a KILL signal if COMMAND is still running\\n                   this long after the initial signal was sent\\n  -s, --signal=SIGNAL\\n                 specify the signal to be sent on timeout;\\n                   SIGNAL may be a name like 'HUP' or a number;\\n                   see 'kill -l' for a list of signals\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"  -v, --verbose  diagnose to stderr any signal sent upon timeout\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"      --help     display this help and exit\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"      --version  output version information and exit\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"\\nDURATION is a floating point number with an optional suffix:\\n's' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.\\n\", 5), g33);\n    fputs_unlocked(dcgettext(NULL, \"\\nIf the command times out, and --preserve-status is not set, then exit with\\nstatus 124.  Otherwise, exit with the status of COMMAND.  If no signal\\nis specified, send the TERM signal upon timeout.  The TERM signal kills\\nany process that does not block or catch that signal.  It may be necessary\\nto use the KILL (9) signal, since this signal cannot be caught, in which\\ncase the exit status is 128+9 rather than 124.\\n\", 5), g33);\n    int64_t v1 = &g1; // bp-136, 0x4029cf\n    bool v2; // 0x402850\n    int64_t v3 = v2 ? -1 : 1;\n    int64_t v4 = &v1;\n    int64_t v5 = v4 + 16; // 0x402a50\n    int64_t v6 = *(int64_t *)v5; // 0x402a54\n    int64_t v7 = 8; // 0x402a5a\n    while (v6 != 0) {\n        int64_t v8 = (int64_t)\"timeout\";\n        int64_t v9 = v6;\n        unsigned char v10 = *(char *)v8; // 0x402a66\n        char v11 = *(char *)v9; // 0x402a66\n        char v12 = v11; // 0x402a66\n        bool v13 = false; // 0x402a66\n        while (v10 == v11) {\n            // 0x402a5c\n            v7--;\n            int64_t v14 = v9 + v3; // 0x402a66\n            int64_t v15 = v8 + v3; // 0x402a66\n            v12 = v10;\n            v13 = true;\n            if (v7 == 0) {\n                // break -> \n                break;\n            }\n            v8 = v15;\n            v9 = v14;\n            v10 = *(char *)v8;\n            v11 = *(char *)v9;\n            v12 = v11;\n            v13 = false;\n        }\n        unsigned char v16 = v12;\n        if ((v10 >= v16 && !v13) == v10 < v16) {\n            // break -> 0x402a72\n            break;\n        }\n        v4 = v5;\n        v5 = v4 + 16;\n        v6 = *(int64_t *)v5;\n        v7 = 8;\n    }\n    // 0x402a72\n    __printf_chk(1, dcgettext(NULL, \"\\n%s online help: <%s>\\n\", 5));\n    char * locale = setlocale(LC_MESSAGES, NULL);\n    if (*(int64_t *)(v4 + 24) == 0) {\n        if (locale == NULL) {\n            goto lab_0x402b84;\n        } else {\n            // 0x402b6e\n            if (strncmp(locale, \"en_\", 3) != 0) {\n                // 0x402bc3\n                __printf_chk(1, dcgettext(NULL, \"Report %s translation bugs to <https://translationproject.org/team/>\\n\", 5));\n                goto lab_0x402ad4;\n            } else {\n                goto lab_0x402b84;\n            }\n        }\n    } else {\n        if (locale == NULL) {\n            goto lab_0x402ad4;\n        } else {\n            // 0x402aba\n            if (strncmp(locale, \"en_\", 3) != 0) {\n                // 0x402bc3\n                __printf_chk(1, dcgettext(NULL, \"Report %s translation bugs to <https://translationproject.org/team/>\\n\", 5));\n                goto lab_0x402ad4;\n            } else {\n                goto lab_0x402ad4;\n            }\n        }\n    }\n  lab_0x402b84:\n    // 0x402b84\n    __printf_chk(1, dcgettext(NULL, \"Full documentation at: <%s%s>\\n\", 5));\n    // 0x402b14\n    __printf_chk(1, dcgettext(NULL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5));\n    // 0x40288f\n    exit(status);\n    // UNREACHABLE\n  lab_0x402ad4:\n    // 0x402ad4\n    __printf_chk(1, dcgettext(NULL, \"Full documentation at: <%s%s>\\n\", 5));\n    // 0x402b14\n    __printf_chk(1, dcgettext(NULL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5));\n    // 0x40288f\n    exit(status);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_402bf0",
            "funcStartAddr": "402bf0",
            "funcEndAddr": "402cbe",
            "decompiledFuncCode": "int64_t function_402bf0(int64_t a1) {\n    // 0x402bf0\n    char * v1; // bp-16, 0x402bf0\n    int64_t v2; // bp-24, 0x402bf0\n    int64_t v3 = function_4054d0(a1, (int64_t *)&v1, &v2, 0x402e70); // 0x402c05\n    bool v4 = false; // 0x402c0c\n    char * format; // 0x402c73\n    if ((char)v3 == 0) {\n        uint32_t v5 = *__errno_location(); // 0x402c13\n        v4 = v5 < 34;\n        if (v5 != 34) {\n            // 0x402c5c\n            function_404c80(a1);\n            format = dcgettext(NULL, \"invalid time interval %s\", 5);\n            error(0, (int32_t)\"invalid time interval %s\" ^ (int32_t)\"invalid time interval %s\", format);\n            function_402850(125);\n            // UNREACHABLE\n        }\n    }\n    int128_t v6 = __asm_movsd_1(v2); // 0x402c18\n    __asm_comisd(v6, g4);\n    if (v4) {\n        // 0x402c5c\n        function_404c80(a1);\n        format = dcgettext(NULL, \"invalid time interval %s\", 5);\n        error(0, (int32_t)\"invalid time interval %s\" ^ (int32_t)\"invalid time interval %s\", format);\n        function_402850(125);\n        // UNREACHABLE\n    }\n    unsigned char v7 = *v1; // 0x402c2c\n    int64_t result = v7; // 0x402c2c\n    if (v7 == 0) {\n        // 0x402c4b\n        return result;\n    }\n    // 0x402c33\n    if (*(char *)((int64_t)v1 + 1) != 0) {\n        // 0x402c5c\n        function_404c80(a1);\n        format = dcgettext(NULL, \"invalid time interval %s\", 5);\n        error(0, (int32_t)\"invalid time interval %s\" ^ (int32_t)\"invalid time interval %s\", format);\n        function_402850(125);\n        // UNREACHABLE\n    }\n    if (v7 == 104) {\n        // 0x402cb0\n        __asm_mulsd(v6, 0x40ac200000000000);\n        return 104;\n    }\n    if (v7 <= 104) {\n        if (v7 == 100) {\n            // 0x402c43\n            __asm_mulsd(v6, 0x40f5180000000000);\n            // 0x402c4b\n            return result;\n        }\n        // 0x402c5c\n        function_404c80(a1);\n        format = dcgettext(NULL, \"invalid time interval %s\", 5);\n        error(0, (int32_t)\"invalid time interval %s\" ^ (int32_t)\"invalid time interval %s\", format);\n        function_402850(125);\n        // UNREACHABLE\n    }\n    if (v7 == 109) {\n        // 0x402c9c\n        __asm_mulsd(v6, 0x404e000000000000);\n        return result;\n    }\n    if (v7 == 115) {\n        // 0x402c4b\n        return result;\n    }\n    // 0x402c5c\n    function_404c80(a1);\n    format = dcgettext(NULL, \"invalid time interval %s\", 5);\n    error(0, (int32_t)\"invalid time interval %s\" ^ (int32_t)\"invalid time interval %s\", format);\n    function_402850(125);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_402cc0",
            "funcStartAddr": "402cc0",
            "funcEndAddr": "402e64",
            "decompiledFuncCode": "int64_t function_402cc0(int64_t str, int64_t * a2) {\n    char v1 = str;\n    int64_t v2; // 0x402cc0\n    int64_t v3; // 0x402cc0\n    int32_t result; // bp-52, 0x402cc0\n    int64_t v4; // 0x402d68\n    if (v1 == 57 || (int32_t)v1 < 57) {\n        int32_t * v5 = __errno_location(); // 0x402ce1\n        *v5 = 0;\n        char * endptr; // bp-48, 0x402cc0\n        int32_t str_as_l = strtol((char *)str, &endptr, 10); // 0x402cfc\n        if ((int64_t)endptr == str) {\n            // 0x402d28\n            result = -1;\n            goto lab_0x402d30;\n        } else {\n            // 0x402d0b\n            if (*endptr != 0) {\n                // 0x402d28\n                result = -1;\n                goto lab_0x402d30;\n            } else {\n                // 0x402d10\n                if (*v5 != 0) {\n                    // 0x402d28\n                    result = -1;\n                    goto lab_0x402d30;\n                } else {\n                    if (str_as_l == -1) {\n                        // 0x402e5b\n                        result = -1;\n                        goto lab_0x402d30;\n                    } else {\n                        int64_t v6 = str_as_l; // 0x402cfc\n                        int32_t v7 = str_as_l - 254; // 0x402e3d\n                        int64_t v8 = (v7 < 0 == (253 - str_as_l & str_as_l) < 0 == (v7 != 0) ? 255 : 127) & v6; // 0x402e50\n                        result = v8;\n                        v3 = v6;\n                        v2 = v8;\n                        goto lab_0x402dc9;\n                    }\n                }\n            }\n        }\n    } else {\n        // 0x402d68\n        v4 = function_405470(str);\n        char * v9 = (char *)v4; // 0x402d6d\n        char c = *v9; // 0x402d6d\n        if (c != 0) {\n            if (strchr(\"abcdefghijklmnopqrstuvwxyz\", (int32_t)c) != NULL) {\n                // 0x402d92\n                *(char *)v4 = c - 32;\n            }\n            int64_t v10 = v4 + 1; // 0x402d98\n            char v11 = *(char *)v10; // 0x402d9c\n            while (v11 != 0) {\n                int64_t v12 = v10;\n                char c2 = v11;\n                if (strchr(\"abcdefghijklmnopqrstuvwxyz\", (int32_t)c2) != NULL) {\n                    // 0x402d92\n                    *(char *)v12 = c2 - 32;\n                }\n                // 0x402d98\n                v10 = v12 + 1;\n                v11 = *(char *)v10;\n            }\n        }\n        // 0x402da4\n        if ((int32_t)function_4063c0(v4, &result) != 0) {\n            // 0x402df0\n            if (*v9 == 83) {\n                // 0x402e10\n                if (*(char *)(v4 + 1) != 73) {\n                    // 0x402df7\n                    result = -1;\n                    free((int64_t *)v4);\n                    goto lab_0x402d30;\n                } else {\n                    // 0x402e17\n                    if (*(char *)(v4 + 2) != 71) {\n                        // 0x402df7\n                        result = -1;\n                        free((int64_t *)v4);\n                        goto lab_0x402d30;\n                    } else {\n                        // 0x402e1e\n                        if ((int32_t)function_4063c0(v4 + 3, &result) != 0) {\n                            // 0x402df7\n                            result = -1;\n                            free((int64_t *)v4);\n                            goto lab_0x402d30;\n                        } else {\n                            goto lab_0x402db5;\n                        }\n                    }\n                }\n            } else {\n                // 0x402df7\n                result = -1;\n                free((int64_t *)v4);\n                goto lab_0x402d30;\n            }\n        } else {\n            goto lab_0x402db5;\n        }\n    }\n  lab_0x402db5:\n    // 0x402db5\n    free((int64_t *)v4);\n    v2 = result;\n    if (result < 0) {\n        goto lab_0x402d30;\n    } else {\n        goto lab_0x402dc9;\n    }\n  lab_0x402d30:\n    // 0x402d30\n    function_404c80(str);\n    error(0, (int32_t)\"%s: invalid signal\" ^ (int32_t)\"%s: invalid signal\", dcgettext(NULL, \"%s: invalid signal\", 5));\n    // 0x402ddf\n    return 0xffffffff;\n  lab_0x402dc9:\n    // 0x402dc9\n    if ((int32_t)function_406520(v2 & 0xffffffff, a2, v3) == 0) {\n        // 0x402ddf\n        return result;\n    }\n    goto lab_0x402d30;\n}\n"
        },
        {
            "funcName": "function_402e70",
            "funcStartAddr": "402e70",
            "funcEndAddr": "402eda",
            "decompiledFuncCode": "int64_t function_402e70(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x402e70\n    int128_t v1; // 0x402e70\n    int128_t v2 = v1;\n    struct __locale_struct * v3 = g45;\n    if (v3 != NULL) {\n        // 0x402e94\n        return strtod_l((char *)a1, (char **)a2, v3);\n    }\n    struct __locale_struct * v4 = newlocale(0x1fbf, \"C\", NULL); // 0x402ecc\n    g45 = v4;\n    if (v4 != NULL) {\n        // 0x402e94\n        return strtod_l((char *)a1, (char **)a2, v4);\n    }\n    if (a2 != 0) {\n        // 0x402ead\n        *(int64_t *)a2 = a1;\n    }\n    // 0x402eb0\n    __asm_pxor(v2, v2);\n    return (int64_t)v4;\n}\n"
        },
        {
            "funcName": "function_402ee0",
            "funcStartAddr": "402ee0",
            "funcEndAddr": "402ee8",
            "decompiledFuncCode": "int64_t function_402ee0(int64_t a1) {\n    // 0x402ee0\n    g47 = a1;\n    int64_t result; // 0x402ee0\n    return result;\n}\n"
        },
        {
            "funcName": "function_402ef0",
            "funcStartAddr": "402ef0",
            "funcEndAddr": "402ef8",
            "decompiledFuncCode": "int64_t function_402ef0(int64_t a1) {\n    // 0x402ef0\n    g46 = a1;\n    int64_t result; // 0x402ef0\n    return result;\n}\n"
        },
        {
            "funcName": "function_402f00",
            "funcStartAddr": "402f00",
            "funcEndAddr": "402f9e",
            "decompiledFuncCode": "int64_t function_402f00(void) {\n    // 0x402f00\n    int32_t * err_num; // 0x402f16\n    if ((int32_t)function_4065f0((int64_t)g33) == 0) {\n        goto lab_0x402f2c;\n    } else {\n        // 0x402f16\n        err_num = __errno_location();\n        if (g46 == 0) {\n            goto lab_0x402f43;\n        } else {\n            // 0x402f27\n            if (*err_num != 32) {\n                goto lab_0x402f43;\n            } else {\n                goto lab_0x402f2c;\n            }\n        }\n    }\n  lab_0x402f2c:;\n    int64_t result = function_4065f0((int64_t)g35); // 0x402f33\n    if ((int32_t)result == 0) {\n        // 0x402f3c\n        return result;\n    }\n    // 0x402f7e\n    _exit(g21);\n    // UNREACHABLE\n  lab_0x402f43:;\n    char * v1 = dcgettext(NULL, \"write error\", 5); // 0x402f4f\n    if (g47 == 0) {\n        // 0x402f89\n        error(0, *err_num, \"%s\", v1);\n    } else {\n        // 0x402f63\n        error(0, *err_num, \"%s: %s\", (char *)function_404ad0((int64_t)g47), v1);\n    }\n    // 0x402f7e\n    _exit(g21);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_402fa0",
            "funcStartAddr": "402fa0",
            "funcEndAddr": "40305c",
            "decompiledFuncCode": "int64_t function_402fa0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {\n    // 0x402fa0\n    int128_t v1; // 0x402fa0\n    __asm_comisd(v1, g5);\n    bool v2; // 0x402fa0\n    if (v2 || v2) {\n        // 0x402fbc\n        return -0x8000000000000000;\n    }\n    int128_t v3 = __asm_movsd_1(0x43e0000000000000); // 0x402fae\n    __asm_comisd(v3, v1);\n    int64_t v4 = __asm_cvttsd2si(v1); // 0x402fd0\n    __asm_pxor(v3, v3);\n    int128_t v5 = __asm_cvtsi2sd(v4); // 0x402fdb\n    int128_t v6 = __asm_mulsd(__asm_subsd(v1, v5), 0x41cdcd6500000000); // 0x402fe4\n    __asm_pxor(v5, v5);\n    int64_t v7 = __asm_cvttsd2si(v6); // 0x402ff0\n    __asm_comisd(v6, __asm_cvtsi2sd(v7));\n    int64_t result = (v7 >> 63) + v4; // 0x403022\n    if ((v7 >> 63 & -0x3b9aca00) + v7 < 0) {\n        // 0x403050\n        return result - 1;\n    }\n    // 0x402fbc\n    return result;\n}\n"
        },
        {
            "funcName": "function_403060",
            "funcStartAddr": "403060",
            "funcEndAddr": "4030f9",
            "decompiledFuncCode": "int64_t function_403060(int64_t str) {\n    // 0x403060\n    if (str == 0) {\n        // 0x4030d9\n        fwrite((int64_t *)\"A NULL argv[0] was passed through an exec system call.\\n\", 1, 55, g35);\n        abort();\n        // UNREACHABLE\n    }\n    char * found_char_pos = strrchr((char *)str, 47); // 0x40306e\n    int64_t result = (int64_t)found_char_pos; // 0x40306e\n    if (found_char_pos == NULL) {\n        // 0x4030c9\n        g48 = str;\n        g34 = str;\n        return result;\n    }\n    int64_t v1 = result + 1; // 0x403078\n    if (v1 - str < 7) {\n        // 0x4030c9\n        g48 = str;\n        g34 = str;\n        return result;\n    }\n    // 0x403088\n    bool v2; // 0x403060\n    int64_t v3 = v2 ? -1 : 1;\n    int64_t v4 = (int64_t)\"/.libs/\"; // 0x403060\n    int64_t v5 = result - 6; // 0x403060\n    int64_t v6 = 7; // 0x403096\n    unsigned char v7 = *(char *)v5; // 0x403096\n    char v8 = *(char *)v4; // 0x403096\n    char v9 = v8; // 0x403096\n    bool v10 = false; // 0x403096\n    while (v7 == v8) {\n        v6--;\n        v4 += v3;\n        v5 += v3;\n        v9 = v7;\n        v10 = true;\n        if (v6 == 0) {\n            // break -> \n            break;\n        }\n        v7 = *(char *)v5;\n        v8 = *(char *)v4;\n        v9 = v8;\n        v10 = false;\n    }\n    unsigned char v11 = v9;\n    int64_t v12 = (int64_t)\"lt-\"; // 0x4030a0\n    int64_t v13 = v1; // 0x4030a0\n    int64_t v14 = 3; // 0x4030a0\n    if ((v7 >= v11 && !v10) != v7 < v11) {\n        // 0x4030c9\n        g48 = str;\n        g34 = str;\n        return result;\n    }\n    unsigned char v15 = *(char *)v13; // 0x4030b2\n    char v16 = *(char *)v12; // 0x4030b2\n    char v17 = v16; // 0x4030b2\n    bool v18 = false; // 0x4030b2\n    while (v15 == v16) {\n        // 0x4030a2\n        v14--;\n        v12 += v3;\n        v13 += v3;\n        v17 = v15;\n        v18 = true;\n        if (v14 == 0) {\n            // break -> \n            break;\n        }\n        v15 = *(char *)v13;\n        v16 = *(char *)v12;\n        v17 = v16;\n        v18 = false;\n    }\n    unsigned char v19 = v17;\n    int64_t v20 = v1; // 0x4030bc\n    if ((v15 >= v19 && !v18) == v15 < v19) {\n        // 0x4030be\n        v20 = result + 4;\n        g32 = v20;\n    }\n    // 0x4030c9\n    g48 = v20;\n    g34 = v20;\n    return result;\n}\n"
        },
        {
            "funcName": "function_403100",
            "funcStartAddr": "403100",
            "funcEndAddr": "4031f2",
            "decompiledFuncCode": "int64_t function_403100(int64_t a1, int64_t a2) {\n    char * v1 = dcgettext(NULL, (char *)a1, 5); // 0x403114\n    int64_t result = (int64_t)v1; // 0x403114\n    if (result != a1) {\n        // 0x403121\n        return result;\n    }\n    int64_t v2 = function_4066b0(); // 0x403130\n    char v3 = *(char *)v2 & -33;\n    int64_t result2; // 0x4031e6\n    if (v3 == 85) {\n        // 0x403140\n        if ((*(char *)(v2 + 1) & -33) != 84 || (*(char *)(v2 + 2) & -33) != 70 || *(char *)(v2 + 3) != 45 || *(char *)(v2 + 4) != 56 || *(char *)(v2 + 5) != 0) {\n            // 0x4031d8\n            result2 = (int32_t)a2 != 9 ? (int64_t)&g11 : (int64_t)&g6;\n            return result2;\n        }\n        char v4 = *v1; // 0x40316e\n        int64_t result3 = v4 != 96 ? (int64_t)&g7 : (int64_t)&g10; // 0x40317b\n        // 0x403121\n        return result3;\n    }\n    if (v3 != 71 || (*(char *)(v2 + 1) & -33) != 66 || *(char *)(v2 + 2) != 49 || *(char *)(v2 + 3) != 56 || *(char *)(v2 + 4) != 48 || *(char *)(v2 + 5) != 51 || *(char *)(v2 + 6) != 48 || *(char *)(v2 + 7) != 0) {\n        // 0x4031d8\n        result2 = (int32_t)a2 != 9 ? (int64_t)&g11 : (int64_t)&g6;\n        return result2;\n    }\n    char v5 = *v1; // 0x4031bd\n    int64_t result4 = v5 != 96 ? (int64_t)&g8 : (int64_t)&g9; // 0x4031ca\n    // 0x403121\n    return result4;\n}\n"
        },
        {
            "funcName": "function_403200",
            "funcStartAddr": "403200",
            "funcEndAddr": "403257",
            "decompiledFuncCode": "int64_t function_403200(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int32_t a6) {\n    // 0x403200\n    __ctype_get_mb_cur_max();\n    if ((uint32_t)(int32_t)a5 < 11) {\n        // 0x403248\n        return a5 & 0xffffffff;\n    }\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_403257",
            "funcStartAddr": "403257",
            "funcEndAddr": "404421",
            "decompiledFuncCode": "int64_t function_403257(int64_t a1, int64_t a2, int64_t a3, int64_t str) {\n    int64_t v1 = str + 1;\n    int64_t v2 = 0; // 0x4032a1\n    int64_t v3 = 0; // 0x4032a1\n    int64_t v4; // 0x403257\n    int64_t v5; // 0x403257\n    int64_t v6; // 0x403257\n    int64_t v7; // 0x403257\n    int64_t v8; // 0x403257\n    int64_t v9; // 0x403257\n    int64_t v10; // 0x403257\n    int64_t v11; // 0x403257\n    int64_t v12; // 0x403257\n    int64_t v13; // 0x403257\n    int64_t v14; // 0x403257\n    int64_t v15; // 0x403257\n    int64_t v16; // 0x403257\n    int64_t v17; // 0x403257\n    int64_t v18; // 0x403257\n    int64_t result; // 0x403257\n    int64_t v19; // 0x403257\n    int32_t wc; // bp+132, 0x403257\n    int64_t ps; // bp+136, 0x403257\n    char v20; // 0x403810\n    int64_t v21; // 0x403810\n    int64_t v22; // 0x403bb8\n    int64_t v23; // 0x403257\n    int64_t v24; // 0x403bd7\n    int32_t v25; // 0x403257\n    while (true) {\n      lab_0x4032a8_2:\n        // 0x4032a8\n        v12 = v11;\n        v8 = v7;\n        v15 = v14;\n        result = v2;\n        int64_t v26 = v3; // 0x403257\n        int64_t v27; // 0x4032dc\n        while (true) {\n          lab_0x4032a8:\n            // 0x4032a8\n            v5 = v26;\n            bool v28 = v15 == v5; // 0x4032b3\n            if (v15 == -1) {\n                // 0x4032b5\n                v28 = *(char *)(v5 + str) == 0;\n            }\n            // 0x4032c3\n            if (v28) {\n                // break (via goto) -> 0x403a28\n                goto lab_0x403a28;\n            }\n            // 0x4032cc\n            v27 = v5 + str;\n            v20 = *(char *)v27;\n            v21 = v20;\n            g59 = v21;\n            v16 = v15;\n            v9 = v8;\n            v13 = v12;\n            v4 = v15;\n            v6 = v8;\n            v10 = v12;\n            switch (v20) {\n                case 0: {\n                    // 0x4038bb\n                    if (v25 % 2 == 0) {\n                        goto lab_0x403401;\n                    }\n                    // 0x403cdd\n                    v26 = v5 + 1;\n                    goto lab_0x4032a8;\n                }\n                case 7: {\n                    goto lab_0x403401;\n                }\n                case 8: {\n                    goto lab_0x403401;\n                }\n                case 9: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 10: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 11: {\n                    goto lab_0x403401;\n                }\n                case 12: {\n                    goto lab_0x403401;\n                }\n                case 13: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 32: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 33: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 34: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 35: {\n                    goto lab_0x4033cd;\n                }\n                case 36: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 37: {\n                    goto lab_0x403401;\n                }\n                case 38: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 39: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 40: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 41: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 42: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 43: {\n                    goto lab_0x403401;\n                }\n                case 44: {\n                    goto lab_0x403401;\n                }\n                case 45: {\n                    goto lab_0x403401;\n                }\n                case 46: {\n                    goto lab_0x403401;\n                }\n                case 47: {\n                    goto lab_0x403401;\n                }\n                case 48: {\n                    goto lab_0x403401;\n                }\n                case 49: {\n                    goto lab_0x403401;\n                }\n                case 50: {\n                    goto lab_0x403401;\n                }\n                case 51: {\n                    goto lab_0x403401;\n                }\n                case 52: {\n                    goto lab_0x403401;\n                }\n                case 53: {\n                    goto lab_0x403401;\n                }\n                case 54: {\n                    goto lab_0x403401;\n                }\n                case 55: {\n                    goto lab_0x403401;\n                }\n                case 56: {\n                    goto lab_0x403401;\n                }\n                case 57: {\n                    goto lab_0x403401;\n                }\n                case 58: {\n                    goto lab_0x403401;\n                }\n                case 59: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 60: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 61: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 62: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 63: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 65: {\n                    goto lab_0x403401;\n                }\n                case 66: {\n                    goto lab_0x403401;\n                }\n                case 67: {\n                    goto lab_0x403401;\n                }\n                case 68: {\n                    goto lab_0x403401;\n                }\n                case 69: {\n                    goto lab_0x403401;\n                }\n                case 70: {\n                    goto lab_0x403401;\n                }\n                case 71: {\n                    goto lab_0x403401;\n                }\n                case 72: {\n                    goto lab_0x403401;\n                }\n                case 73: {\n                    goto lab_0x403401;\n                }\n                case 74: {\n                    goto lab_0x403401;\n                }\n                case 75: {\n                    goto lab_0x403401;\n                }\n                case 76: {\n                    goto lab_0x403401;\n                }\n                case 77: {\n                    goto lab_0x403401;\n                }\n                case 78: {\n                    goto lab_0x403401;\n                }\n                case 79: {\n                    goto lab_0x403401;\n                }\n                case 80: {\n                    goto lab_0x403401;\n                }\n                case 81: {\n                    goto lab_0x403401;\n                }\n                case 82: {\n                    goto lab_0x403401;\n                }\n                case 83: {\n                    goto lab_0x403401;\n                }\n                case 84: {\n                    goto lab_0x403401;\n                }\n                case 85: {\n                    goto lab_0x403401;\n                }\n                case 86: {\n                    goto lab_0x403401;\n                }\n                case 87: {\n                    goto lab_0x403401;\n                }\n                case 88: {\n                    goto lab_0x403401;\n                }\n                case 89: {\n                    goto lab_0x403401;\n                }\n                case 90: {\n                    goto lab_0x403401;\n                }\n                case 91: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 92: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 93: {\n                    goto lab_0x403401;\n                }\n                case 94: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 95: {\n                    goto lab_0x403401;\n                }\n                case 96: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 97: {\n                    goto lab_0x403401;\n                }\n                case 98: {\n                    goto lab_0x403401;\n                }\n                case 99: {\n                    goto lab_0x403401;\n                }\n                case 100: {\n                    goto lab_0x403401;\n                }\n                case 101: {\n                    goto lab_0x403401;\n                }\n                case 102: {\n                    goto lab_0x403401;\n                }\n                case 103: {\n                    goto lab_0x403401;\n                }\n                case 104: {\n                    goto lab_0x403401;\n                }\n                case 105: {\n                    goto lab_0x403401;\n                }\n                case 106: {\n                    goto lab_0x403401;\n                }\n                case 107: {\n                    goto lab_0x403401;\n                }\n                case 108: {\n                    goto lab_0x403401;\n                }\n                case 109: {\n                    goto lab_0x403401;\n                }\n                case 110: {\n                    goto lab_0x403401;\n                }\n                case 111: {\n                    goto lab_0x403401;\n                }\n                case 112: {\n                    goto lab_0x403401;\n                }\n                case 113: {\n                    goto lab_0x403401;\n                }\n                case 114: {\n                    goto lab_0x403401;\n                }\n                case 115: {\n                    goto lab_0x403401;\n                }\n                case 116: {\n                    goto lab_0x403401;\n                }\n                case 117: {\n                    goto lab_0x403401;\n                }\n                case 118: {\n                    goto lab_0x403401;\n                }\n                case 119: {\n                    goto lab_0x403401;\n                }\n                case 120: {\n                    goto lab_0x403401;\n                }\n                case 121: {\n                    goto lab_0x403401;\n                }\n                case 122: {\n                    goto lab_0x403401;\n                }\n                case 123: {\n                    goto lab_0x4033a5;\n                }\n                case 124: {\n                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                }\n                case 125: {\n                    goto lab_0x4033a5;\n                }\n                case 126: {\n                    goto lab_0x4033cd;\n                }\n                default: {\n                    goto lab_0x4037a5;\n                }\n            }\n        }\n      lab_0x4037a5:\n        if (v23 != 1) {\n            // 0x403b10\n            ps = 0;\n            int64_t len = v15; // 0x403b20\n            if (v15 == -1) {\n                // 0x403b22\n                len = strlen((char *)str);\n            }\n            // 0x403b4e\n            v22 = 0x100000000 * len >> 32;\n            v17 = 0;\n            while (true) {\n              lab_0x403baf:\n                // 0x403baf\n                v18 = v17;\n                uint64_t v29 = v18 + v5; // 0x403bb4\n                int64_t v30 = v29 + str;\n                v24 = function_406340(&wc, v30, v22 - v29);\n                v19 = v18;\n                switch (v24) {\n                    case 0: {\n                        goto lab_0x40412a_2;\n                    }\n                    case -1: {\n                        goto lab_0x40412a_2;\n                    }\n                    case -2: {\n                        // 0x40420d\n                        v19 = v18;\n                        if (v22 > v29) {\n                            // 0x404247\n                            v19 = v18;\n                            int64_t v31 = v18; // 0x40424a\n                            if (*(char *)v30 != 0) {\n                                int64_t v32 = v31 + 1; // 0x404257\n                                v19 = v32;\n                                while (v32 + v5 < v22) {\n                                    // 0x404250\n                                    v19 = v32;\n                                    v31 = v32;\n                                    if (*(char *)(v32 + v27) == 0) {\n                                        // break -> 0x40412a\n                                        break;\n                                    }\n                                    v32 = v31 + 1;\n                                    v19 = v32;\n                                }\n                            }\n                        }\n                        goto lab_0x40412a_2;\n                    }\n                    case 1: {\n                        goto lab_0x403b80;\n                    }\n                    default: {\n                        int64_t v33 = v29 + v1; // 0x403c2c\n                        char v34 = *(char *)v33; // 0x403c3d\n                        unsigned char v35; // 0x403257\n                        if (v34 < 125) {\n                            // 0x403c48\n                            v35 = (v34 + 37) % 64;\n                            if (v35 != 0 != ((1 << (int64_t)v35 & 0x20000002b) == 0)) {\n                                // 0x403c5f\n                                v4 = v22;\n                                v6 = 0x100000000 * v8 >> 32;\n                                v10 = 0x100000000 * v12 >> 32;\n                                return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                            }\n                        }\n                        // 0x403c30\n                        v33++;\n                        while (v30 + v24 != v33) {\n                            // 0x403c3d\n                            v34 = *(char *)v33;\n                            if (v34 < 125) {\n                                // 0x403c48\n                                v35 = (v34 + 37) % 64;\n                                if (v35 != 0 != ((1 << (int64_t)v35 & 0x20000002b) == 0)) {\n                                    // 0x403c5f\n                                    v4 = v22;\n                                    v6 = 0x100000000 * v8 >> 32;\n                                    v10 = 0x100000000 * v12 >> 32;\n                                    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n                                }\n                            }\n                            // 0x403c30\n                            v33++;\n                        }\n                        goto lab_0x403b80;\n                    }\n                }\n            }\n            goto lab_0x40412a_2;\n        } else {\n            // 0x4037f4\n            __ctype_b_loc();\n            v16 = 0x100000000000000 * v15 >> 56;\n            v9 = v8;\n            v13 = v12;\n            goto lab_0x403401;\n        }\n    }\n  lab_0x403a28:\n    // 0x403a28\n    v4 = v15;\n    v6 = v8;\n    v10 = v12;\n    if (result != 0) {\n        // 0x40432a\n        if (v8 > result) {\n            // 0x404333\n            *(char *)(v12 + result) = 0;\n        }\n        // 0x403657\n        return result;\n    }\n    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n  lab_0x403401:;\n    int64_t v36 = v13;\n    int64_t v37 = v9;\n    int64_t v38 = v16;\n    if (v23 != 0) {\n        // 0x403410\n        v4 = v38;\n        v6 = v37;\n        v10 = v36;\n        if ((*(int32_t *)((v21 / 8 & 28) + v23) & 1 << (int32_t)(v20 % 32)) != 0) {\n            goto lab_0x40361a_2;\n        }\n    }\n    int64_t v39 = result; // 0x403511\n    char v40 = v20; // 0x403511\n    int64_t v41 = v38; // 0x403511\n    v3 = v5 + 1;\n    int64_t v42 = v37; // 0x403511\n    int64_t v43 = v36; // 0x403511\n    goto lab_0x40348d;\n  lab_0x40361a_2:\n    // 0x403657\n    return function_403200(v10, v6, str, v4, 2, v25 & -3);\n  lab_0x40412a_2:;\n    uint64_t v46 = v19;\n    int64_t v47 = 0x100000000 * v8 >> 32;\n    int64_t v48 = 0x100000000 * v12 >> 32;\n    v16 = v22;\n    v9 = v47;\n    v13 = v48;\n    if (v46 < 2) {\n        goto lab_0x403401;\n    } else {\n        uint64_t v49 = v46 + v5; // 0x403cfe\n        int64_t v50 = v5 + 1; // 0x403de1\n        v39 = result;\n        v40 = v20;\n        v41 = v22;\n        v3 = v50;\n        v42 = v47;\n        v43 = v48;\n        int64_t v51 = v50; // 0x403de8\n        char v52 = v20; // 0x403de8\n        int64_t v53 = result; // 0x403de8\n        if (v50 < v49) {\n            uint64_t v54 = v53;\n            if (v47 > v54) {\n                // 0x403db1\n                *(char *)(v54 + v48) = v52;\n            }\n            char v55 = *(char *)(v51 + str); // 0x403db5\n            int64_t v56 = v54 + 1; // 0x403dba\n            int64_t v57 = v51 + 1; // 0x403de1\n            v39 = v56;\n            v40 = v55;\n            v41 = v22;\n            v3 = v57;\n            v42 = v47;\n            v43 = v48;\n            v51 = v57;\n            while (v57 < v49) {\n                // 0x403dac\n                v54 = v56;\n                if (v47 > v54) {\n                    // 0x403db1\n                    *(char *)(v54 + v48) = v55;\n                }\n                // 0x403db5\n                v55 = *(char *)(v51 + str);\n                v56 = v54 + 1;\n                v57 = v51 + 1;\n                v39 = v56;\n                v40 = v55;\n                v41 = v22;\n                v3 = v57;\n                v42 = v47;\n                v43 = v48;\n                v51 = v57;\n            }\n        }\n        goto lab_0x40348d;\n    }\n  lab_0x403b80:\n    // 0x403b80\n    iswprint(wc);\n    int64_t v58 = v24 + v18; // 0x403b9f\n    int32_t v59 = mbsinit((struct _TYPEDEF___mbstate_t *)&ps); // 0x403ba2\n    v17 = v58;\n    v19 = v58;\n    if (v59 != 0) {\n        // break -> 0x40412a\n        goto lab_0x40412a_2;\n    }\n    goto lab_0x403baf;\n  lab_0x4033cd:\n    // 0x4033cd\n    v16 = v15;\n    v9 = v8;\n    v13 = v12;\n    v4 = v15;\n    v6 = v8;\n    v10 = v12;\n    if (v5 == 0) {\n        goto lab_0x40361a_2;\n    }\n    goto lab_0x403401;\n  lab_0x4033a5:;\n    bool v60 = v15 == 1; // 0x4033b0\n    if (v15 == -1) {\n        // 0x4033b2\n        v60 = *(char *)v1 == 0;\n    }\n    // 0x4033be\n    v16 = v15;\n    v9 = v8;\n    v13 = v12;\n    if (!v60) {\n        goto lab_0x403401;\n    } else {\n        goto lab_0x4033cd;\n    }\n  lab_0x40348d:;\n    int64_t v44 = v43;\n    uint64_t v45 = v39;\n    if (v45 < v42) {\n        // 0x403492\n        *(char *)(v44 + v45) = v40;\n    }\n    // 0x403496\n    v2 = v45 + 1;\n    v14 = v41;\n    v7 = v42;\n    v11 = v44;\n    goto lab_0x4032a8_2;\n}\n"
        },
        {
            "funcName": "function_404430",
            "funcStartAddr": "404430",
            "funcEndAddr": "4045ce",
            "decompiledFuncCode": "int64_t function_404430(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {\n    int64_t v1 = 0x100000000 * a1;\n    uint64_t v2 = v1 >> 32; // 0x404432\n    int32_t * v3 = __errno_location(); // 0x40444c\n    int64_t v4 = (int64_t)g23; // 0x404451\n    int32_t v5 = *v3; // 0x40445b\n    int64_t v6 = v4; // 0x404471\n    if (v2 >= (int64_t)*(int32_t *)&g26) {\n        if ((int32_t)v2 == 0x7fffffff) {\n            // 0x4045c9\n            function_405490(a1);\n            // UNREACHABLE\n        }\n        int64_t v7 = v2 + 1; // 0x404480\n        int64_t v8 = 0x100000000 * v7 >> 28; // 0x404487\n        int64_t v9; // 0x404430\n        if (g23 == &g24) {\n            int64_t v10 = function_4052a0(0, v8); // 0x4045aa\n            int128_t v11 = __asm_movdqa(*(int128_t *)&g24); // 0x4045af\n            *(int64_t *)&g23 = v10;\n            __asm_movups(*(int128_t *)v10, v11);\n            v9 = v10;\n        } else {\n            int64_t v12 = function_4052a0(v4, v8); // 0x40449b\n            *(int64_t *)&g23 = v12;\n            v9 = v12;\n        }\n        // 0x4044aa\n        v6 = v9;\n        int32_t v13 = *(int32_t *)&g26; // 0x4044aa\n        int32_t v14 = v7; // 0x4044b1\n        memset((int64_t *)(16 * (int64_t)v13 + v6), 0, 16 * (v14 - v13));\n        *(int32_t *)&g26 = v14;\n    }\n    int64_t v15 = v6 + (v1 >> 28); // 0x4044e1\n    int32_t v16 = *(int32_t *)((int64_t)a4 + 4) | 1; // 0x4044eb\n    int64_t * v17 = (int64_t *)v15; // 0x4044ee\n    uint64_t v18 = *v17; // 0x4044ee\n    int64_t * v19 = (int64_t *)(v15 + 8); // 0x4044f1\n    int64_t result = *v19; // 0x4044f1\n    int64_t v20; // 0x404430\n    uint64_t v21 = function_403200(result, v18, a2, a3, v20 & 0xffffffff, v16); // 0x404514\n    if (v18 > v21) {\n        // 0x40458b\n        *v3 = v5;\n        return result;\n    }\n    int64_t v22 = v21 + 1; // 0x404527\n    *v17 = v22;\n    if (result != (int64_t)&g49) {\n        // 0x404537\n        free((int64_t *)result);\n    }\n    int64_t result2 = function_405240(v22); // 0x404551\n    *v19 = result2;\n    int64_t v23; // 0x404430\n    function_403200(result2, v22, a2, a3, (int64_t)*(int32_t *)&v23, v16);\n    // 0x40458b\n    *v3 = v5;\n    return result2;\n}\n"
        },
        {
            "funcName": "function_4045d0",
            "funcStartAddr": "4045d0",
            "funcEndAddr": "404604",
            "decompiledFuncCode": "int64_t function_4045d0(int64_t a1) {\n    int32_t * v1 = __errno_location(); // 0x4045d7\n    int64_t result = function_405440(a1 == 0 ? (int64_t)&g50 : a1, 56); // 0x4045f6\n    return result;\n}\n"
        },
        {
            "funcName": "function_404610",
            "funcStartAddr": "404610",
            "funcEndAddr": "40461f",
            "decompiledFuncCode": "int64_t function_404610(int64_t a1) {\n    uint32_t result = *(int32_t *)(a1 == 0 ? (int64_t)&g50 : a1); // 0x40461c\n    return result;\n}\n"
        },
        {
            "funcName": "function_404620",
            "funcStartAddr": "404620",
            "funcEndAddr": "40462f",
            "decompiledFuncCode": "int64_t function_404620(int64_t a1, int64_t a2) {\n    int64_t v1 = a1 == 0 ? (int64_t)&g50 : a1; // 0x404628\n    *(int32_t *)v1 = (int32_t)a2;\n    return (int64_t)&g50;\n}\n"
        },
        {
            "funcName": "function_404630",
            "funcStartAddr": "404630",
            "funcEndAddr": "404663",
            "decompiledFuncCode": "int64_t function_404630(int64_t a1, uint64_t a2, int64_t a3) {\n    int64_t v1 = a1 == 0 ? (int64_t)&g50 + 8 : a1 + 8; // 0x404649\n    int32_t * v2 = (int32_t *)((a2 / 8 & 28) + v1); // 0x40464e\n    uint32_t v3 = *v2; // 0x40464e\n    uint32_t v4 = (int32_t)a2 % 32; // 0x404652\n    uint32_t v5 = v3 >> v4;\n    *v2 = (v5 ^ (int32_t)a3) % 2 << v4 ^ v3;\n    return v5 % 2;\n}\n"
        },
        {
            "funcName": "function_404670",
            "funcStartAddr": "404670",
            "funcEndAddr": "404683",
            "decompiledFuncCode": "int64_t function_404670(int64_t a1, int64_t a2) {\n    int32_t * v1 = (int32_t *)(a1 == 0 ? (int64_t)&g50 + 4 : a1 + 4); // 0x40467c\n    *v1 = (int32_t)a2;\n    return (int64_t)*v1;\n}\n"
        },
        {
            "funcName": "function_404690",
            "funcStartAddr": "404690",
            "funcEndAddr": "4046bb",
            "decompiledFuncCode": "int64_t function_404690(int64_t a1, int64_t a2, int64_t a3) {\n    int64_t v1 = a1 == 0 ? (int64_t)&g50 : a1; // 0x404698\n    *(int32_t *)v1 = 10;\n    if (a2 == 0 || a3 == 0) {\n        // 0x4046b5\n        abort();\n        // UNREACHABLE\n    }\n    // 0x4046ac\n    *(int64_t *)(v1 + 40) = a2;\n    *(int64_t *)(v1 + 48) = a3;\n    return (int64_t)&g50;\n}\n"
        },
        {
            "funcName": "function_4046c0",
            "funcStartAddr": "4046c0",
            "funcEndAddr": "404732",
            "decompiledFuncCode": "int64_t function_4046c0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {\n    int64_t v1 = a5 == 0 ? (int64_t)&g50 : a5; // 0x4046e2\n    int32_t * v2 = __errno_location(); // 0x4046eb\n    uint32_t v3 = *(int32_t *)v1; // 0x40470b\n    int64_t result = function_403200(a1, a2, a3, a4, (int64_t)v3, *(int32_t *)(v1 + 4)); // 0x40471a\n    return result;\n}\n"
        },
        {
            "funcName": "function_404740",
            "funcStartAddr": "404740",
            "funcEndAddr": "404821",
            "decompiledFuncCode": "int64_t function_404740(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {\n    int64_t v1 = a4 == 0 ? (int64_t)&g50 : a4; // 0x404762\n    int32_t * v2 = __errno_location(); // 0x404768\n    int32_t v3 = *(int32_t *)(v1 + 4) | (int32_t)(a3 == 0); // 0x404787\n    int32_t * v4 = (int32_t *)v1; // 0x40478a\n    int64_t v5 = function_403200(0, 0, a1, a2, (int64_t)*v4, v3); // 0x4047a5\n    int64_t v6 = v5 + 1; // 0x4047aa\n    int64_t result = function_405240(v6); // 0x4047bf\n    function_403200(result, v6, a1, a2, (int64_t)*v4, v3);\n    if (a3 != 0) {\n        // 0x404804\n        *(int64_t *)(int64_t)a3 = v5;\n    }\n    // 0x40480d\n    return result;\n}\n"
        },
        {
            "funcName": "function_404830",
            "funcStartAddr": "404830",
            "funcEndAddr": "40483a",
            "decompiledFuncCode": "int64_t function_404830(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x404830\n    return function_404740(a1, a2, 0, a3);\n}\n"
        },
        {
            "funcName": "function_404840",
            "funcStartAddr": "404840",
            "funcEndAddr": "4048d5",
            "decompiledFuncCode": "int64_t function_404840(void) {\n    uint32_t v1 = *(int32_t *)&g26; // 0x404840\n    int64_t v2 = v1; // 0x404840\n    int64_t v3 = v2; // 0x404854\n    if (v1 >= 2) {\n        int64_t v4 = &g26;\n        int64_t v5 = v4 + 16; // 0x404873\n        free((int64_t *)*(int64_t *)v4);\n        v3 = &g60;\n        while (v5 != (int64_t)g23 + 40 + (16 * v2 + 0xfffffffe0 & 0xffffffff0)) {\n            // 0x404870\n            v4 = v5;\n            v5 = v4 + 16;\n            free((int64_t *)*(int64_t *)v4);\n            v3 = &g60;\n        }\n    }\n    int64_t v6 = v3; // 0x40488d\n    if (g24 != 0x60b560) {\n        // 0x40488f\n        free((int64_t *)g24);\n        g24 = 256;\n        *(int64_t *)&g25 = (int64_t)&g49;\n        v6 = &g60;\n    }\n    int64_t result = v6; // 0x4048b1\n    if (g23 != &g24) {\n        // 0x4048b3\n        free(g23);\n        *(int64_t *)&g23 = (int64_t)&g24;\n        result = &g60;\n    }\n    // 0x4048c6\n    *(int32_t *)&g26 = 1;\n    return result;\n}\n"
        },
        {
            "funcName": "function_4048e0",
            "funcStartAddr": "4048e0",
            "funcEndAddr": "4048f1",
            "decompiledFuncCode": "int64_t function_4048e0(void) {\n    // 0x4048e0\n    int64_t v1; // 0x4048e0\n    return function_404430(v1, v1, -1, (int64_t *)&g50);\n}\n"
        },
        {
            "funcName": "function_404900",
            "funcStartAddr": "404900",
            "funcEndAddr": "40490a",
            "decompiledFuncCode": "int64_t function_404900(void) {\n    // 0x404900\n    int64_t v1; // 0x404900\n    return function_404430(v1, v1, v1, (int64_t *)&g50);\n}\n"
        },
        {
            "funcName": "function_404910",
            "funcStartAddr": "404910",
            "funcEndAddr": "404926",
            "decompiledFuncCode": "int64_t function_404910(int64_t a1) {\n    // 0x404910\n    return function_404430(0, a1, -1, (int64_t *)&g50);\n}\n"
        },
        {
            "funcName": "function_404930",
            "funcStartAddr": "404930",
            "funcEndAddr": "404942",
            "decompiledFuncCode": "int64_t function_404930(int64_t a1, int64_t a2) {\n    // 0x404930\n    return function_404430(0, a1, a2, (int64_t *)&g50);\n}\n"
        },
        {
            "funcName": "function_404950",
            "funcStartAddr": "404950",
            "funcEndAddr": "4049b8",
            "decompiledFuncCode": "int64_t function_404950(int32_t a1, int64_t a2, int64_t a3) {\n    int64_t v1 = 0x100000000 * a2 >> 32; // bp-72, 0x404960\n    return function_404430((int64_t)a1, a3, -1, &v1);\n}\n"
        },
        {
            "funcName": "function_4049c0",
            "funcStartAddr": "4049c0",
            "funcEndAddr": "404a24",
            "decompiledFuncCode": "int64_t function_4049c0(int32_t a1, int64_t a2, int64_t a3, int64_t a4) {\n    int64_t v1 = 0x100000000 * a2 >> 32; // bp-72, 0x4049d0\n    return function_404430((int64_t)a1, a3, a4, &v1);\n}\n"
        },
        {
            "funcName": "function_404a30",
            "funcStartAddr": "404a30",
            "funcEndAddr": "404a3c",
            "decompiledFuncCode": "int64_t function_404a30(int64_t a1, int64_t a2) {\n    // 0x404a30\n    return function_404950(0, a1 & 0xffffffff, a2);\n}\n"
        },
        {
            "funcName": "function_404a40",
            "funcStartAddr": "404a40",
            "funcEndAddr": "404a4f",
            "decompiledFuncCode": "int64_t function_404a40(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x404a40\n    return function_4049c0(0, a1 & 0xffffffff, a2, a3);\n}\n"
        },
        {
            "funcName": "function_404a50",
            "funcStartAddr": "404a50",
            "funcEndAddr": "404ac0",
            "decompiledFuncCode": "int64_t function_404a50(int64_t a1, int64_t a2, uint64_t a3) {\n    int128_t v1 = __asm_movdqa(*(int128_t *)&g50); // 0x404a5d\n    int128_t v2 = __asm_movdqa(g51); // 0x404a65\n    int128_t v3 = __asm_movdqa(g52); // 0x404a6d\n    int64_t v4 = __asm_movaps(v1); // bp-72, 0x404a82\n    __asm_movaps(v2);\n    __asm_movaps(v3);\n    int32_t * v5 = (int32_t *)((a3 / 8 & 28) + 8 + (int64_t)&v4); // 0x404a98\n    uint32_t v6 = *v5; // 0x404a98\n    uint32_t v7 = (int32_t)a3 % 32; // 0x404a9d\n    *v5 = ((v6 >> v7) % 2 ^ 1) << v7 ^ v6;\n    return function_404430(0, a1, a2, &v4);\n}\n"
        },
        {
            "funcName": "function_404ac0",
            "funcStartAddr": "404ac0",
            "funcEndAddr": "404acd",
            "decompiledFuncCode": "int64_t function_404ac0(int64_t a1, int64_t a2) {\n    // 0x404ac0\n    return function_404a50(a1, -1, 0x100000000000000 * a2 >> 56);\n}\n"
        },
        {
            "funcName": "function_404ad0",
            "funcStartAddr": "404ad0",
            "funcEndAddr": "404ae1",
            "decompiledFuncCode": "int64_t function_404ad0(int64_t a1) {\n    // 0x404ad0\n    return function_404a50(a1, -1, 58);\n}\n"
        },
        {
            "funcName": "function_404af0",
            "funcStartAddr": "404af0",
            "funcEndAddr": "404afa",
            "decompiledFuncCode": "int64_t function_404af0(void) {\n    // 0x404af0\n    int64_t v1; // 0x404af0\n    return function_404a50(v1, v1, 58);\n}\n"
        },
        {
            "funcName": "function_404b00",
            "funcStartAddr": "404b00",
            "funcEndAddr": "404b6e",
            "decompiledFuncCode": "int64_t function_404b00(int64_t a1, int64_t a2, int64_t a3) {\n    int64_t v1 = 0x100000000 * a2 >> 32; // bp-72, 0x404b1a\n    return function_404430(a1, a3, -1, &v1);\n}\n"
        },
        {
            "funcName": "function_404b70",
            "funcStartAddr": "404b70",
            "funcEndAddr": "404bdc",
            "decompiledFuncCode": "int64_t function_404b70(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {\n    int128_t v1 = __asm_movdqa(*(int128_t *)&g50); // 0x404b77\n    int128_t v2 = __asm_movdqa(g51); // 0x404b7f\n    int128_t v3 = __asm_movdqa(g52); // 0x404b87\n    __asm_movaps(v1);\n    __asm_movaps(v2);\n    __asm_movaps(v3);\n    int64_t v4 = 10; // bp-72, 0x404ba9\n    if (a2 == 0 || a3 == 0) {\n        // 0x404bd7\n        abort();\n        // UNREACHABLE\n    }\n    // 0x404bba\n    return function_404430(a1, a4, a5, &v4);\n}\n"
        },
        {
            "funcName": "function_404be0",
            "funcStartAddr": "404be0",
            "funcEndAddr": "404be9",
            "decompiledFuncCode": "int64_t function_404be0(void) {\n    // 0x404be0\n    int64_t v1; // 0x404be0\n    return function_404b70(v1, v1, v1, v1, -1);\n}\n"
        },
        {
            "funcName": "function_404bf0",
            "funcStartAddr": "404bf0",
            "funcEndAddr": "404c07",
            "decompiledFuncCode": "int64_t function_404bf0(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x404bf0\n    return function_404b70(0, a1, a2, a3, -1);\n}\n"
        },
        {
            "funcName": "function_404c10",
            "funcStartAddr": "404c10",
            "funcEndAddr": "404c23",
            "decompiledFuncCode": "int64_t function_404c10(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {\n    // 0x404c10\n    return function_404b70(0, a1, a2, a3, a4);\n}\n"
        },
        {
            "funcName": "function_404c30",
            "funcStartAddr": "404c30",
            "funcEndAddr": "404c3a",
            "decompiledFuncCode": "int64_t function_404c30(void) {\n    // 0x404c30\n    int64_t v1; // 0x404c30\n    return function_404430(v1, v1, v1, &g22);\n}\n"
        },
        {
            "funcName": "function_404c40",
            "funcStartAddr": "404c40",
            "funcEndAddr": "404c52",
            "decompiledFuncCode": "int64_t function_404c40(int64_t a1, int64_t a2) {\n    // 0x404c40\n    return function_404430(0, a1, a2, &g22);\n}\n"
        },
        {
            "funcName": "function_404c60",
            "funcStartAddr": "404c60",
            "funcEndAddr": "404c71",
            "decompiledFuncCode": "int64_t function_404c60(void) {\n    // 0x404c60\n    int64_t v1; // 0x404c60\n    return function_404430(v1, v1, -1, &g22);\n}\n"
        },
        {
            "funcName": "function_404c80",
            "funcStartAddr": "404c80",
            "funcEndAddr": "404c96",
            "decompiledFuncCode": "int64_t function_404c80(int64_t a1) {\n    // 0x404c80\n    return function_404430(0, a1, -1, &g22);\n}\n"
        },
        {
            "funcName": "function_404ca0",
            "funcStartAddr": "404ca0",
            "funcEndAddr": "40507d",
            "decompiledFuncCode": "int64_t function_404ca0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, uint64_t a6, int64_t a7) {\n    struct _IO_FILE * v1 = (struct _IO_FILE *)a1;\n    if (a2 == 0) {\n        // 0x404d38\n        __fprintf_chk(v1, 1, \"%s %s\\n\", (char *)a3, (char *)a4);\n    } else {\n        // 0x404cbc\n        __fprintf_chk(v1, 1, \"%s (%s) %s\\n\", (char *)a2, (char *)a3, (char *)a4);\n    }\n    // 0x404cd6\n    __fprintf_chk(v1, 1, \"Copyright %s %d Free Software Foundation, Inc.\", dcgettext(NULL, \"(C)\", 5), 2017);\n    int32_t result = fputs_unlocked(dcgettext(NULL, \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\", 5), v1); // 0x404d1b\n    if (a6 < 10) {\n        // 0x404d2a\n        return result;\n    }\n    char * v2 = dcgettext(NULL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\", 5); // 0x404e22\n    return __fprintf_chk(v1, 1, v2);\n}\n"
        },
        {
            "funcName": "function_405080",
            "funcStartAddr": "405080",
            "funcEndAddr": "4050a0",
            "decompiledFuncCode": "int64_t function_405080(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    // 0x405080\n    if (a5 == 0) {\n        // 0x40509b\n        return function_404ca0(a1, a2, a3, a4, a5, 0, (int64_t)&g60);\n    }\n    int64_t v1 = 0; // 0x405087\n    v1++;\n    int64_t v2 = v1; // 0x405099\n    while (*(int64_t *)(8 * v1 + a5) != 0) {\n        // 0x405090\n        v1++;\n        v2 = v1;\n    }\n    // 0x40509b\n    return function_404ca0(a1, a2, a3, a4, a5, v2, (int64_t)&g60);\n}\n"
        },
        {
            "funcName": "function_4050a0",
            "funcStartAddr": "4050a0",
            "funcEndAddr": "405100",
            "decompiledFuncCode": "int64_t function_4050a0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    int64_t v1 = a5;\n    int64_t v2; // bp-88, 0x4050a0\n    int64_t v3 = &v2; // 0x4050a0\n    int64_t v4 = 0;\n    uint32_t v5 = (int32_t)a5; // 0x4050d3\n    int64_t v6; // 0x4050bd\n    int64_t * v7; // 0x4050db\n    int64_t v8; // 0x4050db\n    int64_t v9; // 0x4050e7\n    if (v5 < 48) {\n        // 0x4050b0\n        *(int32_t *)v1 = v5 + 8;\n        v6 = *(int64_t *)(*(int64_t *)(v1 + 16) + (int64_t)v5);\n        *(int64_t *)(8 * v4 + v3) = v6;\n        if (v6 == 0) {\n            // break -> 0x4050f3\n            break;\n        }\n    } else {\n        // 0x4050db\n        v7 = (int64_t *)(v1 + 8);\n        v8 = *v7;\n        *v7 = v8 + 8;\n        v9 = *(int64_t *)v8;\n        *(int64_t *)(8 * v4 + v3) = v9;\n        if (v9 == 0) {\n            // break -> 0x4050f3\n            break;\n        }\n    }\n    int64_t v10 = 10; // 0x4050d1\n    while (v4 != 9) {\n        // 0x4050c9\n        v4++;\n        v5 = *(int32_t *)&v1;\n        if (v5 < 48) {\n            // 0x4050b0\n            *(int32_t *)v1 = v5 + 8;\n            v6 = *(int64_t *)(*(int64_t *)(v1 + 16) + (int64_t)v5);\n            *(int64_t *)(8 * v4 + v3) = v6;\n            v10 = v4;\n            if (v6 == 0) {\n                // break -> 0x4050f3\n                break;\n            }\n        } else {\n            // 0x4050db\n            v7 = (int64_t *)(v1 + 8);\n            v8 = *v7;\n            *v7 = v8 + 8;\n            v9 = *(int64_t *)v8;\n            *(int64_t *)(8 * v4 + v3) = v9;\n            v10 = v4;\n            if (v9 == 0) {\n                // break -> 0x4050f3\n                break;\n            }\n        }\n        // 0x4050c9\n        v10 = 10;\n    }\n    // 0x4050f3\n    return function_404ca0(a1, a2, a3, a4, v3, v10, (int64_t)&g60);\n}\n"
        },
        {
            "funcName": "function_405100",
            "funcStartAddr": "405100",
            "funcEndAddr": "4051bc",
            "decompiledFuncCode": "int64_t function_405100(int64_t a1, char * a2, char * a3, int64_t a4, char * a5, int32_t a6) {\n    // 0x405100\n    int64_t v1; // bp-168, 0x405100\n    int64_t v2 = (int64_t)&v1 + 32;\n    int64_t v3; // 0x405100\n    int64_t v4 = &v3;\n    int64_t v5 = 0;\n    int64_t v6 = 32;\n    int64_t v7; // 0x405100\n    int64_t v8; // 0x405100\n    int64_t v9; // bp-56, 0x405100\n    int64_t v10; // 0x405165\n    int64_t v11; // 0x405189\n    if ((int32_t)v6 < 48) {\n        // 0x405150\n        v10 = *(int64_t *)((v6 & 0xffffffff) + (int64_t)&v9);\n        *(int64_t *)(8 * v5 + v2) = v10;\n        v8 = v6 + 8 & 0xffffffff;\n        v7 = v4;\n        if (v10 == 0) {\n            // break -> 0x4051a0\n            break;\n        }\n    } else {\n        // 0x405182\n        v11 = *(int64_t *)v4;\n        *(int64_t *)(8 * v5 + v2) = v11;\n        v8 = v6;\n        v7 = v4 + 8;\n        if (v11 == 0) {\n            // break -> 0x4051a0\n            break;\n        }\n    }\n    int64_t v12 = v5 + 1; // 0x40517a\n    int64_t v13 = 10; // 0x40517a\n    while (v5 != 9) {\n        // 0x40517c\n        v4 = v7;\n        v5 = v12;\n        v6 = v8;\n        if ((int32_t)v6 < 48) {\n            // 0x405150\n            v10 = *(int64_t *)((v6 & 0xffffffff) + (int64_t)&v9);\n            *(int64_t *)(8 * v5 + v2) = v10;\n            v8 = v6 + 8 & 0xffffffff;\n            v7 = v4;\n            v13 = v5;\n            if (v10 == 0) {\n                // break -> 0x4051a0\n                break;\n            }\n        } else {\n            // 0x405182\n            v11 = *(int64_t *)v4;\n            *(int64_t *)(8 * v5 + v2) = v11;\n            v8 = v6;\n            v7 = v4 + 8;\n            v13 = v5;\n            if (v11 == 0) {\n                // break -> 0x4051a0\n                break;\n            }\n        }\n        // 0x405172\n        v12 = v5 + 1;\n        v13 = 10;\n    }\n    // 0x4051a0\n    int64_t v14; // bp-136, 0x405100\n    int64_t result = function_404ca0(a1, (int64_t)a2, (int64_t)a3, a4, (int64_t)&v14, v13, (int64_t)&g60); // 0x4051af\n    return result;\n}\n"
        },
        {
            "funcName": "function_4051c0",
            "funcStartAddr": "4051c0",
            "funcEndAddr": "405234",
            "decompiledFuncCode": "int64_t function_4051c0(int64_t a1) {\n    // 0x4051c0\n    __printf_chk(1, dcgettext(NULL, \"\\nReport bugs to: %s\\n\", 5));\n    __printf_chk(1, dcgettext(NULL, \"%s home page: <%s>\\n\", 5));\n    char * v1 = dcgettext(NULL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5); // 0x405223\n    return fputs_unlocked(v1, g33);\n}\n"
        },
        {
            "funcName": "function_405240",
            "funcStartAddr": "405240",
            "funcEndAddr": "40525a",
            "decompiledFuncCode": "int64_t function_405240(int64_t size) {\n    int64_t * mem = malloc((int32_t)size); // 0x405244\n    if (size != 0 != (mem == NULL)) {\n        // 0x405253\n        return (int64_t)mem;\n    }\n    // 0x405255\n    function_405490(size);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_405260",
            "funcStartAddr": "405260",
            "funcEndAddr": "405281",
            "decompiledFuncCode": "int64_t function_405260(uint64_t a1, uint64_t a2) {\n    uint128_t v1 = (int128_t)a2 * (int128_t)a1; // 0x405263\n    int64_t v2 = v1; // 0x405263\n    if (v2 < 0) {\n        // 0x40527b\n        function_405490(v2);\n        // UNREACHABLE\n    }\n    if (v1 <= 0xffffffffffffffff) {\n        // 0x405279\n        return function_405240(v2);\n    }\n    // 0x40527b\n    function_405490(v2);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_405290",
            "funcStartAddr": "405290",
            "funcEndAddr": "405292",
            "decompiledFuncCode": "int64_t function_405290(void) {\n    // 0x405290\n    int64_t v1; // 0x405290\n    return function_405240(v1);\n}\n"
        },
        {
            "funcName": "function_4052a0",
            "funcStartAddr": "4052a0",
            "funcEndAddr": "4052d6",
            "decompiledFuncCode": "int64_t function_4052a0(int64_t a1, int64_t a2) {\n    int64_t * v1 = (int64_t *)a1;\n    if (a2 == 0 == (a1 != 0)) {\n        // 0x4052c8\n        free(v1);\n        return (int32_t)&g60 ^ (int32_t)&g60;\n    }\n    int64_t * mem = realloc(v1, (int32_t)a2); // 0x4052b1\n    if (a2 != 0 != (mem == NULL)) {\n        // 0x4052c0\n        return (int64_t)mem;\n    }\n    // 0x4052d1\n    function_405490(a1);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_4052e0",
            "funcStartAddr": "4052e0",
            "funcEndAddr": "405301",
            "decompiledFuncCode": "int64_t function_4052e0(int64_t a1, uint64_t a2, uint64_t a3) {\n    uint128_t v1 = (int128_t)a3 * (int128_t)a2; // 0x4052e3\n    int64_t v2 = v1; // 0x4052e3\n    if (v2 < 0) {\n        // 0x4052fb\n        function_405490(a1);\n        // UNREACHABLE\n    }\n    if (v1 <= 0xffffffffffffffff) {\n        // 0x4052f9\n        return function_4052a0(a1, v2);\n    }\n    // 0x4052fb\n    function_405490(a1);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_405310",
            "funcStartAddr": "405310",
            "funcEndAddr": "405396",
            "decompiledFuncCode": "int64_t function_405310(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, int64_t a5) {\n    if (a1 != 0) {\n        if (0x5555555555555554 / a3 <= a2) {\n            // 0x40536b\n            function_405490(a1);\n            // UNREACHABLE\n        }\n        int64_t v1 = a2 + 1 + a2 / 2;\n        *(int64_t *)a2 = v1;\n        return function_4052a0(a1, v1 * a3);\n    }\n    int64_t v2 = a2; // 0x405353\n    if (a2 == 0) {\n        // 0x405378\n        v2 = 128 / a3 + (int64_t)(a3 >= 129);\n    }\n    uint128_t v3 = (int128_t)v2 * (int128_t)a3; // 0x405358\n    if ((int64_t)v3 > -1 != v3 <= 0xffffffffffffffff) {\n        // 0x40536b\n        function_405490(a1);\n        // UNREACHABLE\n    }\n    // 0x40533a\n    *(int64_t *)a2 = v2;\n    return function_4052a0(a1, v2 * a3);\n}\n"
        },
        {
            "funcName": "function_4053a0",
            "funcStartAddr": "4053a0",
            "funcEndAddr": "4053f0",
            "decompiledFuncCode": "int64_t function_4053a0(int64_t a1, uint64_t a2) {\n    int64_t v1; // 0x4053a0\n    if (a1 != 0) {\n        if (a2 >= 0x5555555555555554) {\n            // 0x4053ea\n            function_405490(a1);\n            // UNREACHABLE\n        }\n        // 0x4053c2\n        v1 = a2 + 1 + a2 / 2;\n        *(int64_t *)a2 = v1;\n        return function_4052a0(a1, v1);\n    }\n    if (a2 == 0) {\n        // 0x4053d5\n        *(int64_t *)a2 = 128;\n        return function_4052a0(0, 128);\n    }\n    // 0x4053e8\n    if (a2 < 0) {\n        // 0x4053ea\n        function_405490(a1);\n        // UNREACHABLE\n    }\n    // 0x4053c2\n    v1 = a2;\n    *(int64_t *)a2 = v1;\n    return function_4052a0(a1, v1);\n}\n"
        },
        {
            "funcName": "function_4053f0",
            "funcStartAddr": "4053f0",
            "funcEndAddr": "405407",
            "decompiledFuncCode": "int64_t function_4053f0(int64_t a1, int64_t a2) {\n    // 0x4053f0\n    return (int64_t)memset((int64_t *)function_405240(a1), 0, (int32_t)a1);\n}\n"
        },
        {
            "funcName": "function_405410",
            "funcStartAddr": "405410",
            "funcEndAddr": "40543e",
            "decompiledFuncCode": "int64_t function_405410(uint64_t nmemb, uint64_t size) {\n    uint128_t v1 = (int128_t)size * (int128_t)nmemb; // 0x405417\n    if ((int64_t)v1 < 0) {\n        // 0x405439\n        function_405490(nmemb);\n        // UNREACHABLE\n    }\n    if (v1 > 0xffffffffffffffff) {\n        // 0x405439\n        function_405490(nmemb);\n        // UNREACHABLE\n    }\n    int64_t * mem = calloc((int32_t)nmemb, (int32_t)size); // 0x40542a\n    if (mem != NULL) {\n        // 0x405434\n        return (int64_t)mem;\n    }\n    // 0x405439\n    function_405490(nmemb);\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_405440",
            "funcStartAddr": "405440",
            "funcEndAddr": "405468",
            "decompiledFuncCode": "int64_t function_405440(int64_t a1, int64_t a2) {\n    int64_t v1 = function_405240(a2); // 0x40544f\n    return (int64_t)memcpy((int64_t *)v1, (int64_t *)a1, (int32_t)a2);\n}\n"
        },
        {
            "funcName": "function_405470",
            "funcStartAddr": "405470",
            "funcEndAddr": "405483",
            "decompiledFuncCode": "int64_t function_405470(int64_t str) {\n    // 0x405470\n    return function_405440(str, (int64_t)strlen((char *)str) + 1);\n}\n"
        },
        {
            "funcName": "function_405490",
            "funcStartAddr": "405490",
            "funcEndAddr": "4054c1",
            "decompiledFuncCode": "int64_t function_405490(int64_t a1) {\n    // 0x405490\n    error(g21, (int32_t)\"memory exhausted\" ^ (int32_t)\"memory exhausted\", \"%s\", dcgettext(NULL, \"memory exhausted\", 5));\n    abort();\n    // UNREACHABLE\n}\n"
        },
        {
            "funcName": "function_4054d0",
            "funcStartAddr": "4054d0",
            "funcEndAddr": "40556c",
            "decompiledFuncCode": "int64_t function_4054d0(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4) {\n    int32_t * v1 = __errno_location(); // 0x4054e8\n    *v1 = 0;\n    char * v2; // 0x4054d0\n    int64_t v3 = (int64_t)v2; // 0x405501\n    int64_t result = 0; // 0x405509\n    int128_t v4; // 0x4054d0\n    if (v3 != a1) {\n        int64_t v5; // 0x4054d0\n        if (a2 == NULL) {\n            char v6 = *v2; // 0x40554a\n            if (v6 != 0) {\n                // 0x405532\n                *a3 = __asm_movsd(v4);\n                return 0;\n            }\n            unsigned char v7 = llvm_ctpop_i8(v6); // 0x40554a\n            __asm_ucomisd(v4, (int64_t)g4);\n            v5 = 0;\n            if (v7 % 2 != 0) {\n                // 0x405532\n                *a3 = __asm_movsd(v4);\n                return 1;\n            }\n        } else {\n            unsigned char v8 = llvm_ctpop_i8((char)(int64_t)a2); // 0x40550b\n            __asm_ucomisd(v4, (int64_t)g4);\n            v5 = v8 % 2 == 0 ? (int64_t)v1 & -256 : 0;\n        }\n        // 0x405521\n        result = v5 | (int64_t)(*v1 != 34);\n    }\n    // 0x405529\n    if (a2 != NULL) {\n        // 0x40552e\n        *a2 = v3;\n    }\n    // 0x405532\n    *a3 = __asm_movsd(v4);\n    return result;\n}\n"
        },
        {
            "funcName": "function_405570",
            "funcStartAddr": "405570",
            "funcEndAddr": "40564f",
            "decompiledFuncCode": "int64_t function_405570(int64_t a1, int64_t a2) {\n    int32_t * v1 = (int32_t *)(a2 + 44); // 0x40557c\n    uint32_t v2 = *v1; // 0x40557c\n    int64_t v3 = a2 & 0xffffffff; // 0x405581\n    int32_t * v4 = (int32_t *)(a2 + 48); // 0x405584\n    uint64_t v5 = (int64_t)*v4; // 0x405584\n    int64_t v6; // 0x4055f2\n    if (v3 <= v5) {\n      lab_0x4055ec_2:\n        // 0x4055ec\n        *v4 = (int32_t)a2;\n        v6 = v3 - v5;\n        *v1 = v2 + (int32_t)v6;\n        return v6 & 0xffffffff;\n    }\n    int64_t v7 = a1 + 8; // 0x405572\n    int64_t v8 = v2; // 0x405570\n    int64_t v9 = v5 - v8;\n    uint64_t v10 = v9 & 0xffffffff;\n    int64_t v11 = 0x100000000 * v8;\n    int64_t v12 = v11 >> 32;\n    int64_t v13 = (v11 >> 29) + a1;\n    int64_t v14 = 8 * ((v9 + 0xffffffff & 0xffffffff) + v12) + v7;\n    if (v8 >= v5) {\n        // break (via goto) -> 0x4055ec\n        goto lab_0x4055ec_2;\n    }\n    int64_t v15 = v3;\n    int64_t v16 = v15 - v5; // 0x4055a8\n    int64_t v17; // 0x4055b6\n    int64_t * v18; // 0x4055d0\n    int64_t * v19; // 0x4055d3\n    int64_t v20; // 0x4055de\n    int64_t v21; // 0x4055b6\n    while ((v16 & 0xffffffff) > v10) {\n        // 0x4055b3\n        v17 = v15 - v10;\n        v20 = v13;\n        v18 = (int64_t *)v20;\n        v19 = (int64_t *)(v20 + 8 * ((0x100000000 * v17 >> 32) - v12));\n        *v18 = *v19;\n        *v19 = *v18;\n        v20 += 8;\n        while (v14 != v20) {\n            // 0x4055d0\n            v18 = (int64_t *)v20;\n            v19 = (int64_t *)(v20 + 8 * ((0x100000000 * v17 >> 32) - v12));\n            *v18 = *v19;\n            *v19 = *v18;\n            v20 += 8;\n        }\n        // 0x4055e7\n        v21 = v17 & 0xffffffff;\n        if (v21 <= v5) {\n            // break (via goto) -> 0x4055ec\n            goto lab_0x4055ec_2;\n        }\n        if (v8 >= v5) {\n            // break (via goto) -> 0x4055ec\n            goto lab_0x4055ec_2;\n        }\n        // 0x4055a2\n        v15 = v21;\n        v16 = v15 - v5;\n    }\n    int64_t v22 = v13; // 0x40562b\n    int64_t * v23 = (int64_t *)v22; // 0x405630\n    int64_t * v24 = (int64_t *)(v22 + 8 * (v5 - v12)); // 0x405633\n    *v23 = *v24;\n    *v24 = *v23;\n    v22 += 8;\n    while (v22 != 8 * ((v16 + 0xffffffff & 0xffffffff) + v12) + v7) {\n        // 0x405630\n        v23 = (int64_t *)v22;\n        v24 = (int64_t *)(v22 + 8 * (v5 - v12));\n        *v23 = *v24;\n        *v24 = *v23;\n        v22 += 8;\n    }\n    // 0x405647\n    v8 = v16 + v8 & 0xffffffff;\n    while (v15 > v5) {\n        // 0x40559d\n        v9 = v5 - v8;\n        v10 = v9 & 0xffffffff;\n        v11 = 0x100000000 * v8;\n        v12 = v11 >> 32;\n        v13 = (v11 >> 29) + a1;\n        v14 = 8 * ((v9 + 0xffffffff & 0xffffffff) + v12) + v7;\n        if (v8 >= v5) {\n            // break (via goto) -> 0x4055ec\n            goto lab_0x4055ec_2;\n        }\n        // 0x4055a2\n        v16 = v15 - v5;\n        while ((v16 & 0xffffffff) > v10) {\n            // 0x4055b3\n            v17 = v15 - v10;\n            v20 = v13;\n            v18 = (int64_t *)v20;\n            v19 = (int64_t *)(v20 + 8 * ((0x100000000 * v17 >> 32) - v12));\n            *v18 = *v19;\n            *v19 = *v18;\n            v20 += 8;\n            while (v14 != v20) {\n                // 0x4055d0\n                v18 = (int64_t *)v20;\n                v19 = (int64_t *)(v20 + 8 * ((0x100000000 * v17 >> 32) - v12));\n                *v18 = *v19;\n                *v19 = *v18;\n                v20 += 8;\n            }\n            // 0x4055e7\n            v21 = v17 & 0xffffffff;\n            if (v21 <= v5) {\n                // break (via goto) -> 0x4055ec\n                goto lab_0x4055ec_2;\n            }\n            if (v8 >= v5) {\n                // break (via goto) -> 0x4055ec\n                goto lab_0x4055ec_2;\n            }\n            // 0x4055a2\n            v15 = v21;\n            v16 = v15 - v5;\n        }\n        // 0x405610\n        v22 = v13;\n        v23 = (int64_t *)v22;\n        v24 = (int64_t *)(v22 + 8 * (v5 - v12));\n        *v23 = *v24;\n        *v24 = *v23;\n        v22 += 8;\n        while (v22 != 8 * ((v16 + 0xffffffff & 0xffffffff) + v12) + v7) {\n            // 0x405630\n            v23 = (int64_t *)v22;\n            v24 = (int64_t *)(v22 + 8 * (v5 - v12));\n            *v23 = *v24;\n            *v24 = *v23;\n            v22 += 8;\n        }\n        // 0x405647\n        v8 = v16 + v8 & 0xffffffff;\n    }\n    // 0x4055ec\n    *v4 = (int32_t)a2;\n    v6 = v3 - v5;\n    *v1 = v2 + (int32_t)v6;\n    return v6 & 0xffffffff;\n}\n"
        },
        {
            "funcName": "function_405650",
            "funcStartAddr": "405650",
            "funcEndAddr": "405c6c",
            "decompiledFuncCode": "int64_t function_405650(int64_t a1, int64_t a2, int64_t str5, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t * a9) {\n    int64_t * v1 = (int64_t *)(a7 + 32); // 0x40566f\n    int64_t v2 = *v1; // 0x40566f\n    char * str2 = (char *)v2; // 0x40567c\n    char c = *str2; // 0x40567c\n    int64_t v3 = v2; // 0x4056a8\n    int64_t v4 = 0; // 0x405650\n    int32_t v5; // 0x405650\n    int64_t v6; // 0x405650\n    int64_t v7; // 0x405650\n    int64_t v8; // 0x405650\n    int64_t v9; // 0x405650\n    int64_t v10; // 0x405650\n    int64_t v11; // 0x405650\n    int64_t v12; // 0x405650\n    int64_t v13; // 0x405650\n    int64_t str3; // 0x405650\n    int64_t v14; // 0x405650\n    int64_t v15; // 0x405650\n    int64_t v16; // 0x405650\n    int64_t v17; // 0x405650\n    int32_t v18; // 0x405650\n    int32_t v19; // 0x405650\n    int32_t v20; // 0x405650\n    int32_t v21; // 0x405650\n    int32_t v22; // 0x405650\n    int32_t v23; // 0x405650\n    int32_t v24; // 0x405650\n    int32_t v25; // 0x405650\n    int32_t v26; // 0x405650\n    int32_t v27; // 0x405650\n    int32_t v28; // 0x405650\n    int32_t v29; // 0x405650\n    int64_t nmemb; // 0x405650\n    int64_t v30; // 0x405650\n    switch (c) {\n        default: {\n            v3++;\n            char v31 = *(char *)v3; // 0x4056ac\n            while (v31 != 0 == (v31 != 61)) {\n                // 0x4056a8\n                v3++;\n                v31 = *(char *)v3;\n            }\n            // 0x4056b8\n            v4 = v3 - v2;\n        }\n        case 61: {\n        }\n        case 0: {\n            // 0x4056be\n            v30 = 0x100000000 * a8 >> 32;\n            int64_t v32 = 0x100000000 * a6 >> 32; // 0x405688\n            if (a4 != 0) {\n                int32_t n = v4;\n                int64_t v33 = 0;\n                char * str = (char *)a4; // 0x4056ec\n                int64_t v34; // 0x405650\n                int64_t v35; // 0x405650\n                if (strncmp(str, str2, n) == 0) {\n                    // 0x4056f5\n                    v35 = a4;\n                    v34 = v33;\n                    if (v4 == (int64_t)strlen(str)) {\n                        goto lab_0x405870;\n                    }\n                }\n                int64_t v36 = a4 + 32; // 0x405706\n                int64_t v37 = *(int64_t *)v36; // 0x40570a\n                nmemb = v33 + 1;\n                while (v37 != 0) {\n                    // 0x4056e0\n                    v33 = 0x100000000 * nmemb >> 32;\n                    int64_t v38 = v36;\n                    str = (char *)v37;\n                    if (strncmp(str, str2, n) == 0) {\n                        // 0x4056f5\n                        v35 = v38;\n                        v34 = v33;\n                        if (v4 == (int64_t)strlen(str)) {\n                            goto lab_0x405870;\n                        }\n                    }\n                    // 0x405706\n                    v36 = v38 + 32;\n                    v37 = *(int64_t *)v36;\n                    nmemb = v33 + 1;\n                }\n                int32_t v39 = v32;\n                v22 = -1;\n                v26 = 0;\n                v18 = 0;\n                v14 = 0;\n                v10 = 0;\n                v8 = a4;\n                str3 = a4;\n                v6 = 0;\n                while (true) {\n                  lab_0x405756:\n                    // 0x405756\n                    v7 = v6;\n                    v9 = v8;\n                    v11 = v10;\n                    v15 = v14;\n                    v19 = v18;\n                    v27 = v26;\n                    v23 = v22;\n                    v24 = v23;\n                    v28 = v27;\n                    v20 = v19;\n                    v16 = v15;\n                    v12 = v11;\n                    if (strncmp((char *)str3, str2, n) != 0) {\n                        goto lab_0x4057b0;\n                    } else {\n                        if (v11 == 0) {\n                            // 0x405920\n                            v24 = v7;\n                            v28 = v27;\n                            v20 = v19;\n                            v16 = v15;\n                            v12 = v9;\n                            goto lab_0x4057b0;\n                        } else {\n                            if (v39 == 0) {\n                                // 0x4058d0\n                                if (*(int32_t *)(v11 + 8) != *(int32_t *)(v9 + 8)) {\n                                    goto lab_0x40577a;\n                                } else {\n                                    // 0x4058dc\n                                    if (*(int64_t *)(v11 + 16) != *(int64_t *)(v9 + 16)) {\n                                        goto lab_0x40577a;\n                                    } else {\n                                        // 0x4058ea\n                                        v24 = v23;\n                                        v28 = v27;\n                                        v20 = v19;\n                                        v16 = v15;\n                                        v12 = v11;\n                                        if (*(int32_t *)(v11 + 24) != *(int32_t *)(v9 + 24)) {\n                                            goto lab_0x40577a;\n                                        } else {\n                                            goto lab_0x4057b0;\n                                        }\n                                    }\n                                }\n                            } else {\n                                goto lab_0x40577a;\n                            }\n                        }\n                    }\n                }\n              lab_0x4057c1:\n                if (v29 == 0 != (v17 == 0)) {\n                    int64_t v40 = v2; // 0x405996\n                    if ((int32_t)v30 != 0) {\n                        if (v29 == 0) {\n                            // 0x405b42\n                            flockfile(g35);\n                            int64_t v41 = *v1; // 0x405b62\n                            __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option '%s%s' is ambiguous; possibilities:\", 5), \"%s: option '%s%s' is ambiguous; possibilities:\", a9, (char *)v41);\n                            int64_t v42 = v17; // 0x405baf\n                            int64_t v43 = (int64_t)g35;\n                            int64_t v44 = v43; // 0x405bc9\n                            int64_t v45; // 0x405bcb\n                            if (*(char *)v42 != 0) {\n                                // 0x405bcb\n                                v45 = *(int64_t *)a4;\n                                __fprintf_chk((struct _IO_FILE *)v43, 1, \" '%s%s'\", a9, (char *)v45);\n                                v44 = (int64_t)g35;\n                            }\n                            int64_t stream = v44;\n                            v42++;\n                            int64_t v46 = a4 + 32; // 0x405bc3\n                            while (v17 + nmemb != v42) {\n                                // 0x405bc5\n                                v43 = stream;\n                                int64_t v47 = v46;\n                                v44 = v43;\n                                if (*(char *)v42 != 0) {\n                                    // 0x405bcb\n                                    v45 = *(int64_t *)v47;\n                                    __fprintf_chk((struct _IO_FILE *)v43, 1, \" '%s%s'\", a9, (char *)v45);\n                                    v44 = (int64_t)g35;\n                                }\n                                // 0x405bb8\n                                stream = v44;\n                                v42++;\n                                v46 = v47 + 32;\n                            }\n                            // 0x405bf0\n                            fputc(10, (struct _IO_FILE *)stream);\n                            funlockfile(g35);\n                            v40 = *v1;\n                        } else {\n                            // 0x4059a4\n                            __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option '%s%s' is ambiguous\\n\", 5), \"%s: option '%s%s' is ambiguous\\n\", a9, str2);\n                            v40 = *v1;\n                        }\n                    }\n                    int64_t str4 = v40;\n                    if (v21 != 0) {\n                        // 0x405aff\n                        free((int64_t *)v17);\n                    }\n                    // 0x4059f9\n                    *v1 = str4 + (int64_t)strlen((char *)str4);\n                    int32_t * v48 = (int32_t *)a7; // 0x405a10\n                    *v48 = *v48 + 1;\n                    *(int32_t *)(a7 + 8) = 0;\n                    // 0x4058be\n                    return 63;\n                }\n                // 0x4057e0\n                v5 = v39;\n                if (v13 != 0) {\n                    // 0x405864\n                    v35 = v13;\n                    v34 = v25;\n                  lab_0x405870:;\n                    int32_t * v49 = (int32_t *)a7; // 0x405880\n                    uint32_t v50 = *v49; // 0x405880\n                    int64_t v51 = v50; // 0x405880\n                    *v1 = 0;\n                    uint32_t v52 = v50 + 1; // 0x40588a\n                    *v49 = v52;\n                    int32_t v53 = *(int32_t *)(v35 + 8); // 0x405893\n                    if (*(char *)v3 != 0) {\n                        if (v53 == 0) {\n                            if ((int32_t)v30 != 0) {\n                                int64_t v54 = *(int64_t *)v35; // 0x405abf\n                                __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option '%s%s' doesn't allow an argument\\n\", 5), \"%s: option '%s%s' doesn't allow an argument\\n\", a9, (char *)v54);\n                            }\n                            // 0x405a6a\n                            *(int32_t *)(a7 + 8) = *(int32_t *)(v35 + 24);\n                            // 0x4058be\n                            return 63;\n                        }\n                        // 0x405908\n                        *(int64_t *)(a7 + 16) = v3 + 1;\n                    } else {\n                        if (v53 == 1) {\n                            if (v52 >= (int32_t)a1) {\n                                if ((int32_t)v30 != 0) {\n                                    int64_t v55 = *(int64_t *)v35; // 0x405c1f\n                                    __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option '%s%s' requires an argument\\n\", 5), \"%s: option '%s%s' requires an argument\\n\", a9, (char *)v55);\n                                }\n                                // 0x405b1d\n                                *(int32_t *)(a7 + 8) = *(int32_t *)(v35 + 24);\n                                char v56 = *(char *)&v51; // 0x405b30\n                                // 0x4058be\n                                return 4 * (int64_t)(v56 != 58) | (v56 != 58 ? 59 : 58);\n                            }\n                            // 0x405a2e\n                            *v49 = (int32_t)v51 + 2;\n                            int64_t v57 = *(int64_t *)((0x100000000 * (int64_t)v52 >> 29) + a2); // 0x405a42\n                            *(int64_t *)(a7 + 16) = v57;\n                        }\n                    }\n                    if (a5 != 0) {\n                        // 0x4058ab\n                        *(int32_t *)a5 = (int32_t)v34;\n                    }\n                    int64_t v58 = *(int64_t *)(v35 + 16); // 0x4058ae\n                    v51 = v58;\n                    uint32_t v59 = *(int32_t *)(v35 + 24); // 0x4058b2\n                    int64_t result = v59; // 0x4058b8\n                    if (v58 != 0) {\n                        // 0x4058ba\n                        *(int32_t *)v58 = v59;\n                        result = 0;\n                    }\n                    // 0x4058be\n                    return result;\n                }\n            } else {\n                // 0x4056be\n                v5 = v32;\n            }\n            // break -> 0x4057e5\n            break;\n        }\n    }\n    // 0x4057e5\n    if (v5 != 0) {\n        int64_t v60 = *(int64_t *)(8 * (int64_t)*(int32_t *)a7 + a2); // 0x4057fd\n        if (*(char *)(v60 + 1) != 45) {\n            // 0x405807\n            if (strchr((char *)str5, (int32_t)c) != NULL) {\n                // 0x4058be\n                return 0xffffffff;\n            }\n        }\n    }\n    if ((int32_t)v30 != 0) {\n        // 0x405949\n        __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: unrecognized option '%s%s'\\n\", 5), \"%s: unrecognized option '%s%s'\\n\", a9, str2);\n    }\n    // 0x405836\n    *v1 = 0;\n    int32_t * v61 = (int32_t *)a7; // 0x405846\n    *v61 = *v61 + 1;\n    *(int32_t *)(a7 + 8) = 0;\n    return 63;\n  lab_0x4057b0:\n    // 0x4057b0\n    v13 = v12;\n    v17 = v16;\n    v21 = v20;\n    v29 = v28;\n    v25 = v24;\n    int64_t v62 = v9 + 32; // 0x4057b0\n    int64_t v63 = *(int64_t *)v62; // 0x4057b4\n    v22 = v25;\n    v26 = v29;\n    v18 = v21;\n    v14 = v17;\n    v10 = v13;\n    v8 = v62;\n    str3 = v63;\n    v6 = v7 + 1;\n    if (v63 == 0) {\n        // break -> 0x4057c1\n        goto lab_0x4057c1;\n    }\n    goto lab_0x405756;\n  lab_0x40577a:\n    // 0x40577a\n    v24 = v23;\n    v28 = v27;\n    v20 = v19;\n    v16 = v15;\n    v12 = v11;\n    int64_t v64; // 0x405650\n    int32_t v65; // 0x405650\n    int32_t v66; // 0x405650\n    if (v27 != 0) {\n        goto lab_0x4057b0;\n    } else {\n        if ((int32_t)v30 == 0) {\n            // 0x405930\n            v66 = 1;\n            v65 = v19;\n            v64 = v15;\n            v24 = v23;\n            v28 = 1;\n            v20 = v19;\n            v16 = 0;\n            v12 = v11;\n            if (v15 == 0) {\n                goto lab_0x4057b0;\n            } else {\n                goto lab_0x4057a1;\n            }\n        } else {\n            // 0x405795\n            v66 = v27;\n            v65 = v19;\n            v64 = v15;\n            if (v15 == 0) {\n                int64_t * mem = calloc((int32_t)nmemb, 1); // 0x405a8c\n                int64_t v67 = (int64_t)mem; // 0x405a8c\n                v24 = v23;\n                v28 = 1;\n                v20 = v19;\n                v16 = v67;\n                v12 = v11;\n                if (mem == NULL) {\n                    goto lab_0x4057b0;\n                } else {\n                    // 0x405a9f\n                    *(char *)(v67 + (int64_t)v23) = 1;\n                    v66 = v27;\n                    v65 = 1;\n                    v64 = v67;\n                    goto lab_0x4057a1;\n                }\n            } else {\n                goto lab_0x4057a1;\n            }\n        }\n    }\n  lab_0x4057a1:\n    // 0x4057a1\n    *(char *)(v64 + v7) = 1;\n    v24 = v23;\n    v28 = v66;\n    v20 = v65;\n    v16 = v64;\n    v12 = v11;\n    goto lab_0x4057b0;\n}\n"
        },
        {
            "funcName": "function_405c70",
            "funcStartAddr": "405c70",
            "funcEndAddr": "406236",
            "decompiledFuncCode": "int64_t function_405c70(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t * a7, int64_t a8) {\n    int64_t v1 = (int64_t)a7;\n    int64_t v2 = a3;\n    int32_t v3 = a1; // 0x405c91\n    if (v3 < 1) {\n        // 0x405e4e\n        return 0xffffffff;\n    }\n    int64_t v4 = (int64_t)*(int32_t *)(v1 + 4); // 0x405c8d\n    int32_t v5 = *(int32_t *)a7; // 0x405c99\n    uint64_t v6 = a1 & 0xffffffff; // 0x405c9b\n    int64_t v7 = v2; // 0x405ca0\n    int64_t * v8 = (int64_t *)(v1 + 16); // 0x405ca3\n    *v8 = 0;\n    int64_t v9; // 0x405c70\n    int64_t v10; // 0x405c70\n    int64_t v11; // 0x405c70\n    int64_t v12; // 0x405c70\n    int64_t str; // 0x405c70\n    int64_t v13; // 0x405c70\n    int64_t v14; // 0x405c70\n    int64_t v15; // 0x405c70\n    int64_t v16; // 0x405c70\n    int64_t v17; // 0x405c70\n    int32_t v18; // 0x405c70\n    char v19; // 0x405c70\n    if (v5 == 0) {\n        // 0x405e88\n        *(int32_t *)a7 = 1;\n        v18 = 1;\n        goto lab_0x405cba;\n    } else {\n        // 0x405cb3\n        v18 = v5;\n        if (*(int32_t *)(v1 + 24) != 0) {\n            char v20 = *(char *)&v2; // 0x405d00\n            int64_t v21 = *(int64_t *)(v1 + 32); // 0x405d03\n            v2 = v21;\n            v9 = v21;\n            v19 = v20;\n            v16 = a6;\n            v13 = v7;\n            if ((v20 - 43 & -3) != 0) {\n                goto lab_0x405dc8;\n            } else {\n                int64_t v22 = v7 + 1; // 0x405d16\n                int64_t v23 = *(char *)v22 == 58 ? 0 : v4; // 0x405d26\n                v15 = a6;\n                v11 = v23;\n                str = v22;\n                v10 = v21;\n                v17 = a6;\n                v12 = v23;\n                v14 = v22;\n                if (v21 != 0) {\n                    goto lab_0x405ddc;\n                } else {\n                    goto lab_0x405d38;\n                }\n            }\n        } else {\n            goto lab_0x405cba;\n        }\n    }\n  lab_0x405cba:\n    // 0x405cba\n    *(int32_t *)(v1 + 48) = v18;\n    *(int32_t *)(v1 + 44) = v18;\n    int64_t * v24 = (int64_t *)(v1 + 32); // 0x405cc0\n    *v24 = 0;\n    int64_t v25; // 0x405c70\n    int64_t v26; // 0x405c70\n    int64_t v27; // 0x405c70\n    switch (*(char *)&v2) {\n        case 45: {\n            // 0x405db0\n            *(int32_t *)(v1 + 40) = 2;\n            v2 = 0;\n            v27 = a6;\n            v25 = v7 + 1;\n            goto lab_0x405dbd;\n        }\n        case 43: {\n            // 0x4060c0\n            *(int32_t *)(v1 + 40) = 0;\n            v2 = 0;\n            v27 = a6;\n            v25 = v7 + 1;\n            goto lab_0x405dbd;\n        }\n        default: {\n            // 0x405cdc\n            v2 = 0;\n            v26 = a6;\n            if ((int32_t)a8 == 0) {\n                int64_t v28 = a6 & 0xffffffff; // 0x40603f\n                if (getenv(\"POSIXLY_CORRECT\") == NULL) {\n                    // 0x406158\n                    *(int32_t *)(v1 + 40) = 1;\n                    v2 = *v24;\n                    v27 = v28;\n                    v25 = v7;\n                    goto lab_0x405dbd;\n                } else {\n                    // 0x40604d\n                    v2 = *v24;\n                    v26 = v28;\n                    goto lab_0x405cea;\n                }\n            } else {\n                goto lab_0x405cea;\n            }\n        }\n    }\n  lab_0x405dc8:;\n    int64_t v29 = v19 == 58 ? 0 : v4; // 0x405dcf\n    v15 = v16;\n    v11 = v29;\n    str = v13;\n    v10 = v9;\n    v17 = v16;\n    v12 = v29;\n    v14 = v13;\n    if (v9 == 0) {\n        goto lab_0x405d38;\n    } else {\n        goto lab_0x405ddc;\n    }\n  lab_0x405cea:\n    // 0x405cea\n    *(int32_t *)(v1 + 40) = 0;\n    v27 = v26;\n    v25 = v7;\n    goto lab_0x405dbd;\n  lab_0x405dbd:\n    // 0x405dbd\n    *(int32_t *)(v1 + 24) = 1;\n    v9 = v2;\n    v19 = *(char *)v25;\n    v16 = v27;\n    v13 = v25;\n    goto lab_0x405dc8;\n  lab_0x405d38:;\n    uint32_t v30 = *(int32_t *)a7; // 0x405d38\n    int64_t v31 = v30; // 0x405d38\n    int32_t * v32 = (int32_t *)(v1 + 48); // 0x405d3a\n    if ((int64_t)*v32 > v31) {\n        // 0x405d3f\n        *v32 = v30;\n    }\n    int32_t * v33 = (int32_t *)(v1 + 44); // 0x405d42\n    if (*v33 > v30) {\n        // 0x405d47\n        *v33 = v30;\n    }\n    int32_t * v34 = (int32_t *)(v1 + 40); // 0x405d4a\n    int64_t v35 = v31; // 0x405d4e\n    int64_t v36 = v15; // 0x405d4e\n    int64_t v37; // 0x405c70\n    int64_t v38; // 0x405c70\n    int64_t v39; // 0x405c70\n    if (*v34 == 1) {\n        uint32_t v40 = *v32; // 0x405eb8\n        int64_t v41 = v40; // 0x405eb8\n        v2 = v41;\n        int64_t v42; // 0x405c70\n        if (*v33 == v40) {\n            // 0x4060a0\n            v42 = v41;\n            v38 = v15;\n            if (v30 != v40) {\n                // 0x4060a8\n                *v33 = v30;\n                v2 = v31;\n                v42 = v31;\n                v38 = v15;\n            }\n        } else {\n            // 0x405ec4\n            v42 = v41;\n            v38 = v15;\n            if (v30 != v40) {\n                // 0x405ec8\n                function_405570(a2, v1);\n                int64_t v43 = (int64_t)*(int32_t *)a7; // 0x405ed8\n                v2 = v43;\n                v42 = v43;\n                v38 = v15 & 0xffffffff;\n            }\n        }\n        int64_t v44 = v42; // 0x405ee1\n        if (v6 > v42) {\n            int64_t v45 = 0x100000000 * v42 >> 32; // 0x405eea\n            int64_t v46 = *(int64_t *)(8 * v45 + a2); // 0x405f01\n            int64_t v47 = v45 & 0xffffffff; // 0x405f05\n            v2 = v47;\n            if (*(char *)v46 == 45) {\n                // 0x405f0e\n                if (*(char *)(v46 + 1) != 0) {\n                    // 0x405f14\n                    v37 = v47;\n                    v39 = (int64_t)*(int32_t *)a7;\n                    goto lab_0x405f16;\n                }\n            }\n            int64_t v48 = v47 + 1; // 0x405ef0\n            int64_t v49 = v48 & 0xffffffff; // 0x405ef0\n            v2 = v49;\n            v45++;\n            *(int32_t *)a7 = (int32_t)v48;\n            v44 = v49;\n            while (v6 > v45) {\n                // 0x405f01\n                v46 = *(int64_t *)(8 * v45 + a2);\n                v47 = v45 & 0xffffffff;\n                v2 = v47;\n                if (*(char *)v46 == 45) {\n                    // 0x405f0e\n                    if (*(char *)(v46 + 1) != 0) {\n                        // 0x405f14\n                        v37 = v47;\n                        v39 = (int64_t)*(int32_t *)a7;\n                        goto lab_0x405f16;\n                    }\n                }\n                // 0x405ef0\n                v48 = v47 + 1;\n                v49 = v48 & 0xffffffff;\n                v2 = v49;\n                v45++;\n                *(int32_t *)a7 = (int32_t)v48;\n                v44 = v49;\n            }\n        }\n        // 0x4060b8\n        v37 = v44;\n        v39 = v44 & 0xffffffff;\n        goto lab_0x405f16;\n    } else {\n        goto lab_0x405d54;\n    }\n  lab_0x405ddc:\n    // 0x405ddc\n    v15 = v17;\n    v11 = v12;\n    str = v14;\n    int64_t v50 = v10; // 0x405ddf\n    int64_t v51 = v12; // 0x405ddf\n    int64_t v52 = v14; // 0x405ddf\n    if (*(char *)v10 == 0) {\n        goto lab_0x405d38;\n    } else {\n        goto lab_0x405de5;\n    }\n  lab_0x405d54:;\n    int32_t v53 = v35; // 0x405d54\n    int64_t v54; // 0x405c70\n    int64_t v55; // 0x405c70\n    int64_t v56; // 0x405c70\n    int64_t v57; // 0x405c70\n    int64_t v58; // 0x405c70\n    int64_t v59; // 0x405c70\n    char * v60; // 0x405c70\n    int64_t v61; // 0x405c70\n    int64_t v62; // 0x405d69\n    int64_t v63; // 0x405c70\n    if (v3 == v53) {\n        int64_t v64 = (int64_t)*v33; // 0x405ea3\n        v2 = v64;\n        v55 = v64;\n        v59 = (int64_t)*v32;\n        goto lab_0x405ea6;\n    } else {\n        // 0x405d5c\n        v62 = *(int64_t *)((0x100000000 * v35 >> 29) + a2);\n        bool v65; // 0x405c70\n        int64_t v66 = v65 ? -1 : 1; // 0x405d70\n        int64_t v67 = (int64_t)\"--\"; // 0x405c70\n        int64_t v68 = v62; // 0x405c70\n        int64_t v69 = 3; // 0x405d70\n        unsigned char v70 = *(char *)v68; // 0x405d70\n        char v71 = *(char *)v67; // 0x405d70\n        char v72 = v71; // 0x405d70\n        bool v73 = false; // 0x405d70\n        while (v70 == v71) {\n            v69--;\n            v67 += v66;\n            v68 += v66;\n            v72 = v70;\n            v73 = true;\n            if (v69 == 0) {\n                // break -> \n                break;\n            }\n            v70 = *(char *)v68;\n            v71 = *(char *)v67;\n            v72 = v71;\n            v73 = false;\n        }\n        unsigned char v74 = v72;\n        if ((v70 >= v74 && !v73) != v70 < v74) {\n            // 0x405e60\n            if (*(char *)v62 == 45) {\n                // 0x405f20\n                v63 = v62 + 1;\n                char c = *(char *)v63; // 0x405f20\n                if (c == 0) {\n                    goto lab_0x405e6a;\n                } else {\n                    // 0x405f2d\n                    v54 = v63;\n                    if (a4 == 0) {\n                        goto lab_0x405fb0;\n                    } else {\n                        if (c == 45) {\n                            // 0x406193\n                            *(int64_t *)(v1 + 32) = v62 + 2;\n                            v60 = \"--\";\n                            v61 = v11;\n                            v58 = v36;\n                            v56 = str;\n                            goto lab_0x406005;\n                        } else {\n                            // 0x405f3e\n                            v54 = v63;\n                            if ((int32_t)v36 == 0) {\n                                goto lab_0x405fb0;\n                            } else {\n                                // 0x405f43\n                                v57 = v36;\n                                if (*(char *)(v62 + 2) != 0) {\n                                    goto lab_0x405f64;\n                                } else {\n                                    // 0x405f4a\n                                    v57 = v36 & 0xffffffff;\n                                    v54 = v63;\n                                    if (strchr((char *)str, (int32_t)c) != NULL) {\n                                        goto lab_0x405fb0;\n                                    } else {\n                                        goto lab_0x405f64;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                goto lab_0x405e6a;\n            }\n        } else {\n            uint32_t v75 = *v33; // 0x405d80\n            v2 = v75;\n            int32_t v76 = *v32; // 0x405d83\n            int64_t v77 = v35 + 1; // 0x405d86\n            int32_t v78 = v77; // 0x405d89\n            *(int32_t *)a7 = v78;\n            if (v75 == v76) {\n                // 0x4060f0\n                *v33 = v78;\n                v2 = v77 & 0xffffffff;\n            } else {\n                if (v76 != v78) {\n                    // 0x405d97\n                    function_405570(a2, v1);\n                    v2 = (int64_t)*v33;\n                }\n            }\n            // 0x405da5\n            *v32 = v3;\n            *(int32_t *)a7 = v3;\n            v55 = v2;\n            v59 = v6;\n            goto lab_0x405ea6;\n        }\n    }\n  lab_0x405de5:;\n    // 0x405de5\n    int64_t v79; // bp-104, 0x405c70\n    int64_t v80 = &v79; // 0x405c7a\n    int64_t v81 = v50 + 1; // 0x405de5\n    int64_t * v82 = (int64_t *)(v80 + 32); // 0x405dec\n    *v82 = v50;\n    int64_t * v83 = (int64_t *)(v1 + 32); // 0x405df1\n    *v83 = v81;\n    char v84 = *(char *)v2; // 0x405df5\n    int64_t * v85 = (int64_t *)(v80 + 40); // 0x405df9\n    *v85 = v81;\n    char * v86 = (char *)(v80 + 28); // 0x405e01\n    *v86 = v84;\n    char * str2 = (char *)v52; // 0x405e06\n    int32_t c2 = v84; // 0x405e06\n    char * found_char_pos = strchr(str2, c2); // 0x405e06\n    int64_t v87 = *v82; // 0x405e0b\n    v2 = v87;\n    int64_t v88 = *v85; // 0x405e15\n    char * v89 = (char *)(v87 + 1);\n    if (*v89 == 0) {\n        // 0x405e20\n        *(int32_t *)a7 = *(int32_t *)a7 + 1;\n    }\n    if (found_char_pos == NULL | (*v86 | 1) == 59) {\n        if ((int32_t)v51 != 0) {\n            // 0x406110\n            __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: invalid option -- '%c'\\n\", 5));\n        }\n        // 0x4060dd\n        *(int32_t *)(v1 + 8) = c2;\n        // 0x405e4e\n        return 63;\n    }\n    int64_t v90 = (int64_t)found_char_pos; // 0x405e06\n    char v91 = *(char *)(v90 + 1); // 0x405e3b\n    if (a4 == 0 | *found_char_pos != 87 || v91 != 59) {\n        int64_t v92 = v84; // 0x405df5\n        if (v91 != 58) {\n            // 0x405e4e\n            return v92 & 0xffffffff;\n        }\n        unsigned char v93 = *v89; // 0x406064\n        v2 = v93;\n        if (*(char *)(v90 + 2) == 58) {\n            if (v93 == 0) {\n                // 0x406168\n                *v8 = 0;\n            } else {\n                // 0x40614c\n                *v8 = v88;\n                *(int32_t *)a7 = *(int32_t *)a7 + 1;\n            }\n            // 0x40608e\n            *v83 = 0;\n            // 0x405e4e\n            return v92 & 0xffffffff;\n        }\n        int32_t v94 = *(int32_t *)a7; // 0x40606e\n        if (v93 != 0) {\n            // 0x406100\n            *v8 = v88;\n            *(int32_t *)a7 = v94 + 1;\n            // 0x40608e\n            *v83 = 0;\n            // 0x405e4e\n            return v92 & 0xffffffff;\n        }\n        if (v94 != v3) {\n            // 0x406081\n            *(int32_t *)a7 = v94 + 1;\n            *v8 = *(int64_t *)(8 * (int64_t)v94 + a2);\n            // 0x40608e\n            *v83 = 0;\n            // 0x405e4e\n            return v92 & 0xffffffff;\n        }\n        if ((int32_t)v51 != 0) {\n            // 0x4061ca\n            __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option requires an argument -- '%c'\\n\", 5));\n        }\n        // 0x40617a\n        *(int32_t *)(v1 + 8) = c2;\n        char v95 = *str2; // 0x406181\n        // 0x40608e\n        *v83 = 0;\n        // 0x405e4e\n        return (4 * (int64_t)(v95 != 58) | (v95 != 58 ? 59 : 58)) & 0xffffffff;\n    }\n    int64_t v96 = v88; // 0x405fd9\n    if (*v89 == 0) {\n        int32_t v97 = *(int32_t *)a7; // 0x405fdb\n        if (v97 == v3) {\n            if ((int32_t)v51 != 0) {\n                // 0x406200\n                __fprintf_chk(g35, 1, dcgettext(NULL, \"%s: option requires an argument -- '%c'\\n\", 5));\n            }\n            // 0x4061b1\n            *(int32_t *)(v1 + 8) = c2;\n            char v98 = *str2; // 0x4061b8\n            // 0x405e4e\n            return (4 * (int64_t)(v98 != 58) | (v98 != 58 ? 59 : 58)) & 0xffffffff;\n        }\n        // 0x405fe6\n        v96 = *(int64_t *)(8 * (int64_t)v97 + a2);\n    }\n    // 0x405fea\n    *v83 = v96;\n    *v8 = 0;\n    v60 = \"-W \";\n    v61 = v51;\n    v58 = 0;\n    v56 = v52;\n    goto lab_0x406005;\n  lab_0x405f16:\n    // 0x405f16\n    *v32 = (int32_t)v37;\n    v35 = v39;\n    v36 = v38;\n    goto lab_0x405d54;\n  lab_0x406005:;\n    int64_t v99 = function_405650(v6, a2, v56, a4, a5, v58, v1, v61, (int64_t *)v60) & 0xffffffff; // 0x406023\n    // 0x405e4e\n    return v99 & 0xffffffff;\n  lab_0x405ea6:;\n    int32_t v100 = v55; // 0x405ea6\n    if (v100 != (int32_t)v59) {\n        // 0x405eaa\n        *(int32_t *)a7 = v100;\n    }\n    // 0x405e4e\n    return 0xffffffff;\n  lab_0x405e6a:\n    // 0x405e6a\n    v99 = 0xffffffff;\n    if (*v34 != 0) {\n        // 0x405e71\n        *v8 = v62;\n        *(int32_t *)a7 = v53 + 1;\n        v99 = 1;\n    }\n    // 0x405e4e\n    return v99 & 0xffffffff;\n  lab_0x405fb0:\n    // 0x405fb0\n    v2 = v54;\n    v50 = v54;\n    v51 = v11;\n    v52 = str;\n    goto lab_0x405de5;\n  lab_0x405f64:\n    // 0x405f64\n    *(int64_t *)(v1 + 32) = v63;\n    int64_t v101 = function_405650(v6, a2, str, a4, a5, v57, v1, v11, &g12); // 0x405f8a\n    if ((int32_t)v101 != -1) {\n        // 0x405e4e\n        return v101 & 0xffffffff & 0xffffffff;\n    }\n    // 0x405f9f\n    v54 = *(int64_t *)(8 * (int64_t)*(int32_t *)a7 + a2) + 1;\n    goto lab_0x405fb0;\n}\n"
        },
        {
            "funcName": "function_406240",
            "funcStartAddr": "406240",
            "funcEndAddr": "406296",
            "decompiledFuncCode": "int64_t function_406240(int64_t a1) {\n    // 0x406240\n    *(int32_t *)&g53 = g29;\n    *(int32_t *)&g54 = g28;\n    int64_t v1; // 0x406240\n    int64_t result = function_405c70(v1, v1, v1, v1, v1, v1, &g53, a1 & 0xffffffff); // 0x406266\n    g29 = *(int32_t *)&g53;\n    g58 = g56;\n    *(int32_t *)&g27 = g55;\n    return result;\n}\n"
        },
        {
            "funcName": "function_4062a0",
            "funcStartAddr": "4062a0",
            "funcEndAddr": "4062b8",
            "decompiledFuncCode": "int64_t function_4062a0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    // 0x4062a0\n    return function_406240(1);\n}\n"
        },
        {
            "funcName": "function_4062c0",
            "funcStartAddr": "4062c0",
            "funcEndAddr": "4062d3",
            "decompiledFuncCode": "int64_t function_4062c0(int64_t a1, int64_t a2, char * a3, char (**a4)[11], int32_t a5, int64_t a6) {\n    // 0x4062c0\n    return function_406240(0);\n}\n"
        },
        {
            "funcName": "function_4062e0",
            "funcStartAddr": "4062e0",
            "funcEndAddr": "4062f5",
            "decompiledFuncCode": "int64_t function_4062e0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    // 0x4062e0\n    return function_405c70(a1, a2, a3, a4, a5, 0, (int64_t *)a6, 0);\n}\n"
        },
        {
            "funcName": "function_406300",
            "funcStartAddr": "406300",
            "funcEndAddr": "406316",
            "decompiledFuncCode": "int64_t function_406300(void) {\n    // 0x406300\n    return function_406240(0);\n}\n"
        },
        {
            "funcName": "function_406320",
            "funcStartAddr": "406320",
            "funcEndAddr": "406338",
            "decompiledFuncCode": "int64_t function_406320(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {\n    // 0x406320\n    return function_405c70(a1, a2, a3, a4, a5, 1, (int64_t *)a6, 0);\n}\n"
        },
        {
            "funcName": "function_406340",
            "funcStartAddr": "406340",
            "funcEndAddr": "4063ba",
            "decompiledFuncCode": "int64_t function_406340(int32_t * a1, int64_t a2, int64_t a3) {\n    int64_t v1 = 1; // 0x40634b\n    int64_t v2 = (int64_t)&g13; // 0x40634b\n    int32_t * pwc; // 0x406340\n    int64_t v3; // 0x406340\n    int64_t n; // 0x406340\n    if (a2 == 0) {\n        goto lab_0x406392;\n    } else {\n        // 0x40634d\n        if (a3 == 0) {\n            // 0x406378\n            return -2;\n        }\n        // 0x406359\n        n = a3;\n        v3 = a2;\n        pwc = a1;\n        v1 = a3;\n        v2 = a2;\n        if (a1 == NULL) {\n            goto lab_0x406392;\n        } else {\n            goto lab_0x406364;\n        }\n    }\n  lab_0x406392:\n    // 0x406392\n    n = v1;\n    v3 = v2;\n    int64_t v4; // bp-28, 0x406340\n    pwc = (int32_t *)&v4;\n    goto lab_0x406364;\n  lab_0x406364:;\n    char * wstr = (char *)v3; // 0x40636a\n    int64_t ps; // 0x406340\n    int32_t v5 = mbrtowc(pwc, wstr, (int32_t)n, (struct _TYPEDEF___mbstate_t *)ps); // 0x40636a\n    int64_t result = v5; // 0x40636a\n    if (v5 < 0xfffffffe) {\n        // 0x406378\n        return result;\n    }\n    int64_t result2 = result; // 0x4063a9\n    if ((char)function_406650(0, v3) == 0) {\n        // 0x4063ab\n        *pwc = (int32_t)*wstr;\n        result2 = 1;\n    }\n    // 0x406378\n    return result2;\n}\n"
        },
        {
            "funcName": "function_4063c0",
            "funcStartAddr": "4063c0",
            "funcEndAddr": "40651a",
            "decompiledFuncCode": "int64_t function_4063c0(int64_t a1, int32_t * a2) {\n    char v1 = a1;\n    char * str2 = (char *)a1;\n    int64_t str = (int64_t)\"HUP\"; // 0x4063e1\n    int64_t v2; // 0x4063c0\n    int64_t v3; // 0x4063c0\n    int64_t v4; // 0x4063c0\n    int32_t v5; // 0x406450\n    int64_t v6; // 0x406455\n    int32_t v7; // 0x406458\n    int64_t v8; // 0x40645d\n    int64_t v9; // 0x406471\n    bool v10; // 0x4063c0\n    if (v1 != 57 && (int32_t)v1 >= 57) {\n        int64_t v11 = 0;\n        while (strcmp((char *)str, str2) != 0) {\n            int64_t v12 = v11 + 1; // 0x4063e8\n            str += 12;\n            if ((int32_t)v12 == 35) {\n                // 0x406450\n                v5 = __libc_current_sigrtmin();\n                v6 = v5;\n                v7 = __libc_current_sigrtmax();\n                v8 = v7;\n                if (v5 < 1) {\n                    goto lab_0x40647c;\n                } else {\n                    // 0x406464\n                    v9 = v10 ? -1 : 1;\n                    v2 = (int64_t)\"RTMIN\";\n                    v4 = a1;\n                    v3 = 5;\n                    goto lab_dec_label_pc_unknown;\n                }\n            }\n            v11 = v12 & 0xffffffff;\n        }\n        int32_t v13 = *(int32_t *)(12 * v11 + (int64_t)&g31);\n        *a2 = v13;\n        // 0x406414\n        return v13 >> 31;\n    }\n    // 0x406420\n    char * endptr; // bp-48, 0x4063c0\n    int32_t str_as_l = strtol(str2, &endptr, 10); // 0x40642a\n    int32_t v14 = str_as_l; // 0x406437\n    if (str_as_l < 65 == *endptr == 0) {\n      lab_0x40640e:\n        // 0x40640e\n        *a2 = v14;\n        // 0x406414\n        return v14 >> 31;\n    }\n  lab_0x406440:\n    // 0x406440\n    *a2 = -1;\n    // 0x406414\n    return 0xffffffff;\n  lab_0x40647c:;\n    int64_t v15; // 0x4063c0\n    int64_t v16; // 0x4063c0\n    int64_t v17; // 0x4063c0\n    int64_t v18; // 0x40648d\n    if (v7 < 1) {\n        goto lab_0x406440;\n    } else {\n        // 0x406480\n        v18 = v10 ? -1 : 1;\n        v15 = (int64_t)\"RTMAX\";\n        v17 = a1;\n        v16 = 5;\n        goto lab_dec_label_pc_unknown_2;\n    }\n  lab_dec_label_pc_unknown:;\n    unsigned char v19 = *(char *)v4; // 0x406471\n    char v20 = *(char *)v2; // 0x406471\n    char v21 = v20; // 0x406471\n    bool v22 = false; // 0x406471\n    if (v19 == v20) {\n        int64_t v23 = v3 - 1; // 0x406471\n        v2 += v9;\n        v4 += v9;\n        v3 = v23;\n        v21 = v19;\n        v22 = true;\n        if (v23 == 0) {\n            goto lab_dec_label_pc_unknown_4;\n        } else {\n            goto lab_dec_label_pc_unknown;\n        }\n    } else {\n        goto lab_dec_label_pc_unknown_4;\n    }\n  lab_dec_label_pc_unknown_2:;\n    unsigned char v24 = *(char *)v17; // 0x40648d\n    char v25 = *(char *)v15; // 0x40648d\n    char v26 = v25; // 0x40648d\n    bool v27 = false; // 0x40648d\n    if (v24 == v25) {\n        int64_t v28 = v16 - 1; // 0x40648d\n        v15 += v18;\n        v17 += v18;\n        v16 = v28;\n        v26 = v24;\n        v27 = true;\n        if (v28 == 0) {\n            goto lab_dec_label_pc_unknown_6;\n        } else {\n            goto lab_dec_label_pc_unknown_2;\n        }\n    } else {\n        goto lab_dec_label_pc_unknown_6;\n    }\n  lab_dec_label_pc_unknown_4:;\n    unsigned char v29 = v21;\n    if ((v19 >= v29 && !v22) == v19 < v29) {\n        int32_t str_as_l2 = strtol((char *)(a1 + 5), &endptr, 10); // 0x4064e7\n        if (str_as_l2 < 0 | *endptr != 0) {\n            goto lab_0x406440;\n        } else {\n            if (0x100000000 * (v8 - v6) >> 32 < (int64_t)str_as_l2) {\n                goto lab_0x406440;\n            } else {\n                // 0x406512\n                v14 = str_as_l2 + v5;\n                goto lab_0x40640e;\n            }\n        }\n    } else {\n        goto lab_0x40647c;\n    }\n  lab_dec_label_pc_unknown_6:;\n    unsigned char v30 = v26;\n    if ((v24 >= v30 && !v27) != v24 < v30) {\n        goto lab_0x406440;\n    } else {\n        int32_t str_as_l3 = strtol((char *)(a1 + 5), &endptr, 10); // 0x4064a7\n        if (*endptr != 0) {\n            goto lab_0x406440;\n        } else {\n            if (0x100000000 * (v6 - v8) >> 32 > (int64_t)str_as_l3) {\n                goto lab_0x406440;\n            } else {\n                if (str_as_l3 >= 0 == (str_as_l3 != 0)) {\n                    goto lab_0x406440;\n                } else {\n                    // 0x4064ce\n                    v14 = str_as_l3 + v7;\n                    goto lab_0x40640e;\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "funcName": "function_406520",
            "funcStartAddr": "406520",
            "funcEndAddr": "4065ec",
            "decompiledFuncCode": "int64_t function_406520(int64_t a1, int64_t * str, int64_t a3) {\n    int64_t v1 = (int64_t)str;\n    uint64_t v2 = a1 & 0xffffffff; // 0x40652e\n    int32_t v3 = a1;\n    int64_t v4 = (int64_t)&g31; // 0x406530\n    int64_t v5 = 0;\n    int32_t v6; // 0x406520\n    int64_t result; // 0x406520\n    while (*(int32_t *)v4 != v3) {\n        int64_t v7 = v5 + 1; // 0x406538\n        v4 += 12;\n        if ((int32_t)v7 == 35) {\n            int32_t v8 = __libc_current_sigrtmin(); // 0x406568\n            int32_t v9 = __libc_current_sigrtmax(); // 0x406570\n            result = 0xffffffff;\n            if (v2 < (int64_t)v8 || v2 > (int64_t)v9) {\n                return result;\n            } else {\n                if (v2 > (int64_t)((v9 - v8 >> 1) + v8)) {\n                    // 0x40658c\n                    *(int32_t *)str = 0x414d5452;\n                    *(int16_t *)(v1 + 4) = 88;\n                    v6 = v9;\n                    goto lab_0x40659f;\n                } else {\n                    // 0x4065d0\n                    *(int32_t *)str = 0x494d5452;\n                    *(int16_t *)(v1 + 4) = 78;\n                    v6 = v8;\n                    goto lab_0x40659f;\n                }\n            }\n        }\n        v5 = v7 & 0xffffffff;\n    }\n    // 0x406548\n    strcpy((char *)str, (char *)(12 * v5 + (int64_t)\"HUP\"));\n    result = 0;\n  lab_0x40655e:\n    // 0x40655e\n    return result;\n  lab_0x40659f:;\n    uint32_t v10 = v3 - v6; // 0x4065a1\n    result = 0;\n    if (v10 != 0) {\n        // 0x4065a6\n        __sprintf_chk((char *)(v1 + 5), 1, -1, \"%+d\", (int64_t)v10);\n        return 0;\n    }\n    return result;\n}\n"
        },
        {
            "funcName": "function_4065f0",
            "funcStartAddr": "4065f0",
            "funcEndAddr": "40664d",
            "decompiledFuncCode": "int64_t function_4065f0(int64_t a1) {\n    int32_t v1 = __fpending((struct _IO_FILE *)a1); // 0x4065f7\n    int64_t v2; // 0x4065f0\n    int64_t result = function_406c20(a1, v2); // 0x406608\n    if ((v2 & 32) != 0) {\n        // 0x406630\n        if ((int32_t)result == 0) {\n            // 0x406634\n            *__errno_location() = 0;\n        }\n        // 0x40662a\n        return 0xffffffff;\n    }\n    // 0x406611\n    if ((int32_t)result == 0) {\n        // 0x40662a\n        return result;\n    }\n    int64_t result2 = 0xffffffff; // 0x406618\n    if (v1 == 0) {\n        // 0x40661a\n        result2 = *__errno_location() != 9 ? 0xffffffff : 0;\n    }\n    // 0x40662a\n    return result2;\n}\n"
        },
        {
            "funcName": "function_406650",
            "funcStartAddr": "406650",
            "funcEndAddr": "4066ae",
            "decompiledFuncCode": "int64_t function_406650(int32_t locale_category, int64_t a2) {\n    char * locale = setlocale(locale_category, NULL); // 0x406656\n    if (locale == NULL) {\n        // 0x406683\n        return 1;\n    }\n    int64_t v1 = (int64_t)locale; // 0x406656\n    bool v2; // 0x406650\n    int64_t v3 = v2 ? -1 : 1;\n    int64_t v4 = (int64_t)\"C\"; // 0x406650\n    int64_t v5 = v1; // 0x406650\n    int64_t v6 = 2; // 0x406675\n    unsigned char v7 = *(char *)v5; // 0x406675\n    char v8 = *(char *)v4; // 0x406675\n    char v9 = v8; // 0x406675\n    bool v10 = false; // 0x406675\n    while (v7 == v8) {\n        // 0x406668\n        v6--;\n        v4 += v3;\n        v5 += v3;\n        v9 = v7;\n        v10 = true;\n        if (v6 == 0) {\n            // break -> \n            break;\n        }\n        v7 = *(char *)v5;\n        v8 = *(char *)v4;\n        v9 = v8;\n        v10 = false;\n    }\n    unsigned char v11 = v9;\n    int64_t v12 = (int64_t)\"POSIX\"; // 0x406681\n    int64_t v13 = v1; // 0x406681\n    if ((v7 >= v11 && !v10) == v7 < v11) {\n        // 0x406683\n        return 0;\n    }\n    int64_t v14 = 6; // 0x406681\n    unsigned char v15 = *(char *)v13; // 0x40669d\n    char v16 = *(char *)v12; // 0x40669d\n    char v17 = v16; // 0x40669d\n    bool v18 = false; // 0x40669d\n    while (v15 == v16) {\n        // 0x406690\n        v14--;\n        v12 += v3;\n        v13 += v3;\n        v17 = v15;\n        v18 = true;\n        if (v14 == 0) {\n            // break -> \n            break;\n        }\n        v15 = *(char *)v13;\n        v16 = *(char *)v12;\n        v17 = v16;\n        v18 = false;\n    }\n    unsigned char v19 = v17;\n    return !((v15 < v19 | v18)) != v15 < v19;\n}\n"
        },
        {
            "funcName": "function_4066b0",
            "funcStartAddr": "4066b0",
            "funcEndAddr": "406c12",
            "decompiledFuncCode": "int64_t function_4066b0(void) {\n    char * v1 = nl_langinfo(14); // 0x4066c6\n    char * v2 = g57; // 0x4066cb\n    char * v3; // 0x4066b0\n    int64_t v4; // 0x4066b0\n    int64_t v5; // 0x4066b0\n    int64_t v6; // 0x4066b0\n    int64_t v7; // 0x4066b0\n    int32_t size; // 0x4066b0\n    int32_t size2; // 0x4066b0\n    int32_t len; // 0x406782\n    int64_t v8; // 0x406782\n    char * env_val; // 0x40676d\n    if (v2 == NULL) {\n        // 0x406768\n        env_val = getenv(\"CHARSETALIASDIR\");\n        size = 115;\n        v4 = 101;\n        v5 = (int64_t)\"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\";\n        v6 = 100;\n        if (env_val == NULL) {\n            goto lab_0x4067d5;\n        } else {\n            // 0x40677a\n            size = 115;\n            v4 = 101;\n            v5 = (int64_t)\"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\";\n            v6 = 100;\n            if (*env_val == 0) {\n                goto lab_0x4067d5;\n            } else {\n                // 0x40677f\n                len = strlen(env_val);\n                v8 = len;\n                size2 = 14;\n                if (len != 0) {\n                    int64_t v9 = (int64_t)env_val; // 0x40676d\n                    if (*(char *)(v9 - 1 + v8) != 47) {\n                        // 0x406c05\n                        size = len + 15;\n                        v4 = v8 + 1;\n                        v5 = v9;\n                        v6 = v8;\n                        goto lab_0x4067d5;\n                    } else {\n                        // 0x406b79\n                        size2 = len + 14;\n                        goto lab_0x40679b;\n                    }\n                } else {\n                    goto lab_0x40679b;\n                }\n            }\n        }\n    } else {\n        // 0x4066b0\n        v3 = v2;\n        v7 = (int64_t)v2;\n        goto lab_0x4066ea;\n    }\n  lab_0x406a1c:;\n    // 0x406a1c\n    struct _IO_FILE * stream; // 0x40685b\n    int32_t v10 = __uflow(stream); // 0x406a1f\n    int64_t v11; // 0x4066b0\n    int64_t v12 = v11; // 0x406a29\n    int64_t v13; // 0x4066b0\n    int64_t v14 = v13; // 0x406a29\n    int32_t v15 = v10; // 0x406a29\n    int64_t v16; // 0x4066b0\n    int64_t v17 = v16; // 0x406a29\n    int64_t v18 = v11; // 0x406a29\n    int64_t v19 = v13; // 0x406a29\n    int64_t v20 = v16; // 0x406a29\n    if (v10 == -1) {\n        // break -> 0x406a2f\n        goto lab_0x406a2f;\n    }\n    goto lab_0x4068a9;\n  lab_0x40689e:;\n    // 0x40689e\n    int64_t v90; // 0x4066b0\n    int64_t * v32; // 0x406890\n    *v32 = v90 + 1;\n    int64_t v89; // 0x4066b0\n    v12 = v89;\n    int64_t v91; // 0x4066b0\n    v14 = v91;\n    v15 = (int32_t)*(char *)v90;\n    int64_t v92; // 0x4066b0\n    v17 = v92;\n    goto lab_0x4068a9;\n  lab_0x4068a9:;\n    int64_t v21 = v17;\n    int32_t c = v15;\n    int64_t v22 = v14;\n    int64_t v23 = v12;\n    int64_t v24; // 0x4066b0\n    int32_t v25; // bp-120, 0x4066b0\n    int32_t v26; // bp-184, 0x4066b0\n    int64_t v27; // 0x40685b\n    int64_t v28; // 0x406878\n    int64_t v29; // 0x40687d\n    int64_t * v30; // 0x406894\n    switch (c) {\n        case 32: {\n            goto lab_0x406890;\n        }\n        case 10: {\n            goto lab_0x406890;\n        }\n        case 9: {\n            goto lab_0x406890;\n        }\n        case 35: {\n            uint64_t v31 = *v32; // 0x406a81\n            int32_t v33; // 0x4066b0\n            char v34; // 0x4066b0\n            int32_t v35; // 0x406a8e\n            if (v31 < *v30) {\n                // 0x406a60\n                *v32 = v31 + 1;\n                v33 = (int32_t)*(char *)v31;\n                v34 = 1;\n            } else {\n                // 0x406a8b\n                v35 = __uflow(stream);\n                v33 = v35;\n                v34 = v35 != -1;\n            }\n            int32_t v36 = v33;\n            while (v36 != 10 && v34 != 0) {\n                // 0x406a81\n                v31 = *v32;\n                if (v31 < *v30) {\n                    // 0x406a60\n                    *v32 = v31 + 1;\n                    v33 = (int32_t)*(char *)v31;\n                    v34 = 1;\n                } else {\n                    // 0x406a8b\n                    v35 = __uflow(stream);\n                    v33 = v35;\n                    v34 = v35 != -1;\n                }\n                // 0x406a70\n                v36 = v33;\n            }\n            // 0x406b5f\n            if (v36 == -1) {\n                // break -> 0x406a2f\n                break;\n            }\n            goto lab_0x406890;\n        }\n        default: {\n            // 0x4068bf\n            ungetc(c, stream);\n            if (fscanf(stream, \"%50s %50s\", &v26, &v25) < 2) {\n                // break -> 0x406a2f\n                break;\n            }\n            int64_t v37 = v29;\n            int32_t v38 = *(int32_t *)v37; // 0x4068e8\n            int64_t v39 = v37 + 4; // 0x4068ea\n            int32_t v40 = v38 - 0x1010101 & (v38 ^ -0x7f7f7f80); // 0x4068f6\n            uint32_t v41 = v40 & -0x7f7f7f80; // 0x4068f8\n            while (v41 == 0) {\n                // 0x4068e8\n                v37 = v39;\n                v38 = *(int32_t *)v37;\n                v39 = v37 + 4;\n                v40 = v38 - 0x1010101 & (v38 ^ -0x7f7f7f80);\n                v41 = v40 & -0x7f7f7f80;\n            }\n            unsigned char v42 = (char)((v40 & 0x8080) == 0 ? v41 / 0x10000 : v41); // 0x406916\n            int64_t v43 = v28;\n            int32_t v44 = *(int32_t *)v43; // 0x406922\n            int64_t v45 = v43 + 4; // 0x406924\n            int32_t v46 = v44 - 0x1010101 & (v44 ^ -0x7f7f7f80); // 0x406930\n            uint32_t v47 = v46 & -0x7f7f7f80; // 0x406932\n            while (v47 == 0) {\n                // 0x406922\n                v43 = v45;\n                v44 = *(int32_t *)v43;\n                v45 = v43 + 4;\n                v46 = v44 - 0x1010101 & (v44 ^ -0x7f7f7f80);\n                v47 = v46 & -0x7f7f7f80;\n            }\n            int64_t v48 = ((v40 & 0x8080) == 0 ? v37 + 6 : v39) - (-1 - v42 < v42 ? 4 : 3) - v29; // 0x40691f\n            int32_t v49 = (v46 & 0x8080) == 0 ? v47 / 0x10000 : v47; // 0x406948\n            int64_t v50 = (char)v49 == 0 ? 3 : 4; // 0x406958\n            int64_t v51 = ((v46 & 0x8080) == 0 ? v43 + 6 : v45) - v50 - v28; // 0x40695c\n            int64_t v52 = v51 + v48; // 0x406965\n            int64_t * mem; // 0x4066b0\n            int64_t v53; // 0x4066b0\n            int64_t v54; // 0x4066b0\n            if (v23 != 0) {\n                int64_t v55 = v52 + v23; // 0x406a9b\n                int64_t v56 = v55 + 3; // 0x406aa7\n                v54 = v55;\n                mem = realloc((int64_t *)v21, (int32_t)v56);\n                v53 = v56;\n            } else {\n                int64_t * mem2 = malloc((int32_t)v52 + 3); // 0x406981\n                v54 = v52;\n                mem = mem2;\n                v53 = v49 & -0x7f7f8000;\n            }\n            // 0x406990\n            if (mem == NULL) {\n                // 0x406bbc\n                free((int64_t *)v21);\n                function_406c20(v27, v53);\n                v24 = (int64_t)&g13;\n                goto lab_0x406834;\n            }\n            int64_t v57 = (int64_t)mem;\n            int64_t v58 = v54 + 2;\n            int64_t v59 = v48 + 1; // 0x4069a8\n            int64_t v60 = v58 - v51 + v57;\n            int64_t v61 = -2 - v48 + v60; // 0x4069b2\n            uint32_t v62 = (int32_t)v59; // 0x4069b5\n            int64_t v63; // 0x4066b0\n            if (v62 >= 8) {\n                // 0x406ac4\n                *(int64_t *)v61 = (int64_t)v26;\n                int64_t v64 = (v59 & 0xffffffff) - 8;\n                *(int64_t *)(v61 + v64) = *(int64_t *)(v64 + v29);\n                int64_t v65 = v61 + 8 & -8; // 0x406ade\n                int64_t v66 = v61 - v65; // 0x406ae2\n                uint32_t v67 = (int32_t)(v66 + v59); // 0x406aed\n                v63 = v66;\n                if (v67 >= 8) {\n                    int64_t v68 = 0;\n                    int64_t v69 = v68 + 8; // 0x406afe\n                    int64_t v70 = v69 & 0xffffffff; // 0x406afe\n                    *(int64_t *)(v68 + v65) = *(int64_t *)(v29 - v66 + v68);\n                    v63 = v70;\n                    while ((v67 & -8) > (int32_t)v69) {\n                        // 0x406afb\n                        v68 = v70;\n                        v69 = v68 + 8;\n                        v70 = v69 & 0xffffffff;\n                        *(int64_t *)(v68 + v65) = *(int64_t *)(v29 - v66 + v68);\n                        v63 = v70;\n                    }\n                }\n            } else {\n                if ((v59 & 4) != 0) {\n                    // 0x406b8f\n                    *(int32_t *)v61 = v26;\n                    int64_t v71 = (v59 & 0xffffffff) - 4;\n                    *(int32_t *)(v61 + v71) = *(int32_t *)(v71 + v29);\n                    v63 = v61;\n                } else {\n                    // 0x4069c7\n                    v63 = v61;\n                    if (v62 != 0) {\n                        // 0x4069cb\n                        *(char *)v61 = (char)v26;\n                        v63 = v61;\n                        if ((v59 & 2) != 0) {\n                            int64_t v72 = (v59 & 0xffffffff) - 2;\n                            *(int16_t *)(v61 + v72) = *(int16_t *)(v72 + v29);\n                            v63 = v61;\n                        }\n                    }\n                }\n            }\n            int64_t v73 = v51 + 1; // 0x4069db\n            int64_t v74 = v60 - 1; // 0x4069df\n            uint32_t v75 = (int32_t)v73; // 0x4069e4\n            int64_t v76; // 0x4066b0\n            if (v75 >= 8) {\n                // 0x406b12\n                *(int64_t *)v74 = (int64_t)v25;\n                int64_t v77 = v73 & 0xffffffff; // 0x406b1c\n                int64_t v78 = v77 - 8;\n                *(int64_t *)(v74 + v78) = *(int64_t *)(v78 + v28);\n                int64_t v79 = v60 + 7 & -8; // 0x406b2c\n                int64_t v80 = v74 - v79; // 0x406b30\n                uint32_t v81 = (int32_t)(v80 + v73); // 0x406b3b\n                v76 = v77;\n                if (v81 >= 8) {\n                    int64_t v82 = 0;\n                    int64_t v83 = v82 + 8; // 0x406b4b\n                    *(int64_t *)(v82 + v79) = *(int64_t *)(v28 - v80 + v82);\n                    v76 = v82;\n                    while ((v81 & -8) > (int32_t)v83) {\n                        // 0x406b49\n                        v82 = v83 & 0xffffffff;\n                        v83 = v82 + 8;\n                        *(int64_t *)(v82 + v79) = *(int64_t *)(v28 - v80 + v82);\n                        v76 = v82;\n                    }\n                }\n            } else {\n                if ((v73 & 4) != 0) {\n                    // 0x406ba6\n                    *(int32_t *)v74 = v25;\n                    int64_t v84 = (v73 & 0xffffffff) - 4;\n                    uint32_t v85 = *(int32_t *)(v84 + v28); // 0x406bae\n                    *(int32_t *)(v74 + v84) = v85;\n                    v76 = v85;\n                } else {\n                    // 0x4069f6\n                    v76 = v63;\n                    if (v75 != 0) {\n                        // 0x4069fa\n                        *(char *)v74 = (char)v25;\n                        v76 = v25 % 256;\n                        if ((v73 & 2) != 0) {\n                            int64_t v86 = v73 & 0xffffffff; // 0x406bf3\n                            int64_t v87 = v86 - 2;\n                            *(int16_t *)(v74 + v87) = *(int16_t *)(v87 + v28);\n                            v76 = v86;\n                        }\n                    }\n                }\n            }\n            uint64_t v88 = *v32; // 0x406a0e\n            v89 = v58;\n            v90 = v88;\n            v91 = v76;\n            v92 = v57;\n            v11 = v58;\n            v13 = v76;\n            v16 = v57;\n            if (v88 < *v30) {\n                goto lab_0x40689e;\n            } else {\n                goto lab_0x406a1c;\n            }\n        }\n    }\n  lab_0x406890:;\n    int64_t v93 = v23; // 0x4066b0\n    int64_t v94 = v22; // 0x4066b0\n    int64_t v95 = v21; // 0x4066b0\n    goto lab_0x406890_2;\n  lab_0x4067d5:;\n    int64_t * mem3 = malloc(size); // 0x4067d5\n    int64_t v97 = (int64_t)&g13; // 0x4067e0\n    int64_t v98; // 0x4066b0\n    int64_t path; // 0x4066b0\n    if (mem3 == NULL) {\n        goto lab_0x4067b2;\n    } else {\n        int64_t v99 = (int64_t)mem3; // 0x4067d5\n        memcpy(mem3, (int64_t *)v5, (int32_t)v6);\n        *(char *)(v6 + v99) = 47;\n        path = v99;\n        v98 = v4;\n        goto lab_0x4067f6;\n    }\n  lab_0x4066ea:;\n    int64_t str = v1 == NULL ? (int64_t)&g13 : (int64_t)v1; // 0x4066dd\n    char v100 = *v3; // 0x4066ea\n    int64_t v101; // 0x4066b0\n    if (v100 == 0) {\n        // 0x406744\n        v101 = str;\n        return *(char *)v101 == 0 ? (int64_t)\"ASCII\" : v101;\n    }\n    char v102 = v100; // 0x4066b0\n    int64_t v103 = v7;\n    char * str2 = (char *)v103;\n    int64_t v104; // 0x4066b0\n    while (strcmp((char *)str, str2) != 0) {\n        int64_t v105 = v103 + 1;\n        if (v102 == 42) {\n            // 0x406730\n            v104 = v105;\n            if (*(char *)v105 == 0) {\n                goto lab_0x406737;\n            }\n        }\n        int64_t str3 = v105 + (int64_t)strlen(str2); // 0x406700\n        int64_t v106 = str3 + 1 + (int64_t)strlen((char *)str3); // 0x40670d\n        char v107 = *(char *)v106; // 0x406712\n        v102 = v107;\n        if (v107 == 0) {\n            // 0x406744\n            v101 = str;\n            return *(char *)v101 == 0 ? (int64_t)\"ASCII\" : v101;\n        }\n        v103 = v106;\n        str2 = (char *)v103;\n    }\n    // 0x40671b\n    v104 = v103 + 1;\n  lab_0x406737:\n    // 0x406744\n    v101 = v104 + (int64_t)strlen(str2);\n    return *(char *)v101 == 0 ? (int64_t)\"ASCII\" : v101;\n  lab_0x4067b2:;\n    char * v108 = (char *)v97;\n    g57 = v108;\n    v3 = v108;\n    v7 = v97;\n    goto lab_0x4066ea;\n  lab_0x4067f6:;\n    int64_t v109 = v98 + path; // 0x4067f6\n    *(int64_t *)v109 = 0x2e74657372616863;\n    *(int16_t *)(v109 + 12) = 115;\n    *(int32_t *)(v109 + 8) = 0x61696c61;\n    int32_t fd = open((char *)path, O_RDONLY); // 0x406822\n    v24 = (int64_t)&g13;\n    if (fd >= 0) {\n        // 0x406851\n        stream = fdopen(fd, \"r\");\n        if (stream == NULL) {\n            // 0x406b82\n            close(fd);\n            v24 = (int64_t)&g13;\n        } else {\n            // 0x406875\n            v27 = (int64_t)stream;\n            v28 = &v25;\n            v29 = &v26;\n            v32 = (int64_t *)(v27 + 8);\n            v30 = (int64_t *)(v27 + 16);\n            v93 = 0;\n            v94 = (int64_t)\"r\";\n            v95 = 0;\n            while (true) {\n              lab_0x406890_2:;\n                uint64_t v96 = *v32; // 0x406890\n                v89 = v93;\n                v90 = v96;\n                v91 = v94;\n                v92 = v95;\n                if (v96 >= *v30) {\n                    goto lab_0x406a1c;\n                } else {\n                    goto lab_0x40689e;\n                }\n            }\n          lab_0x406a2f:\n            // 0x406a2f\n            function_406c20(v27, v19);\n            v24 = (int64_t)&g13;\n            if (v18 != 0) {\n                // 0x406a4e\n                *(char *)(v20 + v18) = 0;\n                v24 = v20;\n            }\n        }\n    }\n    goto lab_0x406834;\n  lab_0x40679b:;\n    int64_t * mem4 = malloc(size2); // 0x40679b\n    v97 = (int64_t)&g13;\n    if (mem4 != NULL) {\n        // 0x406841\n        memcpy(mem4, (int64_t *)env_val, len);\n        path = (int64_t)mem4;\n        v98 = v8;\n        goto lab_0x4067f6;\n    } else {\n        goto lab_0x4067b2;\n    }\n  lab_0x406834:\n    // 0x406834\n    free((int64_t *)path);\n    v97 = v24;\n    goto lab_0x4067b2;\n}\n"
        },
        {
            "funcName": "function_406c20",
            "funcStartAddr": "406c20",
            "funcEndAddr": "406c9b",
            "decompiledFuncCode": "int64_t function_406c20(int64_t a1, int64_t a2) {\n    struct _IO_FILE * stream = (struct _IO_FILE *)a1; // 0x406c27\n    if (fileno(stream) < 0) {\n        // 0x406c87\n        return fclose(stream);\n    }\n    int64_t v1 = a2; // 0x406c3a\n    if (__freading(stream) != 0) {\n        int32_t fd = fileno(stream); // 0x406c6b\n        v1 = 0;\n        if (lseek(fd, 0, SEEK_CUR) == -1) {\n            // 0x406c87\n            return fclose(stream);\n        }\n    }\n    // 0x406c3c\n    if ((int32_t)function_406ca0(a1, v1) == 0) {\n        // 0x406c87\n        return fclose(stream);\n    }\n    int32_t * v2 = __errno_location(); // 0x406c48\n    int32_t v3 = *v2; // 0x406c50\n    int64_t result = fclose(stream); // 0x406c5e\n    if (v3 != 0) {\n        // 0x406c90\n        *v2 = v3;\n        result = 0xffffffff;\n    }\n    // 0x406c60\n    return result;\n}\n"
        },
        {
            "funcName": "function_406ca0",
            "funcStartAddr": "406ca0",
            "funcEndAddr": "406ce0",
            "decompiledFuncCode": "int64_t function_406ca0(int64_t a1, int64_t a2) {\n    struct _IO_FILE * stream = (struct _IO_FILE *)a1;\n    if (a1 == 0 || __freading(stream) == 0) {\n        // 0x406cba\n        return fflush(stream);\n    }\n    if ((a1 & 256) == 0) {\n        // 0x406cba\n        return fflush(stream);\n    }\n    // 0x406cc8\n    function_406ce0(a1, 0, 1);\n    return fflush(stream);\n}\n"
        },
        {
            "funcName": "function_406ce0",
            "funcStartAddr": "406ce0",
            "funcEndAddr": "406d37",
            "decompiledFuncCode": "int64_t function_406ce0(int64_t stream, int32_t offset, int64_t whence) {\n    // 0x406ce0\n    if (*(int64_t *)(stream + 16) != *(int64_t *)(stream + 8) || *(int64_t *)(stream + 40) != *(int64_t *)(stream + 32) || *(int64_t *)(stream + 72) != 0) {\n        // 0x406cea\n        return fseeko((struct _IO_FILE *)stream, offset, (int32_t)whence);\n    }\n    int32_t v1 = lseek(fileno((struct _IO_FILE *)stream), offset, (int32_t)whence); // 0x406d1b\n    int64_t result = -1; // 0x406d24\n    if (v1 != -1) {\n        // 0x406d26\n        *(int32_t *)stream = (int32_t)stream & -17;\n        *(int64_t *)(stream + 144) = (int64_t)v1;\n        result = 0;\n    }\n    // 0x406d32\n    return result;\n}\n"
        },
        {
            "funcName": "function_406d40",
            "funcStartAddr": "406d40",
            "funcEndAddr": "406d9d",
            "decompiledFuncCode": "int64_t function_406d40(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x406d40\n    return function_401918();\n}\n"
        },
        {
            "funcName": "function_406da0",
            "funcStartAddr": "406da0",
            "funcEndAddr": "406da1",
            "decompiledFuncCode": "int64_t function_406da0(void) {\n    // 0x406da0\n    int64_t result; // 0x406da0\n    return result;\n}\n"
        },
        {
            "funcName": "function_406db0",
            "funcStartAddr": "406db0",
            "funcEndAddr": "406dc8",
            "decompiledFuncCode": "int64_t function_406db0(int64_t a1, int64_t a2, int64_t a3) {\n    // 0x406db0\n    return __cxa_atexit((void (*)(int64_t *))a1, NULL, (int64_t *)g18);\n}\n"
        },
        {
            "funcName": "function_406dc8",
            "funcStartAddr": "406dc8",
            "funcEndAddr": "406de8",
            "decompiledFuncCode": "int64_t function_406dc8(int64_t a1, int64_t a2, int64_t result) {\n    int64_t v1 = &g14; // 0x406dd2\n    while (*(int64_t *)v1 != -1) {\n        // 0x406dd3\n        v1 -= 8;\n    }\n    // 0x406de4\n    return result;\n}\n"
        }
    ],
    "isStripped": "True",
    "decompilerName": "Retdec",
    "compilerName": "gcc",
    "optLevel": "-O",
    "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_timeout.elf"
}