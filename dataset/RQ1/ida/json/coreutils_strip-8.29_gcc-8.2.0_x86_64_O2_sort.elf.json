{
    "binaryInfo": {
        "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_sort.elf",
        "isStripped": "True"
    },
    "buildInfo": {
        "decompilerName": "IDA Pro",
        "compilerName": "gcc",
        "compilerVersion": "9.4.0",
        "Optlevel": "-O"
    },
    "funcInfo": [
        {
            "funcName": "main",
            "funcStartAddr": "0x402f50",
            "funcEndAddr": "0x405830",
            "decompiledFuncCode": "__int64 __fastcall main(unsigned int a1, char **a2, char **a3)\n{\n  __off_t st_size; // r12\n  unsigned __int64 p_dest; // rbp\n  __int64 v5; // rbx\n  char v6; // r14\n  struct lconv *v7; // rax\n  char *decimal_point; // rcx\n  char *thousands_sep; // rdx\n  const unsigned __int16 **v10; // r13\n  const __int32_t **v11; // rax\n  __int64 i; // rdx\n  char v13; // si\n  __int64 v14; // rdi\n  bool v15; // si\n  const __int32_t *v16; // rcx\n  unsigned __int16 v17; // cx\n  unsigned __int16 v18; // dx\n  __int64 j; // r14\n  char *v20; // rbx\n  size_t v21; // r15\n  __int64 v22; // rax\n  unsigned __int64 v23; // rdx\n  const unsigned __int16 *v24; // r11\n  char *v25; // rdi\n  __int64 v26; // r8\n  _BYTE *v27; // rcx\n  __int64 v28; // rsi\n  _BYTE *v29; // r9\n  int v30; // r14d\n  __int64 v31; // r13\n  int v32; // r14d\n  __int64 v33; // r13\n  __m128i si128; // xmm1\n  char *v35; // rsi\n  _BOOL8 v36; // rdx\n  double v37; // xmm0_8\n  __int64 v38; // rdi\n  unsigned __int64 v39; // r15\n  __int64 v40; // r14\n  __int64 *v41; // r13\n  __int64 v42; // rax\n  _BYTE *v43; // rdx\n  int v44; // edx\n  __int64 v45; // rax\n  int v46; // eax\n  __int64 v47; // rcx\n  __int64 v48; // rsi\n  char v49; // dl\n  char v50; // al\n  int v51; // eax\n  __int64 v52; // rcx\n  int v53; // eax\n  char *v54; // rax\n  struct stat *p_ptr; // rdi\n  __int64 v56; // rcx\n  __int64 *v57; // rsi\n  __int64 v58; // rbx\n  unsigned __int64 v59; // rax\n  char v60; // al\n  unsigned __int64 v61; // r15\n  unsigned __int64 v62; // r13\n  __int64 v63; // rax\n  __int64 v64; // r14\n  __int64 v65; // rax\n  unsigned __int64 v66; // r13\n  const char *v67; // rax\n  const char *v68; // rax\n  __int64 v69; // r15\n  char *v70; // rax\n  char v71; // al\n  char *v72; // rax\n  int v73; // esi\n  __int64 v74; // rdx\n  char *v75; // rax\n  unsigned int v76; // eax\n  char *v77; // rax\n  const char *v78; // rdi\n  char *v79; // rdx\n  int v80; // eax\n  int v81; // eax\n  unsigned int v82; // r11d\n  __int64 v83; // rbp\n  char *v84; // rax\n  char *v85; // rax\n  char *v86; // rdx\n  int v87; // eax\n  char *v88; // rdx\n  int v89; // esi\n  int v90; // eax\n  __int64 v91; // rcx\n  __int128 *v92; // rdi\n  _BYTE *v93; // rax\n  __int64 v94; // rdx\n  __int64 v95; // rcx\n  _BYTE *v96; // rax\n  __int64 v97; // rax\n  __int64 v98; // rdx\n  __int64 *v99; // rcx\n  const char *v100; // rdi\n  char *v101; // rdx\n  int v102; // eax\n  char *v103; // rdx\n  char *v104; // rdi\n  unsigned int v105; // eax\n  __dev_t st_dev; // rax\n  char v107; // al\n  char st_size_high; // r12\n  char *v109; // rax\n  char *v110; // rax\n  unsigned __int64 v111; // rax\n  FILE *v112; // r14\n  unsigned __int8 v113; // bl\n  __int64 v114; // rax\n  size_t v115; // r12\n  __dev_t v116; // r15\n  __dev_t v117; // rbp\n  __dev_t v118; // rdi\n  size_t v119; // rdx\n  char *v120; // rax\n  void *v121; // rax\n  int v122; // eax\n  char v123; // bl\n  char *v125; // rax\n  __int64 v126; // rbp\n  char *v127; // rax\n  char *v128; // rax\n  _BYTE *v129; // rax\n  __int64 v130; // rcx\n  __int128 *v131; // rdi\n  _BYTE *v132; // rax\n  __int64 v133; // rcx\n  pthread_mutex_t *v134; // rax\n  _BYTE *v135; // rax\n  __int64 v136; // rcx\n  __int64 v137; // rdx\n  __int64 v138; // rax\n  const char *v139; // rsi\n  void *v140; // rbx\n  char *v141; // rax\n  const char **v142; // rbp\n  bool v143; // cf\n  bool v144; // zf\n  __int64 v145; // rbx\n  const char *v146; // rdx\n  __int64 v147; // rcx\n  char *v148; // rdi\n  __int64 v149; // rsi\n  int v150; // eax\n  __int64 v151; // rax\n  unsigned __int64 v152; // r15\n  unsigned __int64 v153; // r14\n  __int64 v154; // rax\n  __int64 v155; // r13\n  char v156; // r12\n  char *v157; // rbx\n  __int64 v158; // rbp\n  rlim_t v159; // rax\n  char *v160; // rax\n  char *v161; // rax\n  char *v162; // rax\n  __int64 v163; // rdx\n  unsigned __int64 v164; // rax\n  __int64 v165; // rsi\n  unsigned __int64 v166; // rcx\n  bool v167; // al\n  rlim_t v168; // r14\n  rlim_t v169; // r14\n  double v170; // xmm0_8\n  double v171; // xmm2_8\n  double v172; // xmm0_8\n  double v173; // xmm0_8\n  unsigned __int64 v174; // rax\n  int v175; // eax\n  __int64 v176; // rax\n  __int64 v177; // rbp\n  __int64 v178; // r12\n  char *v179; // rax\n  char *v180; // rax\n  __int64 v181; // rax\n  __int64 k; // rdx\n  _QWORD *v183; // rbx\n  _QWORD *v184; // rbp\n  _QWORD *v185; // rdx\n  char *v186; // rax\n  __int64 v187; // rax\n  __int64 v188; // rdx\n  __int64 *v189; // rcx\n  _BYTE *v190; // rax\n  __int64 v191; // rdx\n  __int64 v192; // rcx\n  __int64 v193; // rdx\n  char *v194; // rax\n  unsigned __int64 v195; // rax\n  __int64 v196; // rdx\n  double st_dev_low; // xmm1_8\n  __int64 v198; // rbx\n  char *v199; // rax\n  char *v200; // rax\n  char *v201; // rax\n  const char *v202; // rsi\n  const char *v203; // rbx\n  char *v204; // rax\n  char *v205; // rax\n  __int64 v206; // rbx\n  char *v207; // rax\n  char *v208; // rax\n  char *v209; // rax\n  char *v210; // rax\n  char *v211; // rax\n  __int64 v212; // rbp\n  char *v213; // rbx\n  char *v214; // rax\n  __int64 v215; // rbp\n  char *v216; // rax\n  char *v217; // rax\n  __int64 v218; // rbx\n  char *v219; // rax\n  FILE *v220; // rbx\n  char *v221; // rsi\n  __sighandler_t v222; // rbx\n  bool v223; // cf\n  bool v224; // zf\n  char *v225; // r8\n  _BYTE *v226; // rdx\n  __int64 v227; // rcx\n  char *v228; // rdi\n  _BYTE *v229; // rsi\n  __int64 v230; // rbx\n  char *v231; // rax\n  __int64 v232; // rbx\n  char *v233; // rax\n  __int64 v234; // rbx\n  char *v235; // rax\n  __int64 v236; // rbx\n  char *v237; // rax\n  FILE *stream; // [rsp+0h] [rbp-388h]\n  char *src; // [rsp+8h] [rbp-380h]\n  char *v240; // [rsp+10h] [rbp-378h]\n  char *v241; // [rsp+10h] [rbp-378h]\n  double v242; // [rsp+10h] [rbp-378h]\n  char *s1; // [rsp+18h] [rbp-370h]\n  char *s1b; // [rsp+18h] [rbp-370h]\n  char *s1a; // [rsp+18h] [rbp-370h]\n  char *file; // [rsp+20h] [rbp-368h]\n  char *v247; // [rsp+28h] [rbp-360h]\n  __int64 *v248; // [rsp+30h] [rbp-358h]\n  char *v249; // [rsp+38h] [rbp-350h]\n  __int64 *v250; // [rsp+40h] [rbp-348h]\n  pthread_mutex_t *mutex; // [rsp+48h] [rbp-340h]\n  unsigned __int64 sa_handler; // [rsp+50h] [rbp-338h]\n  unsigned int rlim_cur; // [rsp+50h] [rbp-338h]\n  __int64 v254; // [rsp+58h] [rbp-330h]\n  char **v255; // [rsp+60h] [rbp-328h]\n  char *v256; // [rsp+68h] [rbp-320h]\n  char v257[32]; // [rsp+70h] [rbp-318h] BYREF\n  struct rlimit v258; // [rsp+90h] [rbp-2F8h] BYREF\n  void *dest; // [rsp+C0h] [rbp-2C8h] BYREF\n  __int64 v260; // [rsp+C8h] [rbp-2C0h]\n  unsigned __int64 v261; // [rsp+D0h] [rbp-2B8h]\n  char *v262; // [rsp+D8h] [rbp-2B0h]\n  __int64 v263; // [rsp+E0h] [rbp-2A8h]\n  char v264; // [rsp+F0h] [rbp-298h]\n  __int128 v265; // [rsp+100h] [rbp-288h] BYREF\n  __int64 v266; // [rsp+110h] [rbp-278h] BYREF\n  __int64 v267[4]; // [rsp+118h] [rbp-270h] BYREF\n  char v268; // [rsp+139h] [rbp-24Fh]\n  __int64 v269[3]; // [rsp+150h] [rbp-238h] BYREF\n  __int128 v270; // [rsp+168h] [rbp-220h]\n  __int128 v271; // [rsp+178h] [rbp-210h]\n  __int128 v272; // [rsp+188h] [rbp-200h]\n  struct stat ptr; // [rsp+1A0h] [rbp-1E8h] BYREF\n  struct sigaction rlimits[2]; // [rsp+230h] [rbp-158h] BYREF\n\n  p_dest = (unsigned __int64)a2;\n  v5 = a1;\n  v249 = getenv(\"POSIXLY_CORRECT\");\n  LOBYTE(st_size) = v249 != 0LL;\n  LOBYTE(src) = (unsigned int)sub_40DBE0() - 200112 > 0x2B8;\n  sub_40DC60(*a2);\n  v247 = setlocale(6, \"\");\n  bindtextdomain(\n    \"coreutils\",\n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\");\n  textdomain(\"coreutils\");\n  status = 2;\n  byte_61CBA1 = sub_40BD10(3LL);\n  v6 = sub_40BD10(2LL);\n  byte_61CBA0 = v6;\n  v7 = localeconv();\n  decimal_point = v7->decimal_point;\n  dword_61CBA8 = *(unsigned __int8 *)v7->decimal_point;\n  if ( !(_BYTE)dword_61CBA8 || decimal_point[1] )\n    dword_61CBA8 = 46;\n  thousands_sep = v7->thousands_sep;\n  dword_61CBA4 = (unsigned __int8)*thousands_sep;\n  if ( !(_BYTE)dword_61CBA4 || thousands_sep[1] )\n    dword_61CBA4 = -1;\n  byte_61C758 = 0;\n  v10 = __ctype_b_loc();\n  v11 = __ctype_toupper_loc();\n  for ( i = 0LL; i != 256; *(_BYTE *)(i + 6408063) = v16[v14] )\n  {\n    while ( 1 )\n    {\n      v13 = 1;\n      v17 = (*v10)[i];\n      if ( (v17 & 1) != 0 )\n        break;\n      if ( i != 10 )\n      {\n        v13 = 0;\n        break;\n      }\n      v18 = (*v10)[10];\n      byte_61CA8A = 1;\n      byte_61C88A = 0;\n      byte_61C98A = ((v18 >> 14) ^ 1) & 1;\n      byte_61C78A = (*v11)[10];\n      i = 11LL;\n    }\n    byte_61CA80[i] = v13;\n    v14 = i;\n    byte_61C980[i] = ((v17 >> 14) ^ 1) & 1;\n    v15 = 0;\n    if ( (v17 & 8) == 0 )\n      v15 = !((i == 10) | v17 & 1);\n    v16 = *v11;\n    byte_61C880[i++] = v15;\n  }\n  if ( v6 )\n  {\n    LODWORD(stream) = v5;\n    for ( j = 1LL; j != 13; ++j )\n    {\n      v20 = nl_langinfo((int)j + 131085);\n      v21 = strlen(v20);\n      v22 = sub_411210(v21 + 1);\n      v23 = 4 * j;\n      qword_61C430[v23 / 2] = v22;\n      dword_61C438[v23] = j;\n      if ( v21 )\n      {\n        v24 = *v10;\n        v25 = v20;\n        v26 = 0LL;\n        v27 = (_BYTE *)v22;\n        do\n        {\n          v28 = (unsigned __int8)*v25;\n          v29 = v27;\n          if ( (v24[v28] & 1) == 0 )\n          {\n            ++v26;\n            *v27 = byte_61C780[v28];\n            v27 = (_BYTE *)(v22 + v26);\n            v29 = (_BYTE *)(v22 + v26);\n          }\n          ++v25;\n        }\n        while ( &v20[v21] != v25 );\n      }\n      else\n      {\n        v29 = (_BYTE *)v22;\n      }\n      *v29 = 0;\n    }\n    v5 = (unsigned int)stream;\n    qsort(&off_61C440, 0xCuLL, 0x10uLL, compar);\n  }\n  v30 = 14;\n  v31 = 0LL;\n  sigemptyset(&newmask);\n  while ( 1 )\n  {\n    sigaction(v30, 0LL, rlimits);\n    if ( rlimits[0].sa_handler != (__sighandler_t)1 )\n      sigaddset(&newmask, v30);\n    if ( ++v31 == 11 )\n      break;\n    v30 = dword_414980[v31];\n  }\n  rlimits[0].sa_handler = (__sighandler_t)sub_405D80;\n  v32 = 14;\n  rlimits[0].sa_flags = 0;\n  v33 = 0LL;\n  *(__m128i *)rlimits[0].sa_mask.__val = _mm_load_si128((const __m128i *)&newmask);\n  si128 = _mm_load_si128((const __m128i *)&newmask.__val[12]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[2] = _mm_load_si128((const __m128i *)&newmask.__val[2]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[4] = _mm_load_si128((const __m128i *)&newmask.__val[4]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[6] = _mm_load_si128((const __m128i *)&newmask.__val[6]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[8] = _mm_load_si128((const __m128i *)&newmask.__val[8]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[10] = _mm_load_si128((const __m128i *)&newmask.__val[10]);\n  *(__m128i *)&rlimits[0].sa_mask.__val[12] = si128;\n  *(__m128i *)&rlimits[0].sa_mask.__val[14] = _mm_load_si128((const __m128i *)&newmask.__val[14]);\n  while ( 2 )\n  {\n    if ( !sigismember(&newmask, v32) )\n    {\n      if ( ++v33 == 11 )\n        break;\n      goto LABEL_31;\n    }\n    ++v33;\n    sigaction(v32, rlimits, 0LL);\n    if ( v33 != 11 )\n    {\nLABEL_31:\n      v32 = dword_414980[v33];\n      continue;\n    }\n    break;\n  }\n  v35 = 0LL;\n  signal(17, 0LL);\n  sub_413F20(sub_407890);\n  v37 = 0.0;\n  v269[1] = 0LL;\n  v269[0] = -1LL;\n  v269[2] = -1LL;\n  v270 = 0LL;\n  v38 = 8LL * (int)v5;\n  v271 = 0LL;\n  v272 = 0LL;\n  if ( ((int)v5 & 0x1000000000000000LL) != 0 || (unsigned __int64)(int)v5 >> 61 )\n    goto LABEL_449;\n  v39 = 0LL;\n  LOBYTE(v248) = 0;\n  LODWORD(v40) = 0;\n  v41 = (__int64 *)sub_411210(v38);\n  LOBYTE(stream) = 0;\n  file = 0LL;\n  v240 = 0LL;\n  sa_handler = 0LL;\n  s1 = 0LL;\n  v250 = &v266;\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      while ( 2 )\n      {\n        LODWORD(v258.rlim_cur) = -1;\n        if ( (_DWORD)v40 == -1 )\n        {\nLABEL_46:\n          v42 = dword_61C57C;\nLABEL_43:\n          if ( (int)v5 > (int)v42 )\n          {\n            v44 = v42 + 1;\n            v45 = *(_QWORD *)(p_dest + 8 * v42);\n            dword_61C57C = v44;\n            v41[v39++] = v45;\n            continue;\n          }\n          goto LABEL_432;\n        }\n        break;\n      }\n      if ( !v39 || !(_BYTE)st_size )\n      {\nLABEL_50:\n        v46 = sub_412F30((unsigned int)v5, p_dest, \"-bcCdfghik:mMno:rRsS:t:T:uVy:z\", &off_414B40, &v258);\n        LODWORD(v40) = v46;\n        if ( v46 == -1 )\n          goto LABEL_46;\n        switch ( v46 )\n        {\n          case -131:\n            sub_4110D0(\n              (_DWORD)stdout,\n              4286066,\n              (unsigned int)&unk_4165FE,\n              (_DWORD)off_61C508,\n              (unsigned int)\"Mike Haertel\",\n              (unsigned int)\"Paul Eggert\",\n              0LL,\n              p_dest);\n            exit(0);\n          case -130:\n            sub_40A0D0(0);\n          case 1:\n            v103 = nptr;\n            if ( *nptr != 43 )\n              goto LABEL_171;\n            if ( dword_61C57C == (_DWORD)v5 )\n            {\n              LODWORD(mutex) = 0;\n            }\n            else\n            {\n              v129 = *(_BYTE **)(p_dest + 8LL * dword_61C57C);\n              LODWORD(mutex) = 0;\n              if ( *v129 == 45 )\n                LODWORD(mutex) = (unsigned int)((char)v129[1] - 48) <= 9;\n            }\n            LOBYTE(src) = (unsigned __int8)mutex & (v249 == 0LL) | (unsigned __int8)src;\n            if ( !(_BYTE)src )\n              goto LABEL_171;\n            v130 = 18LL;\n            v131 = &v265;\n            while ( v130 )\n            {\n              *(_DWORD *)v131 = 0;\n              v131 = (__int128 *)((char *)v131 + 4);\n              --v130;\n            }\n            v266 = -1LL;\n            v132 = (_BYTE *)sub_407C00(v103 + 1, &v265, 0LL);\n            v133 = -1LL;\n            if ( !v132 )\n            {\n              v103 = nptr;\n              if ( v265 == 0 )\n                *(_QWORD *)&v265 = -1LL;\n              goto LABEL_171;\n            }\n            if ( *v132 == 46 )\n            {\n              v132 = (_BYTE *)sub_407C00(v132 + 1, (char *)&v265 + 8, 0LL);\n              if ( v265 != 0 )\n              {\nLABEL_241:\n                if ( !v132 )\n                  goto LABEL_395;\n                goto LABEL_242;\n              }\n            }\n            else if ( v265 != 0 )\n            {\nLABEL_242:\n              if ( !*(_BYTE *)sub_405C00(v132, &v265, 0LL, v133) )\n              {\n                if ( (_DWORD)mutex )\n                {\n                  v134 = *(pthread_mutex_t **)(p_dest + 8LL * dword_61C57C++);\n                  mutex = v134;\n                  v135 = (_BYTE *)sub_407C00((char *)&v134->__lock + 1, v250, \"invalid number after '-'\");\n                  if ( !v135 )\n                    __assert_fail(\"s\", \"src/sort.c\", 0x110Du, \"main\");\n                  if ( *v135 == 46 )\nLABEL_409:\n                    v135 = (_BYTE *)sub_407C00(v135 + 1, v267, \"invalid number after '.'\");\n                  if ( !v267[0] && v266 )\n                    --v266;\n                  if ( *(_BYTE *)sub_405C00(v135, &v265, 1LL, v136) )\n                  {\n                    sub_405D30(mutex, \"stray character in field spec\");\nLABEL_427:\n                    sub_407DD0(src);\n                  }\n                }\n                v268 = 1;\n                v97 = sub_411410(&v265, 0x48uLL);\n                v137 = qword_61C750;\n                v99 = &qword_61C750;\n                while ( v137 )\n                {\n                  v99 = (__int64 *)(v137 + 64);\n                  v137 = *(_QWORD *)(v137 + 64);\n                }\nLABEL_221:\n                *v99 = v97;\n                *(_QWORD *)(v97 + 64) = 0LL;\n                continue;\n              }\nLABEL_395:\n              v103 = nptr;\nLABEL_171:\n              v41[v39++] = (__int64)v103;\n              continue;\n            }\n            *(_QWORD *)&v265 = -1LL;\n            goto LABEL_241;\n          case 67:\n          case 99:\n            goto LABEL_56;\n          case 77:\n          case 82:\n          case 86:\n          case 98:\n          case 100:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 110:\n          case 114:\n            goto LABEL_53;\n          case 83:\n            v104 = nptr;\n            mutex = (pthread_mutex_t *)nptr;\n            LODWORD(v254) = v258.rlim_cur;\n            v105 = sub_411B40(nptr);\n            if ( !v105 )\n            {\n              if ( (unsigned int)(*((char *)rlimits[0].sa_handler - 1) - 48) <= 9 )\n              {\n                if ( ptr.st_dev > 0x3FFFFFFFFFFFFFLL )\n                  goto LABEL_379;\n                ptr.st_dev <<= 10;\n              }\n              goto LABEL_176;\n            }\n            if ( v105 != 2\n              || (unsigned int)(*((char *)rlimits[0].sa_handler - 1) - 48) > 9\n              || *((_BYTE *)rlimits[0].sa_handler + 1) )\n            {\n              goto LABEL_227;\n            }\n            if ( *(_BYTE *)rlimits[0].sa_handler != 37 )\n            {\n              if ( *(_BYTE *)rlimits[0].sa_handler != 98 )\n                goto LABEL_227;\n              goto LABEL_176;\n            }\n            sub_40D840(v104, rlimits);\n            if ( (ptr.st_dev & 0x8000000000000000LL) != 0LL )\n              st_dev_low = (double)(int)(ptr.st_dev & 1 | (ptr.st_dev >> 1))\n                         + (double)(int)(ptr.st_dev & 1 | (ptr.st_dev >> 1));\n            else\n              st_dev_low = (double)SLODWORD(ptr.st_dev);\n            v37 = v37 * st_dev_low / 100.0;\n            if ( v37 >= 1.844674407370955e19 )\n            {\nLABEL_379:\n              v105 = 1;\nLABEL_227:\n              sub_411AB0(v105, (unsigned int)v254, 83LL, &off_414B40, mutex);\n            }\n            si128.m128i_i64[0] = 0x43E0000000000000LL;\n            if ( v37 < 9.223372036854776e18 )\n            {\n              ptr.st_dev = (unsigned int)(int)v37;\n              goto LABEL_176;\n            }\n            goto LABEL_406;\n          case 84:\n            sub_40A010(nptr);\n            continue;\n          case 107:\n            v91 = 18LL;\n            v92 = &v265;\n            while ( v91 )\n            {\n              *(_DWORD *)v92 = 0;\n              v92 = (__int128 *)((char *)v92 + 4);\n              --v91;\n            }\n            v266 = -1LL;\n            v93 = (_BYTE *)sub_407C00(nptr, &v265, \"invalid number at field start\");\n            v94 = v265;\n            v95 = v265 - 1;\n            *(_QWORD *)&v265 = v265 - 1;\n            if ( !v94 )\n              goto LABEL_423;\n            if ( *v93 == 46 )\n            {\n              v93 = (_BYTE *)sub_407C00(v93 + 1, (char *)&v265 + 8, \"invalid number after '.'\");\n              v193 = *((_QWORD *)&v265 + 1);\n              v95 = --*((_QWORD *)&v265 + 1);\n              if ( !v193 )\n              {\n                sub_405D30(nptr, \"character offset is zero\");\n                goto LABEL_375;\n              }\n            }\n            if ( v265 == 0 )\n              *(_QWORD *)&v265 = -1LL;\n            v96 = (_BYTE *)sub_405C00(v93, &v265, 0LL, v95);\n            if ( *v96 == 44 )\n            {\n              v190 = (_BYTE *)sub_407C00(v96 + 1, v250, \"invalid number after ','\");\n              v191 = v266;\n              v192 = --v266;\n              if ( !v191 )\n                goto LABEL_423;\n              if ( *v190 == 46 )\n                v190 = (_BYTE *)sub_407C00(v190 + 1, v267, \"invalid number after '.'\");\n              v96 = (_BYTE *)sub_405C00(v190, &v265, 1LL, v192);\n            }\n            else\n            {\n              v266 = -1LL;\n              v267[0] = 0LL;\n            }\n            if ( *v96 )\n            {\n              sub_405D30(nptr, \"stray character in field spec\");\n              start();\n            }\n            v97 = sub_411410(&v265, 0x48uLL);\n            v98 = qword_61C750;\n            v99 = &qword_61C750;\n            while ( v98 )\n            {\n              v99 = (__int64 *)(v98 + 64);\n              v98 = *(_QWORD *)(v98 + 64);\n            }\n            goto LABEL_221;\n          case 109:\n            LOBYTE(v248) = 1;\n            continue;\n          case 111:\n            v100 = file;\n            v101 = nptr;\n            if ( file )\n            {\n              file = nptr;\n              v102 = strcmp(v100, nptr);\n              v101 = file;\n              if ( v102 )\n                goto LABEL_419;\n            }\n            file = v101;\n            continue;\n          case 115:\n            byte_61C75A = 1;\n            continue;\n          case 116:\n            v90 = *nptr;\n            if ( !*nptr )\n            {\n              v201 = dcgettext(0LL, \"empty tab\", 5);\n              error(2, 0, v201);\n              goto LABEL_409;\n            }\n            if ( nptr[1] )\n            {\n              mutex = (pthread_mutex_t *)nptr;\n              if ( strcmp(nptr, \"\\\\0\") )\n              {\n                v206 = sub_40F880(mutex);\n                v207 = dcgettext(0LL, \"multi-character tab %s\", 5);\n                error(2, 0, v207, v206);\nLABEL_416:\n                v208 = dcgettext(0LL, \"incompatible tabs\", 5);\n                error(2, 0, v208);\nLABEL_417:\n                v209 = dcgettext(0LL, \"multiple random sources specified\", 5);\n                error(2, 0, v209);\nLABEL_418:\n                v210 = dcgettext(0LL, \"multiple compress programs specified\", 5);\n                error(2, 0, v210);\nLABEL_419:\n                v211 = dcgettext(0LL, \"multiple output files specified\", 5);\n                error(2, 0, v211);\nLABEL_420:\n                if ( !(_BYTE)stream )\n                  LOBYTE(stream) = 111;\n                byte_61C408 = (char)stream;\n                sub_405D00(&byte_61C408);\nLABEL_423:\n                sub_405D30(nptr, \"field number is zero\");\nLABEL_424:\n                sub_405D00(\"cC\");\nLABEL_425:\n                sub_407DD0(file);\n              }\n              v90 = 0;\n            }\n            if ( dword_61C424 != 128 && dword_61C424 != v90 )\n              goto LABEL_416;\n            dword_61C424 = v90;\n            continue;\n          case 117:\n            byte_61C759 = 1;\n            continue;\n          case 121:\n            v88 = nptr;\n            if ( *(char **)(p_dest + 8LL * dword_61C57C - 8) == nptr )\n            {\n              while ( 1 )\n              {\n                v89 = *v88;\n                if ( (unsigned int)(v89 - 48) > 9 )\n                  break;\n                ++v88;\n              }\n              dword_61C57C -= (_BYTE)v89 != 0;\n            }\n            continue;\n          case 122:\n            byte_61C500 = 0;\n            continue;\n          case 128:\n            LODWORD(v40) = 99;\n            if ( nptr )\n              LODWORD(v40) = byte_414B18[sub_40A910(\"--check\", nptr, off_414B20, byte_414B18, 1LL, off_61C510)];\nLABEL_56:\n            if ( (_BYTE)stream && (char)stream != (_DWORD)v40 )\n              goto LABEL_424;\n            LOBYTE(stream) = v40;\n            continue;\n          case 129:\n            v86 = nptr;\n            if ( arg )\n            {\n              mutex = (pthread_mutex_t *)nptr;\n              v87 = strcmp(arg, nptr);\n              v86 = (char *)mutex;\n              if ( v87 )\n                goto LABEL_418;\n            }\n            arg = v86;\n            continue;\n          case 130:\n            byte_61C740 = 1;\n            continue;\n          case 131:\n            goto LABEL_133;\n          case 132:\n            v254 = (__int64)nptr;\n            LODWORD(v255) = v258.rlim_cur;\n            LODWORD(mutex) = sub_411B40(nptr);\n            v81 = getrlimit(RLIMIT_NOFILE, (struct rlimit *)rlimits);\n            v82 = 17;\n            if ( !v81 )\n              v82 = LODWORD(rlimits[0].sa_handler) - 3;\n            if ( (_DWORD)mutex )\n            {\n              if ( (_DWORD)mutex != 1 )\n                sub_411AB0((unsigned int)mutex, (unsigned int)v255, 4294967172LL, &off_414B40, v254);\n            }\n            else\n            {\n              dword_61C420 = (int)dest;\n              if ( dest == (void *)(unsigned int)dest )\n              {\n                if ( (unsigned int)dest <= 1 )\n                {\n                  v212 = sub_40F880(v254);\n                  v213 = (&off_414B40)[4 * (int)v255];\n                  v214 = dcgettext(0LL, \"invalid --%s argument %s\", 5);\n                  error(0, 0, v214, v213, v212);\n                  v215 = sub_40F880(\"2\");\n                  v216 = dcgettext(0LL, \"minimum --%s argument is %s\", 5);\n                  error(2, 0, v216, v213, v215);\n                  goto LABEL_429;\n                }\n                if ( (unsigned int)dest <= v82 )\n                  continue;\n              }\n            }\n            LODWORD(stream) = v82;\n            v83 = sub_40F880(v254);\n            v5 = (__int64)(&off_414B40)[4 * (int)v255];\n            v84 = dcgettext(0LL, \"--%s argument %s too large\", 5);\n            error(0, 0, v84, v5, v83);\n            p_dest = sub_40D330((unsigned int)stream, &ptr);\n            v85 = dcgettext(0LL, \"maximum --%s argument with current rlimit is %s\", 5);\n            error(2, 0, v85, v5, p_dest);\nLABEL_133:\n            v240 = nptr;\n            continue;\n          case 133:\n            goto LABEL_123;\n          case 134:\n            LODWORD(v40) = aGhmnrv[sub_40A910(\"--sort\", nptr, off_414AE0, \"ghMnRV\", 1LL, off_61C510)];\nLABEL_53:\n            LOWORD(rlimits[0].sa_handler) = (unsigned __int8)v40;\n            sub_405C00(rlimits, v269, 2LL, v47);\n            continue;\n          case 135:\n            mutex = (pthread_mutex_t *)nptr;\n            rlim_cur = v258.rlim_cur;\n            v76 = sub_411680(nptr);\n            if ( v76 == 1 )\n            {\n              sa_handler = -1LL;\n            }\n            else\n            {\n              if ( v76 )\n                sub_411AB0(v76, rlim_cur, 4294967175LL, &off_414B40, mutex);\n              sa_handler = (unsigned __int64)rlimits[0].sa_handler;\n              if ( !rlimits[0].sa_handler )\n              {\n                v77 = dcgettext(0LL, \"number in parallel must be nonzero\", 5);\n                error(2, 0, v77);\nLABEL_123:\n                v78 = s1;\n                v79 = nptr;\n                if ( s1 )\n                {\n                  s1b = nptr;\n                  v80 = strcmp(v78, nptr);\n                  v79 = s1b;\n                  if ( v80 )\n                    goto LABEL_417;\n                }\n                s1 = v79;\n              }\n            }\n            continue;\n          default:\n            goto LABEL_404;\n        }\n      }\n      break;\n    }\n    v42 = dword_61C57C;\n    if ( (_BYTE)src != 1 || (_BYTE)stream )\n      goto LABEL_43;\n    if ( dword_61C57C != (_DWORD)v5 )\n    {\n      v43 = *(_BYTE **)(p_dest + 8LL * dword_61C57C);\n      if ( *v43 != 45 || v43[1] != 111 || !v43[2] && dword_61C57C + 1 == (_DWORD)v5 )\n        goto LABEL_43;\n      goto LABEL_50;\n    }\n    if ( v240 )\n      goto LABEL_403;\n    LOBYTE(stream) = 0;\nLABEL_61:\n    if ( qword_61C750 )\n    {\n      v48 = qword_61C750;\n      LODWORD(v5) = 0;\n      do\n      {\n        while ( (unsigned __int8)sub_405AF0(v48) && !*(_BYTE *)(v48 + 55) )\n        {\n          v49 = HIBYTE(v271);\n          *(_QWORD *)(v48 + 32) = *((_QWORD *)&v270 + 1);\n          *(_QWORD *)(v48 + 40) = v271;\n          *(_WORD *)(v48 + 48) = WORD4(v271);\n          *(_BYTE *)(v48 + 54) = BYTE14(v271);\n          *(_BYTE *)(v48 + 50) = BYTE10(v271);\n          *(_WORD *)(v48 + 52) = WORD6(v271);\n          v50 = v272;\n          *(_BYTE *)(v48 + 55) = v49;\n          *(_BYTE *)(v48 + 56) = v50;\n          v51 = BYTE11(v271);\n          *(_BYTE *)(v48 + 51) = BYTE11(v271);\n          v48 = *(_QWORD *)(v48 + 64);\n          v5 = v51 | (unsigned int)v5;\n          if ( !v48 )\n            goto LABEL_67;\n        }\n        v53 = *(unsigned __int8 *)(v48 + 51);\n        v48 = *(_QWORD *)(v48 + 64);\n        v5 = v53 | (unsigned int)v5;\n      }\n      while ( v48 );\nLABEL_67:\n      st_size = 0LL;\nLABEL_68:\n      if ( (unsigned __int8)((*(_QWORD *)(v52 + 32) != 0LL) | *(_BYTE *)(v52 + 56) | *(_BYTE *)(v52 + 51))\n         + *(unsigned __int8 *)(v52 + 54)\n         + *(unsigned __int8 *)(v52 + 53)\n         + *(unsigned __int8 *)(v52 + 52)\n         + *(unsigned __int8 *)(v52 + 50) > 1 )\n      {\nLABEL_405:\n        *(_BYTE *)(v52 + 55) = 0;\n        *(_WORD *)(v52 + 48) = 0;\n        sub_405B50(v52, &ptr);\n        v37 = sub_405D00(&ptr);\nLABEL_406:\n        v37 = v37 - *(double *)si128.m128i_i64;\n        ptr.st_dev = (unsigned int)(int)v37;\n        ptr.st_dev ^= 0x8000000000000000LL;\nLABEL_176:\n        if ( ptr.st_dev >= qword_61C778 )\n        {\n          st_dev = 34LL * (unsigned int)dword_61C420;\n          if ( st_dev < ptr.st_dev )\n            st_dev = ptr.st_dev;\n          qword_61C778 = st_dev;\n        }\n        continue;\n      }\n      while ( 1 )\n      {\n        v52 = *(_QWORD *)(v52 + 64);\n        if ( !v52 )\n          break;\n        if ( *(unsigned __int8 *)(v52 + 53)\n           + *(unsigned __int8 *)(v52 + 52)\n           + *(unsigned __int8 *)(v52 + 50)\n           + *(unsigned __int8 *)(v52 + 54)\n           + (unsigned __int8)((*(_QWORD *)(v52 + 32) != 0LL) | *(_BYTE *)(v52 + 51) | *(_BYTE *)(v52 + 56)) > 1 )\n          goto LABEL_405;\n      }\nLABEL_72:\n      if ( byte_61C740 )\n      {\nLABEL_73:\n        if ( (_BYTE)stream || file )\n          goto LABEL_420;\n        if ( !v247 || !setlocale(3, \"\") )\n        {\n          v128 = dcgettext(0LL, \"failed to set locale\", 5);\n          error(0, 0, \"%s\", v128);\n        }\n        if ( byte_61CBA1 )\n        {\n          v125 = setlocale(3, 0LL);\n          v126 = sub_40F880(v125);\n          v127 = dcgettext(0LL, \"using %s sorting rules\", 5);\n          error(0, 0, v127, v126);\n        }\n        else\n        {\n          v54 = dcgettext(0LL, \"using simple byte comparison\", 5);\n          error(0, 0, \"%s\", v54);\n        }\n        v40 = qword_61C750;\n        p_ptr = &ptr;\n        v56 = 18LL;\n        v57 = v269;\n        src = (char *)&ptr;\n        p_dest = 1LL;\n        while ( v56 )\n        {\n          LODWORD(p_ptr->st_dev) = *(_DWORD *)v57;\n          v57 = (__int64 *)((char *)v57 + 4);\n          p_ptr = (struct stat *)((char *)p_ptr + 4);\n          --v56;\n        }\n        if ( v40 )\n        {\n          LOBYTE(mutex) = v5;\n          v58 = v40;\n          v247 = (char *)&v258.rlim_cur + 1;\n          v249 = (char *)v39;\n          v250 = v41;\n          while ( 1 )\n          {\n            v61 = *(_QWORD *)v58;\n            v62 = *(_QWORD *)(v58 + 16);\n            if ( *(_BYTE *)(v58 + 57) )\n            {\n              if ( v61 == -1LL )\n                v61 = 0LL;\n              v63 = sub_40D370(v61, v257);\n              LOBYTE(v258.rlim_cur) = 43;\n              v64 = __stpcpy_chk((char *)&v258.rlim_cur + 1, v63, 45LL);\n              v65 = sub_40D370(v61 + 1, v257);\n              LODWORD(dest) = 2124589;\n              v240 = (char *)__stpcpy_chk((char *)&dest + 3, v65, 44LL);\n              if ( *(_QWORD *)(v58 + 16) != -1LL )\n              {\n                v66 = v62 + 1;\n                v67 = (const char *)sub_40D370(v66, v257);\n                *(_WORD *)v64 = 11552;\n                strcpy((char *)(v64 + 2), v67);\n                v68 = (const char *)sub_40D370(v66 + (*(_QWORD *)(v58 + 24) == -1LL), v257);\n                *v240 = 44;\n                strcpy(v240 + 1, v68);\n              }\n              v40 = sub_40F860(1LL, &dest);\n              v69 = sub_40F860(0LL, &v258);\n              v70 = dcgettext(0LL, \"obsolescent key %s used; consider %s instead\", 5);\n              error(0, 0, v70, v69, v40);\n              v61 = *(_QWORD *)v58;\n              v62 = *(_QWORD *)(v58 + 16);\n            }\n            v71 = st_size;\n            if ( v61 != -1LL && v62 < v61 )\n            {\n              v72 = dcgettext(0LL, \"key %lu has zero width and will be ignored\", 5);\n              error(0, 0, v72, p_dest);\n              v62 = *(_QWORD *)(v58 + 16);\n              v71 = 1;\n            }\n            v73 = 1;\n            v74 = *(_QWORD *)(v58 + 48) & 0xFFFF00FF0000LL;\n            if ( !v74 )\n              v73 = *(unsigned __int8 *)(v58 + 54);\n            if ( v62 || !*(_QWORD *)(v58 + 24) )\n            {\n              if ( !v71 )\n              {\n                if ( dword_61C424 == 128\n                  && (!*(_BYTE *)(v58 + 48) && (!v73 || *(_QWORD *)(v58 + 8))\n                   || !*(_BYTE *)(v58 + 49) && *(_QWORD *)(v58 + 24)) )\n                {\n                  v75 = dcgettext(0LL, \"leading blanks are significant in key %lu; consider also specifying 'b'\", 5);\n                  error(0, 0, v75, p_dest);\n                  v74 = *(_QWORD *)(v58 + 48) & 0xFFFF00FF0000LL;\n                }\nLABEL_86:\n                if ( v74 )\n                {\n                  v59 = *(_QWORD *)v58 + 1LL;\n                  if ( *(_QWORD *)v58 == -1LL )\n                    v59 = 1LL;\n                  if ( *(_QWORD *)(v58 + 16) == -1LL || *(_QWORD *)(v58 + 16) + 1LL > v59 )\n                  {\n                    v141 = dcgettext(0LL, \"key %lu is numeric and spans multiple fields\", 5);\n                    error(0, 0, v141, p_dest);\n                  }\n                }\n                goto LABEL_91;\n              }\n            }\n            else if ( !v71 )\n            {\n              goto LABEL_86;\n            }\n            if ( !(_BYTE)st_size )\n              goto LABEL_86;\nLABEL_91:\n            if ( *(_QWORD *)&ptr.st_gid && *(_QWORD *)&ptr.st_gid == *(_QWORD *)(v58 + 32) )\n              *(_QWORD *)&ptr.st_gid = 0LL;\n            if ( ptr.st_rdev && ptr.st_rdev == *(_QWORD *)(v58 + 40) )\n              ptr.st_rdev = 0LL;\n            ++p_dest;\n            LOBYTE(ptr.st_size) &= *(_BYTE *)(v58 + 48) ^ 1;\n            BYTE1(ptr.st_size) &= *(_BYTE *)(v58 + 49) ^ 1;\n            BYTE6(ptr.st_size) &= *(_BYTE *)(v58 + 54) ^ 1;\n            BYTE2(ptr.st_size) &= *(_BYTE *)(v58 + 50) ^ 1;\n            BYTE4(ptr.st_size) &= *(_BYTE *)(v58 + 52) ^ 1;\n            BYTE5(ptr.st_size) &= *(_BYTE *)(v58 + 53) ^ 1;\n            BYTE3(ptr.st_size) &= *(_BYTE *)(v58 + 51) ^ 1;\n            LOBYTE(ptr.st_blksize) &= *(_BYTE *)(v58 + 56) ^ 1;\n            v60 = *(_BYTE *)(v58 + 55);\n            v58 = *(_QWORD *)(v58 + 64);\n            HIBYTE(ptr.st_size) &= v60 ^ 1;\n            if ( !v58 )\n            {\n              v39 = (unsigned __int64)v249;\n              v41 = v250;\n              LOBYTE(v5) = (_BYTE)mutex;\n              break;\n            }\n          }\n        }\n        v107 = sub_405AF0(&ptr);\n        st_size_high = HIBYTE(ptr.st_size);\n        if ( v107 )\n        {\n          if ( HIBYTE(ptr.st_size) )\n          {\n            if ( byte_61C75A )\n            {\n              if ( qword_61C750 )\n              {\n                p_dest = (unsigned __int64)&dest;\n                sub_405B50(&ptr, &dest);\n                v194 = dcngettext(\n                         0LL,\n                         \"option '-%s' is ignored\",\n                         \"options '-%s' are ignored\",\n                         strlen((const char *)&dest),\n                         5);\n                error(0, 0, v194, &dest);\n                HIBYTE(ptr.st_size) = 1;\n                goto LABEL_186;\n              }\n            }\n            else\n            {\n              if ( byte_61C759 && qword_61C750 )\n              {\n                p_dest = (unsigned __int64)&dest;\n                sub_405B50(&ptr, &dest);\n                v161 = dcngettext(\n                         0LL,\n                         \"option '-%s' is ignored\",\n                         \"options '-%s' are ignored\",\n                         strlen((const char *)&dest),\n                         5);\n                error(0, 0, v161, &dest);\n                HIBYTE(ptr.st_size) = st_size_high;\n                goto LABEL_186;\n              }\nLABEL_187:\n              if ( !byte_61C759 && qword_61C750 )\n              {\n                v110 = dcgettext(0LL, \"option '-r' only applies to last-resort comparison\", 5);\n                error(0, 0, v110);\n              }\n            }\n          }\n        }\n        else\n        {\n          if ( !byte_61C75A && !byte_61C759 )\n            HIBYTE(ptr.st_size) = 0;\n          p_dest = (unsigned __int64)&dest;\n          sub_405B50(&ptr, &dest);\n          v109 = dcngettext(0LL, \"option '-%s' is ignored\", \"options '-%s' are ignored\", strlen((const char *)&dest), 5);\n          error(0, 0, v109, &dest);\n          HIBYTE(ptr.st_size) = st_size_high;\n          if ( st_size_high )\n          {\nLABEL_186:\n            if ( !byte_61C75A )\n              goto LABEL_187;\n          }\n        }\n      }\n      byte_61C75B = HIBYTE(v271);\n      if ( (_BYTE)v5 )\n      {\n        v138 = sub_40F900(s1, 16LL);\n        v139 = \"open failed\";\n        v140 = (void *)v138;\n        if ( !v138 )\n          goto LABEL_414;\n        src = (char *)&ptr;\n        sub_40FC10(v138, &ptr, 16LL);\n        if ( (unsigned int)sub_40FD70(v140) )\n        {\n          v139 = \"close failed\";\nLABEL_414:\n          v205 = dcgettext(0LL, v139, 5);\n          sub_405DD0(v205, s1);\n        }\n        sub_40AA90(&xmmword_61C600);\n        sub_40B360(&ptr, 0x10uLL);\n      }\n    }\n    else\n    {\n      if ( !(unsigned __int8)sub_405AF0(v269) )\n      {\n        v187 = sub_411410(v269, 0x48uLL);\n        v188 = qword_61C750;\n        v189 = &qword_61C750;\n        while ( v188 )\n        {\n          v189 = (__int64 *)(v188 + 64);\n          v188 = *(_QWORD *)(v188 + 64);\n        }\n        *v189 = v187;\n        v52 = qword_61C750;\n        st_size = 1LL;\n        *(_QWORD *)(v187 + 64) = 0LL;\n        v5 = BYTE11(v271);\n        if ( v52 )\n          goto LABEL_68;\n        goto LABEL_72;\n      }\n      if ( byte_61C740 )\n      {\n        LOBYTE(st_size) = 0;\n        LOBYTE(v5) = 0;\n        goto LABEL_73;\n      }\n      byte_61C75B = HIBYTE(v271);\n    }\n    break;\n  }\n  if ( !qword_61C768 )\n  {\n    v160 = getenv(\"TMPDIR\");\n    if ( !v160 )\n      v160 = \"/tmp\";\n    sub_40A010(v160);\n  }\n  if ( !v39 )\n  {\n    v39 = 1LL;\n    free(v41);\n    v41 = (__int64 *)sub_411210(8LL);\n    *v41 = (__int64)\"-\";\n  }\n  if ( qword_61C778 )\n  {\n    v111 = 34LL * (unsigned int)dword_61C420;\n    if ( v111 < qword_61C778 )\n      v111 = qword_61C778;\n    qword_61C778 = v111;\n  }\n  if ( (_BYTE)stream )\n  {\n    if ( v39 <= 1 )\n    {\n      if ( file )\n      {\n        byte_61C400 = (char)stream;\n        sub_405D00(&byte_61C400);\n      }\n      else\n      {\n        v41 = (__int64 *)*v41;\n        v112 = (FILE *)sub_407CD0((char *)v41, \"r\");\n        if ( v112 )\n        {\n          s1a = (char *)qword_61C750;\n          v113 = byte_61C759 ^ 1;\n          v114 = qword_61C428;\n          if ( qword_61C778 >= (unsigned __int64)qword_61C428 )\n            v114 = qword_61C778;\n          v115 = 0LL;\n          sub_405E30(&ptr, 32LL, v114);\n          dest = 0LL;\n          v241 = 0LL;\n          while ( 1 )\n          {\n            if ( !(unsigned __int8)sub_4074D0(&ptr, v112, v41) )\n            {\n              v123 = 1;\n              goto LABEL_220;\n            }\n            v116 = ptr.st_dev + *(_QWORD *)&ptr.st_mode - 32;\n            v117 = ptr.st_dev + *(_QWORD *)&ptr.st_mode - 32 * ptr.st_nlink;\n            if ( v115 )\n            {\n              v122 = sub_4082A0(&dest, ptr.st_dev + *(_QWORD *)&ptr.st_mode - 32);\n              if ( v113 <= v122 )\n                break;\n            }\n            while ( 1 )\n            {\n              v118 = v116;\n              if ( v117 >= v116 )\n                break;\n              v116 -= 32LL;\n              if ( v113 <= (int)sub_4082A0(v118, v116) )\n                goto LABEL_218;\n            }\n            v119 = *(_QWORD *)(v116 + 8);\n            v241 += ptr.st_nlink;\n            if ( v115 < v119 )\n            {\n              while ( 1 )\n              {\n                v115 *= 2LL;\n                if ( !v115 )\n                  break;\n                if ( v119 <= v115 )\n                  goto LABEL_216;\n              }\n              v115 = *(_QWORD *)(v116 + 8);\nLABEL_216:\n              free(dest);\n              v121 = (void *)sub_411210(v115);\n              v119 = *(_QWORD *)(v116 + 8);\n              dest = v121;\n            }\n            memcpy(dest, *(const void **)v116, v119);\n            v260 = *(_QWORD *)(v116 + 8);\n            if ( s1a )\n            {\n              v120 = (char *)dest + *(_QWORD *)(v116 + 24) - *(_QWORD *)v116;\n              v261 = (unsigned __int64)dest + *(_QWORD *)(v116 + 16) - *(_QWORD *)v116;\n              v262 = v120;\n            }\n          }\nLABEL_218:\n          v123 = 0;\n          if ( (_BYTE)stream == 99 )\n          {\n            v176 = sub_40D370(&v241[(__int64)(ptr.st_dev + *(_QWORD *)&ptr.st_mode - v116) >> 5], &v258);\n            v177 = qword_61CBC8;\n            v178 = v176;\n            v179 = dcgettext(0LL, \"%s: %s:%s: disorder: \", 5);\n            __fprintf_chk(stderr, 1LL, v179, v177, v41, v178);\n            v180 = dcgettext(0LL, \"standard error\", 5);\n            sub_407E70(v116, stderr, v180);\n          }\nLABEL_220:\n          sub_407DF0(v112);\n          free((void *)ptr.st_dev);\n          free(dest);\n          return (unsigned __int8)v123 ^ 1u;\n        }\n      }\n      sub_407DD0(v41);\n    }\n    v218 = sub_40F630(4LL, v41[1]);\n    v219 = dcgettext(0LL, \"extra operand %s not allowed with -%c\", 5);\n    error(2, 0, v219, v218, (unsigned int)(char)stream);\nLABEL_432:\n    if ( v240 )\n    {\n      if ( v39 )\n      {\nLABEL_403:\n        v198 = sub_40F630(4LL, *v41);\n        v199 = dcgettext(0LL, \"extra operand %s\", 5);\n        error(0, 0, v199, v198);\n        v200 = dcgettext(0LL, \"file operands cannot be combined with --files0-from\", 5);\n        __fprintf_chk(stderr, 1LL, \"%s\\n\", v200);\nLABEL_404:\n        sub_40A0D0(2);\n      }\n      v220 = (FILE *)sub_407CD0(v240, \"r\");\n      if ( !v220 )\nLABEL_446:\n        sub_407DD0(v240);\n      sub_4103A0(rlimits);\n      v221 = v240;\n      if ( (unsigned __int8)sub_410440(v220) )\n      {\n        sub_407DF0(v220);\n        v222 = rlimits[0].sa_handler;\n        if ( rlimits[0].sa_handler )\n        {\n          free(v41);\n          v41 = (__int64 *)rlimits[0].sa_mask.__val[0];\n          v225 = \"-\";\n          while ( 1 )\n          {\n            v226 = *(_BYTE **)(rlimits[0].sa_mask.__val[0] + 8 * v39);\n            v227 = 2LL;\n            v228 = \"-\";\n            v229 = v226;\n            do\n            {\n              if ( !v227 )\n                break;\n              v223 = *v229 < (unsigned __int8)*v228;\n              v224 = *v229++ == (unsigned __int8)*v228++;\n              --v227;\n            }\n            while ( v224 );\n            if ( (!v223 && !v224) == v223 )\n              break;\n            ++v39;\n            if ( !*v226 )\n              goto LABEL_445;\n            v223 = (unsigned __int64)v222 < v39;\n            v224 = v222 == (__sighandler_t)v39;\n            if ( v222 == (__sighandler_t)v39 )\n              goto LABEL_61;\n          }\n          v230 = sub_40F630(4LL, *(_QWORD *)(rlimits[0].sa_mask.__val[0] + 8 * v39));\n          v231 = dcgettext(0LL, \"when reading file names from stdin, no file name of %s allowed\", 5);\n          error(2, 0, v231, v230);\nLABEL_445:\n          v232 = sub_40F700(0LL, 3LL, v240, v227, v225);\n          v233 = dcgettext(0LL, \"%s:%lu: invalid zero-length file name\", 5);\n          error(2, 0, v233, v232, v39);\n          goto LABEL_446;\n        }\n        v234 = sub_40F630(4LL, v240);\n        v235 = dcgettext(0LL, \"no input from %s\", 5);\n        v221 = 0LL;\n        error(2, 0, v235, v234);\n      }\n      v236 = sub_40F630(4LL, v221);\n      v237 = dcgettext(0LL, \"cannot read file names from %s\", 5);\n      v35 = 0LL;\n      v38 = 2LL;\n      error(2, 0, v237, v236);\nLABEL_449:\n      sub_411460(v38, v35, v36);\n    }\n    goto LABEL_61;\n  }\n  v142 = (const char **)v41;\n  v143 = 0;\n  v144 = 1;\n  v145 = 0LL;\n  v256 = \"-\";\n  while ( 2 )\n  {\n    v146 = *v142;\n    v147 = 2LL;\n    v148 = \"-\";\n    v149 = (__int64)*v142;\n    do\n    {\n      if ( !v147 )\n        break;\n      v143 = *(_BYTE *)v149 < (unsigned __int8)*v148;\n      v144 = *(_BYTE *)v149++ == (unsigned __int8)*v148++;\n      --v147;\n    }\n    while ( v144 );\n    if ( (!v143 && !v144) != v143 )\n    {\n      v149 = 4LL;\n      if ( euidaccess(*v142, 4) )\n      {\n        v203 = *v142;\n        v202 = \"cannot read\";\nLABEL_412:\n        v204 = dcgettext(0LL, v202, 5);\n        sub_405DD0(v204, v203);\n      }\n    }\n    ++v142;\n    v143 = v39 < v145 + 1;\n    v144 = v39 == v145 + 1;\n    if ( v39 != v145 + 1 )\n    {\n      ++v145;\n      continue;\n    }\n    break;\n  }\n  if ( !file )\n    goto LABEL_271;\n  v149 = 524353LL;\n  v150 = open(file, 524353, 438LL);\n  if ( v150 < 0 )\n  {\nLABEL_429:\n    v217 = dcgettext(0LL, \"open failed\", 5);\n    sub_405DD0(v217, file);\n  }\n  if ( v150 != 1 )\n  {\n    v149 = 1LL;\n    sub_408E10(v150);\n  }\nLABEL_271:\n  if ( (_BYTE)v248 )\n  {\n    v181 = sub_4113E0(v145 + 1, 16LL, v146, v147);\n    for ( k = 0LL; ; ++k )\n    {\n      *(_QWORD *)(v181 + 16 * k) = v41[k];\n      if ( k == v145 )\n        break;\n    }\n    sub_409330(v181, 0LL, v145 + 1, file);\n    goto LABEL_309;\n  }\n  if ( !sa_handler )\n  {\n    v195 = sub_40D6F0(2LL, v149, v146, v147);\n    v196 = 8LL;\n    if ( v195 <= 8 )\n      v196 = v195;\n    sa_handler = v196;\n  }\n  v255 = (char **)v41;\n  v151 = 0xFFFFFFFFFFFFFFLL;\n  v262 = 0LL;\n  v248 = (__int64 *)(v145 + 1);\n  if ( sa_handler <= 0xFFFFFFFFFFFFFFLL )\n    v151 = sa_handler;\n  v152 = 0LL;\n  v247 = (char *)v151;\n  v249 = (char *)(v151 << 8);\n  v250 = (__int64 *)(2 * v151);\n  mutex = (pthread_mutex_t *)&ptr.st_ino;\n  while ( 2 )\n  {\n    src = *v255;\n    stream = (FILE *)sub_407CD0(*v255, \"r\");\n    if ( !stream )\n      goto LABEL_427;\n    v254 = 48LL;\n    if ( sa_handler > 1 )\n    {\n      v163 = 1LL;\n      v164 = 1LL;\n      do\n      {\n        v164 *= 2LL;\n        ++v163;\n      }\n      while ( (unsigned __int64)v247 > v164 );\n      v254 = 32 * v163;\n    }\n    if ( v262 )\n      goto LABEL_279;\n    v41 = v248;\n    s1 = (char *)v152;\n    v39 = 0LL;\n    p_dest = v254 + 1;\n    v5 = v254 + 2;\n    while ( 2 )\n    {\n      if ( v39 )\n      {\n        if ( !memcmp(v255[v39], v256, 2uLL) )\n          v167 = __fxstat(1, 0, &ptr) != 0;\n        else\n          v167 = __xstat(1, v255[v39], &ptr) != 0;\n      }\n      else\n      {\n        v175 = fileno(stream);\n        v167 = __fxstat(1, v175, &ptr) != 0;\n      }\n      if ( v167 )\n      {\n        v202 = \"stat failed\";\n        v203 = v255[v39];\n        goto LABEL_412;\n      }\n      if ( (ptr.st_mode & 0xF000) == 0x8000 )\n      {\n        st_size = ptr.st_size;\n        if ( !qword_61C5E0 )\n        {\n          qword_61C5E0 = qword_61C778;\n          if ( !qword_61C778 )\n            goto LABEL_329;\n        }\n      }\n      else\n      {\n        v165 = qword_61C778;\n        if ( qword_61C778 )\n          goto LABEL_361;\n        st_size = 0x20000LL;\n        if ( !qword_61C5E0 )\n        {\nLABEL_329:\n          v168 = -1LL;\n          if ( !getrlimit(RLIMIT_DATA, &v258) )\n            v168 = v258.rlim_cur;\n          if ( !getrlimit(RLIMIT_AS, &v258) && v168 > v258.rlim_cur )\n            v168 = v258.rlim_cur;\n          v169 = v168 >> 1;\n          if ( !getrlimit(__RLIMIT_RSS, &v258) && v169 > 15 * (v258.rlim_cur >> 4) )\n            v169 = 15 * (v258.rlim_cur >> 4);\n          v242 = sub_40D900();\n          v170 = sub_40D840(5LL, &v258);\n          v171 = 0.125 * v170;\n          v172 = v170 * 0.75;\n          *(double *)si128.m128i_i64 = fmax(v242, v171);\n          if ( (double)(int)v169 > v172 )\n          {\n            if ( v172 < 9.223372036854776e18 )\n              v169 = (unsigned int)(int)v172;\n            else\n              v169 = (unsigned int)(int)(v172 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n          }\n          if ( (v169 & 0x8000000000000000LL) != 0LL )\n            v173 = (double)(int)(v169 & 1 | (v169 >> 1)) + (double)(int)(v169 & 1 | (v169 >> 1));\n          else\n            v173 = (double)(int)v169;\n          if ( v173 > *(double *)si128.m128i_i64 )\n          {\n            if ( *(double *)si128.m128i_i64 < 9.223372036854776e18 )\nLABEL_375:\n              v169 = (unsigned int)(int)*(double *)si128.m128i_i64;\n            else\n              v169 = (unsigned int)(int)(*(double *)si128.m128i_i64 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n          }\n          v174 = 34LL * (unsigned int)dword_61C420;\n          if ( v174 < v169 )\n            v174 = v169;\n          qword_61C5E0 = v174;\n        }\n      }\n      v165 = qword_61C5E0;\n      v166 = st_size * p_dest + 1;\n      if ( st_size != v166 / p_dest || v166 >= qword_61C5E0 - v5 )\n      {\nLABEL_361:\n        v152 = (unsigned __int64)s1;\n        v5 = v165;\n        goto LABEL_362;\n      }\n      ++v39;\n      v5 += v166;\n      if ( v39 < (unsigned __int64)v41 )\n        continue;\n      break;\n    }\n    v152 = (unsigned __int64)s1;\nLABEL_362:\n    sub_405E30(&dest, v254, v5);\nLABEL_279:\n    v264 = 0;\n    v248 = (__int64 *)((char *)v248 - 1);\nLABEL_282:\n    if ( !(unsigned __int8)sub_4074D0(&dest, stream, src) )\n    {\n      v35 = src;\n      sub_407DF0(stream);\n      if ( v248 )\n        goto LABEL_305;\n      v38 = (__int64)dest;\n      free(dest);\n      v183 = ::ptr;\n      v36 = (v152 * (unsigned __int128)0x10uLL) >> 64 != 0;\n      if ( (v152 & 0x800000000000000LL) == 0 && is_mul_ok(v152, 0x10uLL) )\n      {\n        v184 = (_QWORD *)sub_411210(16 * v152);\n        v185 = v184;\n        while ( v183 )\n        {\n          v186 = (char *)v183 + 13;\n          v185[1] = v183;\n          v183 = (_QWORD *)*v183;\n          v185 += 2;\n          *(v185 - 2) = v186;\n        }\n        sub_409330(v184, v152, v152, file);\n        free(v184);\n        goto LABEL_307;\n      }\n      goto LABEL_449;\n    }\n    v156 = v264;\n    if ( !v264 )\n      goto LABEL_286;\n    if ( v248 )\n    {\n      if ( v254 + 1 >= (unsigned __int64)&v262[-v260 - v261 * v254] )\n      {\nLABEL_286:\n        *(_QWORD *)&xmmword_61CB80 = 0LL;\n        v157 = &v262[(_QWORD)dest];\n        goto LABEL_287;\n      }\n      v263 = v260;\n      sub_407DF0(stream);\nLABEL_305:\n      ++v255;\n      continue;\n    }\n    break;\n  }\n  v157 = &v262[(_QWORD)dest];\n  *(_QWORD *)&xmmword_61CB80 = 0LL;\n  if ( v263 | v152 )\n  {\nLABEL_287:\n    ++v152;\n    v156 = 0;\n    v158 = sub_4090C0(&v258, 0LL) + 13;\n  }\n  else\n  {\n    sub_407DF0(stream);\n    v159 = sub_407CD0(file, \"w\");\n    if ( !v159 )\n      goto LABEL_425;\n    v258.rlim_cur = v159;\n    v158 = (__int64)file;\n    v152 = 0LL;\n  }\n  if ( v261 > 1 )\n  {\n    ptr.st_dev = sub_40CFD0(sub_407850, v250);\n    pthread_mutex_init(mutex, 0LL);\n    pthread_cond_init((pthread_cond_t *)&ptr.st_size, 0LL);\n    v153 = v261;\n    v154 = sub_411210(v249);\n    *(_QWORD *)(v154 + 48) = v153;\n    v155 = v154;\n    *(_QWORD *)(v154 + 40) = v153;\n    *(_QWORD *)(v154 + 24) = 0LL;\n    *(_QWORD *)(v154 + 16) = 0LL;\n    *(_QWORD *)(v154 + 8) = 0LL;\n    *(_QWORD *)v154 = 0LL;\n    *(_QWORD *)(v154 + 32) = 0LL;\n    *(_QWORD *)(v154 + 56) = 0LL;\n    *(_DWORD *)(v154 + 80) = 0;\n    *(_BYTE *)(v154 + 84) = 0;\n    pthread_mutex_init((pthread_mutex_t *)(v154 + 88), 0LL);\n    sub_4061F0(v155, v155 + 128, v157, v247, v153, 0LL);\n    sub_409880((_DWORD)v157, (_DWORD)v247, v261, v155 + 128, (unsigned int)&ptr, v258.rlim_cur, v158);\n  }\n  else\n  {\n    sub_4085D0(v157 - 32, v258.rlim_cur, v158);\n  }\n  sub_407DF0((FILE *)v258.rlim_cur);\n  if ( !v156 )\n    goto LABEL_282;\n  free(dest);\nLABEL_307:\n  while ( dword_61C69C > 0 )\n    sub_405FB0(-1);\nLABEL_309:\n  if ( byte_61C758 && (unsigned int)sub_411F80(stdin) == -1 )\n  {\n    v162 = dcgettext(0LL, \"close failed\", 5);\n    sub_405DD0(v162, \"-\");\n  }\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40585B",
            "funcStartAddr": "0x40585b",
            "funcEndAddr": "0x40587a",
            "decompiledFuncCode": "void *sub_40585B()\n{\n  return &unk_61C588;\n}\n"
        },
        {
            "funcName": "sub_40587A",
            "funcStartAddr": "0x40587a",
            "funcEndAddr": "0x4058b1",
            "decompiledFuncCode": "__int64 sub_40587A()\n{\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_4058B1",
            "funcStartAddr": "0x4058b1",
            "funcEndAddr": "0x405908",
            "decompiledFuncCode": "void *sub_4058B1()\n{\n  void *result; // rax\n\n  if ( !byte_61C5C8 )\n  {\n    while ( qword_61C5D0 < (unsigned __int64)(&qword_61BE38 - qword_61BE30 - 1) )\n      ((void (*)(void))qword_61BE30[++qword_61C5D0])();\n    result = sub_40585B();\n    byte_61C5C8 = 1;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405908",
            "funcStartAddr": "0x405908",
            "funcEndAddr": "0x40590d",
            "decompiledFuncCode": "// attributes: thunk\n__int64 sub_405908()\n{\n  return sub_40587A();\n}\n"
        },
        {
            "funcName": "sub_405910",
            "funcStartAddr": "0x405910",
            "funcEndAddr": "0x40591d",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_405910(__int64 a1, unsigned __int64 a2)\n{\n  return *(int *)(a1 + 8) % a2;\n}\n"
        },
        {
            "funcName": "sub_405920",
            "funcStartAddr": "0x405920",
            "funcEndAddr": "0x40592a",
            "decompiledFuncCode": "bool __fastcall sub_405920(__int64 a1, __int64 a2)\n{\n  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);\n}\n"
        },
        {
            "funcName": "sub_405930",
            "funcStartAddr": "0x405930",
            "funcEndAddr": "0x4059e8",
            "decompiledFuncCode": "__int64 __fastcall sub_405930(unsigned __int8 **a1)\n{\n  unsigned __int8 *v1; // rcx\n  char v2; // r10\n  __int64 result; // rax\n  unsigned int v4; // edx\n  unsigned __int8 *v5; // rsi\n  unsigned int v6; // r8d\n  unsigned __int8 *v7; // rcx\n  unsigned int v8; // edx\n\n  v1 = *a1;\n  v2 = 0;\n  result = 0LL;\n  v4 = **a1;\n  while ( 1 )\n  {\n    v5 = v1 + 1;\n    if ( (unsigned int)(unsigned __int8)v4 - 48 > 9 )\n      break;\n    if ( (unsigned __int8)result < (unsigned __int8)v4 )\n      result = v4;\n    v2 = 0;\n    v4 = (char)v1[1];\n    if ( v4 == dword_61CBA4 )\n    {\n      v4 = v1[2];\n      v5 = v1 + 2;\n      v2 = 1;\n    }\n    v1 = v5;\n  }\n  if ( v2 )\n  {\n    *a1 = v1 - 1;\n  }\n  else\n  {\n    if ( (unsigned __int8)v4 != dword_61CBA8 )\n    {\nLABEL_10:\n      *a1 = v1;\n      return result;\n    }\n    v6 = v1[1];\n    v7 = v1 + 2;\n    v8 = v6;\n    if ( v6 - 48 > 9 )\n    {\n      v1 = v5;\n      goto LABEL_10;\n    }\n    while ( 1 )\n    {\n      if ( (unsigned __int8)result < (unsigned __int8)v8 )\n        result = v8;\n      v8 = *v7;\n      if ( v8 - 48 > 9 )\n        break;\n      ++v7;\n    }\n    *a1 = v7;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4059F0",
            "funcStartAddr": "0x4059f0",
            "funcEndAddr": "0x405a39",
            "decompiledFuncCode": "__int64 __fastcall sub_4059F0(char *a1)\n{\n  char v1; // bl\n  unsigned __int8 v2; // al\n  unsigned int v3; // edx\n  char *v5; // [rsp+8h] [rbp-10h] BYREF\n\n  v1 = *a1;\n  v5 = &a1[*a1 == 45];\n  v2 = sub_405930((unsigned __int8 **)&v5);\n  v3 = 0;\n  if ( v2 > 0x30u )\n  {\n    v3 = byte_4149C0[(unsigned __int8)*v5];\n    if ( v1 == 45 )\n      return (unsigned int)-byte_4149C0[(unsigned __int8)*v5];\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "sub_405A40",
            "funcStartAddr": "0x405a40",
            "funcEndAddr": "0x405ae3",
            "decompiledFuncCode": "__int64 __fastcall sub_405A40(unsigned __int8 *a1, _QWORD *a2)\n{\n  unsigned __int64 v2; // r11\n  unsigned __int64 v3; // r10\n  unsigned __int64 v4; // r9\n  char *v5; // rax\n  unsigned __int8 v6; // dl\n  __int64 v7; // rcx\n  unsigned __int8 *v8; // rdx\n  __int64 v9; // r8\n  unsigned __int8 v10; // cl\n\n  while ( byte_61CA80[*a1] )\n    ++a1;\n  v2 = 12LL;\n  v3 = 0LL;\n  while ( 1 )\n  {\n    v4 = (v3 + v2) >> 1;\n    v5 = (&off_61C440)[2 * v4];\n    v6 = *v5;\n    if ( !*v5 )\n    {\n      v8 = a1;\n      goto LABEL_12;\n    }\n    v7 = *a1;\n    if ( (unsigned __int8)byte_61C780[v7] >= v6 )\n      break;\nLABEL_15:\n    v2 = (v3 + v2) >> 1;\nLABEL_16:\n    if ( v3 >= v2 )\n      return 0LL;\n  }\n  if ( (unsigned __int8)byte_61C780[v7] > v6 )\n  {\nLABEL_18:\n    v3 = v4 + 1;\n    goto LABEL_16;\n  }\n  v8 = a1;\n  while ( 1 )\n  {\n    v10 = *++v5;\n    ++v8;\n    if ( !*v5 )\n      break;\n    v9 = *v8;\n    if ( (unsigned __int8)byte_61C780[v9] < v10 )\n      goto LABEL_15;\n    if ( (unsigned __int8)byte_61C780[v9] > v10 )\n      goto LABEL_18;\n  }\nLABEL_12:\n  if ( a2 )\n    *a2 = v8;\n  return (unsigned int)dword_61C448[4 * v4];\n}\n"
        },
        {
            "funcName": "sub_405AF0",
            "funcStartAddr": "0x405af0",
            "funcEndAddr": "0x405b43",
            "decompiledFuncCode": "__int64 __fastcall sub_405AF0(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( !*(_QWORD *)(a1 + 32) && !*(_QWORD *)(a1 + 40) )\n  {\n    result = *(unsigned __int8 *)(a1 + 48);\n    if ( (_BYTE)result )\n      return 0LL;\n    if ( !*(_BYTE *)(a1 + 49) && (*(_QWORD *)(a1 + 48) & 0xFFFF00FF0000LL) == 0 )\n    {\n      result = *(unsigned __int8 *)(a1 + 54);\n      if ( !(_BYTE)result )\n      {\n        if ( !*(_BYTE *)(a1 + 56) )\n          return *(unsigned __int8 *)(a1 + 51) ^ 1u;\n        return result;\n      }\n      return 0LL;\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405B50",
            "funcStartAddr": "0x405b50",
            "funcEndAddr": "0x405bf7",
            "decompiledFuncCode": "_BYTE *__fastcall sub_405B50(__int64 a1, _BYTE *a2)\n{\n  _BYTE *result; // rax\n\n  if ( *(_WORD *)(a1 + 48) )\n    *a2++ = 98;\n  if ( *(char **)(a1 + 32) == byte_61C880 )\n    *a2++ = 100;\n  result = a2;\n  if ( *(_QWORD *)(a1 + 40) )\n  {\n    *a2 = 102;\n    result = a2 + 1;\n  }\n  if ( *(_BYTE *)(a1 + 52) )\n    *result++ = 103;\n  if ( *(_BYTE *)(a1 + 53) )\n    *result++ = 104;\n  if ( *(char **)(a1 + 32) == byte_61C980 )\n    *result++ = 105;\n  if ( *(_BYTE *)(a1 + 54) )\n    *result++ = 77;\n  if ( *(_BYTE *)(a1 + 50) )\n    *result++ = 110;\n  if ( *(_BYTE *)(a1 + 51) )\n    *result++ = 82;\n  if ( *(_BYTE *)(a1 + 55) )\n    *result++ = 114;\n  if ( *(_BYTE *)(a1 + 56) )\n    *result++ = 86;\n  *result = 0;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405C00",
            "funcStartAddr": "0x405c00",
            "funcEndAddr": "0x405ce9",
            "decompiledFuncCode": "char *__fastcall sub_405C00(char *a1, __int64 a2, int a3)\n{\n  char v3; // cl\n  unsigned int v5; // edx\n  unsigned int v6; // eax\n\n  v3 = *a1;\n  if ( *a1 )\n  {\n    v5 = a3 - 1;\n    v6 = a3 & 0xFFFFFFFD;\n    while ( 2 )\n    {\n      switch ( v3 )\n      {\n        case 'M':\n          *(_BYTE *)(a2 + 54) = 1;\n          goto LABEL_5;\n        case 'R':\n          *(_BYTE *)(a2 + 51) = 1;\n          goto LABEL_5;\n        case 'V':\n          *(_BYTE *)(a2 + 56) = 1;\n          goto LABEL_5;\n        case 'b':\n          if ( !v6 )\n            *(_BYTE *)(a2 + 48) = 1;\n          if ( v5 <= 1 )\n            *(_BYTE *)(a2 + 49) = 1;\n          goto LABEL_5;\n        case 'd':\n          *(_QWORD *)(a2 + 32) = byte_61C880;\n          goto LABEL_5;\n        case 'f':\n          *(_QWORD *)(a2 + 40) = byte_61C780;\n          goto LABEL_5;\n        case 'g':\n          *(_BYTE *)(a2 + 52) = 1;\n          goto LABEL_5;\n        case 'h':\n          *(_BYTE *)(a2 + 53) = 1;\n          goto LABEL_5;\n        case 'i':\n          if ( !*(_QWORD *)(a2 + 32) )\n            *(_QWORD *)(a2 + 32) = byte_61C980;\n          goto LABEL_5;\n        case 'n':\n          *(_BYTE *)(a2 + 50) = 1;\n          goto LABEL_5;\n        case 'r':\n          *(_BYTE *)(a2 + 55) = 1;\nLABEL_5:\n          v3 = *++a1;\n          if ( !*a1 )\n            return a1;\n          continue;\n        default:\n          return a1;\n      }\n    }\n  }\n  return a1;\n}\n"
        },
        {
            "funcName": "compar_405cf0",
            "funcStartAddr": "0x405cf0",
            "funcEndAddr": "0x405cfb",
            "decompiledFuncCode": "int __fastcall compar(const char **a1, const char **a2)\n{\n  return strcmp(*a1, *a2);\n}\n"
        },
        {
            "funcName": "sub_405D00",
            "funcStartAddr": "0x405d00",
            "funcEndAddr": "0x405d30",
            "decompiledFuncCode": "__int64 __fastcall sub_405D00(__int64 a1)\n{\n  char *v1; // rax\n\n  v1 = dcgettext(0LL, \"options '-%s' are incompatible\", 5);\n  error(2, 0, v1, a1);\n  return sub_405D30(2LL, 0LL);\n}\n"
        },
        {
            "funcName": "sub_405D30",
            "funcStartAddr": "0x405d30",
            "funcEndAddr": "0x405d80",
            "decompiledFuncCode": "__int64 __fastcall sub_405D30(__int64 a1, const char *a2)\n{\n  __int64 v2; // rbp\n  char *v3; // rbx\n  char *v4; // rax\n\n  v2 = sub_40F880(a1);\n  v3 = dcgettext(0LL, a2, 5);\n  v4 = dcgettext(0LL, \"%s: invalid field specification %s\", 5);\n  error(2, 0, v4, v3, v2);\n  return sub_405D80(2);\n}\n"
        },
        {
            "funcName": "sub_405D80",
            "funcStartAddr": "0x405d80",
            "funcEndAddr": "0x405dca",
            "decompiledFuncCode": "int __fastcall sub_405D80(int sig)\n{\n  const char *v1; // rbx\n\n  v1 = (const char *)ptr;\n  if ( ptr )\n  {\n    do\n    {\n      unlink(v1 + 13);\n      v1 = *(const char **)v1;\n    }\n    while ( v1 );\n  }\n  ptr = 0LL;\n  signal(sig, 0LL);\n  return raise(sig);\n}\n"
        },
        {
            "funcName": "sub_405DD0",
            "funcStartAddr": "0x405dd0",
            "funcEndAddr": "0x405e24",
            "decompiledFuncCode": "void __fastcall __noreturn sub_405DD0(const char *a1, char *a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  char *v5; // rdx\n  const char *v6; // rbp\n  int *v7; // rax\n\n  v5 = a2;\n  if ( !a2 )\n    goto LABEL_3;\n  while ( 1 )\n  {\n    v6 = (const char *)sub_40F700(0LL, 3LL, v5, a4, a5);\n    v7 = __errno_location();\n    error(2, *v7, \"%s: %s\", a1, v6);\nLABEL_3:\n    v5 = dcgettext(0LL, \"standard output\", 5);\n  }\n}\n"
        },
        {
            "funcName": "sub_405E30",
            "funcStartAddr": "0x405e30",
            "funcEndAddr": "0x405ea5",
            "decompiledFuncCode": "void *__fastcall sub_405E30(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  size_t v5; // rbx\n  size_t v6; // rdi\n  void *result; // rax\n  __int64 v8; // rdx\n\n  while ( 1 )\n  {\n    v5 = (a3 & 0xFFFFFFFFFFFFFFE0LL) + 32;\n    v6 = v5;\n    result = malloc(v5);\n    *(_QWORD *)a1 = result;\n    if ( result )\n      break;\n    a3 = v5 >> 1;\n    if ( a2 + 1 >= a3 )\n      sub_411460(v6, a2, v8);\n  }\n  *(_QWORD *)(a1 + 40) = a2;\n  *(_QWORD *)(a1 + 24) = v5;\n  *(_QWORD *)(a1 + 16) = 0LL;\n  *(_QWORD *)(a1 + 32) = 0LL;\n  *(_QWORD *)(a1 + 8) = 0LL;\n  *(_BYTE *)(a1 + 48) = 0;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405EB0",
            "funcStartAddr": "0x405eb0",
            "funcEndAddr": "0x405eec",
            "decompiledFuncCode": "__int64 __fastcall sub_405EB0(char *a1, char *a2)\n{\n  char *v2; // rbx\n  __int64 result; // rax\n\n  v2 = a1;\n  result = (int)sub_40D3C0(a1);\n  if ( a2 > a1 )\n  {\n    do\n      result += *v2++ == 9;\n    while ( a2 != v2 );\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405EF0",
            "funcStartAddr": "0x405ef0",
            "funcEndAddr": "0x405fb0",
            "decompiledFuncCode": "size_t __fastcall sub_405EF0(char *dest, char *src, size_t n)\n{\n  int *v4; // rax\n  int *v5; // rbx\n  size_t result; // rax\n  char *v7; // rax\n  char *v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n\n  v4 = __errno_location();\n  *v4 = 0;\n  v5 = v4;\n  result = strxfrm(dest, src, n);\n  if ( *v5 )\n  {\n    v7 = dcgettext(0LL, \"string transformation failed\", 5);\n    error(0, *v5, v7);\n    v8 = dcgettext(0LL, \"set LC_ALL='C' to work around the problem\", 5);\n    error(0, 0, v8);\n    v9 = sub_40F550(0LL, 8LL, src);\n    v10 = dcgettext(0LL, \"the untransformed string was %s\", 5);\n    error(2, 0, v10, v9);\n    return sub_405FB0(2);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_405FB0",
            "funcStartAddr": "0x405fb0",
            "funcEndAddr": "0x4060a0",
            "decompiledFuncCode": "__int64 __fastcall sub_405FB0(__pid_t pid)\n{\n  int v1; // edx\n  bool v3; // zf\n  __pid_t v4; // edi\n  __pid_t v5; // eax\n  unsigned int v6; // ebp\n  __int64 v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n  __int64 v11; // rbp\n  char *v12; // rbx\n  int *v13; // rax\n  int stat_loc; // [rsp+Ch] [rbp-2Ch] BYREF\n  char v15[8]; // [rsp+10h] [rbp-28h] BYREF\n  __pid_t v16; // [rsp+18h] [rbp-20h]\n\n  v1 = 0;\n  v3 = pid == 0;\n  v4 = -1;\n  if ( !v3 )\n    v4 = pid;\n  LOBYTE(v1) = v3;\n  v5 = waitpid(v4, &stat_loc, v1);\n  if ( v5 >= 0 )\n  {\n    v6 = v5;\n    if ( !v5 )\n      return v6;\n    if ( pid <= 0 )\n    {\n      v16 = v5;\n      v8 = sub_40CDE0(qword_61C6A0, v15);\n      if ( !v8 )\n        return v6;\n      *(_BYTE *)(v8 + 12) = 2;\n    }\n    if ( !(stat_loc & 0x7F | BYTE1(stat_loc)) )\n    {\n      --dword_61C69C;\n      return v6;\n    }\n    v9 = sub_40F630(4LL, arg);\n    v10 = dcgettext(0LL, \"%s [-d] terminated abnormally\", 5);\n    error(2, 0, v10, v9);\n  }\n  v11 = sub_40F630(4LL, arg);\n  v12 = dcgettext(0LL, \"waiting for %s [-d]\", 5);\n  v13 = __errno_location();\n  error(2, *v13, v12, v11);\n  return sub_4060A0(2);\n}\n"
        },
        {
            "funcName": "sub_4060A0",
            "funcStartAddr": "0x4060a0",
            "funcEndAddr": "0x4060d0",
            "decompiledFuncCode": "__int64 __fastcall sub_4060A0(__pid_t pid)\n{\n  __int64 result; // rax\n  _DWORD v2[6]; // [rsp+0h] [rbp-18h] BYREF\n\n  v2[2] = pid;\n  result = sub_40CDE0(qword_61C6A0, v2);\n  if ( result )\n  {\n    *(_BYTE *)(result + 12) = 2;\n    return sub_405FB0(pid);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4060D0",
            "funcStartAddr": "0x4060d0",
            "funcEndAddr": "0x406185",
            "decompiledFuncCode": "void __fastcall __noreturn sub_4060D0(unsigned int a1, const void *a2)\n{\n  const void *v2; // rbx\n  char v3[20]; // [rsp+4h] [rbp-14h] BYREF\n\n  write(2, a2, strlen((const char *)a2));\n  if ( a1 )\n  {\n    v2 = (const void *)sub_40D2B0(a1, v3);\n    write(2, \": errno \", 8uLL);\n    write(2, v2, strlen((const char *)v2));\n  }\n  write(2, \"\\n\", 1uLL);\n  _exit(2);\n}\n"
        },
        {
            "funcName": "sub_406190",
            "funcStartAddr": "0x406190",
            "funcEndAddr": "0x4061e5",
            "decompiledFuncCode": "__int64 __fastcall sub_406190(__int64 a1)\n{\n  __int64 v2; // rdi\n  __int64 v3; // rsi\n  __int64 result; // rax\n  __int64 v5; // rdx\n\n  v2 = qword_61C6A0;\n  if ( !qword_61C6A0 && (v3 = 0LL, v2 = sub_40C600(47LL, 0LL, sub_405910, sub_405920, 0LL), (qword_61C6A0 = v2) == 0)\n    || (*(_BYTE *)(a1 + 12) = 1, v3 = a1, (result = sub_40CDA0(v2, a1)) == 0) )\n  {\n    sub_411460(v2, v3, v5);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4061F0",
            "funcStartAddr": "0x4061f0",
            "funcEndAddr": "0x40631d",
            "decompiledFuncCode": "__int64 __fastcall sub_4061F0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, char a6)\n{\n  unsigned __int64 v6; // r13\n  __int64 v7; // r12\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // r14\n  __int64 v12; // rcx\n  int v13; // eax\n  __int64 result; // rax\n  __int64 v15; // rax\n\n  while ( 1 )\n  {\n    v6 = a4;\n    v7 = a5;\n    v8 = a3 - 32 * a5;\n    if ( a6 )\n    {\n      v9 = *(_QWORD *)(a1 + 40) >> 1;\n      v10 = *(_QWORD *)(a1 + 40) - v9;\n      v11 = v8 - 32 * v9;\n      v12 = a1 + 16;\n    }\n    else\n    {\n      v9 = *(_QWORD *)(a1 + 48) >> 1;\n      v10 = *(_QWORD *)(a1 + 48) - v9;\n      v11 = v8 - 32 * v9;\n      v12 = a1 + 24;\n    }\n    *(_QWORD *)(a2 + 48) = v10;\n    v13 = *(_DWORD *)(a1 + 80);\n    *(_QWORD *)(a2 + 56) = a1;\n    *(_QWORD *)(a2 + 16) = v8;\n    *(_QWORD *)a2 = v8;\n    *(_QWORD *)(a2 + 24) = v11;\n    *(_QWORD *)(a2 + 8) = v11;\n    *(_QWORD *)(a2 + 32) = v12;\n    *(_QWORD *)(a2 + 40) = v9;\n    *(_DWORD *)(a2 + 80) = v13 + 1;\n    *(_BYTE *)(a2 + 84) = 0;\n    pthread_mutex_init((pthread_mutex_t *)(a2 + 88), 0LL);\n    if ( v6 <= 1 )\n      break;\n    *(_QWORD *)(a2 + 64) = a2 + 128;\n    v15 = sub_4061F0(a2, a2 + 128, v8, v6 >> 1, v7, 1LL);\n    a5 = v7;\n    a4 = v6 - (v6 >> 1);\n    a3 = v11;\n    *(_QWORD *)(a2 + 72) = v15;\n    a1 = a2;\n    a6 = 0;\n    a2 = v15;\n  }\n  *(_QWORD *)(a2 + 64) = 0LL;\n  result = a2 + 128;\n  *(_QWORD *)(a2 + 72) = 0LL;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_406320",
            "funcStartAddr": "0x406320",
            "funcEndAddr": "0x40635c",
            "decompiledFuncCode": "int __fastcall sub_406320(__int64 a1, __int64 a2)\n{\n  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));\n  sub_40D070(*(_QWORD *)a1, a2);\n  *(_BYTE *)(a2 + 84) = 1;\n  pthread_cond_signal((pthread_cond_t *)(a1 + 48));\n  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));\n}\n"
        },
        {
            "funcName": "sub_406360",
            "funcStartAddr": "0x406360",
            "funcEndAddr": "0x40646f",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_406360(char *a1, __int64 a2, __int64 *a3)\n{\n  unsigned __int64 result; // rax\n  __int64 v4; // rcx\n  __int64 v5; // r9\n  __int64 v6; // r8\n  unsigned __int8 *v7; // rdi\n  unsigned __int8 *v8; // rdi\n  __int64 v9; // rsi\n  char v10; // cl\n  unsigned __int8 *v11; // rdi\n\n  result = (unsigned __int64)&a1[a2 - 1];\n  v4 = *a3;\n  v5 = a3[1];\n  if ( dword_61C424 == 128 )\n  {\n    if ( result <= (unsigned __int64)a1 )\n      goto LABEL_6;\n    v9 = v4 - 1;\n    if ( v4 )\n    {\n      do\n      {\n        v10 = byte_61CA80[(unsigned __int8)*a1];\n        while ( !v10 )\n        {\n          if ( result <= (unsigned __int64)a1 )\n            goto LABEL_6;\n          do\n          {\n            if ( (char *)result == ++a1 )\n            {\n              a1 = (char *)result;\n              goto LABEL_6;\n            }\n            v10 = byte_61CA80[(unsigned __int8)*a1];\n          }\n          while ( !v10 );\n          if ( --v9 == -1 )\n            goto LABEL_12;\n        }\n        ++a1;\n      }\n      while ( result > (unsigned __int64)a1 );\n      v11 = (unsigned __int8 *)&a1[v5];\n      if ( result > (unsigned __int64)v11 )\n        return (unsigned __int64)v11;\n      return result;\n    }\n  }\n  else\n  {\n    if ( result <= (unsigned __int64)a1 )\n      goto LABEL_6;\n    v6 = v4 - 1;\n    if ( v4 )\n    {\n      do\n      {\n        while ( dword_61C424 != *a1 )\n        {\n          if ( result <= (unsigned __int64)++a1 )\n            goto LABEL_6;\n        }\n        if ( result <= (unsigned __int64)a1 )\n          goto LABEL_6;\n        if ( result <= (unsigned __int64)++a1 )\n          goto LABEL_6;\n      }\n      while ( --v6 != -1 );\n    }\n  }\nLABEL_12:\n  if ( !*((_BYTE *)a3 + 48) )\n  {\nLABEL_6:\n    v7 = (unsigned __int8 *)&a1[v5];\n    if ( result > (unsigned __int64)v7 )\n      return (unsigned __int64)v7;\n    return result;\n  }\n  while ( byte_61CA80[(unsigned __int8)*a1] )\n  {\n    if ( result <= (unsigned __int64)++a1 )\n      goto LABEL_6;\n  }\n  v8 = (unsigned __int8 *)&a1[v5];\n  if ( result > (unsigned __int64)v8 )\n    return (unsigned __int64)v8;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_406470",
            "funcStartAddr": "0x406470",
            "funcEndAddr": "0x4065ad",
            "decompiledFuncCode": "char *__fastcall sub_406470(char *a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r9\n  unsigned __int64 v4; // rcx\n  char *result; // rax\n  __int64 v6; // rsi\n  __int64 v7; // r8\n  __int64 v8; // rdi\n  char v9; // si\n\n  v3 = *(_QWORD *)(a3 + 24);\n  v4 = (unsigned __int64)&a1[a2 - 1];\n  result = a1;\n  v6 = (v3 == 0) + *(_QWORD *)(a3 + 16);\n  if ( dword_61C424 == 128 )\n  {\n    if ( v4 > (unsigned __int64)a1 )\n    {\n      v8 = v6 - 1;\n      if ( v6 )\n      {\n        do\n        {\n          v9 = byte_61CA80[(unsigned __int8)*result];\n          while ( !v9 )\n          {\n            if ( v4 > (unsigned __int64)result )\n            {\n              do\n              {\n                if ( (char *)v4 == ++result )\n                {\n                  result = (char *)v4;\n                  goto LABEL_6;\n                }\n                v9 = byte_61CA80[(unsigned __int8)*result];\n              }\n              while ( !v9 );\n              if ( --v8 != -1 )\n                continue;\n            }\n            goto LABEL_6;\n          }\n          ++result;\n        }\n        while ( v4 > (unsigned __int64)result );\n      }\n    }\n  }\n  else if ( v4 > (unsigned __int64)a1 )\n  {\n    v7 = v6 - 1;\n    if ( v6 )\n    {\n      do\n      {\n        while ( dword_61C424 != *result )\n        {\n          if ( v4 <= (unsigned __int64)++result )\n            goto LABEL_6;\n        }\n        if ( v4 <= (unsigned __int64)result )\n          break;\n        if ( !(v7 | v3) )\n          return result;\n        if ( v4 <= (unsigned __int64)++result )\n          break;\n        --v7;\n      }\n      while ( v7 != -1 );\n    }\n  }\nLABEL_6:\n  if ( v3 )\n  {\n    if ( *(_BYTE *)(a3 + 49) && v4 > (unsigned __int64)result )\n    {\n      while ( byte_61CA80[(unsigned __int8)*result] )\n      {\n        if ( (char *)v4 == ++result )\n        {\n          result = (char *)(v3 + v4);\n          if ( v4 <= v3 + v4 )\n            return (char *)v4;\n          return result;\n        }\n      }\n    }\n    result += v3;\n    if ( v4 <= (unsigned __int64)result )\n      return (char *)v4;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4065B0",
            "funcStartAddr": "0x4065b0",
            "funcEndAddr": "0x4074c8",
            "decompiledFuncCode": "__int64 __fastcall sub_4065B0(__int64 a1, unsigned __int8 **a2)\n{\n  unsigned __int8 *v2; // r15\n  char *v3; // rbx\n  char *v4; // r10\n  __int64 v5; // r12\n  char *v6; // r14\n  char *v7; // rax\n  __int64 v8; // r13\n  __int64 v9; // rbp\n  size_t v10; // r11\n  size_t v11; // r10\n  char v12; // cl\n  unsigned __int8 v13; // cl\n  unsigned int v14; // eax\n  __int64 v15; // rbp\n  __int64 v16; // r11\n  __int64 v17; // r11\n  char *i; // rdi\n  unsigned __int8 *j; // rsi\n  unsigned int v21; // eax\n  unsigned __int64 v22; // rdi\n  char *v23; // rcx\n  char *v24; // rsi\n  char *v25; // rdi\n  char *v26; // r8\n  unsigned __int8 v27; // al\n  unsigned __int8 *v28; // rdi\n  unsigned __int8 v29; // al\n  char *v30; // rax\n  long double v31; // fst7\n  long double v32; // fst6\n  char *k; // rbx\n  char *v34; // rbp\n  int v35; // r13d\n  int v36; // eax\n  unsigned int v37; // eax\n  char *v38; // rcx\n  char *v39; // r8\n  int v40; // edx\n  bool v41; // cf\n  int v42; // ebx\n  int v43; // eax\n  __int64 v44; // rax\n  char *v45; // rbp\n  char *v46; // r13\n  size_t v47; // r15\n  size_t v48; // r12\n  size_t v49; // rbx\n  size_t v50; // rdx\n  unsigned __int64 v51; // rax\n  char *v52; // rcx\n  size_t v53; // rax\n  size_t v54; // rdx\n  char *v55; // rdi\n  unsigned __int64 v56; // r14\n  char *v57; // rax\n  size_t v58; // r11\n  size_t v59; // r10\n  int v60; // eax\n  char *v61; // r11\n  size_t v62; // r10\n  unsigned int v63; // eax\n  int v64; // eax\n  size_t v65; // rdx\n  int v66; // eax\n  __int64 v67; // r14\n  size_t v68; // rdx\n  unsigned int v69; // [rsp+0h] [rbp-2188h]\n  long double v70; // [rsp+0h] [rbp-2188h]\n  size_t v71; // [rsp+0h] [rbp-2188h]\n  __int64 v72; // [rsp+18h] [rbp-2170h]\n  char v73; // [rsp+26h] [rbp-2162h]\n  unsigned __int8 v74; // [rsp+27h] [rbp-2161h]\n  char *srcd; // [rsp+28h] [rbp-2160h]\n  char *srce; // [rsp+28h] [rbp-2160h]\n  char *srcf; // [rsp+28h] [rbp-2160h]\n  char *src; // [rsp+28h] [rbp-2160h]\n  char *srcg; // [rsp+28h] [rbp-2160h]\n  char *srch; // [rsp+28h] [rbp-2160h]\n  char *srca; // [rsp+28h] [rbp-2160h]\n  char *srcb; // [rsp+28h] [rbp-2160h]\n  char *srci; // [rsp+28h] [rbp-2160h]\n  char *srcj; // [rsp+28h] [rbp-2160h]\n  char *srcc; // [rsp+28h] [rbp-2160h]\n  size_t v86; // [rsp+30h] [rbp-2158h]\n  size_t v87; // [rsp+30h] [rbp-2158h]\n  size_t v88; // [rsp+30h] [rbp-2158h]\n  size_t v89; // [rsp+30h] [rbp-2158h]\n  size_t v90; // [rsp+30h] [rbp-2158h]\n  char *v91; // [rsp+30h] [rbp-2158h]\n  char *v92; // [rsp+30h] [rbp-2158h]\n  size_t v93; // [rsp+30h] [rbp-2158h]\n  size_t v94; // [rsp+30h] [rbp-2158h]\n  char *v95; // [rsp+30h] [rbp-2158h]\n  size_t v96; // [rsp+30h] [rbp-2158h]\n  unsigned __int8 *v99; // [rsp+48h] [rbp-2140h]\n  size_t v100; // [rsp+48h] [rbp-2140h]\n  size_t v101; // [rsp+48h] [rbp-2140h]\n  char *v102; // [rsp+50h] [rbp-2138h]\n  char *s2; // [rsp+58h] [rbp-2130h]\n  void *ptr; // [rsp+60h] [rbp-2128h]\n  size_t size; // [rsp+68h] [rbp-2120h]\n  char *v106; // [rsp+78h] [rbp-2110h]\n  __int64 v107; // [rsp+80h] [rbp-2108h]\n  unsigned __int8 *v108; // [rsp+88h] [rbp-2100h]\n  size_t v109; // [rsp+90h] [rbp-20F8h]\n  size_t v110; // [rsp+98h] [rbp-20F0h]\n  char *endptr; // [rsp+A8h] [rbp-20E0h] BYREF\n  char *v112[2]; // [rsp+B0h] [rbp-20D8h] BYREF\n  char v113[16]; // [rsp+C0h] [rbp-20C8h] BYREF\n  __int128 v114[9]; // [rsp+D0h] [rbp-20B8h] BYREF\n  __int64 v115; // [rsp+160h] [rbp-2028h]\n  int v116; // [rsp+168h] [rbp-2020h]\n  __m128i si128; // [rsp+16Ch] [rbp-201Ch] BYREF\n  __m128i v118; // [rsp+17Ch] [rbp-200Ch]\n  __m128i v119; // [rsp+18Ch] [rbp-1FFCh]\n  __m128i v120; // [rsp+19Ch] [rbp-1FECh]\n  __m128i v121; // [rsp+1ACh] [rbp-1FDCh]\n  __m128i v122; // [rsp+1BCh] [rbp-1FCCh]\n  __m128i v123; // [rsp+1CCh] [rbp-1FBCh]\n  __m128i v124; // [rsp+1DCh] [rbp-1FACh]\n  __m128i v125; // [rsp+1ECh] [rbp-1F9Ch]\n  __int64 v126; // [rsp+1FCh] [rbp-1F8Ch]\n  int v127; // [rsp+204h] [rbp-1F84h]\n  char v128[4000]; // [rsp+210h] [rbp-1F78h] BYREF\n  _TBYTE s1[405]; // [rsp+11B0h] [rbp-FD8h] BYREF\n\n  v2 = a2[2];\n  v3 = *(char **)(a1 + 24);\n  v4 = (char *)a2[3];\n  v5 = qword_61C750;\n  v6 = *(char **)(a1 + 16);\n  while ( 1 )\n  {\nLABEL_2:\n    v7 = v4;\n    v8 = *(_QWORD *)(v5 + 40);\n    v9 = *(_QWORD *)(v5 + 32);\n    if ( v6 >= v3 )\n      v3 = v6;\n    if ( v2 >= (unsigned __int8 *)v4 )\n      v7 = (char *)v2;\n    v10 = v3 - v6;\n    v11 = v7 - (char *)v2;\n    if ( byte_61CBA1 || (*(_QWORD *)(v5 + 48) & 0xFFFFFFFFFF0000LL) != 0 || *(_BYTE *)(v5 + 56) )\n      break;\n    if ( !v9 )\n    {\n      if ( !v10 )\n      {\n        v69 = -(v7 != (char *)v2);\n        goto LABEL_19;\n      }\n      if ( v11 )\n      {\n        if ( v8 )\n        {\n          while ( v6 < v3 && v2 < (unsigned __int8 *)v7 )\n          {\n            v40 = *(unsigned __int8 *)(v8 + (unsigned __int8)*v6++) - *(unsigned __int8 *)(v8 + *v2++);\n            if ( v40 )\n            {\nLABEL_171:\n              v69 = v40;\n              v67 = v5;\n              goto LABEL_172;\n            }\n          }\n        }\n        else\n        {\n          v68 = v7 - (char *)v2;\n          if ( v10 <= v11 )\n            v68 = v3 - v6;\n          srcc = (char *)(v7 - (char *)v2);\n          v69 = memcmp(v6, v2, v68);\n          if ( v69 )\n            goto LABEL_35;\n          v10 = v3 - v6;\n          v11 = (size_t)srcc;\n        }\n        if ( v10 >= v11 )\n        {\n          v69 = v10 != v11;\n          goto LABEL_19;\n        }\n        v67 = v5;\n        v69 = -1;\n      }\n      else\n      {\n        v67 = v5;\n        v69 = 1;\n      }\nLABEL_172:\n      if ( !*(_BYTE *)(v67 + 55) )\n        return v69;\n      return -v69;\n    }\n    v38 = v6;\n    v39 = v6;\n    if ( v8 )\n    {\n      while ( 1 )\n      {\n        if ( v38 >= v3 || !*(_BYTE *)(v9 + (unsigned __int8)*v38) )\n        {\n          if ( v2 >= (unsigned __int8 *)v7 )\n            goto LABEL_101;\n          while ( *(_BYTE *)(v9 + *v2) )\n          {\n            if ( v7 == (char *)++v2 )\n            {\n              v2 = (unsigned __int8 *)v7;\n              goto LABEL_101;\n            }\n          }\n          if ( v3 <= v38 || v7 <= (char *)v2 )\n          {\nLABEL_101:\n            v41 = v38 < v3;\n            goto LABEL_102;\n          }\n          v40 = *(unsigned __int8 *)(v8 + (unsigned __int8)*v38) - *(unsigned __int8 *)(v8 + *v2);\n          if ( v40 )\n            goto LABEL_171;\n          ++v2;\n        }\n        ++v38;\n      }\n    }\n    while ( 1 )\n    {\n      if ( v39 < v3 && *(_BYTE *)(v9 + (unsigned __int8)*v39) )\n        goto LABEL_92;\n      if ( v2 >= (unsigned __int8 *)v7 )\n        break;\n      while ( *(_BYTE *)(v9 + *v2) )\n      {\n        if ( v7 == (char *)++v2 )\n        {\n          v2 = (unsigned __int8 *)v7;\n          goto LABEL_153;\n        }\n      }\n      if ( v3 <= v39 || v7 <= (char *)v2 )\n        break;\n      v40 = (unsigned __int8)*v39 - *v2;\n      if ( v40 )\n        goto LABEL_171;\n      ++v2;\nLABEL_92:\n      ++v39;\n    }\nLABEL_153:\n    v41 = v39 < v3;\nLABEL_102:\n    v69 = v41 - (v7 > (char *)v2);\nLABEL_19:\n    if ( v69 )\n      goto LABEL_35;\nLABEL_20:\n    v5 = *(_QWORD *)(v5 + 64);\n    if ( !v5 )\n      return v69;\n    v6 = *(char **)a1;\n    v15 = *(_QWORD *)(a1 + 8);\n    v2 = *a2;\n    if ( *(_QWORD *)(v5 + 16) == -1LL )\n    {\n      v3 = &v6[v15 - 1];\n      v4 = (char *)&a2[1][(_QWORD)v2 - 1];\n      if ( *(_QWORD *)v5 == -1LL )\n        goto LABEL_25;\nLABEL_23:\n      v6 = (char *)sub_406360(v6, v15, (__int64 *)v5);\n      v2 = (unsigned __int8 *)sub_406360((char *)v2, v17, (__int64 *)v5);\n    }\n    else\n    {\n      v3 = sub_406470(*(char **)a1, *(_QWORD *)(a1 + 8), v5);\n      v4 = sub_406470((char *)v2, v16, v5);\n      if ( *(_QWORD *)v5 != -1LL )\n        goto LABEL_23;\nLABEL_25:\n      if ( *(_BYTE *)(v5 + 48) )\n      {\n        if ( v3 > v6 )\n        {\n          while ( byte_61CA80[(unsigned __int8)*v6] )\n          {\n            if ( v3 == ++v6 )\n            {\n              v6 = v3;\n              break;\n            }\n          }\n        }\n        if ( v4 > (char *)v2 )\n        {\n          while ( byte_61CA80[*v2] )\n          {\n            if ( v4 == (char *)++v2 )\n            {\n              v2 = (unsigned __int8 *)v4;\n              goto LABEL_2;\n            }\n          }\n        }\n      }\n    }\n  }\n  v72 = v9 | v8;\n  if ( !(v9 | v8) )\n  {\n    v12 = *v3;\n    *v3 = 0;\n    v73 = v12;\n    v13 = *v7;\n    *v7 = 0;\n    v74 = v13;\n    goto LABEL_10;\n  }\n  v22 = v10 + v11 + 2;\n  if ( v22 <= 0xFA0 )\n  {\n    v23 = v128;\n    ptr = 0LL;\n    v24 = &v128[v10 + 1];\n    if ( v10 )\n      goto LABEL_44;\nLABEL_105:\n    *v23 = 0;\n    if ( !v11 )\n      goto LABEL_106;\nLABEL_52:\n    v28 = &v2[v11];\n    v11 = 0LL;\n    while ( 2 )\n    {\n      v29 = *v2;\n      if ( !v9 )\n      {\nLABEL_58:\n        v29 = *(_BYTE *)(v8 + v29);\n        goto LABEL_55;\n      }\n      if ( !*(_BYTE *)(v9 + v29) )\n      {\n        if ( v8 )\n          goto LABEL_58;\nLABEL_55:\n        v24[v11++] = v29;\n      }\n      if ( v28 == ++v2 )\n      {\n        v30 = &v24[v11];\n        goto LABEL_60;\n      }\n      continue;\n    }\n  }\n  srch = (char *)(v7 - (char *)v2);\n  v44 = sub_411210(v22);\n  v10 = v3 - v6;\n  v11 = (size_t)srch;\n  v23 = (char *)v44;\n  ptr = (void *)v44;\n  v24 = (char *)(v44 + v3 - v6 + 1);\n  if ( v3 == v6 )\n    goto LABEL_105;\nLABEL_44:\n  v25 = &v6[v10];\n  v26 = v6;\n  v10 = 0LL;\n  while ( 2 )\n  {\n    v27 = *v26;\n    if ( !v9 )\n    {\nLABEL_50:\n      v27 = *(_BYTE *)(v8 + v27);\n      goto LABEL_47;\n    }\n    if ( !*(_BYTE *)(v9 + v27) )\n    {\n      if ( v8 )\n        goto LABEL_50;\nLABEL_47:\n      v23[v10++] = v27;\n    }\n    if ( v25 != ++v26 )\n      continue;\n    break;\n  }\n  v23[v10] = 0;\n  if ( v11 )\n    goto LABEL_52;\nLABEL_106:\n  v30 = v24;\nLABEL_60:\n  *v30 = 0;\n  v2 = (unsigned __int8 *)v24;\n  v6 = v23;\nLABEL_10:\n  if ( *(_BYTE *)(v5 + 50) )\n  {\n    for ( i = v6; byte_61CA80[(unsigned __int8)*i]; ++i )\n      ;\n    for ( j = v2; byte_61CA80[*j]; ++j )\n      ;\n    v87 = v11;\n    srce = (char *)v10;\n    v21 = sub_4106A0(i, j, (unsigned int)dword_61CBA8, (unsigned int)dword_61CBA4);\n    v10 = (size_t)srce;\n    v11 = v87;\n    v69 = v21;\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 52) )\n  {\n    v88 = v11;\n    srcf = (char *)v10;\n    v70 = strtold(v6, &endptr);\n    v31 = strtold((const char *)v2, v112);\n    v10 = (size_t)srcf;\n    v11 = v88;\n    if ( v6 == endptr )\n    {\n      v69 = -(v112[0] != (char *)v2);\n      goto LABEL_17;\n    }\n    if ( v2 == (unsigned __int8 *)v112[0] )\n    {\n      v69 = 1;\n      goto LABEL_17;\n    }\n    if ( v31 <= v70 )\n    {\n      v32 = v70;\n      v69 = 1;\n      if ( v32 > v31 )\n        goto LABEL_17;\n      if ( v32 == v31 )\n      {\n        v69 = 0;\n        goto LABEL_17;\n      }\n    }\n    v69 = -1;\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 53) )\n  {\n    for ( k = v6; byte_61CA80[(unsigned __int8)*k]; ++k )\n      ;\n    v34 = (char *)v2;\n    if ( byte_61CA80[*v2] )\n    {\n      do\n        ++v34;\n      while ( byte_61CA80[(unsigned __int8)*v34] );\n    }\n    v89 = v11;\n    src = (char *)v10;\n    v35 = sub_4059F0(k);\n    v36 = sub_4059F0(v34);\n    v10 = (size_t)src;\n    v11 = v89;\n    v69 = v35 - v36;\n    if ( v35 == v36 )\n    {\n      v37 = sub_4106A0(k, v34, (unsigned int)dword_61CBA8, (unsigned int)dword_61CBA4);\n      v10 = (size_t)src;\n      v11 = v89;\n      v69 = v37;\n    }\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 54) )\n  {\n    v90 = v11;\n    srcg = (char *)v10;\n    v42 = sub_405A40((unsigned __int8 *)v6, 0LL);\n    v43 = sub_405A40(v2, 0LL);\n    v10 = (size_t)srcg;\n    v11 = v90;\n    v69 = v42 - v43;\n    goto LABEL_17;\n  }\n  if ( !*(_BYTE *)(v5 + 51) )\n  {\n    if ( *(_BYTE *)(v5 + 56) )\n    {\n      v86 = v11;\n      srcd = (char *)v10;\n      v14 = sub_40B900(v6, (char *)v2);\n      v10 = (size_t)srcd;\n      v11 = v86;\n      v69 = v14;\n    }\n    else if ( v10 )\n    {\n      v69 = 1;\n      if ( v11 )\n      {\n        v93 = v11;\n        srci = (char *)v10;\n        v63 = sub_4115C0(v6, v10 + 1, v2, v11 + 1);\n        v11 = v93;\n        v10 = (size_t)srci;\n        v69 = v63;\n      }\n    }\n    else\n    {\n      v69 = -(v11 != 0);\n    }\n    goto LABEL_17;\n  }\n  si128 = _mm_load_si128((const __m128i *)&xmmword_61C600);\n  v118 = _mm_load_si128((const __m128i *)&xmmword_61C610);\n  v119 = _mm_load_si128((const __m128i *)&xmmword_61C620);\n  v120 = _mm_load_si128((const __m128i *)&xmmword_61C630);\n  v121 = _mm_load_si128((const __m128i *)&xmmword_61C640);\n  v122 = _mm_load_si128((const __m128i *)&xmmword_61C650);\n  v123 = _mm_load_si128((const __m128i *)&xmmword_61C660);\n  v124 = _mm_load_si128((const __m128i *)&xmmword_61C670);\n  v125 = _mm_load_si128((const __m128i *)&xmmword_61C680);\n  v126 = qword_61C690;\n  v127 = dword_61C698;\n  v114[0] = (__int128)si128;\n  v114[1] = (__int128)v118;\n  v114[2] = (__int128)v119;\n  v114[3] = (__int128)v120;\n  v114[4] = (__int128)v121;\n  v114[5] = (__int128)v122;\n  v114[6] = (__int128)v123;\n  v114[7] = (__int128)v124;\n  v114[8] = (__int128)v125;\n  v115 = qword_61C690;\n  v116 = dword_61C698;\n  if ( !byte_61CBA1 )\n  {\n    v71 = v11;\n    v94 = v10;\n    sub_40B360(v6, v10);\n    sub_40B250(v114, v112);\n    srcb = (char *)v71;\n    sub_40B360(v2, v71);\n    sub_40B250(&si128, v113);\n    v64 = memcmp(v112, v113, 0x10uLL);\n    v62 = v71;\n    v61 = (char *)v94;\n    v69 = v64;\n    if ( !v64 )\n    {\n      v49 = v94;\n      v46 = v6;\n      s2 = (char *)v2;\n      v102 = 0LL;\n      goto LABEL_161;\n    }\n    v102 = 0LL;\n    goto LABEL_166;\n  }\n  v69 = 0;\n  v45 = v6;\n  v46 = (char *)s1;\n  v91 = &v6[v10];\n  v99 = &v2[v11];\n  v106 = v6;\n  v102 = 0LL;\n  v107 = v5;\n  v109 = v10;\n  v110 = v11;\n  size = 3 * (v10 + v11) + 2;\n  srca = (char *)v2;\n  v108 = v2;\n  v47 = 4000LL;\nLABEL_111:\n  if ( size > v47 )\n  {\n    while ( 1 )\n    {\n      v46 = (char *)s1;\n      v51 = (3 * v47) >> 1;\n      if ( size >= v51 )\n        v51 = size;\n      v47 = v51;\n      free(v102);\n      v52 = (char *)malloc(v47);\n      v102 = v52;\n      if ( v52 )\n        v46 = v52;\n      else\n        v47 = 4000LL;\n      if ( v91 <= v45 )\n        goto LABEL_113;\nLABEL_130:\n      v53 = sub_405EF0(v46, v45, v47);\n      v49 = v53 + 1;\n      if ( v99 > (unsigned __int8 *)srca )\n        break;\n      v56 = v53 + 1;\n      v48 = 0LL;\n      if ( v47 < v49 )\n        goto LABEL_134;\nLABEL_175:\n      if ( v47 < v56 )\n        goto LABEL_134;\nLABEL_115:\n      s2 = &v46[v49];\n      if ( v91 <= v45 )\n      {\n        if ( v99 <= (unsigned __int8 *)srca )\n          goto LABEL_149;\n        goto LABEL_147;\n      }\n      v45 += strlen(v45) + 1;\n      if ( v99 > (unsigned __int8 *)srca )\n        goto LABEL_147;\nLABEL_117:\n      if ( v91 <= v45 && v99 <= (unsigned __int8 *)srca )\n      {\nLABEL_149:\n        srcb = (char *)v48;\n        v6 = v106;\n        v2 = v108;\n        v58 = v109;\n        v59 = v110;\n        v5 = v107;\n        goto LABEL_141;\n      }\n      sub_40B360(v46, v49);\n      sub_40B360(s2, v48);\n      if ( v69 )\n        goto LABEL_111;\n      v50 = v48;\n      if ( v49 <= v48 )\n        v50 = v49;\n      v69 = memcmp(v46, s2, v50);\n      if ( v69 )\n        goto LABEL_111;\n      v69 = (v49 > v48) - (v49 < v48);\n      if ( size <= v47 )\n        goto LABEL_112;\n    }\n    if ( v47 >= v49 )\n    {\n      v55 = &v46[v49];\n      v54 = v47 - v49;\n    }\n    else\n    {\n      v54 = 0LL;\n      v55 = 0LL;\n    }\n  }\n  else\n  {\nLABEL_112:\n    if ( v91 > v45 )\n      goto LABEL_130;\nLABEL_113:\n    if ( v99 <= (unsigned __int8 *)srca )\n    {\n      v48 = 0LL;\n      v49 = 0LL;\n      goto LABEL_115;\n    }\n    v55 = v46;\n    v54 = v47;\n    v49 = 0LL;\n  }\n  v48 = sub_405EF0(v55, srca, v54) + 1;\n  v56 = v48 + v49;\n  if ( v47 >= v49 )\n    goto LABEL_175;\nLABEL_134:\n  if ( v56 <= 0x5555555555555554LL )\n    v56 = (3 * v56) >> 1;\n  free(v102);\n  v57 = (char *)sub_411210(v56);\n  v46 = v57;\n  if ( v91 > v45 )\n    strxfrm(v57, v45, v49);\n  s2 = &v46[v49];\n  if ( v99 > (unsigned __int8 *)srca )\n  {\n    strxfrm(&v46[v49], srca, v48);\n    if ( v91 > v45 )\n      v45 += strlen(v45) + 1;\n    v102 = v46;\n    v47 = v56;\nLABEL_147:\n    srca += strlen(srca) + 1;\n    goto LABEL_117;\n  }\n  if ( v91 > v45 )\n  {\n    v47 = v56;\n    v102 = v46;\n    v45 += strlen(v45) + 1;\n    goto LABEL_117;\n  }\n  v102 = v46;\n  v6 = v106;\n  srcb = (char *)v48;\n  v2 = v108;\n  v58 = v109;\n  v59 = v110;\n  v5 = v107;\nLABEL_141:\n  v100 = v59;\n  v92 = (char *)v58;\n  sub_40B360(v46, v49);\n  sub_40B250(v114, v112);\n  sub_40B360(s2, (size_t)srcb);\n  sub_40B250(&si128, v113);\n  v60 = memcmp(v112, v113, 0x10uLL);\n  v61 = v92;\n  v62 = v100;\n  if ( v60 )\n  {\nLABEL_165:\n    v69 = v60;\n  }\n  else if ( !v69 )\n  {\nLABEL_161:\n    v101 = v62;\n    v95 = v61;\n    v65 = (size_t)srcb;\n    if ( v49 <= (unsigned __int64)srcb )\n      v65 = v49;\n    v66 = memcmp(v46, s2, v65);\n    v61 = v95;\n    v62 = v101;\n    v69 = v66;\n    if ( !v66 )\n    {\n      v60 = (v49 > (unsigned __int64)srcb) - (v49 < (unsigned __int64)srcb);\n      goto LABEL_165;\n    }\n  }\nLABEL_166:\n  v96 = v62;\n  srcj = v61;\n  free(v102);\n  v10 = (size_t)srcj;\n  v11 = v96;\nLABEL_17:\n  if ( !v72 )\n  {\n    v6[v10] = v73;\n    v2[v11] = v74;\n    goto LABEL_19;\n  }\n  free(ptr);\n  if ( !v69 )\n    goto LABEL_20;\nLABEL_35:\n  if ( *(_BYTE *)(v5 + 55) )\n    return -v69;\n  return v69;\n}\n"
        },
        {
            "funcName": "sub_4074D0",
            "funcStartAddr": "0x4074d0",
            "funcEndAddr": "0x407847",
            "decompiledFuncCode": "__int64 __fastcall sub_4074D0(char **a1, FILE *a2, char *a3)\n{\n  char *v3; // r9\n  __int64 v4; // rbx\n  __int64 v5; // rbp\n  char *v6; // r15\n  size_t v7; // rdx\n  char *v8; // rax\n  unsigned __int64 v9; // rbp\n  __int64 v10; // r12\n  __int64 v11; // rsi\n  char *v12; // r12\n  char **v13; // r13\n  unsigned __int64 v14; // r12\n  char *v15; // r15\n  char **v16; // r14\n  char *v17; // r13\n  size_t v18; // rax\n  unsigned __int64 v19; // r11\n  char *v20; // rax\n  char *v21; // r10\n  char *v22; // r15\n  char *v23; // rax\n  unsigned __int64 v24; // r11\n  bool v25; // zf\n  char *v26; // rax\n  char **v27; // r13\n  char *v28; // r14\n  char *v29; // r15\n  char *v30; // rdi\n  unsigned __int64 v31; // rdx\n  __int64 v32; // rax\n  unsigned __int64 v33; // rax\n  char *v34; // rax\n  __int64 v35; // rax\n  __int64 result; // rax\n  char *v37; // rax\n  __int64 v38; // rdx\n  __int64 v39; // rcx\n  __int64 v40; // r8\n  char *v41; // [rsp+0h] [rbp-78h]\n  char *v42; // [rsp+8h] [rbp-70h]\n  unsigned __int64 v43; // [rsp+10h] [rbp-68h]\n  char v46; // [rsp+37h] [rbp-41h]\n\n  if ( *((_BYTE *)a1 + 48) )\n    return 0LL;\n  v3 = a1[1];\n  v4 = qword_61C750;\n  v5 = qword_61C428;\n  v6 = *a1;\n  v7 = (size_t)a1[4];\n  v46 = byte_61C500;\n  v41 = a1[5];\n  if ( v3 == (char *)v7 )\n  {\n    v8 = a1[2];\n  }\n  else\n  {\n    memmove(v6, &v3[(_QWORD)v6 - v7], v7);\n    v3 = a1[4];\n    v6 = *a1;\n    a1[2] = 0LL;\n    a1[1] = v3;\n    v8 = 0LL;\n  }\n  v9 = v5 - 34;\n  v43 = (unsigned __int64)(v41 + 1);\n  v10 = (__int64)a1[3];\n  v11 = (unsigned int)v46;\n  while ( 1 )\n  {\n    v12 = &v6[v10];\n    v13 = (char **)&v12[-32 * (_QWORD)v8];\n    v14 = &v12[-((_QWORD)v8 * (_QWORD)v41)] - &v3[(_QWORD)v6];\n    if ( v8 )\n    {\n      v15 = &v3[(_QWORD)v6];\n      v16 = v13;\n      v17 = &v13[1][(_QWORD)*v13];\n    }\n    else\n    {\n      v34 = v6;\n      v15 = &v3[(_QWORD)v6];\n      v16 = v13;\n      v17 = v34;\n    }\n    while ( v14 > v43 )\n    {\n      v18 = fread_unlocked(v15, 1uLL, (v14 - 1) / v43, a2);\n      v19 = (v14 - 1) / v43;\n      v14 -= v18;\n      v42 = &v15[v18];\n      if ( v19 == v18 )\n        goto LABEL_36;\n      if ( (a2->_flags & 0x20) != 0 )\n      {\n        v37 = dcgettext(0LL, \"read failed\", 5);\n        sub_405DD0(v37, a3, v38, v39, v40);\n      }\n      if ( (a2->_flags & 0x10) == 0 )\n        goto LABEL_36;\n      *((_BYTE *)a1 + 48) = 1;\n      v20 = &v15[v18];\n      if ( *a1 == v42 )\n        return 0LL;\n      if ( v17 == v42 || *(v42 - 1) == v46 )\n      {\nLABEL_36:\n        v21 = v15;\n        v22 = v42;\n      }\n      else\n      {\n        *v42 = v46;\n        v21 = v15;\n        ++v42;\n        v22 = v20 + 1;\n      }\n      while ( 1 )\n      {\n        v11 = (unsigned int)v46;\n        v23 = (char *)sub_413030(v21, v11, v22 - v21);\n        if ( !v23 )\n          break;\n        v21 = v23 + 1;\n        v16 -= 4;\n        *v23 = 0;\n        *v16 = v17;\n        v24 = v23 + 1 - v17;\n        v16[1] = (char *)v24;\n        if ( v9 < v24 )\n          v9 = v23 + 1 - v17;\n        v14 -= (unsigned __int64)v41;\n        if ( v4 )\n        {\n          if ( *(_QWORD *)(v4 + 16) != -1LL )\n            v23 = sub_406470(v17, v23 + 1 - v17, v4);\n          v25 = *(_QWORD *)v4 == -1LL;\n          v16[3] = v23;\n          if ( v25 )\n          {\n            if ( *(_BYTE *)(v4 + 48) )\n            {\n              while ( byte_61CA80[(unsigned __int8)*v17] )\n                ++v17;\n            }\n            v16[2] = v17;\n          }\n          else\n          {\n            v16[2] = (char *)sub_406360(v17, v24, (__int64 *)v4);\n          }\n        }\n        v17 = v21;\n      }\n      v15 = v42;\n      if ( *((_BYTE *)a1 + 48) )\n        break;\n    }\n    v26 = v17;\n    v27 = v16;\n    v28 = v15;\n    v29 = v26;\n    v30 = *a1;\n    v31 = (unsigned __int64)a1[3];\n    a1[1] = (char *)(v28 - *a1);\n    v32 = (&v30[v31] - (char *)v27) >> 5;\n    a1[2] = (char *)v32;\n    if ( v32 )\n      break;\n    v33 = v31 >> 5;\n    if ( v30 )\n    {\n      v11 = 0x555555555555553FLL;\n      if ( v31 > 0x555555555555553FLL )\n        goto LABEL_46;\n      v10 = 32 * (v33 + (v31 >> 6) + 1);\n    }\n    else if ( v31 <= 0x1F )\n    {\n      v10 = 128LL;\n    }\n    else\n    {\n      v35 = 32 * v33;\n      if ( v35 < 0 )\nLABEL_46:\n        sub_411460(v30, v11, v31);\n      v10 = v35;\n    }\n    v11 = v10;\n    v6 = (char *)sub_411270(v30, v10);\n    *a1 = v6;\n    v3 = a1[1];\n    a1[3] = (char *)v10;\n    v8 = a1[2];\n  }\n  result = 1LL;\n  qword_61C428 = v9 + 34;\n  a1[4] = (char *)(v28 - v29);\n  return result;\n}\n"
        },
        {
            "funcName": "sub_407850",
            "funcStartAddr": "0x407850",
            "funcEndAddr": "0x40787d",
            "decompiledFuncCode": "_BOOL8 __fastcall sub_407850(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n\n  v2 = *(_DWORD *)(a2 + 80);\n  if ( *(_DWORD *)(a1 + 80) == v2 )\n    return *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 48) < *(_QWORD *)(a2 + 40) + *(_QWORD *)(a2 + 48);\n  else\n    return *(_DWORD *)(a1 + 80) < v2;\n}\n"
        },
        {
            "funcName": "sub_407880",
            "funcStartAddr": "0x407880",
            "funcEndAddr": "0x407890",
            "decompiledFuncCode": "int __fastcall sub_407880(__int64 a1)\n{\n  return pthread_sigmask(2, (const __sigset_t *)(a1 + 8), 0LL);\n}\n"
        },
        {
            "funcName": "sub_407890",
            "funcStartAddr": "0x407890",
            "funcEndAddr": "0x40791e",
            "decompiledFuncCode": "__int64 sub_407890()\n{\n  int v0; // eax\n  const char *v1; // rbx\n  char v2; // al\n  char v4[8]; // [rsp+0h] [rbp-98h] BYREF\n  __sigset_t oldmask; // [rsp+8h] [rbp-90h] BYREF\n\n  if ( !ptr )\n    return sub_40A9F0();\n  v0 = pthread_sigmask(0, &newmask, &oldmask);\n  v1 = (const char *)ptr;\n  v2 = v0 == 0;\n  v4[0] = v2;\n  if ( ptr )\n  {\n    do\n    {\n      unlink(v1 + 13);\n      v1 = *(const char **)v1;\n    }\n    while ( v1 );\n    v2 = v4[0];\n  }\n  ptr = 0LL;\n  if ( !v2 )\n    return sub_40A9F0();\n  sub_407880((__int64)v4);\n  return sub_40A9F0();\n}\n"
        },
        {
            "funcName": "sub_407920",
            "funcStartAddr": "0x407920",
            "funcEndAddr": "0x407a2d",
            "decompiledFuncCode": "void __fastcall sub_407920(char *name)\n{\n  __int64 *v1; // r13\n  char *v2; // rbx\n  char *i; // rax\n  __int64 v4; // r12\n  int v5; // r14d\n  int *v6; // rax\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  bool v9; // zf\n  int v10; // r15d\n  __int64 v11; // rbp\n  char *v12; // rax\n  char v13[8]; // [rsp+0h] [rbp-C8h] BYREF\n  __sigset_t oldmask; // [rsp+8h] [rbp-C0h] BYREF\n\n  v1 = (__int64 *)&ptr;\n  v2 = (char *)ptr;\n  if ( name != (char *)ptr + 13 )\n  {\n    for ( i = *(char **)ptr; i + 13 != name; i = *(char **)i )\n      v2 = i;\n    v1 = (__int64 *)v2;\n    v2 = i;\n  }\n  if ( v2[12] == 1 )\n    sub_4060A0(*((_DWORD *)v2 + 2));\n  v4 = *(_QWORD *)v2;\n  v13[0] = pthread_sigmask(0, &newmask, &oldmask) == 0;\n  v5 = unlink(name);\n  v6 = __errno_location();\n  v9 = v13[0] == 0;\n  v10 = *v6;\n  *v1 = v4;\n  if ( v9 )\n  {\n    if ( !v5 )\n      goto LABEL_9;\nLABEL_12:\n    v11 = sub_40F700(0LL, 3LL, name, v7, v8);\n    v12 = dcgettext(0LL, \"warning: cannot remove: %s\", 5);\n    error(0, v10, v12, v11);\n    if ( v4 )\n      goto LABEL_10;\nLABEL_13:\n    off_61C418 = v1;\n    goto LABEL_10;\n  }\n  sub_407880((__int64)v13);\n  if ( v5 )\n    goto LABEL_12;\nLABEL_9:\n  if ( !v4 )\n    goto LABEL_13;\nLABEL_10:\n  free(v2);\n}\n"
        },
        {
            "funcName": "sub_407A30",
            "funcStartAddr": "0x407a30",
            "funcEndAddr": "0x407bf4",
            "decompiledFuncCode": "__int64 __fastcall sub_407A30(int *a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  int *v3; // rbp\n  int v4; // eax\n  void *v5; // r12\n  __pid_t v6; // eax\n  int v7; // r15d\n  unsigned int v8; // r13d\n  double v10; // [rsp+8h] [rbp-E0h]\n  __pid_t v11; // [rsp+14h] [rbp-D4h]\n  char v12[8]; // [rsp+20h] [rbp-C8h] BYREF\n  __sigset_t oldmask; // [rsp+28h] [rbp-C0h] BYREF\n\n  if ( (int)sub_40DA00(a1) < 0 )\n    return (unsigned int)-1;\n  if ( dword_61C420 + 1 < (unsigned int)dword_61C69C )\n  {\n    sub_405FB0(-1);\n    while ( dword_61C69C > 0 && (unsigned int)sub_405FB0(0) )\n      ;\n  }\n  v2 = a2 - 1;\n  v3 = __errno_location();\n  v10 = 0.25;\n  while ( 1 )\n  {\n    v4 = pthread_sigmask(0, &newmask, &oldmask);\n    v5 = ptr;\n    ptr = 0LL;\n    v12[0] = v4 == 0;\n    v6 = fork();\n    v7 = *v3;\n    v8 = v6;\n    if ( v6 )\n    {\n      ptr = v5;\n      if ( !v12[0] )\n        goto LABEL_5;\n    }\n    else if ( !v12[0] )\n    {\n      goto LABEL_19;\n    }\n    v11 = v6;\n    sub_407880((__int64)v12);\n    v6 = v11;\nLABEL_5:\n    *v3 = v7;\n    if ( v6 >= 0 )\n      break;\n    if ( v7 != 11 )\n      goto LABEL_18;\n    sub_411620(v10);\n    v10 = v10 + v10;\n    while ( dword_61C69C > 0 && (unsigned int)sub_405FB0(0) )\n      ;\n    if ( --v2 == -1 )\n    {\n      v7 = *v3;\nLABEL_18:\n      close(*a1);\n      close(a1[1]);\n      *v3 = v7;\n      return v8;\n    }\n  }\n  if ( v6 )\n  {\n    ++dword_61C69C;\n    return v8;\n  }\nLABEL_19:\n  v8 = 0;\n  close(0);\n  close(1);\n  return v8;\n}\n"
        },
        {
            "funcName": "sub_407C00",
            "funcStartAddr": "0x407c00",
            "funcEndAddr": "0x407cd0",
            "decompiledFuncCode": "__int64 __fastcall sub_407C00(char *a1, _QWORD *a2, const char *a3)\n{\n  __int64 v5; // rbp\n  char *v6; // rbx\n  char *v7; // rax\n  __int64 v8; // [rsp+0h] [rbp-28h]\n  __int64 v9; // [rsp+8h] [rbp-20h]\n\n  switch ( (unsigned int)sub_411B40(a1) )\n  {\n    case 0u:\n    case 2u:\n      *a2 = v9;\n      return v8;\n    case 1u:\n    case 3u:\n      *a2 = -1LL;\n      return v8;\n    case 4u:\n      if ( !a3 )\n        return 0LL;\n      v5 = sub_40F880(a1);\n      v6 = dcgettext(0LL, a3, 5);\n      v7 = dcgettext(0LL, \"%s: invalid count at start of %s\", 5);\n      error(2, 0, v7, v6, v5);\n      return sub_407CD0((char *)2, 0LL);\n    default:\n      return v8;\n  }\n}\n"
        },
        {
            "funcName": "sub_407CD0",
            "funcStartAddr": "0x407cd0",
            "funcEndAddr": "0x407dcc",
            "decompiledFuncCode": "_IO_FILE *__fastcall sub_407CD0(char *file, char *modes)\n{\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  FILE *v5; // rbx\n  int v6; // eax\n  __int64 v7; // rbp\n  char *v8; // rbx\n  int *v9; // rax\n\n  if ( *modes != 114 )\n  {\n    if ( *modes == 119 )\n    {\n      if ( !file || !ftruncate(1, 0LL) )\n        return stdout;\n      v7 = sub_40F700(0LL, 3LL, file, v2, v3);\n      v8 = dcgettext(0LL, \"%s: error truncating\", 5);\n      v9 = __errno_location();\n      error(2, *v9, v8, v7);\n    }\n    __assert_fail(\"!\\\"unexpected mode passed to stream_open\\\"\", \"src/sort.c\", 0x3CCu, \"stream_open\");\n  }\n  if ( !strcmp(file, \"-\") )\n  {\n    byte_61C758 = 1;\n    v5 = stdin;\n  }\n  else\n  {\n    v5 = 0LL;\n    v6 = open(file, 0x80000);\n    if ( v6 >= 0 )\n      v5 = fdopen(v6, modes);\n  }\n  sub_40B800(v5, 2LL);\n  return v5;\n}\n"
        },
        {
            "funcName": "sub_407DD0",
            "funcStartAddr": "0x407dd0",
            "funcEndAddr": "0x407df0",
            "decompiledFuncCode": "void __fastcall __noreturn sub_407DD0(char *a1)\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n\n  v1 = dcgettext(0LL, \"open failed\", 5);\n  sub_405DD0(v1, a1, v2, v3, v4);\n}\n"
        },
        {
            "funcName": "sub_407DF0",
            "funcStartAddr": "0x407df0",
            "funcEndAddr": "0x407e6c",
            "decompiledFuncCode": "void __fastcall sub_407DF0(FILE *stream, char *a2)\n{\n  int v3; // eax\n  const char *v4; // rsi\n  char *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n\n  v3 = fileno(stream);\n  if ( v3 )\n  {\n    if ( v3 != 1 )\n    {\n      if ( !(unsigned int)sub_411F80(stream) )\n        return;\n      v4 = \"close failed\";\nLABEL_10:\n      v5 = dcgettext(0LL, v4, 5);\n      sub_405DD0(v5, a2, v6, v7, v8);\n    }\n    if ( fflush_unlocked(stream) )\n    {\n      v4 = \"fflush failed\";\n      goto LABEL_10;\n    }\n  }\n  else if ( (stream->_flags & 0x10) != 0 )\n  {\n    clearerr_unlocked(stream);\n  }\n}\n"
        },
        {
            "funcName": "sub_407E70",
            "funcStartAddr": "0x407e70",
            "funcEndAddr": "0x408297",
            "decompiledFuncCode": "int __fastcall sub_407E70(__int64 a1, FILE *a2, char *a3)\n{\n  char *v5; // rbx\n  __int64 v6; // r15\n  char *v7; // r12\n  size_t v8; // rdx\n  char *v9; // rdi\n  char *v10; // rax\n  unsigned __int8 v11; // si\n  char *IO_write_ptr; // rdx\n  char *v13; // rax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  char v17; // al\n  __int64 v18; // r12\n  char *v19; // r14\n  __int64 v20; // r10\n  char *v21; // rbp\n  __int64 v22; // r11\n  char v23; // r15\n  unsigned __int8 *v24; // rax\n  unsigned __int8 *v25; // rax\n  __int64 v26; // r15\n  __int64 v27; // rbx\n  char *v28; // rax\n  char *v29; // rax\n  char *v30; // rax\n  char *v31; // rax\n  __int64 v32; // rdx\n  __int64 v33; // rcx\n  __int64 v34; // r8\n  char *v36; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int8 *v37; // [rsp+8h] [rbp-40h] BYREF\n\n  v5 = *(char **)a1;\n  v6 = *(_QWORD *)(a1 + 8);\n  v7 = (char *)(*(_QWORD *)a1 + v6);\n  if ( !a3 && byte_61C740 )\n  {\n    if ( v5 >= v7 )\n      goto LABEL_18;\n    while ( 1 )\n    {\n      v17 = *v5++;\n      if ( v17 == 9 )\n      {\n        v11 = 62;\n        v17 = 62;\n        IO_write_ptr = a2->_IO_write_ptr;\n        if ( a2->_IO_write_end <= IO_write_ptr )\n          goto LABEL_15;\n      }\n      else\n      {\n        v11 = *(v5 - 1);\n        if ( v7 == v5 )\n        {\n          v11 = 10;\n          v17 = 10;\n        }\n        IO_write_ptr = a2->_IO_write_ptr;\n        if ( a2->_IO_write_end <= IO_write_ptr )\n        {\nLABEL_15:\n          if ( __overflow(a2, v11) == -1 )\n          {\n            v13 = dcgettext(0LL, \"write failed\", 5);\n            sub_405DD0(v13, 0LL, v14, v15, v16);\n          }\n          goto LABEL_12;\n        }\n      }\n      a2->_IO_write_ptr = IO_write_ptr + 1;\n      *IO_write_ptr = v17;\nLABEL_12:\n      if ( v7 == v5 )\n      {\n        v5 = *(char **)a1;\n        v6 = *(_QWORD *)(a1 + 8);\nLABEL_18:\n        v18 = qword_61C750;\n        v19 = &v5[v6 - 1];\n        if ( !qword_61C750 )\n        {\n          v21 = v5;\n          goto LABEL_39;\n        }\n        while ( 2 )\n        {\n          v20 = *(_QWORD *)v18;\n          if ( *(_QWORD *)v18 == -1LL )\n          {\n            v21 = v5;\n            if ( *(_QWORD *)(v18 + 16) != -1LL )\nLABEL_21:\n              v19 = sub_406470(v5, v6, v18);\n            if ( *(_BYTE *)(v18 + 48) && v20 == -1 )\n            {\nLABEL_26:\n              v23 = *v19;\n              for ( *v19 = 0; byte_61CA80[(unsigned __int8)*v21]; ++v21 )\n                ;\n              v36 = v21;\n              if ( v21 > v19 )\n                goto LABEL_55;\n              if ( *(_BYTE *)(v18 + 54) )\n              {\n                sub_405A40((unsigned __int8 *)v21, &v36);\n              }\n              else if ( *(_BYTE *)(v18 + 52) )\n              {\n                strtold(v21, &v36);\n              }\n              else\n              {\n                if ( (*(_QWORD *)(v18 + 48) & 0xFF0000FF0000LL) != 0 )\n                {\n                  v24 = (unsigned __int8 *)v21;\n                  if ( v21 < v19 )\n                    v24 = (unsigned __int8 *)&v21[*v21 == 45];\n                  v37 = v24;\n                  if ( (unsigned __int8)sub_405930(&v37) > 0x2Fu )\n                  {\n                    v25 = v37;\n                    if ( *(_BYTE *)(v18 + 53) )\n                      v25 = &v37[-(byte_4149C0[*v37] == 0) + 1];\n                    v36 = (char *)v25;\n                  }\n                  goto LABEL_38;\n                }\nLABEL_55:\n                v36 = v19;\n              }\nLABEL_38:\n              *v19 = v23;\n              v19 = v36;\n              goto LABEL_39;\n            }\n          }\n          else\n          {\n            v21 = (char *)sub_406360(v5, v6, (__int64 *)v18);\n            if ( v22 != -1 )\n              goto LABEL_21;\n          }\n          if ( *(_BYTE *)(v18 + 54) || (*(_QWORD *)(v18 + 48) & 0xFFFF00FF0000LL) != 0 )\n            goto LABEL_26;\n          while ( 1 )\n          {\nLABEL_39:\n            v26 = sub_405EB0(v5, v21);\n            v27 = sub_405EB0(v21, v19);\n            while ( --v26 != -1 )\n            {\n              v28 = stdout->_IO_write_ptr;\n              if ( v28 >= stdout->_IO_write_end )\n              {\n                __overflow(stdout, 32);\n              }\n              else\n              {\n                stdout->_IO_write_ptr = v28 + 1;\n                *v28 = 32;\n              }\n            }\n            if ( v27 )\n            {\n              do\n              {\n                v29 = stdout->_IO_write_ptr;\n                if ( v29 >= stdout->_IO_write_end )\n                {\n                  __overflow(stdout, 95);\n                }\n                else\n                {\n                  stdout->_IO_write_ptr = v29 + 1;\n                  *v29 = 95;\n                }\n                --v27;\n              }\n              while ( v27 );\n              v10 = stdout->_IO_write_ptr;\n              if ( v10 >= stdout->_IO_write_end )\n              {\n                LODWORD(v10) = __overflow(stdout, 10);\n              }\n              else\n              {\n                stdout->_IO_write_ptr = v10 + 1;\n                *v10 = 10;\n              }\n            }\n            else\n            {\n              v30 = dcgettext(0LL, \"^ no match for key\\n\", 5);\n              LODWORD(v10) = __printf_chk(1LL, v30);\n            }\n            if ( !v18 )\n              return (int)v10;\n            v18 = *(_QWORD *)(v18 + 64);\n            if ( v18 )\n              break;\n            if ( byte_61C759 || byte_61C75A )\n              return (int)v10;\n            v21 = *(char **)a1;\n            v5 = *(char **)a1;\n            v19 = (char *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 8) - 1LL);\n          }\n          v5 = *(char **)a1;\n          v6 = *(_QWORD *)(a1 + 8);\n          v19 = (char *)(*(_QWORD *)a1 + v6 - 1);\n          continue;\n        }\n      }\n    }\n  }\n  v8 = *(_QWORD *)(a1 + 8);\n  v9 = *(char **)a1;\n  *(v7 - 1) = byte_61C500;\n  v10 = (char *)fwrite_unlocked(v9, 1uLL, v8, a2);\n  if ( (char *)v6 != v10 )\n  {\n    v31 = dcgettext(0LL, \"write failed\", 5);\n    sub_405DD0(v31, a3, v32, v33, v34);\n  }\n  *(v7 - 1) = 0;\n  return (int)v10;\n}\n"
        },
        {
            "funcName": "sub_4082A0",
            "funcStartAddr": "0x4082a0",
            "funcEndAddr": "0x408370",
            "decompiledFuncCode": "int __fastcall sub_4082A0(const void **a1, unsigned __int8 **a2)\n{\n  int result; // eax\n  unsigned __int8 *v5; // r12\n  unsigned __int8 *v6; // r14\n  unsigned __int8 *v7; // r13\n  unsigned __int8 *v8; // r15\n  unsigned __int8 *v9; // rsi\n  const void *v10; // rdi\n  size_t v11; // rdx\n\n  if ( !qword_61C750 || (result = sub_4065B0((__int64)a1, a2)) == 0 && !byte_61C759 && !byte_61C75A )\n  {\n    v5 = (unsigned __int8 *)a1[1];\n    v6 = a2[1];\n    v7 = v6 - 1;\n    v8 = v5 - 1;\n    if ( v5 == (unsigned __int8 *)1 )\n    {\n      result = -(v6 != (unsigned __int8 *)1);\n    }\n    else\n    {\n      result = 1;\n      if ( v6 != (unsigned __int8 *)1 )\n      {\n        v9 = *a2;\n        v10 = *a1;\n        if ( byte_61CBA1 )\n        {\n          result = sub_4115C0(v10, a1[1], *a2, a2[1]);\n        }\n        else\n        {\n          v11 = (size_t)(v6 - 1);\n          if ( v8 <= v7 )\n            v11 = (size_t)(v5 - 1);\n          result = memcmp(v10, v9, v11);\n          if ( !result )\n          {\n            result = -1;\n            if ( v8 >= v7 )\n              result = v5 != v6;\n          }\n        }\n      }\n    }\n    if ( byte_61C75B )\n      return -result;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_408370",
            "funcStartAddr": "0x408370",
            "funcEndAddr": "0x4085c6",
            "decompiledFuncCode": "int __fastcall sub_408370(__m128i *a1, unsigned __int64 a2, __m128i *a3, char a4)\n{\n  const __m128i *v4; // rbp\n  __m128i *v5; // rbx\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // r15\n  __m128i v8; // xmm1\n  unsigned __int8 **v9; // r13\n  __m128i *v10; // rax\n  const void **v11; // rdx\n  unsigned __int8 **i; // r14\n  __int64 v13; // rax\n  __m128i v14; // xmm1\n  __m128i v15; // xmm0\n  __m128i v16; // xmm2\n  __m128i v17; // xmm3\n  int v18; // edx\n  const __m128i *v19; // rdx\n  __m128i v20; // xmm1\n  __m128i v21; // xmm0\n  __m128i v22; // xmm1\n  const void **v24; // [rsp+8h] [rbp-40h]\n\n  v4 = a1;\n  v5 = a3;\n  if ( a2 == 2 )\n  {\n    LODWORD(v13) = sub_4082A0((const void **)&a1[-2], (unsigned __int8 **)&a1[-4]);\n    if ( a4 )\n    {\n      v18 = (int)v13 > 0;\n      v13 = 32LL * (v18 - 2);\n      v19 = &a1[2 * ~v18];\n      v20 = _mm_loadu_si128(v19 + 1);\n      v5[-2] = _mm_loadu_si128(v19);\n      v21 = _mm_loadu_si128((__m128i *)((char *)a1 + v13));\n      v5[-1] = v20;\n      v22 = _mm_loadu_si128((__m128i *)((char *)a1 + v13 + 16));\n      v5[-4] = v21;\n      v5[-3] = v22;\n    }\n    else if ( (int)v13 > 0 )\n    {\n      v14 = _mm_loadu_si128(a1 - 2);\n      v15 = _mm_loadu_si128(a1 - 1);\n      v16 = _mm_loadu_si128(a1 - 4);\n      v17 = _mm_loadu_si128(a1 - 3);\n      v5[-2] = v14;\n      v5[-1] = v15;\n      a1[-2] = v16;\n      a1[-1] = v17;\n      a1[-4] = v14;\n      a1[-3] = v15;\n    }\n  }\n  else\n  {\n    v6 = a2 >> 1;\n    v7 = a2 - (a2 >> 1);\n    if ( a4 )\n    {\n      v9 = (unsigned __int8 **)&a3[-2 * (a2 >> 1)];\n      sub_408370(&a1[-2 * (a2 >> 1)], a2 - (a2 >> 1), v9, 1LL);\n      if ( a2 > 3 )\n        sub_408370(a1, v6, v5, 0LL);\n    }\n    else\n    {\n      sub_408370(&a1[-2 * (a2 >> 1)], a2 - (a2 >> 1), a3, 0LL);\n      if ( a2 > 3 )\n      {\n        sub_408370(a1, v6, v5, 1LL);\n        v9 = (unsigned __int8 **)&a1[-2 * (a2 >> 1)];\n        v10 = v5;\n      }\n      else\n      {\n        v8 = _mm_loadu_si128(a1 - 1);\n        v9 = (unsigned __int8 **)&a1[-2 * (a2 >> 1)];\n        v10 = v5;\n        v5[-2] = _mm_loadu_si128(a1 - 2);\n        v5[-1] = v8;\n      }\n      v5 = a1;\n      v4 = v10;\n    }\n    v11 = (const void **)&v4[-2];\n    for ( i = v9 - 4; ; i -= 4 )\n    {\n      while ( 1 )\n      {\n        v24 = v11;\n        v5 -= 2;\n        LODWORD(v13) = sub_4082A0(v11, i);\n        v11 = v24;\n        if ( (int)v13 > 0 )\n          break;\n        *v5 = _mm_loadu_si128(v4 - 2);\n        v5[1] = _mm_loadu_si128(v4 - 1);\n        if ( !--v6 )\n          return v13;\n        v4 = (const __m128i *)v24;\n        v11 = v24 - 4;\n      }\n      *v5 = _mm_loadu_si128((const __m128i *)v9 - 2);\n      v5[1] = _mm_loadu_si128((const __m128i *)v9 - 1);\n      if ( !--v7 )\n        break;\n      v9 = i;\n    }\n    v13 = -32LL;\n    do\n    {\n      *(__m128i *)((char *)v5 + v13) = _mm_loadu_si128((const __m128i *)((char *)v4 + v13));\n      *(__m128i *)((char *)&v5[1] + v13) = _mm_loadu_si128((const __m128i *)((char *)v4 + v13 + 16));\n      v13 -= 32LL;\n      --v6;\n    }\n    while ( v6 );\n  }\n  return v13;\n}\n"
        },
        {
            "funcName": "sub_4085D0",
            "funcStartAddr": "0x4085d0",
            "funcEndAddr": "0x408637",
            "decompiledFuncCode": "int __fastcall sub_4085D0(__m128i *a1, FILE *a2, char *a3)\n{\n  int result; // eax\n  char *v4; // [rsp+8h] [rbp-20h]\n\n  if ( !byte_61C759 )\n    return sub_407E70((__int64)a1, a2, a3);\n  if ( !(_QWORD)xmmword_61CB80\n    || (v4 = a3, result = sub_4082A0((const void **)a1, (unsigned __int8 **)&xmmword_61CB80), a3 = v4, result) )\n  {\n    xmmword_61CB80 = (__int128)_mm_loadu_si128(a1);\n    xmmword_61CB90 = (__int128)_mm_loadu_si128(a1 + 1);\n    return sub_407E70((__int64)a1, a2, a3);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_408640",
            "funcStartAddr": "0x408640",
            "funcEndAddr": "0x408e08",
            "decompiledFuncCode": "void __fastcall sub_408640(__int64 a1, unsigned __int64 a2, __int64 a3, FILE *a4, char *a5, FILE **a6)\n{\n  __int64 v6; // rdi\n  unsigned __int128 v7; // rax\n  __int64 v8; // rbx\n  unsigned __int64 v9; // r15\n  unsigned __int8 ***v10; // r13\n  unsigned __int64 *v11; // rbx\n  __int64 v12; // rbx\n  char **v13; // r13\n  __int64 v14; // rdx\n  char **v15; // rbp\n  char *v16; // rax\n  unsigned __int64 i; // rax\n  unsigned __int8 ***v18; // rdx\n  unsigned __int64 v19; // rbp\n  unsigned __int64 *v20; // r13\n  unsigned __int64 *v21; // r12\n  unsigned __int64 v22; // rbx\n  unsigned __int64 v23; // r14\n  int v24; // eax\n  unsigned __int8 ***v25; // r14\n  __int64 v26; // r15\n  const void ***v27; // r12\n  unsigned __int64 v28; // r13\n  char **v29; // r13\n  FILE *v30; // rsi\n  char *v31; // r15\n  char v32; // al\n  FILE **v33; // rcx\n  __int64 v34; // rax\n  unsigned __int64 v35; // r13\n  const void **v36; // rax\n  unsigned __int64 v37; // r12\n  unsigned __int8 ***v38; // rax\n  unsigned __int64 v39; // r14\n  unsigned __int64 v40; // r15\n  unsigned __int8 ***v41; // r13\n  unsigned __int64 v42; // rbp\n  int v43; // eax\n  unsigned __int64 v44; // r15\n  unsigned __int64 *v45; // rax\n  unsigned __int64 v46; // rdx\n  void *v47; // rdx\n  void *v48; // rdi\n  const void *v49; // rsi\n  char *v50; // rax\n  unsigned __int64 *v51; // rax\n  unsigned __int64 v52; // rcx\n  unsigned __int64 v53; // rdi\n  __int64 v54; // rax\n  __int64 v55; // rax\n  const __m128i *v56; // rdx\n  __m128i v57; // xmm0\n  __m128i v58; // xmm1\n  __m128i v59; // xmm2\n  __int64 v60; // r9\n  __m128i v61; // xmm3\n  unsigned __int8 **v62; // r9\n  __int64 v63; // r9\n  unsigned __int64 *v64; // rax\n  unsigned __int64 v65; // rdx\n  FILE *v66; // rax\n  unsigned __int64 v67; // rsi\n  unsigned __int8 ***v68; // [rsp+8h] [rbp-D0h]\n  FILE **v69; // [rsp+8h] [rbp-D0h]\n  const void **v70; // [rsp+8h] [rbp-D0h]\n  unsigned __int64 v71; // [rsp+8h] [rbp-D0h]\n  unsigned __int8 ***v72; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v73; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v74; // [rsp+18h] [rbp-C0h]\n  _QWORD *v75; // [rsp+20h] [rbp-B8h]\n  char *v77; // [rsp+30h] [rbp-A8h]\n  unsigned __int64 *v78; // [rsp+38h] [rbp-A0h]\n  void **v79; // [rsp+38h] [rbp-A0h]\n  _QWORD *v81; // [rsp+48h] [rbp-90h]\n  unsigned __int64 *v82; // [rsp+50h] [rbp-88h]\n  unsigned __int64 v85; // [rsp+68h] [rbp-70h]\n  unsigned __int64 v86; // [rsp+70h] [rbp-68h]\n  __int64 v87; // [rsp+78h] [rbp-60h]\n  void *dest[11]; // [rsp+80h] [rbp-58h] BYREF\n\n  v6 = a3;\n  v74 = a3;\n  v85 = a2;\n  v7 = (unsigned __int64)a3 * (unsigned __int128)0x38uLL;\n  BYTE8(v7) = *((_QWORD *)&v7 + 1) != 0LL;\n  if ( (v7 & 0x8000000000000000LL) != 0LL\n    || (*((_QWORD *)&v7 + 1) = BYTE8(v7), BYTE8(v7))\n    || (v8 = 8 * v74, v6 = 56 * v74, v77 = (char *)sub_411210(56 * v74), (v74 & 0x1000000000000000LL) != 0)\n    || v74 >> 61 )\n  {\n    sub_411460(v6, a2, *((_QWORD *)&v7 + 1));\n  }\n  v9 = 0LL;\n  v10 = (unsigned __int8 ***)sub_411210(v8);\n  v75 = (_QWORD *)sub_411210(v8);\n  dest[0] = 0LL;\n  v11 = (unsigned __int64 *)sub_411210(v8);\n  v87 = qword_61C750;\n  if ( v74 )\n  {\n    v78 = v11;\n    v72 = v10;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v12 = 8 * v9;\n        v13 = (char **)&v77[56 * v9];\n        v14 = qword_61C428;\n        if ( qword_61C778 / v74 >= qword_61C428 )\n          v14 = qword_61C778 / v74;\n        sub_405E30((__int64)&v77[56 * v9], 32LL, v14);\n        v15 = (char **)(a1 + 16 * v9);\n        if ( !(unsigned __int8)sub_4074D0(v13, a6[v9], *v15) )\n          break;\n        v16 = &v13[3][(_QWORD)*v13];\n        v72[v9] = (unsigned __int8 **)(v16 - 32);\n        v75[v9++] = &v16[-32 * (_QWORD)v13[2]];\n        if ( v9 >= v74 )\n        {\n          v11 = v78;\n          v10 = v72;\n          goto LABEL_12;\n        }\n      }\n      sub_407DF0(a6[v9], *v15);\n      if ( v85 > v9 )\n      {\n        --v85;\n        sub_407920(*v15);\n      }\n      free(*v13);\n      if ( v74 - 1 <= v9 )\n        break;\n      do\n      {\n        v66 = a6[(unsigned __int64)v12 / 8 + 1];\n        *(__m128i *)(a1 + 2 * v12) = _mm_loadu_si128((const __m128i *)(a1 + 2 * v12 + 16));\n        a6[(unsigned __int64)v12 / 8] = v66;\n        v12 += 8LL;\n      }\n      while ( 8 * v74 - 8 != v12 );\n      --v74;\n    }\n    v11 = v78;\n    v10 = v72;\n    --v74;\nLABEL_12:\n    if ( !v74 )\n      goto LABEL_68;\n    for ( i = 0LL; i != v74; ++i )\n      v11[i] = i;\n    if ( v74 != 1 )\n    {\n      v18 = v10;\n      v19 = 1LL;\n      v20 = v11;\n      do\n      {\n        while ( 1 )\n        {\n          v68 = v18;\n          v21 = &v20[v19];\n          v22 = *v21;\n          v23 = *(v21 - 1);\n          v24 = sub_4082A0((const void **)v18[v23], v18[*v21]);\n          v18 = v68;\n          if ( v24 <= 0 )\n            break;\n          *(v21 - 1) = v22;\n          v19 = 1LL;\n          *v21 = v23;\n        }\n        ++v19;\n      }\n      while ( v19 < v74 );\n      v11 = v20;\n      v10 = v68;\n    }\n    v86 = 0LL;\n    v25 = v10;\n    v79 = 0LL;\n    v82 = v11 - 1;\n    while ( 1 )\n    {\n      v26 = *v11;\n      v73 = *v11;\n      v27 = (const void ***)&v25[v26];\n      v28 = (unsigned __int64)v25[v26];\n      if ( byte_61C759 )\n      {\n        if ( !v79 )\n          goto LABEL_42;\n        if ( sub_4082A0((const void **)v79, v25[v26]) )\n        {\n          sub_407E70((__int64)dest, a4, a5);\nLABEL_42:\n          v47 = *(void **)(v28 + 8);\n          v48 = dest[0];\n          if ( (unsigned __int64)v47 > v86 )\n          {\n            if ( v86 )\n            {\n              v67 = 2 * v86;\n              if ( (unsigned __int64)v47 > 2 * v86 )\n              {\n                while ( v67 )\n                {\n                  v67 *= 2LL;\n                  if ( (unsigned __int64)v47 <= v67 )\n                    goto LABEL_75;\n                }\n              }\n              else\n              {\nLABEL_75:\n                v47 = (void *)v67;\n              }\n            }\n            v71 = (unsigned __int64)v47;\n            free(dest[0]);\n            v48 = (void *)sub_411210(v71);\n            dest[0] = v48;\n            v86 = v71;\n            v47 = *(void **)(v28 + 8);\n          }\n          v49 = *(const void **)v28;\n          dest[1] = v47;\n          memcpy(v48, v49, (size_t)v47);\n          v79 = dest;\n          if ( v87 )\n          {\n            v50 = (char *)dest[0] + *(_QWORD *)(v28 + 24) - *(_QWORD *)v28;\n            dest[2] = (char *)dest[0] + *(_QWORD *)(v28 + 16) - *(_QWORD *)v28;\n            dest[3] = v50;\n          }\n        }\n      }\n      else\n      {\n        sub_407E70((__int64)v25[v26], a4, a5);\n      }\n      if ( v75[v26] < v28 )\n      {\n        *v27 = (const void **)(v28 - 32);\n        v35 = v74;\n        if ( v74 != 1 )\n          goto LABEL_28;\nLABEL_39:\n        *v11 = v73;\n      }\n      else\n      {\n        v81 = &v75[v26];\n        v29 = (char **)(a1 + 16 * v73);\n        v30 = a6[v26];\n        v69 = &a6[v26];\n        v31 = &v77[56 * v73];\n        v32 = sub_4074D0((char **)v31, v30, *v29);\n        v33 = v69;\n        if ( v32 )\n        {\n          v34 = *(_QWORD *)v31 + *((_QWORD *)v31 + 3);\n          v35 = v74;\n          *v27 = (const void **)(v34 - 32);\n          *v81 = v34 - 32LL * *((_QWORD *)v31 + 2);\n          if ( v74 == 1 )\n            goto LABEL_39;\nLABEL_28:\n          v36 = *v27;\n          v37 = 1LL;\n          v70 = v36;\n          v38 = v25;\n          v39 = 1LL;\n          v40 = v35;\n          v41 = v38;\n          do\n          {\n            while ( 1 )\n            {\n              v42 = v11[v37];\n              v43 = sub_4082A0(v70, v41[v42]);\n              if ( v43 < 0 || v73 < v42 && !v43 )\n                break;\n              v39 = v37 + 1;\n              v37 = (v37 + 1 + v40) >> 1;\n              if ( v39 >= v40 )\n                goto LABEL_34;\n            }\n            v40 = v37;\n            v37 = (v39 + v37) >> 1;\n          }\n          while ( v39 < v40 );\nLABEL_34:\n          v44 = v39;\n          v25 = v41;\n          if ( v44 != 1 )\n          {\n            v45 = v11;\n            do\n            {\n              v46 = v45[1];\n              *v45++ = v46;\n            }\n            while ( v45 != &v82[v44] );\n          }\n          v11[v44 - 1] = v73;\n        }\n        else\n        {\n          v51 = v11 + 1;\n          if ( v74 != 1 )\n          {\n            v52 = v73;\n            do\n            {\n              if ( *v51 > v52 )\n              {\n                --*v51;\n                v52 = *v11;\n              }\n              ++v51;\n            }\n            while ( &v11[v74] != v51 );\n            v53 = v52;\n            v54 = 8 * v52;\n            v73 = v52;\n            v29 = (char **)(a1 + 16 * v52);\n            v33 = &a6[v52];\n            v31 = &v77[8 * (v54 - v53)];\n          }\n          sub_407DF0(*v33, *v29);\n          if ( v85 > v73 )\n          {\n            --v85;\n            sub_407920(*v29);\n          }\n          free(*(void **)v31);\n          if ( v74 - 1 > v73 )\n          {\n            v55 = 8 * v73;\n            v56 = (const __m128i *)&v77[56 * v73];\n            do\n            {\n              v57 = _mm_loadu_si128((const __m128i *)(a1 + 2 * v55 + 16));\n              v56 = (const __m128i *)((char *)v56 + 56);\n              v58 = _mm_loadu_si128(v56);\n              v59 = _mm_loadu_si128(v56 + 1);\n              a6[(unsigned __int64)v55 / 8] = a6[(unsigned __int64)v55 / 8 + 1];\n              v60 = v56[3].m128i_i64[0];\n              v61 = _mm_loadu_si128(v56 + 2);\n              *(__m128i *)(a1 + 2 * v55) = v57;\n              v56[-1].m128i_i64[1] = v60;\n              v62 = v25[(unsigned __int64)v55 / 8 + 1];\n              *(__m128i *)((char *)v56 - 56) = v58;\n              v25[(unsigned __int64)v55 / 8] = v62;\n              v63 = v75[(unsigned __int64)v55 / 8 + 1];\n              *(__m128i *)((char *)v56 - 40) = v59;\n              v75[(unsigned __int64)v55 / 8] = v63;\n              v55 += 8LL;\n              *(__m128i *)((char *)v56 - 24) = v61;\n            }\n            while ( 8 * v74 - 8 != v55 );\n          }\n          if ( v74 == 1 )\n          {\n            v10 = v25;\n            if ( v79 && byte_61C759 )\n            {\n              sub_407E70((__int64)dest, a4, a5);\n              free(dest[0]);\n            }\n            break;\n          }\n          v64 = v11;\n          do\n          {\n            v65 = v64[1];\n            *v64++ = v65;\n          }\n          while ( &v82[v74] != v64 );\n          --v74;\n        }\n      }\n    }\n  }\nLABEL_68:\n  sub_407DF0(a4, a5);\n  free(a6);\n  free(v77);\n  free(v11);\n  free(v75);\n  free(v10);\n}\n"
        },
        {
            "funcName": "sub_408E10",
            "funcStartAddr": "0x408e10",
            "funcEndAddr": "0x408e20",
            "decompiledFuncCode": "int __fastcall sub_408E10(int fd, int a2)\n{\n  dup2(fd, a2);\n  return close(fd);\n}\n"
        },
        {
            "funcName": "sub_408E20",
            "funcStartAddr": "0x408e20",
            "funcEndAddr": "0x409030",
            "decompiledFuncCode": "__int64 __fastcall sub_408E20(__int64 a1, unsigned __int64 a2, __int64 *a3)\n{\n  __int64 v4; // rdi\n  __int64 v6; // rax\n  __int64 v7; // r14\n  __int64 v8; // rbx\n  _IO_FILE *v9; // rax\n  __int64 v10; // r12\n  char v11; // al\n  int v12; // r15d\n  int v13; // eax\n  int *v14; // rbp\n  FILE *v16; // rax\n  int *v17; // rax\n  int v18; // r13d\n  int *v19; // rbp\n  int *v20; // rax\n  __int64 v21; // rbx\n  char *v22; // rax\n  int v23; // [rsp+8h] [rbp-40h] BYREF\n  int fd; // [rsp+Ch] [rbp-3Ch]\n\n  v4 = 8 * a2;\n  if ( (a2 & 0x1000000000000000LL) != 0 || a2 >> 61 )\n    sub_411460(v4, a2, a3);\n  v6 = sub_411210(v4);\n  *a3 = v6;\n  v7 = v6;\n  v8 = 0LL;\n  if ( !a2 )\n    return v8;\n  while ( 1 )\n  {\n    v10 = *(_QWORD *)(a1 + 8);\n    if ( !v10 || (v11 = *(_BYTE *)(v10 + 12)) == 0 )\n    {\n      v9 = sub_407CD0(*(char **)a1, \"r\");\n      *(_QWORD *)(v7 + 8 * v8) = v9;\n      if ( !v9 )\n        return v8;\n      goto LABEL_6;\n    }\n    if ( v11 == 1 )\n      sub_4060A0(*(_DWORD *)(v10 + 8));\n    v12 = open((const char *)(v10 + 13), 0);\n    if ( v12 < 0 )\n      goto LABEL_15;\n    v13 = sub_407A30(&v23, 9LL);\n    if ( v13 == -1 )\n      break;\n    if ( !v13 )\n    {\n      close(v23);\n      if ( v12 )\n        sub_408E10(v12, 0);\n      if ( fd != 1 )\n        sub_408E10(fd, 1);\n      execlp(arg, arg, \"-d\", 0LL);\n      v20 = __errno_location();\n      sub_4060D0(*v20, \"couldn't execute compress program (with -d)\");\n    }\n    *(_DWORD *)(v10 + 8) = v13;\n    sub_406190(v10);\n    close(v12);\n    close(fd);\n    v16 = fdopen(v23, \"r\");\n    if ( !v16 )\n    {\n      v17 = __errno_location();\n      v18 = *v17;\n      v19 = v17;\n      close(v23);\n      *(_QWORD *)(v7 + 8 * v8) = 0LL;\n      *v19 = v18;\n      return v8;\n    }\n    *(_QWORD *)(v7 + 8 * v8) = v16;\nLABEL_6:\n    ++v8;\n    a1 += 16LL;\n    if ( a2 == v8 )\n      return v8;\n  }\n  v14 = __errno_location();\n  if ( *v14 == 24 )\n  {\n    close(v12);\n    *v14 = 24;\nLABEL_15:\n    *(_QWORD *)(v7 + 8 * v8) = 0LL;\n    return v8;\n  }\n  v21 = sub_40F630(4LL, arg);\n  v22 = dcgettext(0LL, \"couldn't create process for %s -d\", 5);\n  error(2, *v14, v22, v21);\n  return sub_409030();\n}\n"
        },
        {
            "funcName": "sub_409030",
            "funcStartAddr": "0x409030",
            "funcEndAddr": "0x4090b8",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_409030(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, FILE *a4, char *a5)\n{\n  unsigned __int64 v8; // rax\n  unsigned __int64 v9; // rbx\n  char *v11; // rbx\n  char *v12; // rax\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  FILE **v16; // [rsp+8h] [rbp-40h] BYREF\n\n  v8 = sub_408E20(a1, a3, (__int64 *)&v16);\n  v9 = v8;\n  if ( a3 > v8 && v8 <= 1 )\n  {\n    v11 = *(char **)(a1 + 16 * v8);\n    v12 = dcgettext(0LL, \"open failed\", 5);\n    sub_405DD0(v12, v11, v13, v14, v15);\n  }\n  sub_408640(a1, a2, v8, a4, a5, v16);\n  return v9;\n}\n"
        },
        {
            "funcName": "sub_4090C0",
            "funcStartAddr": "0x4090c0",
            "funcEndAddr": "0x409330",
            "decompiledFuncCode": "__int64 __fastcall sub_4090C0(FILE **a1, char a2)\n{\n  const char *v2; // r13\n  size_t v3; // r12\n  __int64 v4; // rax\n  char *v5; // rbp\n  __int64 v6; // rbx\n  __int64 v7; // rax\n  int v8; // r12d\n  int *v9; // rax\n  unsigned int *v10; // r14\n  __int64 *v11; // rax\n  bool v12; // zf\n  int v13; // eax\n  FILE *v14; // rax\n  int v16; // ebp\n  void *v17; // rdi\n  unsigned int v18; // r13d\n  char *v19; // rax\n  __int64 v20; // rdx\n  __int64 v21; // rcx\n  __int64 v22; // r8\n  __int64 v23; // rbx\n  char *v24; // rax\n  __int64 v25; // rsi\n  __int64 v26; // rdx\n  __int64 v27; // rcx\n  int fd; // [rsp+10h] [rbp-C8h] BYREF\n  int v29; // [rsp+14h] [rbp-C4h]\n  __sigset_t oldmask; // [rsp+18h] [rbp-C0h] BYREF\n\n  v2 = *(const char **)(qword_61C770 + 8 * qword_61C5E8);\n  v3 = strlen(v2);\n  v4 = sub_411210((v3 + 32) & 0xFFFFFFFFFFFFFFF8LL);\n  v5 = (char *)(v4 + 13);\n  v6 = v4;\n  memcpy((void *)(v4 + 13), v2, v3);\n  *(_QWORD *)(v6 + v3 + 13) = 0x58585874726F732FLL;\n  *(_DWORD *)&v5[v3 + 8] = 5789784;\n  v7 = qword_61C5E8;\n  *(_QWORD *)v6 = 0LL;\n  qword_61C5E8 = v7 + 1;\n  if ( v7 + 1 == qword_61C768 )\n    qword_61C5E8 = 0LL;\n  LOBYTE(fd) = pthread_sigmask(0, &newmask, &oldmask) == 0;\n  v8 = sub_410680(v5, 0x80000LL);\n  v9 = __errno_location();\n  v10 = (unsigned int *)v9;\n  if ( v8 >= 0 )\n  {\n    v11 = off_61C418;\n    v12 = (_BYTE)fd == 0;\n    off_61C418 = (__int64 *)v6;\n    *v11 = v6;\n    if ( !v12 )\n    {\n      v18 = *v10;\n      sub_407880((__int64)&fd);\n      *v10 = v18;\n    }\n    v12 = arg == 0LL;\n    *(_BYTE *)(v6 + 12) = 0;\n    if ( !v12 )\n    {\n      v13 = sub_407A30(&fd, 4LL);\n      *(_DWORD *)(v6 + 8) = v13;\n      if ( v13 > 0 )\n      {\n        close(v8);\n        close(fd);\n        v8 = v29;\n        sub_406190(v6);\n      }\n      else if ( !v13 )\n      {\n        close(v29);\n        if ( v8 != 1 )\n          sub_408E10(v8, 1);\n        if ( fd )\n          sub_408E10(fd, 0);\n        execlp(arg, arg, 0LL);\n        sub_4060D0(*v10, \"couldn't execute compress program\");\n      }\n    }\n    v14 = fdopen(v8, \"w\");\n    *a1 = v14;\n    if ( !v14 )\n    {\n      v19 = dcgettext(0LL, \"couldn't create temporary file\", 5);\n      sub_405DD0(v19, v5, v20, v21, v22);\n    }\n    return v6;\n  }\n  v16 = *v9;\n  if ( (_BYTE)fd )\n  {\n    sub_407880((__int64)&fd);\n    *v10 = v16;\n  }\n  if ( v16 == 24 && a2 == 1 )\n  {\n    v17 = (void *)v6;\n    v6 = 0LL;\n    free(v17);\n    return v6;\n  }\n  v23 = sub_40F630(4LL, v2);\n  v24 = dcgettext(0LL, \"cannot create temporary file in %s\", 5);\n  v25 = *v10;\n  error(2, v25, v24, v23);\n  return sub_409330(2LL, v25, v26, v27);\n}\n"
        },
        {
            "funcName": "sub_409330",
            "funcStartAddr": "0x409330",
            "funcEndAddr": "0x409821",
            "decompiledFuncCode": "void __fastcall sub_409330(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, char *a4)\n{\n  _QWORD *v4; // r14\n  unsigned __int64 v5; // r13\n  unsigned __int64 v7; // rcx\n  unsigned __int64 v8; // rbp\n  __int64 v9; // rbx\n  __int64 v10; // rax\n  unsigned __int64 v11; // rsi\n  __int64 v12; // r13\n  __int64 v13; // r15\n  unsigned __int64 v14; // rax\n  unsigned __int64 v15; // rdx\n  unsigned __int64 v16; // rsi\n  __int64 v17; // rdx\n  unsigned __int64 v18; // rdx\n  _QWORD *v19; // r15\n  const void *v20; // r9\n  unsigned __int64 v21; // rax\n  unsigned __int64 v22; // rbx\n  __int64 v23; // r15\n  __int64 v24; // rbp\n  char v25; // r12\n  __int64 v26; // r14\n  _BOOL4 v27; // r13d\n  int v28; // eax\n  unsigned __int64 v29; // rax\n  unsigned __int64 v30; // rbx\n  char **v31; // r15\n  char **v32; // rbp\n  __int64 v33; // rax\n  unsigned __int64 v34; // r15\n  unsigned __int64 v35; // r13\n  size_t v36; // rdx\n  FILE *v37; // rax\n  char *v38; // rax\n  __int64 v39; // rdx\n  __int64 v40; // rcx\n  __int64 v41; // r8\n  __int64 v42; // rax\n  unsigned __int64 v43; // rdx\n  unsigned __int64 v44; // rsi\n  bool v45; // cc\n  unsigned __int64 v46; // rax\n  unsigned __int64 v47; // rdx\n  char *v48; // rbx\n  char *v49; // rax\n  __int64 v50; // rdx\n  __int64 v51; // rcx\n  __int64 v52; // r8\n  unsigned __int64 v53; // [rsp+0h] [rbp-198h]\n  unsigned __int64 v54; // [rsp+0h] [rbp-198h]\n  __int64 v55; // [rsp+0h] [rbp-198h]\n  __int64 v56; // [rsp+8h] [rbp-190h]\n  unsigned __int64 v57; // [rsp+8h] [rbp-190h]\n  __int64 v58; // [rsp+8h] [rbp-190h]\n  struct stat *v59; // [rsp+10h] [rbp-188h]\n  unsigned __int64 v61; // [rsp+20h] [rbp-178h]\n  __int64 v62; // [rsp+20h] [rbp-178h]\n  FILE *v63; // [rsp+38h] [rbp-160h] BYREF\n  struct stat v64; // [rsp+40h] [rbp-158h] BYREF\n  struct stat stat_buf; // [rsp+D0h] [rbp-C8h] BYREF\n\n  v4 = (_QWORD *)a1;\n  v5 = a3;\n  v7 = (unsigned int)dword_61C420;\n  if ( (unsigned int)dword_61C420 < a3 )\n  {\n    v53 = a3;\n    do\n    {\n      v8 = 0LL;\n      v9 = 0LL;\n      if ( v7 > v53 )\n      {\n        v21 = v7;\n        v19 = (_QWORD *)a1;\n        v20 = (const void *)a1;\n        v16 = v53;\n        v18 = 0LL;\n      }\n      else\n      {\n        do\n        {\n          v10 = sub_4090C0((FILE **)&stat_buf, 0);\n          v11 = a2;\n          v12 = v10 + 13;\n          v13 = v10;\n          if ( (unsigned int)dword_61C420 <= a2 )\n            v11 = (unsigned int)dword_61C420;\n          v14 = sub_409030(a1 + 16 * v9, v11, (unsigned int)dword_61C420, (FILE *)stat_buf.st_dev, (char *)(v10 + 13));\n          v15 = a2;\n          v7 = (unsigned int)dword_61C420;\n          if ( v14 <= a2 )\n            v15 = v14;\n          v9 += v14;\n          v16 = v53 - v9;\n          a2 -= v15;\n          v17 = v8++;\n          v17 *= 16LL;\n          *(_QWORD *)(a1 + v17) = v12;\n          *(_QWORD *)(a1 + v17 + 8) = v13;\n        }\n        while ( v7 <= v53 - v9 );\n        v18 = v8 % v7;\n        v19 = (_QWORD *)(a1 + 16 * v8);\n        v20 = (const void *)(a1 + 16 * v9);\n        v21 = v7 - v8 % v7;\n      }\n      if ( v16 > v21 )\n      {\n        v62 = (__int64)v20;\n        v57 = v16 + v18 + 1 - v7;\n        v42 = sub_4090C0((FILE **)&stat_buf, 0);\n        v43 = v57;\n        v44 = a2;\n        v59 = (struct stat *)v42;\n        v45 = v57 <= a2;\n        v58 = v42 + 13;\n        if ( v45 )\n          v44 = v43;\n        v46 = sub_409030(v62, v44, v43, (FILE *)stat_buf.st_dev, (char *)(v42 + 13));\n        v47 = a2;\n        if ( v46 <= a2 )\n          v47 = v46;\n        ++v8;\n        v9 += v46;\n        *v19 = v58;\n        v19[1] = v59;\n        a2 -= v47;\n        v20 = (const void *)(a1 + 16 * v9);\n        v19 = (_QWORD *)(a1 + 16 * v8);\n      }\n      a2 += v8;\n      memmove(v19, v20, 16 * (v53 - v9));\n      v7 = (unsigned int)dword_61C420;\n      v53 += v8 - v9;\n    }\n    while ( (unsigned int)dword_61C420 < v53 );\n    v5 = v53;\n  }\n  if ( v5 <= a2 )\n  {\n    v29 = sub_408E20(a1, v5, (__int64 *)&v64);\n    goto LABEL_27;\n  }\n  v22 = a2;\n  v23 = 0LL;\n  v24 = a1 + 16 * a2;\n  v61 = a2;\n  v25 = 0;\n  v26 = v24;\n  v54 = v5;\n  while ( 1 )\n  {\n    v27 = strcmp(*(const char **)v26, \"-\") != 0;\n    if ( a4 )\n    {\n      v28 = strcmp(a4, *(const char **)v26);\n      if ( v27 && !v28 )\n      {\nLABEL_35:\n        if ( !v23 )\n        {\n          v23 = sub_4090C0(&v63, 0);\n          sub_409030(v26, 0LL, 1uLL, v63, (char *)(v23 + 13));\n        }\n        *(_QWORD *)v26 = v23 + 13;\n        *(_QWORD *)(v26 + 8) = v23;\n        goto LABEL_17;\n      }\n    }\n    if ( !v25 && __fxstat(1, 1, &v64) )\n      break;\n    if ( !v27 )\n    {\n      v25 = 1;\n      if ( __fxstat(1, 0, &stat_buf) )\n        goto LABEL_17;\n      goto LABEL_16;\n    }\n    v25 = 1;\n    if ( __xstat(1, *(const char **)v26, &stat_buf) )\n    {\n      ++v22;\n      v26 += 16LL;\n      if ( v22 == v54 )\n        break;\n    }\n    else\n    {\nLABEL_16:\n      v25 = 1;\n      if ( stat_buf.st_ino == v64.st_ino && stat_buf.st_dev == v64.st_dev )\n        goto LABEL_35;\nLABEL_17:\n      ++v22;\n      v26 += 16LL;\n      if ( v22 == v54 )\n        break;\n    }\n  }\n  v4 = (_QWORD *)a1;\n  a2 = v61;\n  v5 = v54;\n  while ( 2 )\n  {\n    v29 = sub_408E20((__int64)v4, v5, (__int64 *)&v64);\nLABEL_27:\n    v30 = v29;\n    if ( v5 != v29 )\n    {\n      if ( v29 <= 2 )\n      {\n        v48 = (char *)v4[2 * v29];\n        v49 = dcgettext(0LL, \"open failed\", 5);\n        sub_405DD0(v49, v48, v50, v51, v52);\n      }\nLABEL_29:\n      v31 = (char **)&v4[2 * v30 - 2];\n      do\n      {\n        --v30;\n        v32 = v31;\n        sub_407DF0(*(FILE **)(v64.st_dev + 8 * v30), *v31);\n        v31 -= 2;\n        v33 = sub_4090C0((FILE **)&stat_buf, v30 > 2);\n      }\n      while ( !v33 );\n      v34 = v30;\n      if ( a2 <= v30 )\n        v34 = a2;\n      v56 = v33;\n      v35 = v5 - v30;\n      v55 = v33 + 13;\n      sub_408640((__int64)v4, v34, v30, (FILE *)stat_buf.st_dev, (char *)(v33 + 13), (FILE **)v64.st_dev);\n      v36 = 16 * v35;\n      a2 = a2 - v34 + 1;\n      *v4 = v55;\n      v5 = v35 + 1;\n      v4[1] = v56;\n      memmove(v4 + 2, v32, v36);\n      continue;\n    }\n    break;\n  }\n  v37 = sub_407CD0(a4, \"w\");\n  if ( !v37 )\n  {\n    if ( *__errno_location() != 24 || v5 <= 2 )\n    {\n      v38 = dcgettext(0LL, \"open failed\", 5);\n      sub_405DD0(v38, a4, v39, v40, v41);\n    }\n    goto LABEL_29;\n  }\n  sub_408640((__int64)v4, a2, v5, v37, a4, (FILE **)v64.st_dev);\n}\n"
        },
        {
            "funcName": "sub_409830",
            "funcStartAddr": "0x409830",
            "funcEndAddr": "0x409871",
            "decompiledFuncCode": "int __fastcall sub_409830(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n\n  v2 = a2[1];\n  v3 = a2[3];\n  if ( *a2 != a2[2] )\n  {\n    if ( v2 == v3 && a2[6] )\n      return v3;\nLABEL_3:\n    LODWORD(v3) = sub_406320(a1, (__int64)a2);\n    return v3;\n  }\n  if ( v2 != v3 && !a2[5] )\n    goto LABEL_3;\n  return v3;\n}\n"
        },
        {
            "funcName": "sub_409880",
            "funcStartAddr": "0x409880",
            "funcEndAddr": "0x409fdc",
            "decompiledFuncCode": "int __fastcall sub_409880(\n        __m128i *a1,\n        unsigned __int64 a2,\n        unsigned __int64 a3,\n        __m128i **a4,\n        pthread_cond_t *a5,\n        FILE *a6,\n        char *a7)\n{\n  unsigned __int64 v10; // r8\n  unsigned __int64 v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // r12\n  __m128i *v14; // r10\n  pthread_mutex_t *v15; // r9\n  __int64 v16; // rax\n  __int64 v17; // rbx\n  unsigned int v18; // eax\n  __int64 v19; // r12\n  __int64 v20; // rbp\n  __int64 v21; // r15\n  const __m128i *v22; // rsi\n  __int64 v23; // rdi\n  __m128i *v24; // r8\n  __int64 v25; // rax\n  __m128i v26; // xmm2\n  const __m128i *v27; // r11\n  int v28; // eax\n  __m128i v29; // xmm0\n  __int64 v30; // r9\n  __int64 v31; // r10\n  __int64 v32; // rdx\n  __int64 v33; // rax\n  __int64 v34; // rsi\n  const __m128i *v35; // rdi\n  __m128i v36; // xmm4\n  const __m128i *v37; // rax\n  bool v38; // zf\n  __int64 v39; // rsi\n  __int64 v40; // rsi\n  __int64 v41; // rdi\n  __m128i *v42; // rdi\n  __int64 v43; // r15\n  const __m128i *v44; // r11\n  __int64 v45; // rdi\n  const __m128i *v46; // rdx\n  __m128i v47; // xmm6\n  const __m128i *v48; // rcx\n  __int64 i; // r15\n  __m128i *v50; // rdi\n  int v52; // [rsp-10h] [rbp-C8h]\n  __m128i *mutexa; // [rsp+8h] [rbp-B0h]\n  pthread_mutex_t *mutexb; // [rsp+8h] [rbp-B0h]\n  pthread_mutex_t *mutex; // [rsp+8h] [rbp-B0h]\n  pthread_mutex_t *v57; // [rsp+18h] [rbp-A0h]\n  pthread_mutex_t *v58; // [rsp+18h] [rbp-A0h]\n  pthread_mutex_t *v59; // [rsp+18h] [rbp-A0h]\n  __m128i *v60; // [rsp+20h] [rbp-98h]\n  pthread_cond_t *cond; // [rsp+28h] [rbp-90h]\n  pthread_t newthread; // [rsp+38h] [rbp-80h] BYREF\n  __int64 arg[15]; // [rsp+40h] [rbp-78h] BYREF\n\n  v10 = (unsigned __int64)a4[5];\n  v11 = (unsigned __int64)a4[6];\n  arg[2] = a3;\n  v12 = (__int64)a4[8];\n  arg[0] = (__int64)a1;\n  arg[3] = v12;\n  arg[1] = a2 >> 1;\n  arg[4] = (__int64)a5;\n  arg[5] = (__int64)a6;\n  arg[6] = (__int64)a7;\n  if ( v10 + v11 > 0x1FFFF && a2 > 1 )\n  {\n    if ( !pthread_create(&newthread, 0LL, start_routine, arg) )\n    {\n      sub_409880(\n        (_DWORD)a1 - 32 * *((_DWORD *)a4 + 10),\n        a2 - (a2 >> 1),\n        a3,\n        (unsigned int)a4[9],\n        (_DWORD)a5,\n        (_DWORD)a6,\n        (__int64)a7);\n      pthread_join(newthread, 0LL);\n      return v52;\n    }\n    v10 = (unsigned __int64)a4[5];\n    v11 = (unsigned __int64)a4[6];\n  }\n  v13 = -32LL * v10;\n  v14 = &a1[-2 * a3];\n  v15 = (pthread_mutex_t *)&a1[-2 * v10];\n  if ( v11 > 1 )\n  {\n    cond = (pthread_cond_t *)v10;\n    v57 = (pthread_mutex_t *)v11;\n    mutexa = &a1[-2 * v10];\n    sub_408370(mutexa, v11, &v14[-2 * (v10 >> 1)], 0);\n    v10 = (unsigned __int64)cond;\n    v14 = &a1[-2 * a3];\n    v11 = (unsigned __int64)v57;\n    v15 = (pthread_mutex_t *)mutexa;\n  }\n  if ( v10 > 1 )\n  {\n    v58 = v15;\n    mutexb = (pthread_mutex_t *)v11;\n    sub_408370(a1, v10, v14, 0);\n    v15 = v58;\n    v11 = (unsigned __int64)mutexb;\n  }\n  *a4 = a1;\n  a4[1] = (__m128i *)v15;\n  a4[2] = (__m128i *)v15;\n  a4[3] = (__m128i *)((char *)a1 + v13 - 32 * v11);\n  sub_406320((__int64)a5, (__int64)a4);\n  mutex = (pthread_mutex_t *)(&a5->__align + 1);\n  while ( 1 )\n  {\n    pthread_mutex_lock(mutex);\n    while ( 1 )\n    {\n      v16 = sub_40D190(a5->__align);\n      if ( v16 )\n        break;\n      pthread_cond_wait(a5 + 1, mutex);\n    }\n    v17 = v16;\n    pthread_mutex_unlock(mutex);\n    v59 = (pthread_mutex_t *)(v17 + 88);\n    pthread_mutex_lock((pthread_mutex_t *)(v17 + 88));\n    v18 = *(_DWORD *)(v17 + 80);\n    *(_BYTE *)(v17 + 84) = 0;\n    if ( !v18 )\n      break;\n    v19 = *(_QWORD *)v17;\n    v20 = *(_QWORD *)(v17 + 8);\n    v21 = (a3 >> (2 * (unsigned __int8)v18 + 2)) + 1;\n    if ( v18 > 1 )\n    {\n      v22 = *(const __m128i **)(v17 + 8);\n      v23 = *(_QWORD *)v17;\n      v24 = **(__m128i ***)(v17 + 32);\n      while ( 1 )\n      {\n        v27 = *(const __m128i **)(v17 + 16);\n        if ( v27 == (const __m128i *)v23 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          v31 = *(_QWORD *)(v17 + 40);\n          v33 = (v19 - v23) >> 5;\n          if ( (v20 - (__int64)v22) >> 5 == v30 )\n          {\n            v32 = *(_QWORD *)(v17 + 48);\n            goto LABEL_27;\n          }\n          goto LABEL_35;\n        }\n        if ( *(const __m128i **)(v17 + 24) == v22 )\n          break;\n        if ( !v21 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          v31 = *(_QWORD *)(v17 + 40);\n          v21 = -1LL;\n          v32 = (v20 - (__int64)v22) >> 5;\n          v33 = (v19 - v23) >> 5;\n          if ( v30 == v32 )\n          {\n            v34 = -2LL;\nLABEL_23:\n            v35 = (const __m128i *)(v23 - 32);\n            do\n            {\n              v36 = _mm_loadu_si128(v35);\n              v24 -= 2;\n              *(_QWORD *)v17 = v35;\n              v37 = v35;\n              *v24 = v36;\n              v24[1] = _mm_loadu_si128(v35 + 1);\n              if ( v27 == v35 )\n              {\n                v30 = v32;\n                v33 = (v19 - (__int64)v27) >> 5;\n                goto LABEL_27;\n              }\n              --v34;\n              v35 -= 2;\n            }\n            while ( v34 != -1 );\n            v30 = v32;\n            v33 = (v19 - (__int64)v37) >> 5;\n            goto LABEL_27;\n          }\n          goto LABEL_35;\n        }\n        v60 = v24;\n        v28 = sub_4082A0((const void **)(v23 - 32), (unsigned __int8 **)&v22[-2]);\n        v24 = v60 - 2;\n        if ( v28 > 0 )\n        {\n          v25 = *(_QWORD *)(v17 + 8);\n          v23 = *(_QWORD *)v17;\n          v26 = _mm_loadu_si128((const __m128i *)(v25 - 32));\n          v22 = (const __m128i *)(v25 - 32);\n          *(_QWORD *)(v17 + 8) = v25 - 32;\n          *v24 = v26;\n        }\n        else\n        {\n          v25 = *(_QWORD *)v17;\n          v22 = *(const __m128i **)(v17 + 8);\n          v29 = _mm_loadu_si128((const __m128i *)(*(_QWORD *)v17 - 32LL));\n          v23 = *(_QWORD *)v17 - 32LL;\n          *(_QWORD *)v17 = v23;\n          *v24 = v29;\n        }\n        v24[1] = _mm_loadu_si128((const __m128i *)(v25 - 16));\n        --v21;\n      }\n      v30 = *(_QWORD *)(v17 + 48);\n      v31 = *(_QWORD *)(v17 + 40);\n      v32 = (v20 - (__int64)v22) >> 5;\n      v33 = (v19 - v23) >> 5;\n      if ( v30 == v32 )\n      {\n        v34 = v21 - 1;\n        if ( !v21 )\n          goto LABEL_27;\n        goto LABEL_23;\n      }\nLABEL_35:\n      if ( v33 == v31 && (v44 = *(const __m128i **)(v17 + 24), v44 != v22) && (v45 = v21 - 1, v46 = v22 - 2, v21) )\n      {\n        do\n        {\n          v47 = _mm_loadu_si128(v46);\n          v24 -= 2;\n          *(_QWORD *)(v17 + 8) = v46;\n          v48 = v46;\n          *v24 = v47;\n          v24[1] = _mm_loadu_si128(v46 + 1);\n          if ( v46 == v44 )\n          {\n            v32 = (v20 - (__int64)v46) >> 5;\n            goto LABEL_27;\n          }\n          --v45;\n          v46 -= 2;\n        }\n        while ( v45 != -1 );\n        v32 = (v20 - (__int64)v48) >> 5;\n      }\n      else\n      {\n        v32 = (v20 - (__int64)v22) >> 5;\n      }\nLABEL_27:\n      **(_QWORD **)(v17 + 32) = v24;\n      goto LABEL_28;\n    }\n    v40 = *(_QWORD *)(v17 + 8);\n    v41 = *(_QWORD *)v17;\n    while ( 1 )\n    {\n      if ( *(_QWORD *)(v17 + 16) == v41 )\n      {\n        v32 = *(_QWORD *)(v17 + 48);\n        v31 = *(_QWORD *)(v17 + 40);\n        v33 = (v19 - v41) >> 5;\n        if ( (v20 - v40) >> 5 == v32 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          goto LABEL_28;\n        }\n        if ( v33 == v31 )\n          goto LABEL_56;\n        goto LABEL_53;\n      }\n      if ( *(_QWORD *)(v17 + 24) == v40 )\n        break;\n      if ( !v21 )\n      {\n        v21 = -1LL;\n        v33 = (v19 - v41) >> 5;\n        if ( *(_QWORD *)(v17 + 48) == (v20 - v40) >> 5 )\n        {\n          for ( i = -2LL; i != -1; --i )\n          {\nLABEL_71:\n            v50 = (__m128i *)(v41 - 32);\n            *(_QWORD *)v17 = v50;\n            sub_4085D0(v50, a6, a7);\n            v41 = *(_QWORD *)v17;\n            if ( *(_QWORD *)v17 == *(_QWORD *)(v17 + 16) )\n              break;\n          }\n          v31 = *(_QWORD *)(v17 + 40);\n          v30 = *(_QWORD *)(v17 + 48);\n          v33 = (v19 - v41) >> 5;\n          v32 = (v20 - *(_QWORD *)(v17 + 8)) >> 5;\n          goto LABEL_28;\n        }\nLABEL_55:\n        v31 = *(_QWORD *)(v17 + 40);\n        if ( v33 == v31 )\n        {\nLABEL_56:\n          if ( *(_QWORD *)(v17 + 24) != v40 && v21 )\n          {\n            v43 = v21 - 1;\n            do\n            {\n              *(_QWORD *)(v17 + 8) = v40 - 32;\n              sub_4085D0((__m128i *)(v40 - 32), a6, a7);\n              v40 = *(_QWORD *)(v17 + 8);\n              if ( v40 == *(_QWORD *)(v17 + 24) )\n                break;\n              --v43;\n            }\n            while ( v43 != -1 );\n            v31 = *(_QWORD *)(v17 + 40);\n            v30 = *(_QWORD *)(v17 + 48);\n            v33 = (v19 - *(_QWORD *)v17) >> 5;\n            v32 = (v20 - v40) >> 5;\n            goto LABEL_28;\n          }\n        }\nLABEL_53:\n        v30 = *(_QWORD *)(v17 + 48);\n        v32 = (v20 - v40) >> 5;\n        goto LABEL_28;\n      }\n      if ( sub_4082A0((const void **)(v41 - 32), (unsigned __int8 **)(v40 - 32)) > 0 )\n      {\n        v42 = (__m128i *)(*(_QWORD *)(v17 + 8) - 32LL);\n        *(_QWORD *)(v17 + 8) = v42;\n      }\n      else\n      {\n        v42 = (__m128i *)(*(_QWORD *)v17 - 32LL);\n        *(_QWORD *)v17 = v42;\n      }\n      sub_4085D0(v42, a6, a7);\n      v41 = *(_QWORD *)v17;\n      v40 = *(_QWORD *)(v17 + 8);\n      --v21;\n    }\n    v32 = *(_QWORD *)(v17 + 48);\n    v33 = (v19 - v41) >> 5;\n    if ( (v20 - v40) >> 5 != v32 )\n      goto LABEL_55;\n    if ( v21 )\n    {\n      i = v21 - 1;\n      goto LABEL_71;\n    }\n    v31 = *(_QWORD *)(v17 + 40);\n    v30 = *(_QWORD *)(v17 + 48);\nLABEL_28:\n    v38 = *(_BYTE *)(v17 + 84) == 0;\n    *(_QWORD *)(v17 + 40) = v31 - v33;\n    *(_QWORD *)(v17 + 48) = v30 - v32;\n    if ( v38 )\n      sub_409830((__int64)a5, (_QWORD *)v17);\n    if ( *(_DWORD *)(v17 + 80) > 1u )\n    {\n      pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(v17 + 56) + 88LL));\n      v39 = *(_QWORD *)(v17 + 56);\n      if ( !*(_BYTE *)(v39 + 84) )\n      {\n        sub_409830((__int64)a5, (_QWORD *)v39);\n        v39 = *(_QWORD *)(v17 + 56);\n      }\n      pthread_mutex_unlock((pthread_mutex_t *)(v39 + 88));\n    }\n    else if ( !(*(_QWORD *)(v17 + 40) + *(_QWORD *)(v17 + 48)) )\n    {\n      sub_406320((__int64)a5, *(_QWORD *)(v17 + 56));\n    }\n    pthread_mutex_unlock(v59);\n  }\n  pthread_mutex_unlock(v59);\n  return sub_406320((__int64)a5, v17);\n}\n"
        },
        {
            "funcName": "pthread_409fe0",
            "funcStartAddr": "0x409fe0",
            "funcEndAddr": "0x40a00a",
            "decompiledFuncCode": "void *__fastcall start_routine(void *a1)\n{\n  sub_409880(\n    *(__m128i **)a1,\n    *((_QWORD *)a1 + 1),\n    *((_QWORD *)a1 + 2),\n    *((__m128i ***)a1 + 3),\n    *((pthread_cond_t **)a1 + 4),\n    *((FILE **)a1 + 5),\n    *((char **)a1 + 6));\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40A010",
            "funcStartAddr": "0x40a010",
            "funcEndAddr": "0x40a0c4",
            "decompiledFuncCode": "__int64 __fastcall sub_40A010(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  unsigned __int64 v3; // rcx\n  __int64 result; // rax\n  __int64 v5; // rdx\n\n  v2 = qword_61C768;\n  v3 = qword_61C760;\n  result = qword_61C770;\n  if ( qword_61C768 == qword_61C760 )\n  {\n    if ( qword_61C770 )\n    {\n      v5 = 0xAAAAAAAAAAAAAA9LL;\n      if ( (unsigned __int64)qword_61C760 <= 0xAAAAAAAAAAAAAA9LL )\n      {\n        v3 = qword_61C760 + ((unsigned __int64)qword_61C760 >> 1) + 1;\n        a2 = 8 * v3;\nLABEL_6:\n        qword_61C760 = v3;\n        result = sub_411270(qword_61C770, a2);\n        v2 = qword_61C768;\n        qword_61C770 = result;\n        goto LABEL_2;\n      }\n    }\n    else\n    {\n      if ( !qword_61C760 )\n      {\n        a2 = 128LL;\n        v3 = 16LL;\n        goto LABEL_6;\n      }\n      v5 = (unsigned __int64)qword_61C760 >> 61 != 0;\n      a2 = 8 * qword_61C760;\n      if ( (qword_61C760 & 0x1000000000000000LL) == 0 && !((unsigned __int64)qword_61C760 >> 61) )\n        goto LABEL_6;\n    }\n    sub_411460(a1, a2, v5);\n  }\nLABEL_2:\n  *(_QWORD *)(result + 8 * v2) = a1;\n  qword_61C768 = v2 + 1;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40A0D0",
            "funcStartAddr": "0x40a0d0",
            "funcEndAddr": "0x40a63d",
            "decompiledFuncCode": "void __fastcall __noreturn sub_40A0D0(int status)\n{\n  __int64 v2; // rbp\n  char *v3; // rax\n  char *v4; // rax\n  FILE *v5; // rbp\n  char *v6; // rax\n  FILE *v7; // rbp\n  char *v8; // rax\n  FILE *v9; // rbp\n  char *v10; // rax\n  FILE *v11; // rbp\n  char *v12; // rax\n  FILE *v13; // rbp\n  char *v14; // rax\n  FILE *v15; // rbp\n  char *v16; // rax\n  FILE *v17; // rbp\n  char *v18; // rax\n  FILE *v19; // rbp\n  char *v20; // rax\n  FILE *v21; // rbp\n  char *v22; // rax\n  FILE *v23; // rbp\n  char *v24; // rax\n  FILE *v25; // rbp\n  char *v26; // rax\n  FILE *v27; // rbp\n  char *v28; // rax\n  FILE *v29; // rbp\n  char *v30; // rax\n  FILE *v31; // rbp\n  char *v32; // rax\n  FILE *v33; // rbp\n  char *v34; // rax\n  char *v35; // rax\n  FILE *v36; // rbp\n  char *v37; // rax\n  FILE *v38; // rbp\n  char *v39; // rax\n  FILE *v40; // rbp\n  char *v41; // rax\n  FILE *v42; // rbp\n  char *v43; // rax\n  FILE *v44; // rbp\n  char *v45; // rax\n  __int64 *v46; // rax\n  char *v47; // rax\n  char *v48; // rax\n  char *v49; // rax\n  char *v50; // rax\n  char *v51; // rax\n  char *v52; // rax\n  char *v53; // rax\n  __int64 v54[17]; // [rsp+0h] [rbp-88h] BYREF\n\n  v2 = qword_61CBC8;\n  if ( status )\n  {\n    v3 = dcgettext(0LL, \"Try '%s --help' for more information.\\n\", 5);\n    __fprintf_chk(stderr, 1LL, v3, v2);\n    goto LABEL_3;\n  }\n  v4 = dcgettext(0LL, \"Usage: %s [OPTION]... [FILE]...\\n  or:  %s [OPTION]... --files0-from=F\\n\", 5);\n  __printf_chk(1LL, v4);\n  v5 = stdout;\n  v6 = dcgettext(0LL, \"Write sorted concatenation of all FILE(s) to standard output.\\n\", 5);\n  fputs_unlocked(v6, v5);\n  v7 = stdout;\n  v8 = dcgettext(0LL, \"\\nWith no FILE, or when FILE is -, read standard input.\\n\", 5);\n  fputs_unlocked(v8, v7);\n  v9 = stdout;\n  v10 = dcgettext(0LL, \"\\nMandatory arguments to long options are mandatory for short options too.\\n\", 5);\n  fputs_unlocked(v10, v9);\n  v11 = stdout;\n  v12 = dcgettext(0LL, \"Ordering options:\\n\\n\", 5);\n  fputs_unlocked(v12, v11);\n  v13 = stdout;\n  v14 = dcgettext(\n          0LL,\n          \"  -b, --ignore-leading-blanks  ignore leading blanks\\n\"\n          \"  -d, --dictionary-order      consider only blanks and alphanumeric characters\\n\"\n          \"  -f, --ignore-case           fold lower case to upper case characters\\n\",\n          5);\n  fputs_unlocked(v14, v13);\n  v15 = stdout;\n  v16 = dcgettext(\n          0LL,\n          \"  -g, --general-numeric-sort  compare according to general numerical value\\n\"\n          \"  -i, --ignore-nonprinting    consider only printable characters\\n\"\n          \"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\\n\",\n          5);\n  fputs_unlocked(v16, v15);\n  v17 = stdout;\n  v18 = dcgettext(0LL, \"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\\n\", 5);\n  fputs_unlocked(v18, v17);\n  v19 = stdout;\n  v20 = dcgettext(\n          0LL,\n          \"  -n, --numeric-sort          compare according to string numerical value\\n\"\n          \"  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\\n\"\n          \"      --random-source=FILE    get random bytes from FILE\\n\"\n          \"  -r, --reverse               reverse the result of comparisons\\n\",\n          5);\n  fputs_unlocked(v20, v19);\n  v21 = stdout;\n  v22 = dcgettext(\n          0LL,\n          \"      --sort=WORD             sort according to WORD:\\n\"\n          \"                                general-numeric -g, human-numeric -h, month -M,\\n\"\n          \"                                numeric -n, random -R, version -V\\n\"\n          \"  -V, --version-sort          natural sort of (version) numbers within text\\n\"\n          \"\\n\",\n          5);\n  fputs_unlocked(v22, v21);\n  v23 = stdout;\n  v24 = dcgettext(0LL, \"Other options:\\n\\n\", 5);\n  fputs_unlocked(v24, v23);\n  v25 = stdout;\n  v26 = dcgettext(\n          0LL,\n          \"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\\n\"\n          \"                            for more use temp files\\n\",\n          5);\n  fputs_unlocked(v26, v25);\n  v27 = stdout;\n  v28 = dcgettext(\n          0LL,\n          \"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\\n\"\n          \"  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\\n\"\n          \"      --compress-program=PROG  compress temporaries with PROG;\\n\"\n          \"                              decompress them with PROG -d\\n\",\n          5);\n  fputs_unlocked(v28, v27);\n  v29 = stdout;\n  v30 = dcgettext(\n          0LL,\n          \"      --debug               annotate the part of the line used to sort,\\n\"\n          \"                              and warn about questionable usage to stderr\\n\"\n          \"      --files0-from=F       read input from the files specified by\\n\"\n          \"                            NUL-terminated names in file F;\\n\"\n          \"                            If F is - then read names from standard input\\n\",\n          5);\n  fputs_unlocked(v30, v29);\n  v31 = stdout;\n  v32 = dcgettext(\n          0LL,\n          \"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\\n\"\n          \"  -m, --merge               merge already sorted files; do not sort\\n\",\n          5);\n  fputs_unlocked(v32, v31);\n  v33 = stdout;\n  v34 = dcgettext(\n          0LL,\n          \"  -o, --output=FILE         write result to FILE instead of standard output\\n\"\n          \"  -s, --stable              stabilize sort by disabling last-resort comparison\\n\"\n          \"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\\n\",\n          5);\n  fputs_unlocked(v34, v33);\n  v35 = dcgettext(\n          0LL,\n          \"  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\\n\"\n          \"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\\n\"\n          \"                              multiple options specify multiple directories\\n\"\n          \"      --parallel=N          change the number of sorts run concurrently to N\\n\"\n          \"  -u, --unique              with -c, check for strict ordering;\\n\"\n          \"                              without -c, output only the first of an equal run\\n\",\n          5);\n  __printf_chk(1LL, v35);\n  v36 = stdout;\n  v37 = dcgettext(0LL, \"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\", 5);\n  fputs_unlocked(v37, v36);\n  v38 = stdout;\n  v39 = dcgettext(0LL, \"      --help     display this help and exit\\n\", 5);\n  fputs_unlocked(v39, v38);\n  v40 = stdout;\n  v41 = dcgettext(0LL, \"      --version  output version information and exit\\n\", 5);\n  fputs_unlocked(v41, v40);\n  v42 = stdout;\n  v43 = dcgettext(\n          0LL,\n          \"\\n\"\n          \"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\\n\"\n          \"field number and C a character position in the field; both are origin 1, and\\n\"\n          \"the stop position defaults to the line's end.  If neither -t nor -b is in\\n\"\n          \"effect, characters in a field are counted from the beginning of the preceding\\n\"\n          \"whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\\n\"\n          \"which override global ordering options for that key.  If no key is given, use\\n\"\n          \"the entire line as the key.  Use --debug to diagnose incorrect key usage.\\n\"\n          \"\\n\"\n          \"SIZE may be followed by the following multiplicative suffixes:\\n\",\n          5);\n  fputs_unlocked(v43, v42);\n  v44 = stdout;\n  v45 = dcgettext(\n          0LL,\n          \"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\\n\"\n          \"\\n\"\n          \"*** WARNING ***\\n\"\n          \"The locale specified by the environment affects sort order.\\n\"\n          \"Set LC_ALL=C to get the traditional sort order that uses\\n\"\n          \"native byte values.\\n\",\n          5);\n  fputs_unlocked(v45, v44);\n  v54[0] = (__int64)\"[\";\n  v46 = v54;\n  v54[1] = (__int64)\"test invocation\";\n  v54[2] = (__int64)\"coreutils\";\n  v54[3] = (__int64)\"Multi-call invocation\";\n  v54[4] = (__int64)\"sha224sum\";\n  v54[5] = (__int64)\"sha2 utilities\";\n  v54[6] = (__int64)\"sha256sum\";\n  v54[7] = (__int64)\"sha2 utilities\";\n  v54[8] = (__int64)\"sha384sum\";\n  v54[9] = (__int64)\"sha2 utilities\";\n  v54[10] = (__int64)\"sha512sum\";\n  v54[11] = (__int64)\"sha2 utilities\";\n  v54[12] = 0LL;\n  v54[13] = 0LL;\n  do\n    v46 += 2;\n  while ( *v46 && memcmp(\"sort\", (const void *)*v46, 5uLL) );\n  if ( v46[1] )\n  {\n    v47 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v47);\n    v48 = setlocale(5, 0LL);\n    if ( !v48 || !strncmp(v48, \"en_\", 3uLL) )\n      goto LABEL_10;\n  }\n  else\n  {\n    v51 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v51);\n    v52 = setlocale(5, 0LL);\n    if ( !v52 || !strncmp(v52, \"en_\", 3uLL) )\n      goto LABEL_10;\n  }\n  v53 = dcgettext(0LL, \"Report %s translation bugs to <https://translationproject.org/team/>\\n\", 5);\n  __printf_chk(1LL, v53);\nLABEL_10:\n  v49 = dcgettext(0LL, \"Full documentation at: <%s%s>\\n\", 5);\n  __printf_chk(1LL, v49);\n  v50 = dcgettext(0LL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5);\n  __printf_chk(1LL, v50);\nLABEL_3:\n  exit(status);\n}\n"
        },
        {
            "funcName": "sub_40A640",
            "funcStartAddr": "0x40a640",
            "funcEndAddr": "0x40a64a",
            "decompiledFuncCode": "void __noreturn sub_40A640()\n{\n  sub_40A0D0(1);\n}\n"
        },
        {
            "funcName": "sub_40A650",
            "funcStartAddr": "0x40a650",
            "funcEndAddr": "0x40a766",
            "decompiledFuncCode": "__int64 __fastcall sub_40A650(const char *a1, const char **a2, char *a3, size_t a4)\n{\n  char *v5; // rbp\n  size_t v6; // rax\n  const char *v7; // r14\n  size_t v8; // r12\n  __int64 v9; // rbx\n  bool v10; // zf\n  char v11; // al\n  __int64 v12; // rax\n  __int64 v14; // [rsp+0h] [rbp-58h]\n  char v15; // [rsp+17h] [rbp-41h]\n\n  v5 = a3;\n  v6 = strlen(a1);\n  v7 = *a2;\n  v14 = -1LL;\n  if ( !*a2 )\n    return v14;\n  v8 = v6;\n  v15 = 0;\n  v9 = 0LL;\n  do\n  {\n    while ( strncmp(v7, a1, v8) )\n    {\nLABEL_7:\n      ++v9;\n      v5 += a4;\n      v7 = a2[v9];\n      if ( !v7 )\n        goto LABEL_12;\n    }\n    if ( strlen(v7) == v8 )\n      return v9;\n    if ( v14 != -1 )\n    {\n      if ( a3 )\n      {\n        v10 = memcmp(&a3[a4 * v14], v5, a4) == 0;\n        v11 = v15;\n        if ( !v10 )\n          v11 = 1;\n        v15 = v11;\n      }\n      else\n      {\n        v15 = 1;\n      }\n      goto LABEL_7;\n    }\n    v14 = v9++;\n    v5 += a4;\n    v7 = a2[v9];\n  }\n  while ( v7 );\nLABEL_12:\n  v12 = -2LL;\n  if ( !v15 )\n    return v14;\n  return v12;\n}\n"
        },
        {
            "funcName": "sub_40A770",
            "funcStartAddr": "0x40a770",
            "funcEndAddr": "0x40a7e1",
            "decompiledFuncCode": "void __fastcall sub_40A770(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rbx\n  __int64 v4; // rbp\n  __int64 v5; // rax\n\n  if ( a3 == -1 )\n    v3 = dcgettext(0LL, \"invalid argument %s for %s\", 5);\n  else\n    v3 = dcgettext(0LL, \"ambiguous argument %s for %s\", 5);\n  v4 = sub_40F860(1LL, a1);\n  v5 = sub_40F550(0LL, 8LL, a2);\n  error(0, 0, v3, v5, v4);\n}\n"
        },
        {
            "funcName": "sub_40A7F0",
            "funcStartAddr": "0x40a7f0",
            "funcEndAddr": "0x40a908",
            "decompiledFuncCode": "int __fastcall sub_40A7F0(__int64 *a1, char *a2, size_t a3)\n{\n  const void *v3; // r14\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rsi\n  __int64 v9; // rbx\n  __int64 i; // r12\n  const char *v11; // rax\n  const char *v12; // rax\n  char *IO_write_ptr; // rax\n\n  v3 = 0LL;\n  v6 = stderr;\n  v7 = dcgettext(0LL, \"Valid arguments are:\", 5);\n  v8 = v6;\n  v9 = 0LL;\n  fputs_unlocked(v7, v8);\n  for ( i = *a1; i; i = a1[v9] )\n  {\n    while ( !v9 || memcmp(v3, a2, a3) )\n    {\n      ++v9;\n      v3 = a2;\n      a2 += a3;\n      v11 = (const char *)sub_40F880(i);\n      __fprintf_chk(stderr, 1LL, \"\\n  - %s\", v11);\n      i = a1[v9];\n      if ( !i )\n        goto LABEL_7;\n    }\n    ++v9;\n    a2 += a3;\n    v12 = (const char *)sub_40F880(i);\n    __fprintf_chk(stderr, 1LL, \", %s\", v12);\n  }\nLABEL_7:\n  IO_write_ptr = stderr->_IO_write_ptr;\n  if ( IO_write_ptr >= stderr->_IO_write_end )\n  {\n    LODWORD(IO_write_ptr) = __overflow(stderr, 10);\n  }\n  else\n  {\n    stderr->_IO_write_ptr = IO_write_ptr + 1;\n    *IO_write_ptr = 10;\n  }\n  return (int)IO_write_ptr;\n}\n"
        },
        {
            "funcName": "sub_40A910",
            "funcStartAddr": "0x40a910",
            "funcEndAddr": "0x40a980",
            "decompiledFuncCode": "__int64 __fastcall sub_40A910(__int64 a1, const char *a2, const char **a3, char *a4, size_t a5, void (*a6)(void))\n{\n  __int64 result; // rax\n\n  result = sub_40A650(a2, a3, a4, a5);\n  if ( result < 0 )\n  {\n    sub_40A770(a1, (__int64)a2, result);\n    sub_40A7F0((__int64 *)a3, a4, a5);\n    a6();\n    return -1LL;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40A980",
            "funcStartAddr": "0x40a980",
            "funcEndAddr": "0x40a9cd",
            "decompiledFuncCode": "__int64 __fastcall sub_40A980(void *s1, __int64 *a2, char *a3, size_t a4)\n{\n  __int64 v4; // r14\n  __int64 *v6; // rbx\n\n  v4 = *a2;\n  if ( *a2 )\n  {\n    v6 = a2 + 1;\n    do\n    {\n      if ( !memcmp(s1, a3, a4) )\n        break;\n      v4 = *v6;\n      a3 += a4;\n      ++v6;\n    }\n    while ( v4 );\n  }\n  return v4;\n}\n"
        },
        {
            "funcName": "sub_40A9F0",
            "funcStartAddr": "0x40a9f0",
            "funcEndAddr": "0x40aa8e",
            "decompiledFuncCode": "__int64 sub_40A9F0()\n{\n  int *v0; // rax\n  int *v1; // rbx\n  __int64 result; // rax\n  char *v3; // rax\n  const char *v4; // rbp\n  const char *v5; // rax\n\n  if ( (unsigned int)sub_413520(stdout) )\n  {\n    v0 = __errno_location();\n    v1 = v0;\n    if ( !byte_61CBB0 || *v0 != 32 )\n    {\n      v3 = dcgettext(0LL, \"write error\", 5);\n      v4 = v3;\n      if ( qword_61CBB8 )\n      {\n        v5 = (const char *)sub_40F6D0();\n        error(0, *v1, \"%s: %s\", v5, v4);\n      }\n      else\n      {\n        error(0, *v1, \"%s\", v3);\n      }\nLABEL_8:\n      _exit(status);\n    }\n  }\n  result = sub_413520(stderr);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40AA90",
            "funcStartAddr": "0x40aa90",
            "funcEndAddr": "0x40aabb",
            "decompiledFuncCode": "__int64 __fastcall sub_40AA90(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_QWORD *)(a1 + 16) = 0LL;\n  *(_QWORD *)a1 = 0xEFCDAB8967452301LL;\n  result = 0x1032547698BADCFELL;\n  *(_QWORD *)(a1 + 8) = 0x1032547698BADCFELL;\n  *(_DWORD *)(a1 + 24) = 0;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40AAC0",
            "funcStartAddr": "0x40aac0",
            "funcEndAddr": "0x40aada",
            "decompiledFuncCode": "_DWORD *__fastcall sub_40AAC0(_DWORD *a1, _DWORD *a2)\n{\n  _DWORD *result; // rax\n\n  result = a2;\n  *a2 = *a1;\n  a2[1] = a1[1];\n  a2[2] = a1[2];\n  a2[3] = a1[3];\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40AAE0",
            "funcStartAddr": "0x40aae0",
            "funcEndAddr": "0x40b24f",
            "decompiledFuncCode": "_DWORD *__fastcall sub_40AAE0(char *a1, __int64 a2, _DWORD *a3)\n{\n  int v5; // r11d\n  char *v6; // rcx\n  int v7; // r10d\n  int v8; // edx\n  _BOOL4 v9; // eax\n  int v10; // esi\n  int v11; // r15d\n  int v12; // r14d\n  int v13; // r13d\n  int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r9d\n  int v18; // esi\n  int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int v22; // ebp\n  int v23; // esi\n  int v24; // r12d\n  int v25; // eax\n  int v26; // edx\n  int v27; // r8d\n  int v28; // ecx\n  int v29; // esi\n  int v30; // eax\n  int v31; // edx\n  int v32; // ecx\n  int v33; // esi\n  int v34; // eax\n  int v35; // edx\n  int v36; // ecx\n  int v37; // esi\n  int v38; // eax\n  int v39; // edx\n  int v40; // ecx\n  int v41; // esi\n  int v42; // eax\n  int v43; // edx\n  int v44; // ecx\n  int v45; // edi\n  int v46; // eax\n  int v47; // edx\n  int v48; // esi\n  int v49; // edi\n  int v50; // ecx\n  int v51; // edx\n  int v52; // esi\n  int v53; // eax\n  int v54; // ecx\n  int v55; // edi\n  int v56; // edx\n  int v57; // esi\n  int v58; // ecx\n  int v59; // eax\n  int v60; // edi\n  int v61; // esi\n  int v62; // edx\n  int v63; // ecx\n  int v64; // edi\n  int v65; // eax\n  int v66; // edx\n  int v67; // ecx\n  int v68; // esi\n  int v69; // eax\n  int v70; // edx\n  int v71; // ecx\n  int v72; // esi\n  int v73; // eax\n  int v74; // edx\n  int v75; // ecx\n  int v76; // esi\n  int v77; // edi\n  int v78; // eax\n  int v79; // edx\n  int v80; // ecx\n  _DWORD *result; // rax\n  int v82; // [rsp+0h] [rbp-74h]\n  int v83; // [rsp+4h] [rbp-70h]\n  int v84; // [rsp+8h] [rbp-6Ch]\n  int v85; // [rsp+Ch] [rbp-68h]\n  int v86; // [rsp+10h] [rbp-64h]\n  int v87; // [rsp+14h] [rbp-60h]\n  int v88; // [rsp+18h] [rbp-5Ch]\n  int v89; // [rsp+1Ch] [rbp-58h]\n  int v90; // [rsp+20h] [rbp-54h]\n  int v91; // [rsp+24h] [rbp-50h]\n  int v92; // [rsp+28h] [rbp-4Ch]\n  int v93; // [rsp+2Ch] [rbp-48h]\n  unsigned __int64 v94; // [rsp+34h] [rbp-40h]\n\n  v5 = a3[1];\n  v6 = &a1[a2 & 0xFFFFFFFFFFFFFFFCLL];\n  v7 = a3[2];\n  v93 = *a3;\n  v91 = a3[3];\n  v8 = a3[4] + a2;\n  v9 = __CFADD__(a3[4], (_DWORD)a2);\n  v10 = a3[5] + HIDWORD(a2);\n  v94 = (unsigned __int64)v6;\n  a3[4] = v8;\n  a3[5] = v9 + v10;\n  if ( a1 < v6 )\n  {\n    v11 = v7;\n    do\n    {\n      v12 = *(_DWORD *)a1;\n      v82 = *((_DWORD *)a1 + 1);\n      v13 = *((_DWORD *)a1 + 7);\n      v86 = *((_DWORD *)a1 + 5);\n      v84 = *((_DWORD *)a1 + 3);\n      v88 = *((_DWORD *)a1 + 9);\n      v90 = *((_DWORD *)a1 + 11);\n      v14 = v5 + __ROL4__(*(_DWORD *)a1 + v93 - 680876936 + (v91 ^ v5 & (v11 ^ v91)), 7);\n      v15 = v14 + __ROL4__(v82 + v91 - 389564586 + (v11 ^ v14 & (v11 ^ v5)), 12);\n      v83 = *((_DWORD *)a1 + 2);\n      v16 = v15 + __ROR4__(v83 + v11 + 606105819 + (v5 ^ v15 & (v5 ^ v14)), 15);\n      v85 = *((_DWORD *)a1 + 4);\n      v17 = *((_DWORD *)a1 + 15);\n      v18 = v16 + __ROR4__(v84 + v5 - 1044525330 + (v14 ^ v16 & (v15 ^ v14)), 10);\n      v92 = *((_DWORD *)a1 + 6);\n      v19 = v18 + __ROL4__(v85 + v14 - 176418897 + (v15 ^ v18 & (v16 ^ v15)), 7);\n      v20 = v19 + __ROL4__(v86 + v15 + 1200080426 + (v16 ^ v19 & (v18 ^ v16)), 12);\n      v21 = v20 + __ROR4__(v92 + v16 - 1473231341 + (v18 ^ v20 & (v19 ^ v18)), 15);\n      v87 = *((_DWORD *)a1 + 8);\n      v22 = *((_DWORD *)a1 + 12);\n      v23 = v21 + __ROR4__(v13 + v18 - 45705983 + (v19 ^ v21 & (v20 ^ v19)), 10);\n      v24 = *((_DWORD *)a1 + 14);\n      v25 = v23 + __ROL4__(v87 + v19 + 1770035416 + (v20 ^ v23 & (v21 ^ v20)), 7);\n      v89 = *((_DWORD *)a1 + 10);\n      v26 = v25 + __ROL4__(v88 + v20 - 1958414417 + (v21 ^ v25 & (v23 ^ v21)), 12);\n      v27 = *((_DWORD *)a1 + 13);\n      a1 += 64;\n      v28 = v26 + __ROR4__(v89 + v21 - 42063 + (v23 ^ v26 & (v25 ^ v23)), 15);\n      v29 = v28 + __ROR4__(v90 + v23 - 1990404162 + (v25 ^ v28 & (v26 ^ v25)), 10);\n      v30 = v29 + __ROL4__(v22 + v25 + 1804603682 + (v26 ^ v29 & (v28 ^ v26)), 7);\n      v31 = v30 + __ROL4__(v27 + v26 - 40341101 + (v28 ^ v30 & (v29 ^ v28)), 12);\n      v32 = v31 + __ROR4__(v24 + v28 - 1502002290 + (v29 ^ v31 & (v30 ^ v29)), 15);\n      v33 = v32 + __ROR4__(v17 + v29 + 1236535329 + (v30 ^ v32 & (v31 ^ v30)), 10);\n      v34 = v33 + __ROL4__(v82 + v30 - 165796510 + (v32 ^ v31 & (v33 ^ v32)), 5);\n      v35 = v34 + __ROL4__(v92 + v31 - 1069501632 + (v33 ^ v32 & (v34 ^ v33)), 9);\n      v36 = v35 + __ROL4__(v90 + v32 + 643717713 + (v34 ^ v33 & (v35 ^ v34)), 14);\n      v37 = v36 + __ROR4__(v12 + v33 - 373897302 + (v35 ^ v34 & (v36 ^ v35)), 12);\n      v38 = v37 + __ROL4__(v86 + v34 - 701558691 + (v36 ^ v35 & (v37 ^ v36)), 5);\n      v39 = v38 + __ROL4__(v89 + v35 + 38016083 + (v37 ^ v36 & (v38 ^ v37)), 9);\n      v40 = v39 + __ROL4__(v17 + v36 - 660478335 + (v38 ^ v37 & (v39 ^ v38)), 14);\n      v41 = v40 + __ROR4__(v85 + v37 - 405537848 + (v39 ^ v38 & (v40 ^ v39)), 12);\n      v42 = v41 + __ROL4__(v88 + v38 + 568446438 + (v40 ^ v39 & (v41 ^ v40)), 5);\n      v43 = v42 + __ROL4__(v24 + v39 - 1019803690 + (v41 ^ v40 & (v42 ^ v41)), 9);\n      v44 = v43 + __ROL4__(v84 + v40 - 187363961 + (v42 ^ v41 & (v43 ^ v42)), 14);\n      v45 = v44 + __ROR4__(v87 + v41 + 1163531501 + (v43 ^ v42 & (v44 ^ v43)), 12);\n      v46 = v45 + __ROL4__(v27 + v42 - 1444681467 + (v44 ^ v43 & (v45 ^ v44)), 5);\n      v47 = v46 + __ROL4__(v83 + v43 - 51403784 + (v45 ^ v44 & (v46 ^ v45)), 9);\n      v48 = v47 + __ROL4__(v13 + v44 + 1735328473 + (v46 ^ v45 & (v47 ^ v46)), 14);\n      v49 = v48 + __ROR4__(v22 + v45 - 1926607734 + (v47 ^ v46 & (v48 ^ v47)), 12);\n      v50 = v49 + __ROL4__(v86 + v46 - 378558 + (v49 ^ v48 ^ v47), 4);\n      v51 = v50 + __ROL4__(v87 + v47 - 2022574463 + (v50 ^ v49 ^ v48), 11);\n      v52 = v51 + __ROL4__(v90 + v48 + 1839030562 + (v51 ^ v50 ^ v49), 16);\n      v53 = v52 + __ROR4__(v24 + v49 - 35309556 + (v52 ^ v51 ^ v50), 9);\n      v54 = v53 + __ROL4__(v82 + v50 - 1530992060 + (v53 ^ v52 ^ v51), 4);\n      v55 = v54 + __ROL4__(v85 + v51 + 1272893353 + (v54 ^ v53 ^ v52), 11);\n      v56 = v55 + __ROL4__(v13 + v52 - 155497632 + (v55 ^ v54 ^ v53), 16);\n      v57 = v56 + __ROR4__(v89 + v53 - 1094730640 + (v56 ^ v55 ^ v54), 9);\n      v58 = v57 + __ROL4__(v27 + v54 + 681279174 + (v57 ^ v56 ^ v55), 4);\n      v59 = v58 + __ROL4__(v12 + v55 - 358537222 + (v58 ^ v57 ^ v56), 11);\n      v60 = v59 + __ROL4__(v84 + v56 - 722521979 + (v59 ^ v58 ^ v57), 16);\n      v61 = v60 + __ROR4__(v92 + v57 + 76029189 + (v60 ^ v59 ^ v58), 9);\n      v62 = v61 + __ROL4__(v88 + v58 - 640364487 + (v61 ^ v60 ^ v59), 4);\n      v63 = v62 + __ROL4__(v22 + v59 - 421815835 + (v62 ^ v61 ^ v60), 11);\n      v64 = v63 + __ROL4__(v17 + v60 + 530742520 + (v63 ^ v62 ^ v61), 16);\n      v65 = v64 + __ROR4__(v83 + v61 - 995338651 + (v64 ^ v63 ^ v62), 9);\n      v66 = v65 + __ROL4__(v12 + v62 - 198630844 + (v64 ^ (v65 | ~v63)), 6);\n      v67 = v66 + __ROL4__(v13 + v63 + 1126891415 + (v65 ^ (v66 | ~v64)), 10);\n      v68 = v67 + __ROL4__(v24 + v64 - 1416354905 + (v66 ^ (v67 | ~v65)), 15);\n      v69 = v68 + __ROR4__(v86 + v65 - 57434055 + (v67 ^ (v68 | ~v66)), 11);\n      v70 = v69 + __ROL4__(v22 + v66 + 1700485571 + (v68 ^ (v69 | ~v67)), 6);\n      v71 = v70 + __ROL4__(v84 + v67 - 1894986606 + (v69 ^ (v70 | ~v68)), 10);\n      v72 = v71 + __ROL4__(v89 + v68 - 1051523 + (v70 ^ (v71 | ~v69)), 15);\n      v73 = v72 + __ROR4__(v82 + v69 - 2054922799 + (v71 ^ (v72 | ~v70)), 11);\n      v74 = v73 + __ROL4__(v87 + v70 + 1873313359 + (v72 ^ (v73 | ~v71)), 6);\n      v75 = v74 + __ROL4__(v17 + v71 - 30611744 + (v73 ^ (v74 | ~v72)), 10);\n      v76 = v75 + __ROL4__(v92 + v72 - 1560198380 + (v74 ^ (v75 | ~v73)), 15);\n      v77 = v76 + __ROR4__(v27 + v73 + 1309151649 + (v75 ^ (v76 | ~v74)), 11);\n      v78 = v77 + __ROL4__(v85 + v74 - 145523070 + (v76 ^ (v77 | ~v75)), 6);\n      v79 = v78 + __ROL4__(v90 + v75 - 1120210379 + (v77 ^ (v78 | ~v76)), 10);\n      v80 = v79 + __ROL4__(v83 + v76 + 718787259 + (v78 ^ (v79 | ~v77)), 15);\n      v93 += v78;\n      v11 += v80;\n      v5 += v80 + __ROR4__(v88 + v77 - 343485551 + (v79 ^ (v80 | ~v78)), 11);\n      v91 += v79;\n    }\n    while ( v94 > (unsigned __int64)a1 );\n    v7 = v11;\n  }\n  result = a3;\n  *a3 = v93;\n  a3[1] = v5;\n  a3[2] = v7;\n  a3[3] = v91;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40B250",
            "funcStartAddr": "0x40b250",
            "funcEndAddr": "0x40b354",
            "decompiledFuncCode": "_DWORD *__fastcall sub_40B250(__int64 a1, _DWORD *a2)\n{\n  __int64 v3; // rax\n  int v4; // edx\n  int v5; // esi\n  __int64 v6; // r8\n  bool v7; // cf\n  unsigned int v8; // esi\n  _QWORD *v9; // rdx\n  unsigned __int64 v10; // rcx\n\n  v3 = *(unsigned int *)(a1 + 24);\n  v4 = *(_DWORD *)(a1 + 20);\n  v5 = *(_DWORD *)(a1 + 24);\n  v6 = (-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFC0LL) + 128;\n  v7 = __CFADD__(*(_DWORD *)(a1 + 16), v5);\n  v8 = *(_DWORD *)(a1 + 16) + v5;\n  *(_DWORD *)(a1 + 16) = v8;\n  if ( v7 )\n    *(_DWORD *)(a1 + 20) = ++v4;\n  *(_DWORD *)(a1 + 4 * ((-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFF0LL) + 30) + 28) = 8 * v8;\n  *(_DWORD *)(a1 + 4 * ((-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFF0LL) + 31) + 28) = (v8 >> 29) | (8 * v4);\n  v9 = (_QWORD *)(a1 + 28 + v3);\n  v10 = v6 - v3 - 8;\n  if ( v10 >= 8 )\n  {\n    *v9 = 128LL;\n    *(_QWORD *)((char *)v9 + v10 - 8) = *(_QWORD *)((char *)&unk_416AD8 + v10);\n    qmemcpy(\n      (void *)((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL),\n      (const void *)((char *)&qword_416AE0 - ((char *)v9 - ((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL))),\n      8 * (((unsigned __int64)v9 + v10 - ((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL)) >> 3));\n  }\n  else if ( (v10 & 4) != 0 )\n  {\n    *(_DWORD *)v9 = 128;\n    *(_DWORD *)((char *)v9 + v10 - 4) = *(_DWORD *)((char *)&unk_416ADC + v10);\n  }\n  else if ( v6 - v3 != 8 )\n  {\n    *(_BYTE *)v9 = 0x80;\n    if ( (v10 & 2) != 0 )\n      *(_WORD *)((char *)v9 + v10 - 2) = *(__int16 *)((char *)&word_416ADE + v10);\n  }\n  sub_40AAE0((char *)(a1 + 28), v6, (_DWORD *)a1);\n  return sub_40AAC0((_DWORD *)a1, a2);\n}\n"
        },
        {
            "funcName": "sub_40B360",
            "funcStartAddr": "0x40b360",
            "funcEndAddr": "0x40b65e",
            "decompiledFuncCode": "__int64 __fastcall sub_40B360(const __m128i *src, size_t n, __int64 a3)\n{\n  unsigned __int64 v3; // r13\n  __m128i *v5; // rbx\n  __int64 result; // rax\n  char *v7; // rbp\n  const __m128i *v8; // r14\n  __m128i v9; // xmm0\n  __int64 v10; // rcx\n  char *v11; // rsi\n  size_t v12; // r13\n  unsigned __int64 v13; // rbp\n  char *v14; // rdi\n  __int64 v15; // rbp\n  __int64 v16; // r15\n  size_t v17; // rdx\n  size_t v18; // r14\n  unsigned int v19; // esi\n  unsigned __int64 v20; // rdi\n  signed __int64 v21; // r14\n  unsigned int v22; // edx\n  __int64 v23; // rsi\n  int v24; // ecx\n  __int64 v25; // rdx\n  unsigned __int64 v26; // rsi\n  __int64 v27; // r15\n  unsigned int v28; // r15d\n  unsigned int v29; // r15d\n  unsigned int v30; // edx\n  __int64 v31; // rcx\n\n  v3 = n;\n  v5 = (__m128i *)src;\n  result = *(unsigned int *)(a3 + 24);\n  if ( (_DWORD)result )\n  {\n    v15 = (unsigned int)result;\n    v16 = a3 + 28;\n    v17 = 128LL - (unsigned int)result;\n    if ( v17 > n )\n      v17 = n;\n    v18 = v17;\n    result = (__int64)memcpy((void *)(a3 + 28 + (unsigned int)result), src, v17);\n    v19 = v18 + *(_DWORD *)(a3 + 24);\n    *(_DWORD *)(a3 + 24) = v19;\n    if ( v19 > 0x40 )\n    {\n      sub_40AAE0((char *)(a3 + 28), v19 & 0xFFFFFFC0, (_DWORD *)a3);\n      v24 = *(_DWORD *)(a3 + 24);\n      result = v16 + ((v15 + v18) & 0xFFFFFFFFFFFFFFC0LL);\n      v25 = v24 & 0x3F;\n      *(_DWORD *)(a3 + 24) = v25;\n      if ( (unsigned int)v25 >= 8 )\n      {\n        *(_QWORD *)(a3 + 28) = *(_QWORD *)result;\n        *(_QWORD *)(v16 + (v24 & 0x3F) - 8) = *(_QWORD *)(result + (v24 & 0x3F) - 8);\n        v26 = (a3 + 36) & 0xFFFFFFFFFFFFFFF8LL;\n        v27 = v16 - v26;\n        result -= v27;\n        v28 = (v25 + v27) & 0xFFFFFFF8;\n        if ( v28 >= 8 )\n        {\n          v29 = v28 & 0xFFFFFFF8;\n          v30 = 0;\n          do\n          {\n            v31 = v30;\n            v30 += 8;\n            *(_QWORD *)(v26 + v31) = *(_QWORD *)(result + v31);\n          }\n          while ( v30 < v29 );\n        }\n      }\n      else if ( (v24 & 4) != 0 )\n      {\n        *(_DWORD *)(a3 + 28) = *(_DWORD *)result;\n        result = *(unsigned int *)(result + v25 - 4);\n        *(_DWORD *)(v16 + v25 - 4) = result;\n      }\n      else if ( (v24 & 0x3F) != 0 )\n      {\n        *(_BYTE *)(a3 + 28) = *(_BYTE *)result;\n        if ( (v24 & 2) != 0 )\n        {\n          result = *(unsigned __int16 *)(result + v25 - 2);\n          *(_WORD *)(v16 + v25 - 2) = result;\n        }\n      }\n    }\n    v5 = (__m128i *)((char *)src + v18);\n    v3 -= v18;\n  }\n  if ( v3 > 0x3F )\n  {\n    if ( ((unsigned __int8)v5 & 3) != 0 )\n    {\n      v7 = (char *)(a3 + 28);\n      if ( v3 == 64 )\n      {\n        v8 = v5;\n      }\n      else\n      {\n        v8 = &v5[4 * ((v3 - 65) >> 6) + 4];\n        do\n        {\n          v9 = _mm_loadu_si128(v5);\n          v5 += 4;\n          *(__m128i *)v7 = v9;\n          *(__m128i *)(a3 + 44) = _mm_loadu_si128(v5 - 3);\n          *(__m128i *)(a3 + 60) = _mm_loadu_si128(v5 - 2);\n          *(__m128i *)(a3 + 76) = _mm_loadu_si128(v5 - 1);\n          sub_40AAE0((char *)(a3 + 28), 64LL, (_DWORD *)a3);\n        }\n        while ( v5 != v8 );\n        v3 = v3 - ((v3 - 65) >> 6 << 6) - 64;\n      }\n      goto LABEL_8;\n    }\n    v13 = v3;\n    v14 = (char *)v5;\n    v3 &= 0x3Fu;\n    v5 = (__m128i *)((char *)v5 + (v13 & 0xFFFFFFFFFFFFFFC0LL));\n    result = (__int64)sub_40AAE0(v14, v13 & 0xFFFFFFFFFFFFFFC0LL, (_DWORD *)a3);\n  }\n  if ( !v3 )\n    return result;\n  v7 = (char *)(a3 + 28);\n  v8 = v5;\nLABEL_8:\n  v10 = *(unsigned int *)(a3 + 24);\n  result = (unsigned int)v3;\n  v11 = &v7[v10];\n  if ( (unsigned int)v3 >= 8 )\n  {\n    v20 = (unsigned __int64)(v11 + 8) & 0xFFFFFFFFFFFFFFF8LL;\n    *(_QWORD *)v11 = v8->m128i_i64[0];\n    *(_QWORD *)&v11[(unsigned int)v3 - 8] = *(__int64 *)((char *)&v8->m128i_i64[-1] + (unsigned int)v3);\n    v21 = (char *)v8 - &v11[-v20];\n    result = ((_DWORD)v3 + (_DWORD)v11 - (_DWORD)v20) & 0xFFFFFFF8;\n    if ( (unsigned int)result >= 8 )\n    {\n      result = ((_DWORD)v3 + (_DWORD)v11 - (_DWORD)v20) & 0xFFFFFFF8;\n      v22 = 0;\n      do\n      {\n        v23 = v22;\n        v22 += 8;\n        *(_QWORD *)(v20 + v23) = *(_QWORD *)(v21 + v23);\n      }\n      while ( v22 < (unsigned int)result );\n    }\n  }\n  else if ( (v3 & 4) != 0 )\n  {\n    *(_DWORD *)v11 = v8->m128i_i32[0];\n    result = *(unsigned int *)((char *)&v8->m128i_u32[-1] + (unsigned int)v3);\n    *(_DWORD *)&v11[(unsigned int)v3 - 4] = result;\n  }\n  else if ( (_DWORD)v3 )\n  {\n    *v11 = v8->m128i_i8[0];\n    if ( (v3 & 2) != 0 )\n    {\n      result = *(unsigned __int16 *)((char *)&v8->m128i_u16[-1] + (unsigned int)v3);\n      *(_WORD *)&v11[(unsigned int)v3 - 2] = result;\n    }\n  }\n  v12 = v10 + v3;\n  if ( v12 > 0x3F )\n  {\n    v12 -= 64LL;\n    sub_40AAE0(v7, 64LL, (_DWORD *)a3);\n    result = (__int64)memcpy(v7, (const void *)(a3 + 92), v12);\n  }\n  *(_DWORD *)(a3 + 24) = v12;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40B660",
            "funcStartAddr": "0x40b660",
            "funcEndAddr": "0x40b6b5",
            "decompiledFuncCode": "_DWORD *__fastcall sub_40B660(const __m128i *a1, size_t a2, _DWORD *a3)\n{\n  __int64 v5[3]; // [rsp+0h] [rbp-A8h] BYREF\n  int v6; // [rsp+18h] [rbp-90h]\n\n  v5[0] = 0xEFCDAB8967452301LL;\n  v5[1] = 0x1032547698BADCFELL;\n  v5[2] = 0LL;\n  v6 = 0;\n  sub_40B360(a1, a2, (__int64)v5);\n  return sub_40B250((__int64)v5, a3);\n}\n"
        },
        {
            "funcName": "sub_40B6C0",
            "funcStartAddr": "0x40b6c0",
            "funcEndAddr": "0x40b7e5",
            "decompiledFuncCode": "__int64 __fastcall sub_40B6C0(FILE *stream, _DWORD *a2)\n{\n  __m128i *v2; // rax\n  __m128i *v3; // r12\n  size_t v4; // rbx\n  int flags; // edx\n  size_t v6; // rax\n  __int64 v8[3]; // [rsp+0h] [rbp-C8h] BYREF\n  int v9; // [rsp+18h] [rbp-B0h]\n\n  v2 = (__m128i *)malloc(0x8048uLL);\n  if ( !v2 )\n    return 1LL;\n  v3 = v2;\n  v9 = 0;\n  v8[0] = 0xEFCDAB8967452301LL;\n  v8[1] = 0x1032547698BADCFELL;\n  v8[2] = 0LL;\nLABEL_3:\n  v4 = 0LL;\n  while ( 1 )\n  {\n    v6 = fread_unlocked(&v3->m128i_i8[v4], 1uLL, 0x8000 - v4, stream);\n    v4 += v6;\n    if ( v4 == 0x8000 )\n    {\n      sub_40AAE0(v3->m128i_i8, 0x8000LL, v8);\n      goto LABEL_3;\n    }\n    flags = stream->_flags;\n    if ( !v6 )\n      break;\n    if ( (flags & 0x10) != 0 )\n      goto LABEL_9;\n  }\n  if ( (flags & 0x20) != 0 )\n  {\n    free(v3);\n    return 1LL;\n  }\nLABEL_9:\n  if ( v4 )\n    sub_40B360(v3, v4, (__int64)v8);\n  sub_40B250((__int64)v8, a2);\n  free(v3);\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40B800",
            "funcStartAddr": "0x40b800",
            "funcEndAddr": "0x40b821",
            "decompiledFuncCode": "void __fastcall sub_40B800(FILE *a1, int a2)\n{\n  int v2; // eax\n\n  if ( a1 )\n  {\n    v2 = fileno(a1);\n    posix_fadvise(v2, 0LL, 0LL, a2);\n  }\n}\n"
        },
        {
            "funcName": "sub_40B830",
            "funcStartAddr": "0x40b830",
            "funcEndAddr": "0x40b8f3",
            "decompiledFuncCode": "char *__fastcall sub_40B830(char **a1)\n{\n  char *v1; // rsi\n  char v2; // dl\n  char v3; // cl\n  char *result; // rax\n  unsigned int v5; // ecx\n  __int64 v6; // r8\n\n  v1 = *a1;\n  v2 = **a1;\n  if ( v2 )\n  {\n    v3 = 0;\n    result = 0LL;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( v3 )\n        {\n          v5 = v2 - 65;\n          if ( v5 > 0x39 || (v6 = 1LL << v5, v3 = 0, (v6 & 0x3FFFFFF03FFFFFFLL) == 0) )\n          {\n            v3 = 0;\n            if ( v2 != 126 )\n              result = 0LL;\n          }\n          goto LABEL_7;\n        }\n        if ( v2 == 46 )\n        {\n          v3 = 1;\n          if ( !result )\n            result = v1;\n          goto LABEL_7;\n        }\n        if ( v2 <= 90 )\n          break;\n        if ( (unsigned __int8)(v2 - 97) > 0x19u )\n          goto LABEL_13;\nLABEL_7:\n        *a1 = ++v1;\n        v2 = *v1;\n        if ( !*v1 )\n          return result;\n      }\n      if ( v2 >= 65 || (unsigned __int8)(v2 - 48) <= 9u )\n        goto LABEL_7;\nLABEL_13:\n      if ( v2 != 126 )\n        result = 0LL;\n      *a1 = ++v1;\n      v2 = *v1;\n      if ( !*v1 )\n        return result;\n    }\n  }\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40B900",
            "funcStartAddr": "0x40b900",
            "funcEndAddr": "0x40bd0d",
            "decompiledFuncCode": "__int64 __fastcall sub_40B900(char *s1, char *s2)\n{\n  char *v2; // rbp\n  char *v3; // rbx\n  unsigned int v4; // r12d\n  char v5; // r8\n  char v6; // r9\n  char *v7; // r13\n  char *v8; // rax\n  char *v9; // r13\n  char *v10; // r14\n  unsigned __int64 v11; // rsi\n  char *v12; // rdx\n  unsigned __int64 v13; // r9\n  unsigned __int8 v14; // al\n  unsigned int v15; // r10d\n  unsigned int v16; // ecx\n  unsigned int v17; // ecx\n  unsigned __int8 v18; // di\n  int v19; // eax\n  int v20; // ecx\n  unsigned int v21; // ecx\n  int v22; // eax\n  unsigned int v23; // r9d\n  char *v25; // rdi\n  unsigned int v26; // r9d\n  unsigned int v27; // eax\n  unsigned int v28; // [rsp+4h] [rbp-54h]\n  char *v29; // [rsp+10h] [rbp-48h] BYREF\n  char *v30; // [rsp+18h] [rbp-40h] BYREF\n\n  v2 = s2;\n  v3 = s1;\n  v4 = strcmp(s1, s2);\n  if ( v4 )\n  {\n    v5 = *s1;\n    if ( *s1 )\n    {\n      v6 = *s2;\n      if ( !*s2 )\n        return 1;\n      if ( !strcmp(\".\", s1) )\n        return (unsigned int)-1;\n      if ( !strcmp(\".\", s2) )\n        return 1;\n      if ( !strcmp(\"..\", s1) )\n        return (unsigned int)-1;\n      if ( !strcmp(\"..\", s2) )\n        return 1;\n      if ( v6 == 46 || v5 != 46 )\n      {\n        if ( v5 == 46 )\n        {\n          if ( v6 == 46 )\n          {\n            v3 = s1 + 1;\n            v2 = s2 + 1;\n          }\nLABEL_12:\n          v29 = v3;\n          v30 = v2;\n          v7 = sub_40B830(&v29);\n          v8 = sub_40B830(&v30);\n          if ( v7 )\n          {\n            v9 = (char *)(v7 - v3);\n            if ( !v8 )\n            {\n              v10 = (char *)(v30 - v2);\nLABEL_15:\n              if ( v9 != v10 || strncmp(v3, v2, (size_t)v9) )\n                goto LABEL_16;\n              v9 = (char *)(v29 - v3);\nLABEL_62:\n              v10 = (char *)(v30 - v2);\nLABEL_16:\n              v11 = 0LL;\n              v12 = 0LL;\n              while ( 1 )\n              {\n                if ( v9 <= v12 && (unsigned __int64)v10 <= v11 )\n                  return v4;\n                v13 = v11 - (_QWORD)v12;\n                if ( v9 > v12 )\n                  break;\nLABEL_31:\n                while ( 1 )\n                {\n                  v18 = v2[v11];\n                  v20 = (char)v18;\n                  if ( (unsigned __int64)v10 <= v11 || (unsigned int)((char)v18 - 48) <= 9 )\n                    break;\n                  if ( v9 != v12 )\n                  {\n                    v16 = (unsigned __int8)v12[(_QWORD)v3];\n                    v14 = v12[(_QWORD)v3];\n                    v15 = v16;\n                    if ( v16 - 48 > 9 )\n                      goto LABEL_22;\n                  }\n                  v19 = v18;\n                  v15 = 0;\n                  if ( (unsigned int)v18 - 48 > 9 )\n                    goto LABEL_36;\nLABEL_30:\n                  ++v12;\n                  ++v11;\n                  if ( v9 > v12 )\n                    goto LABEL_20;\n                }\n                while ( 1 )\n                {\n                  v22 = v12[(_QWORD)v3];\n                  if ( v12[(_QWORD)v3] != 48 )\n                    break;\n                  ++v12;\n                }\n                if ( v18 == 48 )\n                {\n                  do\n                    v20 = v2[++v11];\n                  while ( v2[v11] == 48 );\n                }\n                v23 = v20 - 48;\n                if ( (unsigned int)(v22 - 48) > 9 )\n                {\n                  if ( v23 <= 9 )\n                    return (unsigned int)-1;\n                }\n                else\n                {\n                  if ( v23 > 9 )\n                    return 1;\n                  v25 = v12;\n                  v26 = 0;\n                  while ( 1 )\n                  {\n                    v27 = v22 - v20;\n                    if ( !v26 )\n                      v26 = v27;\n                    v20 = v2[v11 - (_QWORD)v12 + (_QWORD)++v25];\n                    v22 = v25[(_QWORD)v3];\n                    v28 = v20 - 48;\n                    if ( (unsigned int)(v22 - 48) > 9 )\n                      break;\n                    if ( v28 > 9 )\n                      return 1;\n                  }\n                  if ( v28 <= 9 )\n                    return (unsigned int)-1;\n                  if ( v26 )\n                    return v26;\n                  v11 += v25 - v12;\n                  v12 = v25;\n                }\n              }\nLABEL_20:\n              v14 = v12[(_QWORD)v3];\n              if ( (unsigned int)((char)v14 - 48) <= 9 )\n                goto LABEL_31;\n              v15 = v14;\n              v16 = v14;\nLABEL_22:\n              v17 = v16 - 65;\n              if ( v17 <= 0x39 && ((1LL << v17) & 0x3FFFFFF03FFFFFFLL) != 0 )\n              {\n                v19 = 0;\n                if ( v10 == &v12[v13] )\n                {\nLABEL_29:\n                  if ( v19 == v15 )\n                    goto LABEL_30;\n                  return v15 - v19;\n                }\n              }\n              else\n              {\n                if ( v14 == 126 )\n                  v15 = -1;\n                else\n                  v15 += 256;\n                if ( v10 == &v12[v13] )\n                  return v15;\n              }\n              v18 = v2[v11];\n              v19 = v18;\n              if ( (unsigned int)v18 - 48 > 9 )\n              {\nLABEL_36:\n                v21 = v18 - 65;\n                if ( v21 > 0x39 || ((1LL << v21) & 0x3FFFFFF03FFFFFFLL) == 0 )\n                {\n                  if ( v18 == 126 )\n                    v19 = -1;\n                  else\n                    v19 += 256;\n                }\n              }\n              else\n              {\n                v19 = 0;\n              }\n              goto LABEL_29;\n            }\n          }\n          else\n          {\n            v9 = (char *)(v29 - v3);\n            if ( !v8 )\n              goto LABEL_62;\n          }\n          v10 = (char *)(v8 - v2);\n          goto LABEL_15;\n        }\n        if ( v6 != 46 )\n          goto LABEL_12;\n        return 1;\n      }\n    }\n    return (unsigned int)-1;\n  }\n  return v4;\n}\n"
        },
        {
            "funcName": "sub_40BD10",
            "funcStartAddr": "0x40bd10",
            "funcEndAddr": "0x40bd6e",
            "decompiledFuncCode": "bool __fastcall sub_40BD10(int a1)\n{\n  char *v1; // rdx\n  bool result; // al\n\n  v1 = setlocale(a1, 0LL);\n  result = 1;\n  if ( v1 )\n  {\n    result = 0;\n    if ( strcmp(v1, \"C\") )\n      return strcmp(v1, \"POSIX\") != 0;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40BD70",
            "funcStartAddr": "0x40bd70",
            "funcEndAddr": "0x40be03",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40BD70(unsigned __int64 a1)\n{\n  __int64 v1; // rsi\n  unsigned __int64 v2; // rsi\n  unsigned __int64 v3; // rax\n  __int64 v4; // r8\n  unsigned __int64 v5; // rdi\n  unsigned __int64 v6; // rcx\n\n  v1 = 10LL;\n  if ( a1 >= 0xA )\n    v1 = a1;\n  v2 = v1 | 1;\n  if ( v2 != -1LL )\n  {\n    while ( 1 )\n    {\n      v3 = v2 % 3;\n      if ( v2 <= 9 )\n        goto LABEL_9;\n      if ( v2 % 3 )\n        break;\nLABEL_10:\n      v2 += 2LL;\n      if ( v2 == -1LL )\n        return v2;\n    }\n    v4 = 16LL;\n    v5 = 9LL;\n    v6 = 3LL;\n    while ( 1 )\n    {\n      v6 += 2LL;\n      v5 += v4;\n      v3 = v2 % v6;\n      if ( v5 >= v2 )\n        break;\n      v4 += 8LL;\n      if ( !(v2 % v6) )\n        goto LABEL_10;\n    }\nLABEL_9:\n    if ( v3 )\n      return v2;\n    goto LABEL_10;\n  }\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_40BE10",
            "funcStartAddr": "0x40be10",
            "funcEndAddr": "0x40be20",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40BE10(__int64 a1, unsigned __int64 a2)\n{\n  return __ROR8__(a1, 3) % a2;\n}\n"
        },
        {
            "funcName": "sub_40BE20",
            "funcStartAddr": "0x40be20",
            "funcEndAddr": "0x40be27",
            "decompiledFuncCode": "bool __fastcall sub_40BE20(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n"
        },
        {
            "funcName": "sub_40BE30",
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f05",
            "decompiledFuncCode": "__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n\n__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n"
        },
        {
            "funcName": "sub_40BE30",
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f05",
            "decompiledFuncCode": "__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n\n__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n"
        },
        {
            "funcName": "sub_40BE60",
            "funcStartAddr": "0x40be60",
            "funcEndAddr": "0x40bf79",
            "decompiledFuncCode": "__int64 __fastcall sub_40BE60(__int64 a1, __int64 a2, __m128i **a3, char a4)\n{\n  __m128i *v7; // rax\n  __int64 v8; // rsi\n  __m128i *v9; // rbx\n  __int64 *v10; // rax\n  const __m128i *v12; // rax\n\n  v7 = (__m128i *)sub_40BE30(a1, a2);\n  *a3 = v7;\n  v8 = v7->m128i_i64[0];\n  if ( v7->m128i_i64[0] )\n  {\n    v9 = v7;\n    if ( v8 != a2 )\n    {\n      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(a2) )\n      {\n        v10 = (__int64 *)v9->m128i_i64[1];\n        if ( v10 )\n        {\n          v8 = *v10;\n          if ( a2 != *v10 )\n          {\n            while ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(a2) )\n            {\n              v9 = (__m128i *)v9->m128i_i64[1];\n              v10 = (__int64 *)v9->m128i_i64[1];\n              if ( !v10 )\n                return 0LL;\n              v8 = *v10;\n              if ( *v10 == a2 )\n                goto LABEL_11;\n            }\n            v10 = (__int64 *)v9->m128i_i64[1];\n            v8 = *v10;\n          }\nLABEL_11:\n          if ( a4 )\n          {\n            v9->m128i_i64[1] = v10[1];\n            *v10 = 0LL;\n            v10[1] = *(_QWORD *)(a1 + 72);\n            *(_QWORD *)(a1 + 72) = v10;\n          }\n          return v8;\n        }\n        return 0LL;\n      }\n      v8 = v9->m128i_i64[0];\n    }\n    if ( a4 )\n    {\n      v12 = (const __m128i *)v9->m128i_i64[1];\n      if ( v12 )\n      {\n        *v9 = _mm_loadu_si128(v12);\n        v12->m128i_i64[0] = 0LL;\n        v12->m128i_i64[1] = *(_QWORD *)(a1 + 72);\n        *(_QWORD *)(a1 + 72) = v12;\n        return v8;\n      }\n      v9->m128i_i64[0] = 0LL;\n    }\n    return v8;\n  }\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40BF80",
            "funcStartAddr": "0x40bf80",
            "funcEndAddr": "0x40bffe",
            "decompiledFuncCode": "__int64 __fastcall sub_40BF80(float **a1)\n{\n  float *v1; // rax\n  float v2; // xmm0_4\n  float v3; // xmm1_4\n  float v4; // xmm2_4\n  __int64 result; // rax\n\n  v1 = *a1;\n  if ( *a1 == (float *)&unk_416BA0 )\n    return 1LL;\n  v2 = v1[2];\n  if ( v2 <= 0.1\n    || v2 >= 0.89999998\n    || v1[3] <= 1.1\n    || *v1 < 0.0\n    || (v3 = *v1 + 0.1, v4 = v1[1], v4 <= v3)\n    || v4 > 1.0\n    || (result = 1LL, v2 <= v3) )\n  {\n    *a1 = (float *)&unk_416BA0;\n    return 0LL;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40C000",
            "funcStartAddr": "0x40c000",
            "funcEndAddr": "0x40c14a",
            "decompiledFuncCode": "__int64 __fastcall sub_40C000(__int64 a1, __int64 a2, char a3)\n{\n  __int64 *v4; // r12\n  __int64 v5; // r15\n  __int64 *v6; // rbx\n  __int64 v7; // r15\n  _QWORD *v8; // rax\n  __int64 *v9; // rdx\n  _QWORD *v10; // rax\n  _QWORD *v11; // rbx\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n\n  v4 = *(__int64 **)a2;\n  if ( *(_QWORD *)a2 >= *(_QWORD *)(a2 + 8) )\n    return 1LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v5 = *v4;\n      if ( *v4 )\n      {\n        v6 = (__int64 *)v4[1];\n        if ( v6 )\n        {\n          do\n          {\n            while ( 1 )\n            {\n              v7 = *v6;\n              v8 = (_QWORD *)sub_40BE30(a1, *v6);\n              v9 = (__int64 *)v6[1];\n              if ( !*v8 )\n                break;\n              v6[1] = v8[1];\n              v8[1] = v6;\n              v6 = v9;\n              if ( !v9 )\n                goto LABEL_10;\n            }\n            *v8 = v7;\n            ++*(_QWORD *)(a1 + 24);\n            *v6 = 0LL;\n            v6[1] = *(_QWORD *)(a1 + 72);\n            *(_QWORD *)(a1 + 72) = v6;\n            v6 = v9;\n          }\n          while ( v9 );\nLABEL_10:\n          v5 = *v4;\n        }\n        v4[1] = 0LL;\n        if ( !a3 )\n          break;\n      }\n      v4 += 2;\n      if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )\n        return 1LL;\n    }\n    v10 = (_QWORD *)sub_40BE30(a1, v5);\n    v11 = v10;\n    if ( !*v10 )\n    {\n      *v10 = v5;\n      ++*(_QWORD *)(a1 + 24);\n      goto LABEL_16;\n    }\n    v12 = *(_QWORD **)(a1 + 72);\n    if ( !v12 )\n      break;\n    *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_15:\n    v13 = v11[1];\n    *v12 = v5;\n    v12[1] = v13;\n    v11[1] = v12;\nLABEL_16:\n    *v4 = 0LL;\n    v4 += 2;\n    --*(_QWORD *)(a2 + 24);\n    if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )\n      return 1LL;\n  }\n  v12 = malloc(0x10uLL);\n  if ( v12 )\n    goto LABEL_15;\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40C240",
            "funcStartAddr": "0x40c240",
            "funcEndAddr": "0x40c388",
            "decompiledFuncCode": "__int64 __fastcall sub_40C240(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // rbx\n  __int64 v4; // rcx\n  __int64 v5; // r12\n  __int64 v6; // r13\n  _QWORD *v7; // rsi\n  unsigned __int64 i; // rdi\n  __int64 v9; // rax\n  unsigned __int64 j; // rdx\n  double v11; // xmm0_8\n  double v12; // xmm1_8\n\n  v3 = 0LL;\n  v4 = *(_QWORD *)(a1 + 32);\n  v5 = *(_QWORD *)(a1 + 16);\n  v6 = *(_QWORD *)(a1 + 24);\n  v7 = *(_QWORD **)a1;\n  for ( i = *(_QWORD *)(a1 + 8); (unsigned __int64)v7 < i; v7 += 2 )\n  {\n    while ( !*v7 )\n    {\n      v7 += 2;\n      if ( (unsigned __int64)v7 >= i )\n        goto LABEL_10;\n    }\n    v9 = v7[1];\n    for ( j = 1LL; v9; ++j )\n      v9 = *(_QWORD *)(v9 + 8);\n    if ( v3 < j )\n      v3 = j;\n  }\nLABEL_10:\n  __fprintf_chk(a2, 1LL, \"# entries:         %lu\\n\", v4);\n  __fprintf_chk(a2, 1LL, \"# buckets:         %lu\\n\", v5);\n  if ( v6 < 0 )\n  {\n    v11 = ((double)(int)(v6 & 1 | ((unsigned __int64)v6 >> 1)) + (double)(int)(v6 & 1 | ((unsigned __int64)v6 >> 1)))\n        * 100.0;\n    if ( v5 >= 0 )\n      goto LABEL_12;\nLABEL_15:\n    v12 = (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1)) + (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1));\n    goto LABEL_13;\n  }\n  v11 = (double)(int)v6 * 100.0;\n  if ( v5 < 0 )\n    goto LABEL_15;\nLABEL_12:\n  v12 = (double)(int)v5;\nLABEL_13:\n  __fprintf_chk(a2, 1LL, \"# buckets used:    %lu (%.2f%%)\\n\", v6, v11 / v12);\n  return __fprintf_chk(a2, 1LL, \"max bucket length: %lu\\n\", v3);\n}\n"
        },
        {
            "funcName": "sub_40C390",
            "funcStartAddr": "0x40c390",
            "funcEndAddr": "0x40c3e3",
            "decompiledFuncCode": "__int64 __fastcall sub_40C390(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rbp\n  _QWORD *v3; // rax\n  __int64 v4; // rsi\n  _QWORD *v5; // rbx\n\n  v2 = a2;\n  v3 = (_QWORD *)sub_40BE30(a1, a2);\n  v4 = *v3;\n  if ( !*v3 )\n    return 0LL;\n  v5 = v3;\n  while ( v4 != v2 )\n  {\n    if ( (*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v2) )\n      return *v5;\n    v5 = (_QWORD *)v5[1];\n    if ( !v5 )\n      return 0LL;\n    v4 = *v5;\n  }\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_40C440",
            "funcStartAddr": "0x40c440",
            "funcEndAddr": "0x40c4aa",
            "decompiledFuncCode": "__int64 __fastcall sub_40C440(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rcx\n  _QWORD *v3; // rdx\n  __int64 v4; // rax\n  __int64 result; // rax\n\n  v2 = (_QWORD *)sub_40BE30(a1, a2);\n  v3 = v2;\n  while ( 1 )\n  {\n    v4 = *v3;\n    v3 = (_QWORD *)v3[1];\n    if ( v4 == a2 )\n      break;\n    if ( !v3 )\n      goto LABEL_7;\n  }\n  if ( v3 )\n    return *v3;\nLABEL_7:\n  while ( 1 )\n  {\n    v2 += 2;\n    if ( *(_QWORD *)(a1 + 8) <= (unsigned __int64)v2 )\n      break;\n    result = *v2;\n    if ( *v2 )\n      return result;\n  }\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40C520",
            "funcStartAddr": "0x40c520",
            "funcEndAddr": "0x40c598",
            "decompiledFuncCode": "__int64 __fastcall sub_40C520(__int64 a1, unsigned __int8 (__fastcall *a2)(__int64, __int64), __int64 a3)\n{\n  __int64 *v3; // r14\n  __int64 v6; // rbp\n  __int64 v7; // rdi\n  __int64 *v9; // rbx\n\n  v3 = *(__int64 **)a1;\n  if ( *(_QWORD *)(a1 + 8) <= *(_QWORD *)a1 )\n    return 0LL;\n  v6 = 0LL;\n  while ( 1 )\n  {\n    v7 = *v3;\n    if ( *v3 )\n      break;\nLABEL_4:\n    v3 += 2;\n    if ( *(_QWORD *)(a1 + 8) <= (unsigned __int64)v3 )\n      return v6;\n  }\n  v9 = v3;\n  while ( a2(v7, a3) )\n  {\n    v9 = (__int64 *)v9[1];\n    ++v6;\n    if ( !v9 )\n      goto LABEL_4;\n    v7 = *v9;\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "sub_40C600",
            "funcStartAddr": "0x40c600",
            "funcEndAddr": "0x40c78a",
            "decompiledFuncCode": "_QWORD *__fastcall sub_40C600(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2),\n        bool (__fastcall *a4)(__int64 a1, __int64 a2),\n        __int64 a5)\n{\n  bool (__fastcall *v6)(__int64, __int64); // r13\n  unsigned __int64 (__fastcall *v7)(__int64, unsigned __int64); // r12\n  char *v9; // rax\n  _QWORD *v10; // rbx\n  float **v11; // rdi\n  unsigned __int64 v12; // rbp\n  char *v13; // rax\n  void *v14; // rdi\n  float v16; // xmm1_4\n  float v17; // xmm0_4\n  float v18; // xmm0_4\n\n  v6 = a4;\n  v7 = a3;\n  if ( !a3 )\n    v7 = sub_40BE10;\n  if ( !a4 )\n    v6 = sub_40BE20;\n  v9 = (char *)malloc(0x50uLL);\n  v10 = v9;\n  if ( v9 )\n  {\n    v11 = (float **)(v9 + 40);\n    if ( a2 )\n    {\n      *((_QWORD *)v9 + 5) = a2;\n      if ( !(unsigned __int8)sub_40BF80(v11) )\n        goto LABEL_14;\n      if ( *(_BYTE *)(a2 + 16) )\n      {\nLABEL_9:\n        v12 = sub_40BD70(a1);\n        if ( (v12 & 0x1000000000000000LL) == 0 && !(v12 >> 61) )\n        {\n          v10[2] = v12;\n          if ( v12 )\n          {\n            v13 = (char *)calloc(v12, 0x10uLL);\n            *v10 = v13;\n            if ( v13 )\n            {\n              v10[3] = 0LL;\n              v10[4] = 0LL;\n              v10[1] = &v13[16 * v12];\n              v10[6] = v7;\n              v10[7] = v6;\n              v10[8] = a5;\n              v10[9] = 0LL;\n              return v10;\n            }\n          }\n        }\nLABEL_14:\n        v14 = v10;\n        v10 = 0LL;\n        free(v14);\n        return v10;\n      }\n      v16 = *(float *)(a2 + 8);\n      if ( a1 < 0 )\n        goto LABEL_23;\n    }\n    else\n    {\n      *((_QWORD *)v9 + 5) = &unk_416BA0;\n      v16 = 0.80000001;\n      if ( !(unsigned __int8)sub_40BF80(v11) )\n        goto LABEL_14;\n      if ( a1 < 0 )\n      {\nLABEL_23:\n        v17 = (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1))\n            + (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1));\n        goto LABEL_19;\n      }\n    }\n    v17 = (float)(int)a1;\nLABEL_19:\n    v18 = v17 / v16;\n    if ( v18 >= 1.8446744e19 )\n      goto LABEL_14;\n    if ( v18 < 9.223372e18 )\n      a1 = (unsigned int)(int)v18;\n    else\n      a1 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n    goto LABEL_9;\n  }\n  return v10;\n}\n"
        },
        {
            "funcName": "sub_40C790",
            "funcStartAddr": "0x40c790",
            "funcEndAddr": "0x40c838",
            "decompiledFuncCode": "void __fastcall sub_40C790(_QWORD *a1)\n{\n  _QWORD *v1; // r12\n  _QWORD *v2; // rbx\n  void (__fastcall *v3)(_QWORD); // rax\n  _QWORD *v4; // rdx\n  __int64 v5; // rcx\n\n  v1 = (_QWORD *)*a1;\n  if ( *a1 < a1[1] )\n  {\n    do\n    {\n      while ( !*v1 )\n      {\n        v1 += 2;\n        if ( a1[1] <= (unsigned __int64)v1 )\n          goto LABEL_12;\n      }\n      v2 = (_QWORD *)v1[1];\n      v3 = (void (__fastcall *)(_QWORD))a1[8];\n      if ( v2 )\n      {\n        do\n        {\n          if ( v3 )\n          {\n            v3(*v2);\n            v3 = (void (__fastcall *)(_QWORD))a1[8];\n          }\n          v4 = (_QWORD *)v2[1];\n          v5 = a1[9];\n          *v2 = 0LL;\n          v2[1] = v5;\n          a1[9] = v2;\n          v2 = v4;\n        }\n        while ( v4 );\n      }\n      if ( v3 )\n        v3(*v1);\n      *v1 = 0LL;\n      v1 += 2;\n      *(v1 - 1) = 0LL;\n    }\n    while ( a1[1] > (unsigned __int64)v1 );\n  }\nLABEL_12:\n  a1[3] = 0LL;\n  a1[4] = 0LL;\n}\n"
        },
        {
            "funcName": "sub_40C840",
            "funcStartAddr": "0x40c840",
            "funcEndAddr": "0x40c916",
            "decompiledFuncCode": "void __fastcall sub_40C840(_QWORD *ptr)\n{\n  _QWORD *v2; // rbp\n  unsigned __int64 v3; // rax\n  _QWORD *v4; // rbx\n  _QWORD *v5; // rdi\n  _QWORD *v6; // rbx\n  _QWORD *v7; // rdi\n  _QWORD *v8; // rbx\n\n  v2 = (_QWORD *)*ptr;\n  v3 = ptr[1];\n  if ( ptr[8] && ptr[4] )\n  {\n    if ( (unsigned __int64)v2 >= v3 )\n      goto LABEL_15;\n    do\n    {\n      while ( !*v2 )\n      {\n        v2 += 2;\n        if ( v3 <= (unsigned __int64)v2 )\n          goto LABEL_10;\n      }\n      v4 = v2;\n      do\n      {\n        ((void (*)(void))ptr[8])();\n        v4 = (_QWORD *)v4[1];\n      }\n      while ( v4 );\n      v3 = ptr[1];\n      v2 += 2;\n    }\n    while ( v3 > (unsigned __int64)v2 );\nLABEL_10:\n    v2 = (_QWORD *)*ptr;\n  }\n  if ( (unsigned __int64)v2 < v3 )\n  {\n    do\n    {\n      v5 = (_QWORD *)v2[1];\n      if ( v5 )\n      {\n        do\n        {\n          v6 = (_QWORD *)v5[1];\n          free(v5);\n          v5 = v6;\n        }\n        while ( v6 );\n      }\n      v2 += 2;\n    }\n    while ( ptr[1] > (unsigned __int64)v2 );\n  }\nLABEL_15:\n  v7 = (_QWORD *)ptr[9];\n  if ( v7 )\n  {\n    do\n    {\n      v8 = (_QWORD *)v7[1];\n      free(v7);\n      v7 = v8;\n    }\n    while ( v8 );\n  }\n  free((void *)*ptr);\n  free(ptr);\n}\n"
        },
        {
            "funcName": "sub_40C920",
            "funcStartAddr": "0x402f0a",
            "funcEndAddr": "0x402f0f",
            "decompiledFuncCode": "__int64 __fastcall sub_40C920(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rbx\n  _BOOL8 v6; // rax\n  void *v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  unsigned int v12; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h] BYREF\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  unsigned __int64 v16; // [rsp+10h] [rbp-58h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  __int64 v18; // [rsp+20h] [rbp-48h]\n  __int64 v19; // [rsp+28h] [rbp-40h]\n  __int64 v20; // [rsp+30h] [rbp-38h]\n  __int64 v21; // [rsp+38h] [rbp-30h]\n  __int64 v22; // [rsp+40h] [rbp-28h]\n  __int64 v23; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( a2 < 0 )\n      v3 = (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1))\n         + (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5 >> 61 != 0;\n  if ( (v5 & 0x1000000000000000LL) != 0 )\n    v6 = 1LL;\n  if ( !v5 || v6 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v5 )\n    return 1LL;\n  v7 = calloc(v5, 0x10uLL);\n  ptr = v7;\n  if ( !v7 )\n    return 0;\n  v16 = v5;\n  v8 = (__int64)v7 + 16 * v5;\n  v9 = *(_QWORD *)(a1 + 48);\n  v17 = 0LL;\n  v15 = v8;\n  v20 = v9;\n  v10 = *(_QWORD *)(a1 + 56);\n  v18 = 0LL;\n  v21 = v10;\n  v11 = *(_QWORD *)(a1 + 64);\n  v19 = v2;\n  v22 = v11;\n  v23 = *(_QWORD *)(a1 + 72);\n  v12 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v12 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v15;\n    *(_QWORD *)(a1 + 16) = v16;\n    *(_QWORD *)(a1 + 24) = v17;\n    *(_QWORD *)(a1 + 72) = v23;\n    return v12;\n  }\n  *(_QWORD *)(a1 + 72) = v23;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v12;\n}\n\n__int64 __fastcall sub_40C920(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rbx\n  _BOOL8 v6; // rax\n  void *v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  unsigned int v12; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h] BYREF\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  unsigned __int64 v16; // [rsp+10h] [rbp-58h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  __int64 v18; // [rsp+20h] [rbp-48h]\n  __int64 v19; // [rsp+28h] [rbp-40h]\n  __int64 v20; // [rsp+30h] [rbp-38h]\n  __int64 v21; // [rsp+38h] [rbp-30h]\n  __int64 v22; // [rsp+40h] [rbp-28h]\n  __int64 v23; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( a2 < 0 )\n      v3 = (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1))\n         + (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5 >> 61 != 0;\n  if ( (v5 & 0x1000000000000000LL) != 0 )\n    v6 = 1LL;\n  if ( !v5 || v6 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v5 )\n    return 1LL;\n  v7 = calloc(v5, 0x10uLL);\n  ptr = v7;\n  if ( !v7 )\n    return 0;\n  v16 = v5;\n  v8 = (__int64)v7 + 16 * v5;\n  v9 = *(_QWORD *)(a1 + 48);\n  v17 = 0LL;\n  v15 = v8;\n  v20 = v9;\n  v10 = *(_QWORD *)(a1 + 56);\n  v18 = 0LL;\n  v21 = v10;\n  v11 = *(_QWORD *)(a1 + 64);\n  v19 = v2;\n  v22 = v11;\n  v23 = *(_QWORD *)(a1 + 72);\n  v12 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v12 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v15;\n    *(_QWORD *)(a1 + 16) = v16;\n    *(_QWORD *)(a1 + 24) = v17;\n    *(_QWORD *)(a1 + 72) = v23;\n    return v12;\n  }\n  *(_QWORD *)(a1 + 72) = v23;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v12;\n}\n"
        },
        {
            "funcName": "sub_40C920",
            "funcStartAddr": "0x402f0a",
            "funcEndAddr": "0x402f0f",
            "decompiledFuncCode": "__int64 __fastcall sub_40C920(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rbx\n  _BOOL8 v6; // rax\n  void *v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  unsigned int v12; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h] BYREF\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  unsigned __int64 v16; // [rsp+10h] [rbp-58h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  __int64 v18; // [rsp+20h] [rbp-48h]\n  __int64 v19; // [rsp+28h] [rbp-40h]\n  __int64 v20; // [rsp+30h] [rbp-38h]\n  __int64 v21; // [rsp+38h] [rbp-30h]\n  __int64 v22; // [rsp+40h] [rbp-28h]\n  __int64 v23; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( a2 < 0 )\n      v3 = (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1))\n         + (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5 >> 61 != 0;\n  if ( (v5 & 0x1000000000000000LL) != 0 )\n    v6 = 1LL;\n  if ( !v5 || v6 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v5 )\n    return 1LL;\n  v7 = calloc(v5, 0x10uLL);\n  ptr = v7;\n  if ( !v7 )\n    return 0;\n  v16 = v5;\n  v8 = (__int64)v7 + 16 * v5;\n  v9 = *(_QWORD *)(a1 + 48);\n  v17 = 0LL;\n  v15 = v8;\n  v20 = v9;\n  v10 = *(_QWORD *)(a1 + 56);\n  v18 = 0LL;\n  v21 = v10;\n  v11 = *(_QWORD *)(a1 + 64);\n  v19 = v2;\n  v22 = v11;\n  v23 = *(_QWORD *)(a1 + 72);\n  v12 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v12 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v15;\n    *(_QWORD *)(a1 + 16) = v16;\n    *(_QWORD *)(a1 + 24) = v17;\n    *(_QWORD *)(a1 + 72) = v23;\n    return v12;\n  }\n  *(_QWORD *)(a1 + 72) = v23;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v12;\n}\n\n__int64 __fastcall sub_40C920(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rbx\n  _BOOL8 v6; // rax\n  void *v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  unsigned int v12; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h] BYREF\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  unsigned __int64 v16; // [rsp+10h] [rbp-58h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  __int64 v18; // [rsp+20h] [rbp-48h]\n  __int64 v19; // [rsp+28h] [rbp-40h]\n  __int64 v20; // [rsp+30h] [rbp-38h]\n  __int64 v21; // [rsp+38h] [rbp-30h]\n  __int64 v22; // [rsp+40h] [rbp-28h]\n  __int64 v23; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( a2 < 0 )\n      v3 = (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1))\n         + (float)(a2 & 1 | (unsigned int)((unsigned __int64)a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5 >> 61 != 0;\n  if ( (v5 & 0x1000000000000000LL) != 0 )\n    v6 = 1LL;\n  if ( !v5 || v6 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v5 )\n    return 1LL;\n  v7 = calloc(v5, 0x10uLL);\n  ptr = v7;\n  if ( !v7 )\n    return 0;\n  v16 = v5;\n  v8 = (__int64)v7 + 16 * v5;\n  v9 = *(_QWORD *)(a1 + 48);\n  v17 = 0LL;\n  v15 = v8;\n  v20 = v9;\n  v10 = *(_QWORD *)(a1 + 56);\n  v18 = 0LL;\n  v21 = v10;\n  v11 = *(_QWORD *)(a1 + 64);\n  v19 = v2;\n  v22 = v11;\n  v23 = *(_QWORD *)(a1 + 72);\n  v12 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v12 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v15;\n    *(_QWORD *)(a1 + 16) = v16;\n    *(_QWORD *)(a1 + 24) = v17;\n    *(_QWORD *)(a1 + 72) = v23;\n    return v12;\n  }\n  *(_QWORD *)(a1 + 72) = v23;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v12;\n}\n"
        },
        {
            "funcName": "sub_40CB20",
            "funcStartAddr": "0x402f0f",
            "funcEndAddr": "0x402f14",
            "decompiledFuncCode": "__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdx\n  __int64 result; // rax\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  __int64 v10; // rax\n  __m128i *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  __int64 v25; // rsi\n  __m128i *v26[4]; // [rsp+8h] [rbp-20h] BYREF\n\n  if ( !a2 )\n    goto LABEL_35;\n  v5 = sub_40BE60(a1, a2, v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( v7 < 0 )\n    {\n      v14 = v7 & 1 | ((unsigned __int64)v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( v10 >= 0 )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18\n            ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL\n            : (unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, a2, v26, 0) )\n        {\nLABEL_9:\n          v11 = v26[0];\n          if ( !*(_QWORD *)v26[0] )\n          {\n            *(_QWORD *)v26[0] = a2;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11->m128i_i64[1];\n            *v12 = a2;\n            v12[1] = v13;\n            v11->m128i_i64[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( v10 >= 0 )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1))\n                             + (float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( a3 )\n    *a3 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdx\n  __int64 result; // rax\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  __int64 v10; // rax\n  __m128i *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  __int64 v25; // rsi\n  __m128i *v26[4]; // [rsp+8h] [rbp-20h] BYREF\n\n  if ( !a2 )\n    goto LABEL_35;\n  v5 = sub_40BE60(a1, a2, v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( v7 < 0 )\n    {\n      v14 = v7 & 1 | ((unsigned __int64)v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( v10 >= 0 )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18\n            ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL\n            : (unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, a2, v26, 0) )\n        {\nLABEL_9:\n          v11 = v26[0];\n          if ( !*(_QWORD *)v26[0] )\n          {\n            *(_QWORD *)v26[0] = a2;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11->m128i_i64[1];\n            *v12 = a2;\n            v12[1] = v13;\n            v11->m128i_i64[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( v10 >= 0 )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1))\n                             + (float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( a3 )\n    *a3 = v5;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40CB20",
            "funcStartAddr": "0x402f0f",
            "funcEndAddr": "0x402f14",
            "decompiledFuncCode": "__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdx\n  __int64 result; // rax\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  __int64 v10; // rax\n  __m128i *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  __int64 v25; // rsi\n  __m128i *v26[4]; // [rsp+8h] [rbp-20h] BYREF\n\n  if ( !a2 )\n    goto LABEL_35;\n  v5 = sub_40BE60(a1, a2, v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( v7 < 0 )\n    {\n      v14 = v7 & 1 | ((unsigned __int64)v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( v10 >= 0 )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18\n            ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL\n            : (unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, a2, v26, 0) )\n        {\nLABEL_9:\n          v11 = v26[0];\n          if ( !*(_QWORD *)v26[0] )\n          {\n            *(_QWORD *)v26[0] = a2;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11->m128i_i64[1];\n            *v12 = a2;\n            v12[1] = v13;\n            v11->m128i_i64[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( v10 >= 0 )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1))\n                             + (float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( a3 )\n    *a3 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdx\n  __int64 result; // rax\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  __int64 v10; // rax\n  __m128i *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  __int64 v25; // rsi\n  __m128i *v26[4]; // [rsp+8h] [rbp-20h] BYREF\n\n  if ( !a2 )\n    goto LABEL_35;\n  v5 = sub_40BE60(a1, a2, v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( v7 < 0 )\n    {\n      v14 = v7 & 1 | ((unsigned __int64)v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( v10 >= 0 )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18\n            ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL\n            : (unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, a2, v26, 0) )\n        {\nLABEL_9:\n          v11 = v26[0];\n          if ( !*(_QWORD *)v26[0] )\n          {\n            *(_QWORD *)v26[0] = a2;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11->m128i_i64[1];\n            *v12 = a2;\n            v12[1] = v13;\n            v11->m128i_i64[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( v10 >= 0 )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1))\n                             + (float)(v10 & 1 | (unsigned int)((unsigned __int64)v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( a3 )\n    *a3 = v5;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40CDA0",
            "funcStartAddr": "0x40cda0",
            "funcEndAddr": "0x40cddb",
            "decompiledFuncCode": "__int64 __fastcall sub_40CDA0(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  int v3; // eax\n  __int64 v5; // [rsp+8h] [rbp-10h] BYREF\n\n  v2 = a2;\n  v3 = sub_40CB20(a1, a2, &v5);\n  if ( v3 == -1 )\n    return 0LL;\n  if ( !v3 )\n    return v5;\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_40CDE0",
            "funcStartAddr": "0x40cde0",
            "funcEndAddr": "0x40cfb7",
            "decompiledFuncCode": "__int64 __fastcall sub_40CDE0(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rbp\n  __m128i *v4; // rax\n  __int64 v6; // rax\n  float *v7; // rdx\n  float v8; // xmm0_4\n  __int64 v9; // rax\n  float v10; // xmm1_4\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  float v13; // xmm0_4\n  __int64 v14; // rax\n  float v15; // xmm1_4\n  float v16; // xmm0_4\n  __int64 v17; // rsi\n  _QWORD *v18; // rdi\n  _QWORD *v19; // r12\n  int v20; // edx\n  float v21; // xmm0_4\n  __int64 v22; // rcx\n  __int64 v23; // rcx\n  __m128i *v24; // [rsp+8h] [rbp-20h] BYREF\n\n  v3 = sub_40BE60(a1, a2, &v24, 1);\n  if ( !v3 )\n    return v3;\n  v4 = v24;\n  --*(_QWORD *)(a1 + 32);\n  if ( v4->m128i_i64[0] )\n    return v3;\n  v6 = *(_QWORD *)(a1 + 24) - 1LL;\n  *(_QWORD *)(a1 + 24) = v6;\n  if ( v6 < 0 )\n  {\n    v20 = v6 & 1 | ((unsigned __int64)v6 >> 1);\n    v9 = *(_QWORD *)(a1 + 16);\n    v21 = (float)v20;\n    v7 = *(float **)(a1 + 40);\n    v8 = v21 + v21;\n    if ( v9 >= 0 )\n      goto LABEL_6;\nLABEL_22:\n    v10 = (float)(v9 & 1 | (unsigned int)((unsigned __int64)v9 >> 1))\n        + (float)(v9 & 1 | (unsigned int)((unsigned __int64)v9 >> 1));\n    goto LABEL_7;\n  }\n  v7 = *(float **)(a1 + 40);\n  v8 = (float)(int)v6;\n  v9 = *(_QWORD *)(a1 + 16);\n  if ( v9 < 0 )\n    goto LABEL_22;\nLABEL_6:\n  v10 = (float)(int)v9;\nLABEL_7:\n  if ( (float)(v10 * *v7) > v8 )\n  {\n    sub_40BF80((float **)(a1 + 40));\n    v11 = *(_QWORD *)(a1 + 16);\n    v12 = *(_QWORD *)(a1 + 40);\n    if ( v11 < 0 )\n    {\n      v23 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n      v13 = (float)(int)v23 + (float)(int)v23;\n    }\n    else\n    {\n      v13 = (float)(int)v11;\n    }\n    v14 = *(_QWORD *)(a1 + 24);\n    if ( v14 < 0 )\n    {\n      v22 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n      v15 = (float)(int)v22 + (float)(int)v22;\n    }\n    else\n    {\n      v15 = (float)(int)v14;\n    }\n    if ( (float)(*(float *)v12 * v13) > v15 )\n    {\n      v16 = v13 * *(float *)(v12 + 4);\n      if ( !*(_BYTE *)(v12 + 16) )\n        v16 = v16 * *(float *)(v12 + 8);\n      if ( v16 >= 9.223372e18 )\n        v17 = (unsigned int)(int)(float)(v16 - 9.223372e18) ^ 0x8000000000000000LL;\n      else\n        v17 = (unsigned int)(int)v16;\n      if ( !(unsigned __int8)sub_40C920(a1, v17) )\n      {\n        v18 = *(_QWORD **)(a1 + 72);\n        if ( v18 )\n        {\n          do\n          {\n            v19 = (_QWORD *)v18[1];\n            free(v18);\n            v18 = v19;\n          }\n          while ( v19 );\n        }\n        *(_QWORD *)(a1 + 72) = 0LL;\n      }\n    }\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "sub_40CFC0",
            "funcStartAddr": "0x40cfc0",
            "funcEndAddr": "0x40cfc3",
            "decompiledFuncCode": "__int64 sub_40CFC0()\n{\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40CFD0",
            "funcStartAddr": "0x40cfd0",
            "funcEndAddr": "0x40d04d",
            "decompiledFuncCode": "_QWORD *__fastcall sub_40CFD0(__int64 (__fastcall *a1)(), unsigned __int64 a2)\n{\n  __int64 v3; // rbp\n  __int64 v4; // rdx\n  _QWORD *v5; // rbx\n  __int64 v6; // rdi\n  _QWORD *v7; // rax\n  _QWORD *result; // rax\n\n  v3 = a2;\n  v5 = (_QWORD *)sub_411210(32LL);\n  if ( a2 )\n  {\n    v6 = 8 * a2;\n    if ( (a2 & 0x1000000000000000LL) != 0 || a2 >> 61 )\n      sub_411460(v6, a2, v4);\n  }\n  else\n  {\n    v6 = 8LL;\n    v3 = 1LL;\n  }\n  v7 = (_QWORD *)sub_411210(v6);\n  v5[1] = v3;\n  *v7 = 0LL;\n  *v5 = v7;\n  if ( !a1 )\n    a1 = sub_40CFC0;\n  v5[2] = 0LL;\n  result = v5;\n  v5[3] = a1;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40D050",
            "funcStartAddr": "0x40d050",
            "funcEndAddr": "0x40d065",
            "decompiledFuncCode": "void __fastcall sub_40D050(void **ptr)\n{\n  free(*ptr);\n  free(ptr);\n}\n"
        },
        {
            "funcName": "sub_40D070",
            "funcStartAddr": "0x40d070",
            "funcEndAddr": "0x40d184",
            "decompiledFuncCode": "__int64 __fastcall sub_40D070(__int64 *a1, __int64 a2)\n{\n  __int64 v2; // r12\n  __int64 *v3; // rbp\n  unsigned __int64 v4; // rdx\n  unsigned __int64 v5; // rbx\n  __int64 v6; // rax\n  unsigned __int64 v7; // rbx\n  __int64 (__fastcall *v8)(_QWORD, __int64); // r13\n  __int64 v9; // rbp\n  __int64 v10; // r15\n  unsigned __int64 v11; // r14\n  _QWORD *v12; // r12\n  int v13; // eax\n  _QWORD *v14; // rdx\n\n  v2 = a2;\n  v3 = a1;\n  v4 = a1[1];\n  v5 = a1[2];\n  v6 = *a1;\n  if ( v4 - 1 <= v5 )\n  {\n    if ( v6 )\n    {\n      if ( v4 <= 0xAAAAAAAAAAAAAA9LL )\n      {\n        v4 += (v4 >> 1) + 1;\n        a2 = 8 * v4;\nLABEL_11:\n        v3[1] = v4;\n        v6 = sub_411270(v6, a2);\n        v5 = v3[2];\n        *v3 = v6;\n        goto LABEL_2;\n      }\n    }\n    else\n    {\n      if ( !v4 )\n      {\n        a2 = 128LL;\n        v4 = 16LL;\n        goto LABEL_11;\n      }\n      a1 = (__int64 *)(v4 >> 61);\n      a2 = 8 * v4;\n      if ( (v4 & 0x1000000000000000LL) == 0 && !(v4 >> 61) )\n        goto LABEL_11;\n    }\n    sub_411460(a1, a2, v4);\n  }\nLABEL_2:\n  v7 = v5 + 1;\n  v3[2] = v7;\n  *(_QWORD *)(v6 + 8 * v7) = v2;\n  v8 = (__int64 (__fastcall *)(_QWORD, __int64))v3[3];\n  v9 = *v3;\n  v10 = *(_QWORD *)(v9 + 8 * v7);\n  if ( v7 == 1 )\n  {\nLABEL_7:\n    v14 = (_QWORD *)(v9 + 8);\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v11 = v7 >> 1;\n      v12 = (_QWORD *)(v9 + 8 * (v7 >> 1));\n      v13 = v8(*v12, v10);\n      v14 = (_QWORD *)(v9 + 8 * v7);\n      if ( v13 > 0 )\n        break;\n      v7 >>= 1;\n      *v14 = *v12;\n      if ( v11 == 1 )\n        goto LABEL_7;\n    }\n  }\n  *v14 = v10;\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40D190",
            "funcStartAddr": "0x40d190",
            "funcEndAddr": "0x40d2ad",
            "decompiledFuncCode": "__int64 __fastcall sub_40D190(_QWORD *a1)\n{\n  __int64 v1; // rax\n  __int64 v2; // rdx\n  unsigned __int64 v3; // rbp\n  __int64 v4; // rax\n  __int64 v5; // rcx\n  __int64 v6; // r15\n  int (__fastcall *v7)(_QWORD, __int64); // r13\n  __int64 v8; // r14\n  _QWORD *v9; // rbx\n  int v10; // eax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // r12\n  __int64 v14; // [rsp+8h] [rbp-60h]\n  __int64 v15; // [rsp+10h] [rbp-58h]\n\n  v1 = a1[2];\n  v14 = 0LL;\n  if ( v1 )\n  {\n    v2 = *a1;\n    v3 = v1 - 1;\n    v4 = *(_QWORD *)(*a1 + 8 * v1);\n    v5 = *(_QWORD *)(*a1 + 8LL);\n    a1[2] = v3;\n    *(_QWORD *)(v2 + 8) = v4;\n    v6 = *a1;\n    v14 = v5;\n    v7 = (int (__fastcall *)(_QWORD, __int64))a1[3];\n    v15 = *(_QWORD *)(*a1 + 8LL);\n    if ( v3 >> 1 )\n    {\n      v8 = 1LL;\n      while ( 1 )\n      {\n        v12 = 2 * v8;\n        if ( v3 <= 2 * v8 )\n        {\n          v9 = (_QWORD *)(v6 + 16 * v8);\n        }\n        else\n        {\n          v9 = (_QWORD *)(v6 + 16 * v8);\n          if ( v7(*v9, *(_QWORD *)(v6 + 8 * (v12 + 1))) < 0 )\n            v9 = (_QWORD *)(v6 + 8 * ++v12);\n        }\n        v10 = v7(*v9, v15);\n        v11 = (_QWORD *)(v6 + 8 * v8);\n        if ( v10 <= 0 )\n          break;\n        v8 = v12;\n        *v11 = *v9;\n        if ( v12 > v3 >> 1 )\n        {\n          *v9 = v15;\n          return v14;\n        }\n      }\n    }\n    else\n    {\n      v11 = (_QWORD *)(v6 + 8);\n    }\n    *v11 = v15;\n  }\n  return v14;\n}\n"
        },
        {
            "funcName": "sub_40D2B0",
            "funcStartAddr": "0x40d2b0",
            "funcEndAddr": "0x40d32c",
            "decompiledFuncCode": "__int64 __fastcall sub_40D2B0(int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n  char v4; // al\n\n  v2 = a2 + 11;\n  *(_BYTE *)(a2 + 11) = 0;\n  if ( a1 < 0 )\n  {\n    while ( 1 )\n    {\n      v4 = 10 * (a1 / 10) + 48 - a1;\n      a1 /= 10;\n      *(_BYTE *)(v2 - 1) = v4;\n      if ( !a1 )\n        break;\n      --v2;\n    }\n    *(_BYTE *)(v2 - 2) = 45;\n    return v2 - 2;\n  }\n  else\n  {\n    do\n    {\n      *(_BYTE *)--v2 = a1 % 0xAu + 48;\n      a1 /= 0xAu;\n    }\n    while ( a1 );\n    return v2;\n  }\n}\n"
        },
        {
            "funcName": "sub_40D330",
            "funcStartAddr": "0x40d330",
            "funcEndAddr": "0x40d369",
            "decompiledFuncCode": "__int64 __fastcall sub_40D330(unsigned int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n\n  v2 = a2 + 10;\n  *(_BYTE *)(a2 + 10) = 0;\n  while ( 1 )\n  {\n    *(_BYTE *)--v2 = a1 % 0xA + 48;\n    if ( a1 <= 9 )\n      break;\n    a1 /= 0xAu;\n  }\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_40D370",
            "funcStartAddr": "0x40d370",
            "funcEndAddr": "0x40d3b8",
            "decompiledFuncCode": "__int64 __fastcall sub_40D370(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v2; // rcx\n\n  v2 = a2 + 20;\n  *(_BYTE *)(a2 + 20) = 0;\n  while ( 1 )\n  {\n    *(_BYTE *)--v2 = a1 % 0xA + 48;\n    if ( a1 <= 9 )\n      break;\n    a1 /= 0xAuLL;\n  }\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_40D3C0",
            "funcStartAddr": "0x40d3c0",
            "funcEndAddr": "0x40d573",
            "decompiledFuncCode": "__int64 __fastcall sub_40D3C0(char *s, __int64 a2, char a3)\n{\n  char *v4; // r13\n  char *v5; // rbx\n  unsigned int v6; // r12d\n  char v7; // al\n  __int64 v8; // rax\n  __int64 v9; // rbp\n  int v10; // eax\n  int v12; // r15d\n  const unsigned __int16 *v13; // rdx\n  unsigned __int16 v14; // ax\n  wchar_t c; // [rsp+4h] [rbp-44h] BYREF\n  mbstate_t ps; // [rsp+8h] [rbp-40h] BYREF\n\n  v4 = &s[a2];\n  v5 = s;\n  if ( __ctype_get_mb_cur_max() <= 1 )\n  {\n    v6 = 0;\n    if ( s >= v4 )\n      return v6;\n    v6 = 0;\n    v12 = a3 & 2;\n    v13 = *__ctype_b_loc();\n    while ( 1 )\n    {\n      v14 = v13[(unsigned __int8)*v5++];\n      if ( (v14 & 0x4000) != 0 )\n        goto LABEL_33;\n      if ( v12 )\n        return (unsigned int)-1;\n      if ( (v14 & 2) == 0 )\n      {\nLABEL_33:\n        if ( v6 == 0x7FFFFFFF )\n          return v6;\n        ++v6;\n      }\n      if ( v4 == v5 )\n        return v6;\n    }\n  }\n  v6 = 0;\n  if ( s < v4 )\n  {\n    do\n    {\n      v7 = *v5;\n      if ( *v5 <= 63 )\n      {\n        if ( v7 < 37 && (unsigned __int8)(v7 - 32) > 3u )\n        {\nLABEL_12:\n          ps = 0LL;\n          while ( 1 )\n          {\n            v8 = sub_412FB0(&c, v5);\n            v9 = v8;\n            if ( v8 == -1 )\n            {\n              if ( (a3 & 1) == 0 )\n                goto LABEL_6;\n              return (unsigned int)-1;\n            }\n            if ( v8 == -2 )\n              break;\n            if ( !v8 )\n              v9 = 1LL;\n            v10 = wcwidth(c);\n            if ( v10 >= 0 )\n            {\n              if ( (int)(0x7FFFFFFF - v6) < v10 )\n                return 0x7FFFFFFF;\n              v6 += v10;\n            }\n            else\n            {\n              if ( (a3 & 2) != 0 )\n                return (unsigned int)-1;\n              if ( !iswcntrl(c) )\n              {\n                if ( v6 == 0x7FFFFFFF )\n                  return 0x7FFFFFFF;\n                ++v6;\n              }\n            }\n            v5 += v9;\n            if ( mbsinit(&ps) )\n              goto LABEL_7;\n          }\n          if ( (a3 & 1) != 0 )\n            return (unsigned int)-1;\n          ++v6;\n          v5 = &s[a2];\n          continue;\n        }\n      }\n      else if ( v7 < 65 || v7 > 95 && (unsigned __int8)(v7 - 97) > 0x1Du )\n      {\n        goto LABEL_12;\n      }\nLABEL_6:\n      ++v5;\n      ++v6;\nLABEL_7:\n      ;\n    }\n    while ( v5 < v4 );\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "sub_40D580",
            "funcStartAddr": "0x40d580",
            "funcEndAddr": "0x40d5a3",
            "decompiledFuncCode": "__int64 __fastcall sub_40D580(char *s, char a2)\n{\n  __int64 v2; // rax\n\n  v2 = strlen(s);\n  return sub_40D3C0(s, v2, a2);\n}\n"
        },
        {
            "funcName": "sub_40D5B0",
            "funcStartAddr": "0x40d5b0",
            "funcEndAddr": "0x40d5f4",
            "decompiledFuncCode": "__int64 sub_40D5B0()\n{\n  __int64 result; // rax\n  cpu_set_t v1; // [rsp+0h] [rbp-88h] BYREF\n\n  if ( sched_getaffinity(0, 0x80uLL, &v1) )\n    return 0LL;\n  result = __sched_cpucount(0x80uLL, &v1);\n  if ( !(_DWORD)result )\n    return 0LL;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40D600",
            "funcStartAddr": "0x40d600",
            "funcEndAddr": "0x40d6eb",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40D600(const char *a1)\n{\n  unsigned __int64 v1; // rcx\n  int v2; // eax\n  __int64 v3; // rdx\n  char v4; // cl\n  unsigned int v5; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v7; // rcx\n  __int64 v8; // rsi\n  char *v9; // rdx\n  char *endptr; // [rsp+0h] [rbp-10h] BYREF\n\n  v1 = *(unsigned __int8 *)a1;\n  if ( !(_BYTE)v1 )\n    return 0LL;\n  v2 = (char)v1;\n  if ( (unsigned int)(char)v1 <= 0x20 )\n  {\n    v3 = 0x100003E00LL;\n    if ( _bittest64(&v3, v1) )\n    {\n      do\n      {\n        v4 = *++a1;\n        if ( !*a1 )\n          return 0LL;\n        v2 = v4;\n      }\n      while ( (unsigned int)v4 <= 0x20 && ((1LL << v4) & 0x100003E00LL) != 0 );\n    }\n  }\n  v5 = v2 - 48;\n  result = 0LL;\n  if ( v5 <= 9 )\n  {\n    endptr = 0LL;\n    result = strtoul(a1, &endptr, 10);\n    if ( endptr )\n    {\n      v7 = (unsigned __int8)*endptr;\n      if ( !(_BYTE)v7 )\n        return result;\n      if ( (unsigned int)(char)v7 <= 0x20 )\n      {\n        v8 = 0x100003E00LL;\n        if ( _bittest64(&v8, v7) )\n        {\n          v9 = endptr + 1;\n          while ( 1 )\n          {\n            endptr = v9;\n            LOBYTE(v7) = *v9;\n            if ( !*v9 )\n              return result;\n            if ( (unsigned int)(char)v7 <= 0x20 )\n            {\n              ++v9;\n              if ( ((1LL << v7) & 0x100003E00LL) != 0 )\n                continue;\n            }\n            break;\n          }\n        }\n      }\n      if ( (_BYTE)v7 == 44 )\n        return result;\n    }\n    return 0LL;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40D6F0",
            "funcStartAddr": "0x40d6f0",
            "funcEndAddr": "0x40d837",
            "decompiledFuncCode": "__int64 __fastcall sub_40D6F0(int a1)\n{\n  __int64 result; // rax\n  char *v2; // rax\n  unsigned __int64 v3; // rbp\n  unsigned __int64 v4; // rbx\n  char *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rdx\n  char *v8; // rax\n\n  if ( a1 == 2 )\n  {\n    v2 = getenv(\"OMP_NUM_THREADS\");\n    if ( v2 )\n    {\n      v3 = -1LL;\n      v4 = sub_40D600(v2);\n      v5 = getenv(\"OMP_THREAD_LIMIT\");\n      if ( v5 )\n      {\n        v3 = sub_40D600(v5);\n        if ( !v3 )\n          v3 = -1LL;\n      }\n      if ( v4 )\n      {\n        result = v4;\n        if ( v3 <= v4 )\n          return v3;\n        return result;\n      }\n    }\n    else\n    {\n      v8 = getenv(\"OMP_THREAD_LIMIT\");\n      if ( !v8 )\n        goto LABEL_27;\n      v3 = sub_40D600(v8);\n      if ( !v3 )\n        goto LABEL_27;\n    }\nLABEL_12:\n    result = sub_40D5B0();\n    if ( result )\n    {\n      if ( result > v3 )\n        return v3;\n    }\n    else\n    {\n      v6 = sysconf(84);\n      result = 1LL;\n      if ( v6 > 0 )\n      {\n        result = v3;\n        if ( v6 <= v3 )\n          return v6;\n      }\n    }\n    return result;\n  }\n  if ( a1 == 1 )\n  {\nLABEL_27:\n    v3 = -1LL;\n    goto LABEL_12;\n  }\n  result = sysconf(83);\n  if ( result == 1 )\n  {\n    v7 = sub_40D5B0();\n    result = 1LL;\n    if ( !v7 )\n      return result;\n    result = v7;\n  }\n  if ( result <= 0 )\n    return 1LL;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40D840",
            "funcStartAddr": "0x40d840",
            "funcEndAddr": "0x40d8fb",
            "decompiledFuncCode": "double sub_40D840()\n{\n  int v0; // eax\n  double totalram_low; // xmm0_8\n  double mem_unit; // xmm1_8\n  double result; // xmm0_8\n  double v4; // [rsp+8h] [rbp-80h]\n  struct sysinfo v5; // [rsp+10h] [rbp-78h] BYREF\n\n  v4 = (double)(int)sysconf(85);\n  v0 = sysconf(30);\n  totalram_low = v4;\n  if ( v4 < 0.0 || (mem_unit = (double)v0, (double)v0 < 0.0) )\n  {\n    result = 67108864.0;\n    if ( sysinfo(&v5) )\n      return result;\n    if ( (v5.totalram & 0x8000000000000000LL) != 0LL )\n      totalram_low = (double)(int)(v5.totalram & 1 | (v5.totalram >> 1))\n                   + (double)(int)(v5.totalram & 1 | (v5.totalram >> 1));\n    else\n      totalram_low = (double)SLODWORD(v5.totalram);\n    mem_unit = (double)(int)v5.mem_unit;\n  }\n  return totalram_low * mem_unit;\n}\n"
        },
        {
            "funcName": "sub_40D900",
            "funcStartAddr": "0x40d900",
            "funcEndAddr": "0x40d9f6",
            "decompiledFuncCode": "double sub_40D900()\n{\n  int v0; // eax\n  double v1; // xmm0_8\n  double mem_unit; // xmm1_8\n  double freeram_low; // xmm0_8\n  __kernel_ulong_t bufferram; // rax\n  double v5; // xmm1_8\n  double v7; // [rsp+8h] [rbp-80h]\n  struct sysinfo v8; // [rsp+10h] [rbp-78h] BYREF\n\n  v7 = (double)(int)sysconf(86);\n  v0 = sysconf(30);\n  v1 = v7;\n  if ( v7 >= 0.0 )\n  {\n    mem_unit = (double)v0;\n    if ( (double)v0 >= 0.0 )\n      return v1 * mem_unit;\n  }\n  if ( !sysinfo(&v8) )\n  {\n    if ( (v8.freeram & 0x8000000000000000LL) != 0LL )\n    {\n      bufferram = v8.bufferram;\n      freeram_low = (double)(int)(v8.freeram & 1 | (v8.freeram >> 1))\n                  + (double)(int)(v8.freeram & 1 | (v8.freeram >> 1));\n      if ( (v8.bufferram & 0x8000000000000000LL) == 0LL )\n        goto LABEL_6;\n    }\n    else\n    {\n      freeram_low = (double)SLODWORD(v8.freeram);\n      bufferram = v8.bufferram;\n      if ( (v8.bufferram & 0x8000000000000000LL) == 0LL )\n      {\nLABEL_6:\n        v5 = (double)(int)bufferram;\nLABEL_7:\n        v1 = freeram_low + v5;\n        mem_unit = (double)(int)v8.mem_unit;\n        return v1 * mem_unit;\n      }\n    }\n    v5 = (double)(int)(bufferram & 1 | (bufferram >> 1)) + (double)(int)(bufferram & 1 | (bufferram >> 1));\n    goto LABEL_7;\n  }\n  return sub_40D840() * 0.25;\n}\n"
        },
        {
            "funcName": "sub_40DA00",
            "funcStartAddr": "0x40da00",
            "funcEndAddr": "0x40dbd1",
            "decompiledFuncCode": "__int64 __fastcall sub_40DA00(int pipedes[2], int a2)\n{\n  __int64 v2; // r13\n  unsigned int v3; // r12d\n  int v4; // ecx\n  int v5; // r8d\n  int v6; // r9d\n  int v8; // eax\n  int v9; // ecx\n  int v10; // r8d\n  int v11; // r9d\n  int v12; // ecx\n  int v13; // r8d\n  int v14; // r9d\n  int v15; // eax\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n  int *v19; // rax\n  int v20; // r12d\n  int *v21; // rbp\n  int v22; // eax\n  int v23; // ecx\n  int v24; // r8d\n  int v25; // r9d\n  int v26; // ecx\n  int v27; // r8d\n  int v28; // r9d\n  int v29; // eax\n  int v30; // ecx\n  int v31; // r8d\n  int v32; // r9d\n  int v33; // r12d\n\n  v2 = *(_QWORD *)pipedes;\n  if ( dword_61CBC0 >= 0 )\n  {\n    v33 = pipe2(pipedes, a2);\n    if ( v33 >= 0 || *__errno_location() != 38 )\n    {\n      dword_61CBC0 = 1;\n      return (unsigned int)v33;\n    }\n    dword_61CBC0 = -1;\n  }\n  v3 = a2 & 0xFFF7F7FF;\n  if ( (a2 & 0xFFF7F7FF) != 0 )\n  {\n    v3 = -1;\n    *__errno_location() = 22;\n    return v3;\n  }\n  if ( pipe(pipedes) < 0 )\n    return (unsigned int)-1;\n  if ( (a2 & 0x800) != 0 )\n  {\n    v8 = sub_412000(pipedes[1], 3, 0, v4, v5, v6);\n    if ( v8 < 0 )\n      goto LABEL_11;\n    BYTE1(v8) |= 8u;\n    if ( (unsigned int)sub_412000(pipedes[1], 4, v8, v9, v10, v11) == -1 )\n      goto LABEL_11;\n    v15 = sub_412000(*pipedes, 3, 0, v12, v13, v14);\n    if ( v15 < 0 )\n      goto LABEL_11;\n    BYTE1(v15) |= 8u;\n    if ( (unsigned int)sub_412000(*pipedes, 4, v15, v16, v17, v18) == -1 )\n      goto LABEL_11;\n  }\n  if ( (a2 & 0x80000) == 0 )\n    return v3;\n  v22 = sub_412000(pipedes[1], 1, 0, v4, v5, v6);\n  if ( v22 < 0\n    || (unsigned int)sub_412000(pipedes[1], 2, v22 | 1u, v23, v24, v25) == -1\n    || (v29 = sub_412000(*pipedes, 1, 0, v26, v27, v28), v29 < 0)\n    || (unsigned int)sub_412000(*pipedes, 2, v29 | 1u, v30, v31, v32) == -1 )\n  {\nLABEL_11:\n    v19 = __errno_location();\n    v20 = *v19;\n    v21 = v19;\n    close(*pipedes);\n    close(pipedes[1]);\n    *(_QWORD *)pipedes = v2;\n    *v21 = v20;\n    return (unsigned int)-1;\n  }\n  return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40DBE0",
            "funcStartAddr": "0x40dbe0",
            "funcEndAddr": "0x40dc52",
            "decompiledFuncCode": "__int64 sub_40DBE0()\n{\n  unsigned int v0; // ebx\n  char *v1; // rax\n  __int64 v3; // rax\n  unsigned int v4; // ebx\n  char *endptr; // [rsp+8h] [rbp-10h] BYREF\n\n  v0 = 200809;\n  v1 = getenv(\"_POSIX2_VERSION\");\n  if ( !v1 )\n    return v0;\n  if ( !*v1 )\n    return v0;\n  v3 = strtol(v1, &endptr, 10);\n  if ( *endptr )\n    return v0;\n  if ( v3 < (__int64)0xFFFFFFFF80000000LL )\n    return 0x80000000;\n  v4 = 0x7FFFFFFF;\n  if ( v3 <= 0x7FFFFFFF )\n    return (unsigned int)v3;\n  return v4;\n}\n"
        },
        {
            "funcName": "sub_40DC60",
            "funcStartAddr": "0x40dc60",
            "funcEndAddr": "0x40dcf9",
            "decompiledFuncCode": "char *__fastcall sub_40DC60(const char *a1)\n{\n  __int64 v1; // rbx\n  char *result; // rax\n\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v1 = (__int64)a1;\n  result = strrchr(a1, 47);\n  if ( result )\n  {\n    if ( result + 1 - a1 > 6 && !memcmp(result - 6, \"/.libs/\", 7uLL) )\n    {\n      v1 = (__int64)(result + 1);\n      if ( !memcmp(result + 1, \"lt-\", 3uLL) )\n      {\n        v1 = (__int64)(result + 4);\n        program_invocation_short_name = (__int64)(result + 4);\n      }\n    }\n  }\n  qword_61CBC8 = v1;\n  program_invocation_name = v1;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40DD00",
            "funcStartAddr": "0x40dd00",
            "funcEndAddr": "0x40ddf2",
            "decompiledFuncCode": "const char *__fastcall sub_40DD00(char *msgid, int a2)\n{\n  char *v2; // rbx\n  _BYTE *v4; // rax\n  bool v5; // zf\n  const char *v6; // rbx\n\n  v2 = dcgettext(0LL, msgid, 5);\n  if ( msgid != v2 )\n    return v2;\n  v4 = (_BYTE *)sub_413750();\n  if ( (*v4 & 0xDF) == 85 )\n  {\n    if ( (v4[1] & 0xDF) == 84 && (v4[2] & 0xDF) == 70 && v4[3] == 45 && v4[4] == 56 && !v4[5] )\n    {\n      v5 = *v2 == 96;\n      v2 = (char *)&unk_416C61;\n      if ( !v5 )\n        return (const char *)&unk_416C56;\n      return v2;\n    }\n  }\n  else if ( (*v4 & 0xDF) == 71\n         && (v4[1] & 0xDF) == 66\n         && v4[2] == 49\n         && v4[3] == 56\n         && v4[4] == 48\n         && v4[5] == 51\n         && v4[6] == 48\n         && !v4[7] )\n  {\n    v5 = *v2 == 96;\n    v2 = (char *)&unk_416C5D;\n    if ( !v5 )\n      return (const char *)&unk_416C5A;\n    return v2;\n  }\n  v6 = \"\\\"\";\n  if ( a2 != 9 )\n    return \"invalid number after ','\" + 23;\n  return v6;\n}\n"
        },
        {
            "funcName": "sub_40DE00",
            "funcStartAddr": "0x402f14",
            "funcEndAddr": "0x402f19",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40DE00(\n        _BYTE *a1,\n        unsigned __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        int a5,\n        int a6,\n        __int64 a7,\n        const char *a8,\n        char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v12; // ebp\n  unsigned __int64 v13; // r11\n  int v14; // r10d\n  unsigned __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  unsigned __int64 v17; // r12\n  int v18; // r11d\n  _BYTE *v19; // r8\n  size_t v20; // rax\n  int v21; // eax\n  unsigned __int64 v22; // rbp\n  bool v23; // al\n  unsigned __int8 v24; // dl\n  const unsigned __int16 **v25; // rax\n  int v26; // eax\n  char v27; // di\n  unsigned __int64 v28; // rdx\n  char v29; // cl\n  int v30; // r13d\n  unsigned __int8 v31; // al\n  bool v33; // dl\n  unsigned __int64 v34; // rcx\n  unsigned __int64 v35; // rdi\n  int v36; // edx\n  unsigned __int8 v37; // al\n  unsigned __int8 v38; // al\n  int v39; // r13d\n  bool v40; // dl\n  bool v41; // dl\n  bool v42; // al\n  size_t v43; // rax\n  const unsigned __int16 **v44; // rbx\n  char *v45; // r15\n  const unsigned __int16 **v46; // r14\n  char *v47; // rax\n  int v48; // esi\n  unsigned __int64 v49; // rcx\n  unsigned __int8 v50; // di\n  char *v51; // rax\n  size_t v52; // rax\n  __int64 v53; // rsi\n  char *v54; // rsi\n  _BYTE *v55; // rcx\n  char i; // al\n  char v57; // dl\n  const char *v58; // rax\n  unsigned __int8 v60; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v61; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v62; // [rsp+10h] [rbp-B8h]\n  char v63; // [rsp+1Fh] [rbp-A9h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  _BYTE *v66; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v67; // [rsp+30h] [rbp-98h]\n  _BYTE *v68; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v69; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v70; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v71; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v72; // [rsp+38h] [rbp-90h]\n  char v73; // [rsp+38h] [rbp-90h]\n  int v74; // [rsp+38h] [rbp-90h]\n  int v75; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v76; // [rsp+40h] [rbp-88h]\n  int v77; // [rsp+40h] [rbp-88h]\n  int v78; // [rsp+40h] [rbp-88h]\n  _BYTE *v79; // [rsp+40h] [rbp-88h]\n  int v80; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v81; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  unsigned __int64 v83; // [rsp+58h] [rbp-70h]\n  size_t mb_cur_max; // [rsp+60h] [rbp-68h]\n  bool v86; // [rsp+6Ch] [rbp-5Ch]\n  char v87; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v88; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v89; // [rsp+70h] [rbp-58h]\n  _BYTE *v90; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h] BYREF\n  mbstate_t ps; // [rsp+88h] [rbp-40h] BYREF\n\n  v9 = a1;\n  v10 = a2;\n  v12 = a6 & 2;\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v86 = v12 != 0;\n  v13 = a4;\n  switch ( a5 )\n  {\n    case 0:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v60 = 0;\n        goto LABEL_216;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 2;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        a5 = 2;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v60 = 1;\nLABEL_216:\n      if ( a2 )\n      {\n        v14 = 0;\n        v42 = 0;\n        v63 = 1;\n        v83 = 0LL;\n        goto LABEL_142;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 1LL;\n      a5 = 2;\n      v83 = 0LL;\n      v87 = 0;\n      v86 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v16 = v13;\n      v17 = 0LL;\n      v18 = a5;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(a5) = v16 != v17;\n        if ( v16 == -1LL )\n          LOBYTE(a5) = *(_BYTE *)(a3 + v17) != 0;\n        if ( !(_BYTE)a5 )\n        {\n          v39 = v18;\n          v13 = v16;\n          v40 = v39 == 2;\n          if ( !v15 && v40 && v86 )\n          {\n            v30 = 2;\n            goto LABEL_72;\n          }\n          v41 = !v86 && v40;\n          if ( v41 )\n          {\n            if ( v87 )\n            {\n              if ( v63 )\n                return sub_40DE00((int)v9, v83, a3, v16, 5, a6, a7, (__int64)a8, a9);\n              v42 = v83 != 0 && v10 == 0;\n              if ( v42 )\n              {\n                v10 = v83;\nLABEL_142:\n                *v9 = 39;\n                a5 = 2;\n                v15 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v86 = 0;\n                v87 = v42;\n                goto LABEL_3;\n              }\n              v41 = v87;\n            }\n          }\n          else\n          {\n            v41 = !v86;\n          }\n          if ( s2 )\n          {\n            if ( v41 )\n            {\n              v57 = *s2;\n              if ( *s2 )\n              {\n                v58 = &s2[-v15];\n                do\n                {\n                  if ( v10 > v15 )\n                    v9[v15] = v57;\n                  v57 = v58[++v15];\n                }\n                while ( v57 );\n              }\n            }\n          }\n          if ( v10 > v15 )\n            v9[v15] = 0;\n          return v15;\n        }\n        v19 = (_BYTE *)(a3 + v17);\n        v61 = v60 & (v18 != 2);\n        if ( !v61 )\n          break;\n        if ( n )\n        {\n          if ( v16 == -1LL && n > 1 )\n          {\n            v75 = v18;\n            v70 = v14;\n            v20 = strlen((const char *)a3);\n            v18 = v75;\n            v14 = v70;\n            v19 = (_BYTE *)(a3 + v17);\n            v16 = v20;\n          }\n          if ( v17 + n <= v16 )\n          {\n            v80 = v18;\n            v76 = v16;\n            v71 = v14;\n            v66 = v19;\n            v21 = memcmp(v19, s2, n);\n            v19 = v66;\n            v14 = v71;\n            v16 = v76;\n            v18 = v80;\n            if ( !v21 )\n            {\n              if ( !v86 )\n              {\n                LOBYTE(v22) = *v66;\n                switch ( *v66 )\n                {\n                  case 0:\n                    goto LABEL_87;\n                  case 7:\n                    LOBYTE(v22) = 97;\n                    goto LABEL_83;\n                  case 8:\n                    v24 = 0;\n                    a5 = 0;\n                    LOBYTE(v22) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_76;\n                  case 0xA:\n                    goto LABEL_68;\n                  case 0xB:\n                    goto LABEL_84;\n                  case 0xC:\n                    goto LABEL_81;\n                  case 0xD:\n                    goto LABEL_80;\n                  case 0x20:\n                    v37 = v61;\n                    goto LABEL_132;\n                  case 0x21:\n                  case 0x22:\n                  case 0x24:\n                  case 0x26:\n                  case 0x28:\n                  case 0x29:\n                  case 0x2A:\n                  case 0x3B:\n                  case 0x3C:\n                  case 0x3D:\n                  case 0x3E:\n                  case 0x5B:\n                  case 0x5E:\n                  case 0x60:\n                  case 0x7C:\n                    goto LABEL_78;\n                  case 0x23:\n                  case 0x7E:\n                    v38 = v61;\n                    goto LABEL_129;\n                  case 0x25:\n                  case 0x2B:\n                  case 0x2C:\n                  case 0x2D:\n                  case 0x2E:\n                  case 0x2F:\n                  case 0x30:\n                  case 0x31:\n                  case 0x32:\n                  case 0x33:\n                  case 0x34:\n                  case 0x35:\n                  case 0x36:\n                  case 0x37:\n                  case 0x38:\n                  case 0x39:\n                  case 0x3A:\n                  case 0x41:\n                  case 0x42:\n                  case 0x43:\n                  case 0x44:\n                  case 0x45:\n                  case 0x46:\n                  case 0x47:\n                  case 0x48:\n                  case 0x49:\n                  case 0x4A:\n                  case 0x4B:\n                  case 0x4C:\n                  case 0x4D:\n                  case 0x4E:\n                  case 0x4F:\n                  case 0x50:\n                  case 0x51:\n                  case 0x52:\n                  case 0x53:\n                  case 0x54:\n                  case 0x55:\n                  case 0x56:\n                  case 0x57:\n                  case 0x58:\n                  case 0x59:\n                  case 0x5A:\n                  case 0x5D:\n                  case 0x5F:\n                  case 0x61:\n                  case 0x62:\n                  case 0x63:\n                  case 0x64:\n                  case 0x65:\n                  case 0x66:\n                  case 0x67:\n                  case 0x68:\n                  case 0x69:\n                  case 0x6A:\n                  case 0x6B:\n                  case 0x6C:\n                  case 0x6D:\n                  case 0x6E:\n                  case 0x6F:\n                  case 0x70:\n                  case 0x71:\n                  case 0x72:\n                  case 0x73:\n                  case 0x74:\n                  case 0x75:\n                  case 0x76:\n                  case 0x77:\n                  case 0x78:\n                  case 0x79:\n                  case 0x7A:\n                    v37 = v61;\n                    goto LABEL_127;\n                  case 0x27:\n                    goto LABEL_62;\n                  case 0x3F:\n                    goto LABEL_58;\n                  case 0x5C:\n                    goto LABEL_65;\n                  case 0x7B:\n                  case 0x7D:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_102;\n                }\n              }\nLABEL_277:\n              v30 = v18;\n              LODWORD(v13) = v16;\n              return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n            }\n          }\n        }\n        LOBYTE(v22) = *v19;\n        switch ( *v19 )\n        {\n          case 0:\n            goto LABEL_85;\n          case 7:\n            LOBYTE(v22) = 97;\n            goto LABEL_82;\n          case 8:\n            LOBYTE(v22) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_76:\n            LOBYTE(v22) = 116;\n            goto LABEL_69;\n          case 0xA:\nLABEL_68:\n            LOBYTE(v22) = 110;\nLABEL_69:\n            v24 = 0;\n            a5 = 0;\n            if ( v86 )\n              goto LABEL_70;\n            goto LABEL_29;\n          case 0xB:\nLABEL_84:\n            LOBYTE(v22) = 118;\n            goto LABEL_82;\n          case 0xC:\nLABEL_81:\n            LOBYTE(v22) = 102;\nLABEL_82:\n            if ( v86 )\n            {\n              v30 = v18;\n              v31 = 0;\n              LODWORD(v13) = v16;\n              goto LABEL_71;\n            }\nLABEL_83:\n            a5 = 0;\n            goto LABEL_37;\n          case 0xD:\n            v61 = 0;\nLABEL_80:\n            LOBYTE(v22) = 13;\n            v29 = 114;\n            v24 = v18 == 2;\n            goto LABEL_66;\n          case 0x20:\n            v37 = 0;\nLABEL_132:\n            LOBYTE(v22) = 32;\n            goto LABEL_127;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2A:\n          case 0x3B:\n          case 0x3C:\n          case 0x3D:\n          case 0x3E:\n          case 0x5B:\n          case 0x5E:\n          case 0x60:\n          case 0x7C:\n            v61 = 0;\nLABEL_78:\n            v24 = 0;\n            goto LABEL_67;\n          case 0x23:\n          case 0x7E:\n            v38 = 0;\nLABEL_129:\n            if ( !v17 )\n            {\n              a5 = v61;\n              v24 = 0;\n              v61 = v38;\n              goto LABEL_23;\n            }\n            v61 = v38;\n            a5 = 0;\n            break;\n          case 0x25:\n          case 0x2B:\n          case 0x2C:\n          case 0x2D:\n          case 0x2E:\n          case 0x2F:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3A:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4A:\n          case 0x4B:\n          case 0x4C:\n          case 0x4D:\n          case 0x4E:\n          case 0x4F:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5A:\n          case 0x5D:\n          case 0x5F:\n          case 0x61:\n          case 0x62:\n          case 0x63:\n          case 0x64:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6A:\n          case 0x6B:\n          case 0x6C:\n          case 0x6D:\n          case 0x6E:\n          case 0x6F:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7A:\n            v37 = 0;\nLABEL_127:\n            a5 = v61;\n            v61 = v37;\n            LOBYTE(v25) = 0;\n            goto LABEL_25;\n          case 0x27:\n            v61 = 0;\n            goto LABEL_62;\n          case 0x3F:\n            v61 = 0;\n            goto LABEL_58;\n          case 0x5C:\n            v61 = 0;\n            goto LABEL_65;\n          case 0x7B:\n          case 0x7D:\n            v61 = 0;\n            goto LABEL_17;\n          default:\n            v61 = 0;\n            goto LABEL_102;\n        }\nLABEL_24:\n        LOBYTE(v25) = 0;\nLABEL_25:\n        if ( a7 && ((*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v22 >> 5)) >> v22) & 1) != 0 )\n        {\n          v24 = v18 == 2;\nLABEL_28:\n          if ( v86 )\n          {\nLABEL_70:\n            v30 = v18;\n            v31 = v24;\n            LODWORD(v13) = v16;\nLABEL_71:\n            v60 &= v31;\n            goto LABEL_72;\n          }\nLABEL_29:\n          v26 = v14 ^ 1;\n          if ( (v24 & ((unsigned __int8)v14 ^ 1)) != 0 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v15 + 1 < v10 )\n              v9[v15 + 1] = 36;\n            if ( v15 + 2 < v10 )\n              v9[v15 + 2] = 39;\n            v15 += 3LL;\n            LOBYTE(v26) = v24 & (v14 ^ 1);\n            v14 = v26;\n          }\nLABEL_37:\n          if ( v10 > v15 )\n            v9[v15] = 92;\n          ++v15;\n          ++v17;\n          goto LABEL_40;\n        }\nLABEL_49:\n        v24 = v18 == 2;\n        if ( v61 )\n          goto LABEL_28;\n        ++v17;\n        LOBYTE(v25) = v14 & ((unsigned __int8)v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v25 )\n        {\n          if ( v10 > v15 )\n            v9[v15] = 39;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 39;\n          v15 += 2LL;\n          v14 = 0;\n        }\nLABEL_40:\n        if ( v15 < v10 )\n          v9[v15] = v22;\n        v27 = v63;\n        ++v15;\n        if ( !(_BYTE)a5 )\n          v27 = 0;\n        v63 = v27;\n      }\n      LOBYTE(v22) = *v19;\n      switch ( *v19 )\n      {\n        case 0:\n          if ( !v60 )\n          {\n            if ( (a6 & 1) == 0 )\n            {\n              v61 = 0;\n              v24 = v18 == 2;\n              a5 = 0;\n              LOBYTE(v22) = 0;\n              goto LABEL_23;\n            }\n            ++v17;\n            goto LABEL_4;\n          }\nLABEL_85:\n          if ( v86 )\n          {\n            v30 = v18;\n            LODWORD(v13) = v16;\n            v60 = v30 == 2;\n            goto LABEL_72;\n          }\n          v61 = 0;\nLABEL_87:\n          v33 = v18 == 2;\n          LODWORD(v25) = v14 ^ 1;\n          LOBYTE(v25) = (v18 == 2) & (v14 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 36;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v34 = v15 + 3;\n            if ( v10 <= v15 + 3 )\n            {\n              v15 += 4LL;\n              v14 = (int)v25;\n              a5 = 0;\n              LOBYTE(v22) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_95;\n          }\n          v34 = v15;\n          if ( v10 > v15 )\n          {\n            LODWORD(v25) = v14;\nLABEL_95:\n            v9[v34] = 92;\n            v14 = (int)v25;\n          }\n          v15 = v34 + 1;\n          if ( v18 == 2 )\n          {\n            LOBYTE(v25) = a5;\n            LOBYTE(v22) = 48;\n            a5 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v22) = 48;\n          if ( v17 + 1 < v16 && (unsigned __int8)(*(_BYTE *)(a3 + v17 + 1) - 48) <= 9u )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 48;\n            if ( v10 > v34 + 2 )\n              v9[v34 + 2] = 48;\n            v15 = v34 + 3;\n            LOBYTE(v22) = 48;\n          }\nLABEL_99:\n          LOBYTE(v25) = a5;\n          a5 = 0;\n          if ( v33 | v60 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v22) = 7;\n          v29 = 97;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v22) = 8;\n          v29 = 98;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v22) = 9;\n          v29 = 116;\n          goto LABEL_108;\n        case 0xA:\n          LOBYTE(v22) = 10;\n          v29 = 110;\n          goto LABEL_108;\n        case 0xB:\n          LOBYTE(v22) = 11;\n          v29 = 118;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xC:\n          LOBYTE(v22) = 12;\n          v29 = 102;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xD:\n          LOBYTE(v22) = 13;\n          v29 = 114;\nLABEL_108:\n          v24 = v18 == 2;\n          v61 = v18 == 2 && v86;\n          if ( v61 )\n            goto LABEL_109;\n          goto LABEL_66;\n        case 0x20:\n          LOBYTE(v22) = 32;\n          v24 = v18 == 2;\n          goto LABEL_21;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2A:\n        case 0x3B:\n        case 0x3C:\n        case 0x3D:\n        case 0x3E:\n        case 0x5B:\n        case 0x5E:\n        case 0x60:\n        case 0x7C:\n          v24 = v18 == 2;\n          a5 = 0;\n          goto LABEL_21;\n        case 0x23:\n        case 0x7E:\n          v24 = v18 == 2;\n          goto LABEL_20;\n        case 0x25:\n        case 0x2B:\n        case 0x2C:\n        case 0x2D:\n        case 0x2E:\n        case 0x2F:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3A:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4A:\n        case 0x4B:\n        case 0x4C:\n        case 0x4D:\n        case 0x4E:\n        case 0x4F:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5A:\n        case 0x5D:\n        case 0x5F:\n        case 0x61:\n        case 0x62:\n        case 0x63:\n        case 0x64:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6A:\n        case 0x6B:\n        case 0x6C:\n        case 0x6D:\n        case 0x6E:\n        case 0x6F:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7A:\n          goto LABEL_105;\n        case 0x27:\nLABEL_62:\n          if ( v18 != 2 )\n          {\n            v87 = a5;\n            v24 = 0;\n            LOBYTE(v22) = 39;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_288;\n          if ( !v10 || (v28 = 0LL, v83) )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 92;\n            v28 = v10;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v10 = v83;\n          }\n          v87 = a5;\n          v15 += 3LL;\n          LOBYTE(v25) = 0;\n          v14 = 0;\n          v83 = v10;\n          LOBYTE(v22) = 39;\n          v10 = v28;\n          goto LABEL_49;\n        case 0x3F:\nLABEL_58:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n            {\nLABEL_288:\n              v30 = 2;\n              LODWORD(v13) = v16;\n              goto LABEL_72;\n            }\n            a5 = 0;\n            LOBYTE(v25) = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_49;\n          }\n          if ( v18 != 5 )\n          {\n            LOBYTE(v22) = 63;\n            v24 = v18 == 2;\n            a5 = 0;\n            goto LABEL_23;\n          }\n          if ( (a6 & 4) == 0\n            || v17 + 2 >= v16\n            || *(_BYTE *)(a3 + v17 + 1) != 63\n            || (v22 = *(unsigned __int8 *)(a3 + v17 + 2), (unsigned __int8)v22 > 0x3Eu)\n            || (v53 = 0x7000A38200000000LL, !_bittest64(&v53, v22)) )\n          {\n            v24 = 0;\n            a5 = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_277;\n          if ( v10 > v15 )\n            v9[v15] = 63;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 34;\n          if ( v10 > v15 + 2 )\n            v9[v15 + 2] = 34;\n          if ( v10 > v15 + 3 )\n            v9[v15 + 3] = 63;\n          v15 += 4LL;\n          v33 = 0;\n          LOBYTE(a5) = 0;\n          v17 += 2LL;\n          goto LABEL_99;\n        case 0x5C:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n              goto LABEL_288;\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            LOBYTE(v22) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LOBYTE(v22) = 92;\n          v29 = 92;\n          v24 = (n != 0) & v86 & v60;\n          if ( v24 )\n          {\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v60 )\n          {\nLABEL_67:\n            a5 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v22) = v29;\n          a5 = 0;\n          goto LABEL_28;\n        case 0x7B:\n        case 0x7D:\nLABEL_17:\n          v23 = v16 != 1;\n          if ( v16 == -1LL )\n            v23 = *(_BYTE *)(a3 + 1) != 0;\n          v24 = v18 == 2;\n          if ( v23 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v17 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v86 || !v24 )\n            goto LABEL_23;\nLABEL_109:\n          LODWORD(v13) = v16;\n          v30 = 2;\n          goto LABEL_72;\n        default:\nLABEL_102:\n          if ( mb_cur_max == 1 )\n          {\n            v77 = v18;\n            v72 = v16;\n            v67 = v14;\n            v25 = __ctype_b_loc();\n            v14 = v67;\n            v16 = v72;\n            v18 = v77;\n            v35 = 1LL;\n            LODWORD(v25) = (*v25)[(unsigned __int8)v22];\n            LOWORD(v25) = (unsigned __int16)v25 & 0x4000;\n            LOBYTE(a5) = (_WORD)v25 != 0;\n            LOBYTE(v36) = v60 & ((_WORD)v25 == 0);\nLABEL_104:\n            if ( (_BYTE)v36 )\n            {\n              v36 = v60;\n              LOBYTE(a5) = 0;\nLABEL_178:\n              v48 = 0;\n              v49 = v17 + v35;\n              v50 = v61;\n              while ( 1 )\n              {\n                if ( (_BYTE)v36 )\n                {\n                  if ( v86 )\n                  {\n                    v30 = v18;\n                    v60 = v18 == 2;\n                    LODWORD(v13) = v16;\n                    goto LABEL_72;\n                  }\n                  LOBYTE(v25) = (v14 ^ 1) & (v18 == 2);\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 36;\n                    if ( v10 > v15 + 2 )\n                      v9[v15 + 2] = 39;\n                    v15 += 3LL;\n                    v14 = (int)v25;\n                  }\n                  if ( v10 > v15 )\n                    v9[v15] = 92;\n                  if ( v10 > v15 + 1 )\n                    v9[v15 + 1] = ((unsigned __int8)v22 >> 6) + 48;\n                  LODWORD(v25) = v15 + 2;\n                  if ( v10 > v15 + 2 )\n                  {\n                    LODWORD(v25) = (((unsigned __int8)v22 >> 3) & 7) + 48;\n                    v9[v15 + 2] = (_BYTE)v25;\n                  }\n                  ++v17;\n                  v15 += 3LL;\n                  LOBYTE(v22) = (v22 & 7) + 48;\n                  if ( v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_40;\n                  }\n                  v48 = v36;\n                }\n                else\n                {\n                  LODWORD(v25) = v14 & (v48 ^ 1);\n                  if ( v50 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 92;\n                    ++v15;\n                  }\n                  if ( ++v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_51;\n                  }\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    LODWORD(v25) = v15 + 1;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 39;\n                    v15 += 2LL;\n                    v50 = 0;\n                    v14 = 0;\n                  }\n                  else\n                  {\n                    v50 = 0;\n                  }\n                }\n                if ( v10 > v15 )\n                  v9[v15] = v22;\n                LOBYTE(v22) = *(_BYTE *)(a3 + v17);\n                ++v15;\n              }\n            }\nLABEL_105:\n            v24 = v18 == 2;\nLABEL_23:\n            LOBYTE(v25) = v86 | (v24 | v60 ^ 1) ^ 1;\n            if ( !(_BYTE)v25 )\n              goto LABEL_49;\n            goto LABEL_24;\n          }\n          ps = 0LL;\n          if ( v16 == -1LL )\n          {\n            v78 = v18;\n            v73 = v14;\n            v68 = v19;\n            v43 = strlen((const char *)a3);\n            v18 = v78;\n            LOBYTE(v14) = v73;\n            v19 = v68;\n            v16 = v43;\n          }\n          v89 = v15;\n          v90 = v19;\n          v44 = 0LL;\n          v88 = v14;\n          v79 = v9;\n          v81 = v10;\n          v69 = v16;\n          v74 = v18;\n          break;\n      }\n      while ( 2 )\n      {\n        v45 = (char *)v44 + v17;\n        v25 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, (char *)v44 + v17 + a3);\n        v46 = v25;\n        if ( !v25 )\n        {\nLABEL_245:\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          v14 = v88;\n          v9 = v79;\n          v36 = a5 ^ 1;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          LOBYTE(v36) = v60 & (a5 ^ 1);\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-1LL )\n        {\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          a5 = 0;\n          v14 = v88;\n          v9 = v79;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          v36 = v60;\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-2LL )\n        {\n          v16 = v69;\n          v54 = (char *)v44 + v17;\n          v55 = (char *)v44 + v17 + a3;\n          v25 = v44;\n          v35 = (unsigned __int64)v44;\n          v14 = v88;\n          v15 = v89;\n          v9 = v79;\n          v10 = v81;\n          v18 = v74;\n          if ( (unsigned __int64)v54 < v69 && *v55 )\n          {\n            do\n              v25 = (const unsigned __int16 **)((char *)v25 + 1);\n            while ( (unsigned __int64)v25 + v17 < v69 && *((_BYTE *)v25 + (_QWORD)v90) );\n            v35 = (unsigned __int64)v25;\n          }\n          v36 = v60;\n          a5 = 0;\nLABEL_246:\n          if ( v35 > 1 )\n            goto LABEL_178;\n          goto LABEL_104;\n        }\n        if ( v74 != 2 || !v86 || v25 == (const unsigned __int16 **)1 )\n        {\nLABEL_152:\n          if ( !iswprint(wc) )\n            a5 = 0;\n          v44 = (const unsigned __int16 **)((char *)v44 + (_QWORD)v46);\n          LODWORD(v25) = mbsinit(&ps);\n          if ( (_DWORD)v25 )\n            goto LABEL_245;\n          continue;\n        }\n        break;\n      }\n      v47 = &v45[a3 + 1];\n      while ( (unsigned __int8)(*v47 - 91) > 0x21u || ((1LL << (*v47 - 91)) & 0x20000002BLL) == 0 )\n      {\n        if ( (char *)v46 + a3 + (_QWORD)v45 == ++v47 )\n          goto LABEL_152;\n      }\n      LODWORD(v9) = (_DWORD)v79;\n      LODWORD(v10) = v81;\n      v30 = 2;\n      LODWORD(v13) = v69;\nLABEL_72:\n      if ( v60 )\n        v30 = 4;\n      return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n    case 5:\n      if ( v12 )\n      {\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n          v83 = 0LL;\n        }\n        else\n        {\n          v83 = 0LL;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n        }\n        v86 = 0;\n        v15 = 1LL;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 5;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", a5);\n        v51 = (char *)sub_40DD00(\"'\", a5);\n        v13 = a4;\n        a9 = v51;\n      }\n      v15 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v15] )\n        {\n          if ( a2 > v15 )\n            a1[v15] = i;\n          ++v15;\n        }\n      }\n      v62 = v13;\n      v52 = strlen(a9);\n      v63 = 1;\n      v14 = 0;\n      v13 = v62;\n      n = v52;\n      v87 = 0;\n      s2 = a9;\n      v83 = 0LL;\n      v60 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n  }\n}\n\nunsigned __int64 __fastcall sub_40DE00(\n        _BYTE *a1,\n        unsigned __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        int a5,\n        int a6,\n        __int64 a7,\n        const char *a8,\n        char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v12; // ebp\n  unsigned __int64 v13; // r11\n  int v14; // r10d\n  unsigned __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  unsigned __int64 v17; // r12\n  int v18; // r11d\n  _BYTE *v19; // r8\n  size_t v20; // rax\n  int v21; // eax\n  unsigned __int64 v22; // rbp\n  bool v23; // al\n  unsigned __int8 v24; // dl\n  const unsigned __int16 **v25; // rax\n  int v26; // eax\n  char v27; // di\n  unsigned __int64 v28; // rdx\n  char v29; // cl\n  int v30; // r13d\n  unsigned __int8 v31; // al\n  bool v33; // dl\n  unsigned __int64 v34; // rcx\n  unsigned __int64 v35; // rdi\n  int v36; // edx\n  unsigned __int8 v37; // al\n  unsigned __int8 v38; // al\n  int v39; // r13d\n  bool v40; // dl\n  bool v41; // dl\n  bool v42; // al\n  size_t v43; // rax\n  const unsigned __int16 **v44; // rbx\n  char *v45; // r15\n  const unsigned __int16 **v46; // r14\n  char *v47; // rax\n  int v48; // esi\n  unsigned __int64 v49; // rcx\n  unsigned __int8 v50; // di\n  char *v51; // rax\n  size_t v52; // rax\n  __int64 v53; // rsi\n  char *v54; // rsi\n  _BYTE *v55; // rcx\n  char i; // al\n  char v57; // dl\n  const char *v58; // rax\n  unsigned __int8 v60; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v61; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v62; // [rsp+10h] [rbp-B8h]\n  char v63; // [rsp+1Fh] [rbp-A9h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  _BYTE *v66; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v67; // [rsp+30h] [rbp-98h]\n  _BYTE *v68; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v69; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v70; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v71; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v72; // [rsp+38h] [rbp-90h]\n  char v73; // [rsp+38h] [rbp-90h]\n  int v74; // [rsp+38h] [rbp-90h]\n  int v75; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v76; // [rsp+40h] [rbp-88h]\n  int v77; // [rsp+40h] [rbp-88h]\n  int v78; // [rsp+40h] [rbp-88h]\n  _BYTE *v79; // [rsp+40h] [rbp-88h]\n  int v80; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v81; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  unsigned __int64 v83; // [rsp+58h] [rbp-70h]\n  size_t mb_cur_max; // [rsp+60h] [rbp-68h]\n  bool v86; // [rsp+6Ch] [rbp-5Ch]\n  char v87; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v88; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v89; // [rsp+70h] [rbp-58h]\n  _BYTE *v90; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h] BYREF\n  mbstate_t ps; // [rsp+88h] [rbp-40h] BYREF\n\n  v9 = a1;\n  v10 = a2;\n  v12 = a6 & 2;\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v86 = v12 != 0;\n  v13 = a4;\n  switch ( a5 )\n  {\n    case 0:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v60 = 0;\n        goto LABEL_216;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 2;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        a5 = 2;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v60 = 1;\nLABEL_216:\n      if ( a2 )\n      {\n        v14 = 0;\n        v42 = 0;\n        v63 = 1;\n        v83 = 0LL;\n        goto LABEL_142;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 1LL;\n      a5 = 2;\n      v83 = 0LL;\n      v87 = 0;\n      v86 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v16 = v13;\n      v17 = 0LL;\n      v18 = a5;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(a5) = v16 != v17;\n        if ( v16 == -1LL )\n          LOBYTE(a5) = *(_BYTE *)(a3 + v17) != 0;\n        if ( !(_BYTE)a5 )\n        {\n          v39 = v18;\n          v13 = v16;\n          v40 = v39 == 2;\n          if ( !v15 && v40 && v86 )\n          {\n            v30 = 2;\n            goto LABEL_72;\n          }\n          v41 = !v86 && v40;\n          if ( v41 )\n          {\n            if ( v87 )\n            {\n              if ( v63 )\n                return sub_40DE00((int)v9, v83, a3, v16, 5, a6, a7, (__int64)a8, a9);\n              v42 = v83 != 0 && v10 == 0;\n              if ( v42 )\n              {\n                v10 = v83;\nLABEL_142:\n                *v9 = 39;\n                a5 = 2;\n                v15 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v86 = 0;\n                v87 = v42;\n                goto LABEL_3;\n              }\n              v41 = v87;\n            }\n          }\n          else\n          {\n            v41 = !v86;\n          }\n          if ( s2 )\n          {\n            if ( v41 )\n            {\n              v57 = *s2;\n              if ( *s2 )\n              {\n                v58 = &s2[-v15];\n                do\n                {\n                  if ( v10 > v15 )\n                    v9[v15] = v57;\n                  v57 = v58[++v15];\n                }\n                while ( v57 );\n              }\n            }\n          }\n          if ( v10 > v15 )\n            v9[v15] = 0;\n          return v15;\n        }\n        v19 = (_BYTE *)(a3 + v17);\n        v61 = v60 & (v18 != 2);\n        if ( !v61 )\n          break;\n        if ( n )\n        {\n          if ( v16 == -1LL && n > 1 )\n          {\n            v75 = v18;\n            v70 = v14;\n            v20 = strlen((const char *)a3);\n            v18 = v75;\n            v14 = v70;\n            v19 = (_BYTE *)(a3 + v17);\n            v16 = v20;\n          }\n          if ( v17 + n <= v16 )\n          {\n            v80 = v18;\n            v76 = v16;\n            v71 = v14;\n            v66 = v19;\n            v21 = memcmp(v19, s2, n);\n            v19 = v66;\n            v14 = v71;\n            v16 = v76;\n            v18 = v80;\n            if ( !v21 )\n            {\n              if ( !v86 )\n              {\n                LOBYTE(v22) = *v66;\n                switch ( *v66 )\n                {\n                  case 0:\n                    goto LABEL_87;\n                  case 7:\n                    LOBYTE(v22) = 97;\n                    goto LABEL_83;\n                  case 8:\n                    v24 = 0;\n                    a5 = 0;\n                    LOBYTE(v22) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_76;\n                  case 0xA:\n                    goto LABEL_68;\n                  case 0xB:\n                    goto LABEL_84;\n                  case 0xC:\n                    goto LABEL_81;\n                  case 0xD:\n                    goto LABEL_80;\n                  case 0x20:\n                    v37 = v61;\n                    goto LABEL_132;\n                  case 0x21:\n                  case 0x22:\n                  case 0x24:\n                  case 0x26:\n                  case 0x28:\n                  case 0x29:\n                  case 0x2A:\n                  case 0x3B:\n                  case 0x3C:\n                  case 0x3D:\n                  case 0x3E:\n                  case 0x5B:\n                  case 0x5E:\n                  case 0x60:\n                  case 0x7C:\n                    goto LABEL_78;\n                  case 0x23:\n                  case 0x7E:\n                    v38 = v61;\n                    goto LABEL_129;\n                  case 0x25:\n                  case 0x2B:\n                  case 0x2C:\n                  case 0x2D:\n                  case 0x2E:\n                  case 0x2F:\n                  case 0x30:\n                  case 0x31:\n                  case 0x32:\n                  case 0x33:\n                  case 0x34:\n                  case 0x35:\n                  case 0x36:\n                  case 0x37:\n                  case 0x38:\n                  case 0x39:\n                  case 0x3A:\n                  case 0x41:\n                  case 0x42:\n                  case 0x43:\n                  case 0x44:\n                  case 0x45:\n                  case 0x46:\n                  case 0x47:\n                  case 0x48:\n                  case 0x49:\n                  case 0x4A:\n                  case 0x4B:\n                  case 0x4C:\n                  case 0x4D:\n                  case 0x4E:\n                  case 0x4F:\n                  case 0x50:\n                  case 0x51:\n                  case 0x52:\n                  case 0x53:\n                  case 0x54:\n                  case 0x55:\n                  case 0x56:\n                  case 0x57:\n                  case 0x58:\n                  case 0x59:\n                  case 0x5A:\n                  case 0x5D:\n                  case 0x5F:\n                  case 0x61:\n                  case 0x62:\n                  case 0x63:\n                  case 0x64:\n                  case 0x65:\n                  case 0x66:\n                  case 0x67:\n                  case 0x68:\n                  case 0x69:\n                  case 0x6A:\n                  case 0x6B:\n                  case 0x6C:\n                  case 0x6D:\n                  case 0x6E:\n                  case 0x6F:\n                  case 0x70:\n                  case 0x71:\n                  case 0x72:\n                  case 0x73:\n                  case 0x74:\n                  case 0x75:\n                  case 0x76:\n                  case 0x77:\n                  case 0x78:\n                  case 0x79:\n                  case 0x7A:\n                    v37 = v61;\n                    goto LABEL_127;\n                  case 0x27:\n                    goto LABEL_62;\n                  case 0x3F:\n                    goto LABEL_58;\n                  case 0x5C:\n                    goto LABEL_65;\n                  case 0x7B:\n                  case 0x7D:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_102;\n                }\n              }\nLABEL_277:\n              v30 = v18;\n              LODWORD(v13) = v16;\n              return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n            }\n          }\n        }\n        LOBYTE(v22) = *v19;\n        switch ( *v19 )\n        {\n          case 0:\n            goto LABEL_85;\n          case 7:\n            LOBYTE(v22) = 97;\n            goto LABEL_82;\n          case 8:\n            LOBYTE(v22) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_76:\n            LOBYTE(v22) = 116;\n            goto LABEL_69;\n          case 0xA:\nLABEL_68:\n            LOBYTE(v22) = 110;\nLABEL_69:\n            v24 = 0;\n            a5 = 0;\n            if ( v86 )\n              goto LABEL_70;\n            goto LABEL_29;\n          case 0xB:\nLABEL_84:\n            LOBYTE(v22) = 118;\n            goto LABEL_82;\n          case 0xC:\nLABEL_81:\n            LOBYTE(v22) = 102;\nLABEL_82:\n            if ( v86 )\n            {\n              v30 = v18;\n              v31 = 0;\n              LODWORD(v13) = v16;\n              goto LABEL_71;\n            }\nLABEL_83:\n            a5 = 0;\n            goto LABEL_37;\n          case 0xD:\n            v61 = 0;\nLABEL_80:\n            LOBYTE(v22) = 13;\n            v29 = 114;\n            v24 = v18 == 2;\n            goto LABEL_66;\n          case 0x20:\n            v37 = 0;\nLABEL_132:\n            LOBYTE(v22) = 32;\n            goto LABEL_127;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2A:\n          case 0x3B:\n          case 0x3C:\n          case 0x3D:\n          case 0x3E:\n          case 0x5B:\n          case 0x5E:\n          case 0x60:\n          case 0x7C:\n            v61 = 0;\nLABEL_78:\n            v24 = 0;\n            goto LABEL_67;\n          case 0x23:\n          case 0x7E:\n            v38 = 0;\nLABEL_129:\n            if ( !v17 )\n            {\n              a5 = v61;\n              v24 = 0;\n              v61 = v38;\n              goto LABEL_23;\n            }\n            v61 = v38;\n            a5 = 0;\n            break;\n          case 0x25:\n          case 0x2B:\n          case 0x2C:\n          case 0x2D:\n          case 0x2E:\n          case 0x2F:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3A:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4A:\n          case 0x4B:\n          case 0x4C:\n          case 0x4D:\n          case 0x4E:\n          case 0x4F:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5A:\n          case 0x5D:\n          case 0x5F:\n          case 0x61:\n          case 0x62:\n          case 0x63:\n          case 0x64:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6A:\n          case 0x6B:\n          case 0x6C:\n          case 0x6D:\n          case 0x6E:\n          case 0x6F:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7A:\n            v37 = 0;\nLABEL_127:\n            a5 = v61;\n            v61 = v37;\n            LOBYTE(v25) = 0;\n            goto LABEL_25;\n          case 0x27:\n            v61 = 0;\n            goto LABEL_62;\n          case 0x3F:\n            v61 = 0;\n            goto LABEL_58;\n          case 0x5C:\n            v61 = 0;\n            goto LABEL_65;\n          case 0x7B:\n          case 0x7D:\n            v61 = 0;\n            goto LABEL_17;\n          default:\n            v61 = 0;\n            goto LABEL_102;\n        }\nLABEL_24:\n        LOBYTE(v25) = 0;\nLABEL_25:\n        if ( a7 && ((*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v22 >> 5)) >> v22) & 1) != 0 )\n        {\n          v24 = v18 == 2;\nLABEL_28:\n          if ( v86 )\n          {\nLABEL_70:\n            v30 = v18;\n            v31 = v24;\n            LODWORD(v13) = v16;\nLABEL_71:\n            v60 &= v31;\n            goto LABEL_72;\n          }\nLABEL_29:\n          v26 = v14 ^ 1;\n          if ( (v24 & ((unsigned __int8)v14 ^ 1)) != 0 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v15 + 1 < v10 )\n              v9[v15 + 1] = 36;\n            if ( v15 + 2 < v10 )\n              v9[v15 + 2] = 39;\n            v15 += 3LL;\n            LOBYTE(v26) = v24 & (v14 ^ 1);\n            v14 = v26;\n          }\nLABEL_37:\n          if ( v10 > v15 )\n            v9[v15] = 92;\n          ++v15;\n          ++v17;\n          goto LABEL_40;\n        }\nLABEL_49:\n        v24 = v18 == 2;\n        if ( v61 )\n          goto LABEL_28;\n        ++v17;\n        LOBYTE(v25) = v14 & ((unsigned __int8)v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v25 )\n        {\n          if ( v10 > v15 )\n            v9[v15] = 39;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 39;\n          v15 += 2LL;\n          v14 = 0;\n        }\nLABEL_40:\n        if ( v15 < v10 )\n          v9[v15] = v22;\n        v27 = v63;\n        ++v15;\n        if ( !(_BYTE)a5 )\n          v27 = 0;\n        v63 = v27;\n      }\n      LOBYTE(v22) = *v19;\n      switch ( *v19 )\n      {\n        case 0:\n          if ( !v60 )\n          {\n            if ( (a6 & 1) == 0 )\n            {\n              v61 = 0;\n              v24 = v18 == 2;\n              a5 = 0;\n              LOBYTE(v22) = 0;\n              goto LABEL_23;\n            }\n            ++v17;\n            goto LABEL_4;\n          }\nLABEL_85:\n          if ( v86 )\n          {\n            v30 = v18;\n            LODWORD(v13) = v16;\n            v60 = v30 == 2;\n            goto LABEL_72;\n          }\n          v61 = 0;\nLABEL_87:\n          v33 = v18 == 2;\n          LODWORD(v25) = v14 ^ 1;\n          LOBYTE(v25) = (v18 == 2) & (v14 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 36;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v34 = v15 + 3;\n            if ( v10 <= v15 + 3 )\n            {\n              v15 += 4LL;\n              v14 = (int)v25;\n              a5 = 0;\n              LOBYTE(v22) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_95;\n          }\n          v34 = v15;\n          if ( v10 > v15 )\n          {\n            LODWORD(v25) = v14;\nLABEL_95:\n            v9[v34] = 92;\n            v14 = (int)v25;\n          }\n          v15 = v34 + 1;\n          if ( v18 == 2 )\n          {\n            LOBYTE(v25) = a5;\n            LOBYTE(v22) = 48;\n            a5 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v22) = 48;\n          if ( v17 + 1 < v16 && (unsigned __int8)(*(_BYTE *)(a3 + v17 + 1) - 48) <= 9u )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 48;\n            if ( v10 > v34 + 2 )\n              v9[v34 + 2] = 48;\n            v15 = v34 + 3;\n            LOBYTE(v22) = 48;\n          }\nLABEL_99:\n          LOBYTE(v25) = a5;\n          a5 = 0;\n          if ( v33 | v60 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v22) = 7;\n          v29 = 97;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v22) = 8;\n          v29 = 98;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v22) = 9;\n          v29 = 116;\n          goto LABEL_108;\n        case 0xA:\n          LOBYTE(v22) = 10;\n          v29 = 110;\n          goto LABEL_108;\n        case 0xB:\n          LOBYTE(v22) = 11;\n          v29 = 118;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xC:\n          LOBYTE(v22) = 12;\n          v29 = 102;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xD:\n          LOBYTE(v22) = 13;\n          v29 = 114;\nLABEL_108:\n          v24 = v18 == 2;\n          v61 = v18 == 2 && v86;\n          if ( v61 )\n            goto LABEL_109;\n          goto LABEL_66;\n        case 0x20:\n          LOBYTE(v22) = 32;\n          v24 = v18 == 2;\n          goto LABEL_21;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2A:\n        case 0x3B:\n        case 0x3C:\n        case 0x3D:\n        case 0x3E:\n        case 0x5B:\n        case 0x5E:\n        case 0x60:\n        case 0x7C:\n          v24 = v18 == 2;\n          a5 = 0;\n          goto LABEL_21;\n        case 0x23:\n        case 0x7E:\n          v24 = v18 == 2;\n          goto LABEL_20;\n        case 0x25:\n        case 0x2B:\n        case 0x2C:\n        case 0x2D:\n        case 0x2E:\n        case 0x2F:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3A:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4A:\n        case 0x4B:\n        case 0x4C:\n        case 0x4D:\n        case 0x4E:\n        case 0x4F:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5A:\n        case 0x5D:\n        case 0x5F:\n        case 0x61:\n        case 0x62:\n        case 0x63:\n        case 0x64:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6A:\n        case 0x6B:\n        case 0x6C:\n        case 0x6D:\n        case 0x6E:\n        case 0x6F:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7A:\n          goto LABEL_105;\n        case 0x27:\nLABEL_62:\n          if ( v18 != 2 )\n          {\n            v87 = a5;\n            v24 = 0;\n            LOBYTE(v22) = 39;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_288;\n          if ( !v10 || (v28 = 0LL, v83) )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 92;\n            v28 = v10;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v10 = v83;\n          }\n          v87 = a5;\n          v15 += 3LL;\n          LOBYTE(v25) = 0;\n          v14 = 0;\n          v83 = v10;\n          LOBYTE(v22) = 39;\n          v10 = v28;\n          goto LABEL_49;\n        case 0x3F:\nLABEL_58:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n            {\nLABEL_288:\n              v30 = 2;\n              LODWORD(v13) = v16;\n              goto LABEL_72;\n            }\n            a5 = 0;\n            LOBYTE(v25) = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_49;\n          }\n          if ( v18 != 5 )\n          {\n            LOBYTE(v22) = 63;\n            v24 = v18 == 2;\n            a5 = 0;\n            goto LABEL_23;\n          }\n          if ( (a6 & 4) == 0\n            || v17 + 2 >= v16\n            || *(_BYTE *)(a3 + v17 + 1) != 63\n            || (v22 = *(unsigned __int8 *)(a3 + v17 + 2), (unsigned __int8)v22 > 0x3Eu)\n            || (v53 = 0x7000A38200000000LL, !_bittest64(&v53, v22)) )\n          {\n            v24 = 0;\n            a5 = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_277;\n          if ( v10 > v15 )\n            v9[v15] = 63;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 34;\n          if ( v10 > v15 + 2 )\n            v9[v15 + 2] = 34;\n          if ( v10 > v15 + 3 )\n            v9[v15 + 3] = 63;\n          v15 += 4LL;\n          v33 = 0;\n          LOBYTE(a5) = 0;\n          v17 += 2LL;\n          goto LABEL_99;\n        case 0x5C:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n              goto LABEL_288;\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            LOBYTE(v22) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LOBYTE(v22) = 92;\n          v29 = 92;\n          v24 = (n != 0) & v86 & v60;\n          if ( v24 )\n          {\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v60 )\n          {\nLABEL_67:\n            a5 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v22) = v29;\n          a5 = 0;\n          goto LABEL_28;\n        case 0x7B:\n        case 0x7D:\nLABEL_17:\n          v23 = v16 != 1;\n          if ( v16 == -1LL )\n            v23 = *(_BYTE *)(a3 + 1) != 0;\n          v24 = v18 == 2;\n          if ( v23 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v17 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v86 || !v24 )\n            goto LABEL_23;\nLABEL_109:\n          LODWORD(v13) = v16;\n          v30 = 2;\n          goto LABEL_72;\n        default:\nLABEL_102:\n          if ( mb_cur_max == 1 )\n          {\n            v77 = v18;\n            v72 = v16;\n            v67 = v14;\n            v25 = __ctype_b_loc();\n            v14 = v67;\n            v16 = v72;\n            v18 = v77;\n            v35 = 1LL;\n            LODWORD(v25) = (*v25)[(unsigned __int8)v22];\n            LOWORD(v25) = (unsigned __int16)v25 & 0x4000;\n            LOBYTE(a5) = (_WORD)v25 != 0;\n            LOBYTE(v36) = v60 & ((_WORD)v25 == 0);\nLABEL_104:\n            if ( (_BYTE)v36 )\n            {\n              v36 = v60;\n              LOBYTE(a5) = 0;\nLABEL_178:\n              v48 = 0;\n              v49 = v17 + v35;\n              v50 = v61;\n              while ( 1 )\n              {\n                if ( (_BYTE)v36 )\n                {\n                  if ( v86 )\n                  {\n                    v30 = v18;\n                    v60 = v18 == 2;\n                    LODWORD(v13) = v16;\n                    goto LABEL_72;\n                  }\n                  LOBYTE(v25) = (v14 ^ 1) & (v18 == 2);\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 36;\n                    if ( v10 > v15 + 2 )\n                      v9[v15 + 2] = 39;\n                    v15 += 3LL;\n                    v14 = (int)v25;\n                  }\n                  if ( v10 > v15 )\n                    v9[v15] = 92;\n                  if ( v10 > v15 + 1 )\n                    v9[v15 + 1] = ((unsigned __int8)v22 >> 6) + 48;\n                  LODWORD(v25) = v15 + 2;\n                  if ( v10 > v15 + 2 )\n                  {\n                    LODWORD(v25) = (((unsigned __int8)v22 >> 3) & 7) + 48;\n                    v9[v15 + 2] = (_BYTE)v25;\n                  }\n                  ++v17;\n                  v15 += 3LL;\n                  LOBYTE(v22) = (v22 & 7) + 48;\n                  if ( v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_40;\n                  }\n                  v48 = v36;\n                }\n                else\n                {\n                  LODWORD(v25) = v14 & (v48 ^ 1);\n                  if ( v50 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 92;\n                    ++v15;\n                  }\n                  if ( ++v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_51;\n                  }\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    LODWORD(v25) = v15 + 1;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 39;\n                    v15 += 2LL;\n                    v50 = 0;\n                    v14 = 0;\n                  }\n                  else\n                  {\n                    v50 = 0;\n                  }\n                }\n                if ( v10 > v15 )\n                  v9[v15] = v22;\n                LOBYTE(v22) = *(_BYTE *)(a3 + v17);\n                ++v15;\n              }\n            }\nLABEL_105:\n            v24 = v18 == 2;\nLABEL_23:\n            LOBYTE(v25) = v86 | (v24 | v60 ^ 1) ^ 1;\n            if ( !(_BYTE)v25 )\n              goto LABEL_49;\n            goto LABEL_24;\n          }\n          ps = 0LL;\n          if ( v16 == -1LL )\n          {\n            v78 = v18;\n            v73 = v14;\n            v68 = v19;\n            v43 = strlen((const char *)a3);\n            v18 = v78;\n            LOBYTE(v14) = v73;\n            v19 = v68;\n            v16 = v43;\n          }\n          v89 = v15;\n          v90 = v19;\n          v44 = 0LL;\n          v88 = v14;\n          v79 = v9;\n          v81 = v10;\n          v69 = v16;\n          v74 = v18;\n          break;\n      }\n      while ( 2 )\n      {\n        v45 = (char *)v44 + v17;\n        v25 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, (char *)v44 + v17 + a3);\n        v46 = v25;\n        if ( !v25 )\n        {\nLABEL_245:\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          v14 = v88;\n          v9 = v79;\n          v36 = a5 ^ 1;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          LOBYTE(v36) = v60 & (a5 ^ 1);\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-1LL )\n        {\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          a5 = 0;\n          v14 = v88;\n          v9 = v79;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          v36 = v60;\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-2LL )\n        {\n          v16 = v69;\n          v54 = (char *)v44 + v17;\n          v55 = (char *)v44 + v17 + a3;\n          v25 = v44;\n          v35 = (unsigned __int64)v44;\n          v14 = v88;\n          v15 = v89;\n          v9 = v79;\n          v10 = v81;\n          v18 = v74;\n          if ( (unsigned __int64)v54 < v69 && *v55 )\n          {\n            do\n              v25 = (const unsigned __int16 **)((char *)v25 + 1);\n            while ( (unsigned __int64)v25 + v17 < v69 && *((_BYTE *)v25 + (_QWORD)v90) );\n            v35 = (unsigned __int64)v25;\n          }\n          v36 = v60;\n          a5 = 0;\nLABEL_246:\n          if ( v35 > 1 )\n            goto LABEL_178;\n          goto LABEL_104;\n        }\n        if ( v74 != 2 || !v86 || v25 == (const unsigned __int16 **)1 )\n        {\nLABEL_152:\n          if ( !iswprint(wc) )\n            a5 = 0;\n          v44 = (const unsigned __int16 **)((char *)v44 + (_QWORD)v46);\n          LODWORD(v25) = mbsinit(&ps);\n          if ( (_DWORD)v25 )\n            goto LABEL_245;\n          continue;\n        }\n        break;\n      }\n      v47 = &v45[a3 + 1];\n      while ( (unsigned __int8)(*v47 - 91) > 0x21u || ((1LL << (*v47 - 91)) & 0x20000002BLL) == 0 )\n      {\n        if ( (char *)v46 + a3 + (_QWORD)v45 == ++v47 )\n          goto LABEL_152;\n      }\n      LODWORD(v9) = (_DWORD)v79;\n      LODWORD(v10) = v81;\n      v30 = 2;\n      LODWORD(v13) = v69;\nLABEL_72:\n      if ( v60 )\n        v30 = 4;\n      return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n    case 5:\n      if ( v12 )\n      {\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n          v83 = 0LL;\n        }\n        else\n        {\n          v83 = 0LL;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n        }\n        v86 = 0;\n        v15 = 1LL;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 5;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", a5);\n        v51 = (char *)sub_40DD00(\"'\", a5);\n        v13 = a4;\n        a9 = v51;\n      }\n      v15 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v15] )\n        {\n          if ( a2 > v15 )\n            a1[v15] = i;\n          ++v15;\n        }\n      }\n      v62 = v13;\n      v52 = strlen(a9);\n      v63 = 1;\n      v14 = 0;\n      v13 = v62;\n      n = v52;\n      v87 = 0;\n      s2 = a9;\n      v83 = 0LL;\n      v60 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n  }\n}\n"
        },
        {
            "funcName": "sub_40DE00",
            "funcStartAddr": "0x402f14",
            "funcEndAddr": "0x402f19",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40DE00(\n        _BYTE *a1,\n        unsigned __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        int a5,\n        int a6,\n        __int64 a7,\n        const char *a8,\n        char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v12; // ebp\n  unsigned __int64 v13; // r11\n  int v14; // r10d\n  unsigned __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  unsigned __int64 v17; // r12\n  int v18; // r11d\n  _BYTE *v19; // r8\n  size_t v20; // rax\n  int v21; // eax\n  unsigned __int64 v22; // rbp\n  bool v23; // al\n  unsigned __int8 v24; // dl\n  const unsigned __int16 **v25; // rax\n  int v26; // eax\n  char v27; // di\n  unsigned __int64 v28; // rdx\n  char v29; // cl\n  int v30; // r13d\n  unsigned __int8 v31; // al\n  bool v33; // dl\n  unsigned __int64 v34; // rcx\n  unsigned __int64 v35; // rdi\n  int v36; // edx\n  unsigned __int8 v37; // al\n  unsigned __int8 v38; // al\n  int v39; // r13d\n  bool v40; // dl\n  bool v41; // dl\n  bool v42; // al\n  size_t v43; // rax\n  const unsigned __int16 **v44; // rbx\n  char *v45; // r15\n  const unsigned __int16 **v46; // r14\n  char *v47; // rax\n  int v48; // esi\n  unsigned __int64 v49; // rcx\n  unsigned __int8 v50; // di\n  char *v51; // rax\n  size_t v52; // rax\n  __int64 v53; // rsi\n  char *v54; // rsi\n  _BYTE *v55; // rcx\n  char i; // al\n  char v57; // dl\n  const char *v58; // rax\n  unsigned __int8 v60; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v61; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v62; // [rsp+10h] [rbp-B8h]\n  char v63; // [rsp+1Fh] [rbp-A9h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  _BYTE *v66; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v67; // [rsp+30h] [rbp-98h]\n  _BYTE *v68; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v69; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v70; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v71; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v72; // [rsp+38h] [rbp-90h]\n  char v73; // [rsp+38h] [rbp-90h]\n  int v74; // [rsp+38h] [rbp-90h]\n  int v75; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v76; // [rsp+40h] [rbp-88h]\n  int v77; // [rsp+40h] [rbp-88h]\n  int v78; // [rsp+40h] [rbp-88h]\n  _BYTE *v79; // [rsp+40h] [rbp-88h]\n  int v80; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v81; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  unsigned __int64 v83; // [rsp+58h] [rbp-70h]\n  size_t mb_cur_max; // [rsp+60h] [rbp-68h]\n  bool v86; // [rsp+6Ch] [rbp-5Ch]\n  char v87; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v88; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v89; // [rsp+70h] [rbp-58h]\n  _BYTE *v90; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h] BYREF\n  mbstate_t ps; // [rsp+88h] [rbp-40h] BYREF\n\n  v9 = a1;\n  v10 = a2;\n  v12 = a6 & 2;\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v86 = v12 != 0;\n  v13 = a4;\n  switch ( a5 )\n  {\n    case 0:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v60 = 0;\n        goto LABEL_216;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 2;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        a5 = 2;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v60 = 1;\nLABEL_216:\n      if ( a2 )\n      {\n        v14 = 0;\n        v42 = 0;\n        v63 = 1;\n        v83 = 0LL;\n        goto LABEL_142;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 1LL;\n      a5 = 2;\n      v83 = 0LL;\n      v87 = 0;\n      v86 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v16 = v13;\n      v17 = 0LL;\n      v18 = a5;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(a5) = v16 != v17;\n        if ( v16 == -1LL )\n          LOBYTE(a5) = *(_BYTE *)(a3 + v17) != 0;\n        if ( !(_BYTE)a5 )\n        {\n          v39 = v18;\n          v13 = v16;\n          v40 = v39 == 2;\n          if ( !v15 && v40 && v86 )\n          {\n            v30 = 2;\n            goto LABEL_72;\n          }\n          v41 = !v86 && v40;\n          if ( v41 )\n          {\n            if ( v87 )\n            {\n              if ( v63 )\n                return sub_40DE00((int)v9, v83, a3, v16, 5, a6, a7, (__int64)a8, a9);\n              v42 = v83 != 0 && v10 == 0;\n              if ( v42 )\n              {\n                v10 = v83;\nLABEL_142:\n                *v9 = 39;\n                a5 = 2;\n                v15 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v86 = 0;\n                v87 = v42;\n                goto LABEL_3;\n              }\n              v41 = v87;\n            }\n          }\n          else\n          {\n            v41 = !v86;\n          }\n          if ( s2 )\n          {\n            if ( v41 )\n            {\n              v57 = *s2;\n              if ( *s2 )\n              {\n                v58 = &s2[-v15];\n                do\n                {\n                  if ( v10 > v15 )\n                    v9[v15] = v57;\n                  v57 = v58[++v15];\n                }\n                while ( v57 );\n              }\n            }\n          }\n          if ( v10 > v15 )\n            v9[v15] = 0;\n          return v15;\n        }\n        v19 = (_BYTE *)(a3 + v17);\n        v61 = v60 & (v18 != 2);\n        if ( !v61 )\n          break;\n        if ( n )\n        {\n          if ( v16 == -1LL && n > 1 )\n          {\n            v75 = v18;\n            v70 = v14;\n            v20 = strlen((const char *)a3);\n            v18 = v75;\n            v14 = v70;\n            v19 = (_BYTE *)(a3 + v17);\n            v16 = v20;\n          }\n          if ( v17 + n <= v16 )\n          {\n            v80 = v18;\n            v76 = v16;\n            v71 = v14;\n            v66 = v19;\n            v21 = memcmp(v19, s2, n);\n            v19 = v66;\n            v14 = v71;\n            v16 = v76;\n            v18 = v80;\n            if ( !v21 )\n            {\n              if ( !v86 )\n              {\n                LOBYTE(v22) = *v66;\n                switch ( *v66 )\n                {\n                  case 0:\n                    goto LABEL_87;\n                  case 7:\n                    LOBYTE(v22) = 97;\n                    goto LABEL_83;\n                  case 8:\n                    v24 = 0;\n                    a5 = 0;\n                    LOBYTE(v22) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_76;\n                  case 0xA:\n                    goto LABEL_68;\n                  case 0xB:\n                    goto LABEL_84;\n                  case 0xC:\n                    goto LABEL_81;\n                  case 0xD:\n                    goto LABEL_80;\n                  case 0x20:\n                    v37 = v61;\n                    goto LABEL_132;\n                  case 0x21:\n                  case 0x22:\n                  case 0x24:\n                  case 0x26:\n                  case 0x28:\n                  case 0x29:\n                  case 0x2A:\n                  case 0x3B:\n                  case 0x3C:\n                  case 0x3D:\n                  case 0x3E:\n                  case 0x5B:\n                  case 0x5E:\n                  case 0x60:\n                  case 0x7C:\n                    goto LABEL_78;\n                  case 0x23:\n                  case 0x7E:\n                    v38 = v61;\n                    goto LABEL_129;\n                  case 0x25:\n                  case 0x2B:\n                  case 0x2C:\n                  case 0x2D:\n                  case 0x2E:\n                  case 0x2F:\n                  case 0x30:\n                  case 0x31:\n                  case 0x32:\n                  case 0x33:\n                  case 0x34:\n                  case 0x35:\n                  case 0x36:\n                  case 0x37:\n                  case 0x38:\n                  case 0x39:\n                  case 0x3A:\n                  case 0x41:\n                  case 0x42:\n                  case 0x43:\n                  case 0x44:\n                  case 0x45:\n                  case 0x46:\n                  case 0x47:\n                  case 0x48:\n                  case 0x49:\n                  case 0x4A:\n                  case 0x4B:\n                  case 0x4C:\n                  case 0x4D:\n                  case 0x4E:\n                  case 0x4F:\n                  case 0x50:\n                  case 0x51:\n                  case 0x52:\n                  case 0x53:\n                  case 0x54:\n                  case 0x55:\n                  case 0x56:\n                  case 0x57:\n                  case 0x58:\n                  case 0x59:\n                  case 0x5A:\n                  case 0x5D:\n                  case 0x5F:\n                  case 0x61:\n                  case 0x62:\n                  case 0x63:\n                  case 0x64:\n                  case 0x65:\n                  case 0x66:\n                  case 0x67:\n                  case 0x68:\n                  case 0x69:\n                  case 0x6A:\n                  case 0x6B:\n                  case 0x6C:\n                  case 0x6D:\n                  case 0x6E:\n                  case 0x6F:\n                  case 0x70:\n                  case 0x71:\n                  case 0x72:\n                  case 0x73:\n                  case 0x74:\n                  case 0x75:\n                  case 0x76:\n                  case 0x77:\n                  case 0x78:\n                  case 0x79:\n                  case 0x7A:\n                    v37 = v61;\n                    goto LABEL_127;\n                  case 0x27:\n                    goto LABEL_62;\n                  case 0x3F:\n                    goto LABEL_58;\n                  case 0x5C:\n                    goto LABEL_65;\n                  case 0x7B:\n                  case 0x7D:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_102;\n                }\n              }\nLABEL_277:\n              v30 = v18;\n              LODWORD(v13) = v16;\n              return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n            }\n          }\n        }\n        LOBYTE(v22) = *v19;\n        switch ( *v19 )\n        {\n          case 0:\n            goto LABEL_85;\n          case 7:\n            LOBYTE(v22) = 97;\n            goto LABEL_82;\n          case 8:\n            LOBYTE(v22) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_76:\n            LOBYTE(v22) = 116;\n            goto LABEL_69;\n          case 0xA:\nLABEL_68:\n            LOBYTE(v22) = 110;\nLABEL_69:\n            v24 = 0;\n            a5 = 0;\n            if ( v86 )\n              goto LABEL_70;\n            goto LABEL_29;\n          case 0xB:\nLABEL_84:\n            LOBYTE(v22) = 118;\n            goto LABEL_82;\n          case 0xC:\nLABEL_81:\n            LOBYTE(v22) = 102;\nLABEL_82:\n            if ( v86 )\n            {\n              v30 = v18;\n              v31 = 0;\n              LODWORD(v13) = v16;\n              goto LABEL_71;\n            }\nLABEL_83:\n            a5 = 0;\n            goto LABEL_37;\n          case 0xD:\n            v61 = 0;\nLABEL_80:\n            LOBYTE(v22) = 13;\n            v29 = 114;\n            v24 = v18 == 2;\n            goto LABEL_66;\n          case 0x20:\n            v37 = 0;\nLABEL_132:\n            LOBYTE(v22) = 32;\n            goto LABEL_127;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2A:\n          case 0x3B:\n          case 0x3C:\n          case 0x3D:\n          case 0x3E:\n          case 0x5B:\n          case 0x5E:\n          case 0x60:\n          case 0x7C:\n            v61 = 0;\nLABEL_78:\n            v24 = 0;\n            goto LABEL_67;\n          case 0x23:\n          case 0x7E:\n            v38 = 0;\nLABEL_129:\n            if ( !v17 )\n            {\n              a5 = v61;\n              v24 = 0;\n              v61 = v38;\n              goto LABEL_23;\n            }\n            v61 = v38;\n            a5 = 0;\n            break;\n          case 0x25:\n          case 0x2B:\n          case 0x2C:\n          case 0x2D:\n          case 0x2E:\n          case 0x2F:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3A:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4A:\n          case 0x4B:\n          case 0x4C:\n          case 0x4D:\n          case 0x4E:\n          case 0x4F:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5A:\n          case 0x5D:\n          case 0x5F:\n          case 0x61:\n          case 0x62:\n          case 0x63:\n          case 0x64:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6A:\n          case 0x6B:\n          case 0x6C:\n          case 0x6D:\n          case 0x6E:\n          case 0x6F:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7A:\n            v37 = 0;\nLABEL_127:\n            a5 = v61;\n            v61 = v37;\n            LOBYTE(v25) = 0;\n            goto LABEL_25;\n          case 0x27:\n            v61 = 0;\n            goto LABEL_62;\n          case 0x3F:\n            v61 = 0;\n            goto LABEL_58;\n          case 0x5C:\n            v61 = 0;\n            goto LABEL_65;\n          case 0x7B:\n          case 0x7D:\n            v61 = 0;\n            goto LABEL_17;\n          default:\n            v61 = 0;\n            goto LABEL_102;\n        }\nLABEL_24:\n        LOBYTE(v25) = 0;\nLABEL_25:\n        if ( a7 && ((*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v22 >> 5)) >> v22) & 1) != 0 )\n        {\n          v24 = v18 == 2;\nLABEL_28:\n          if ( v86 )\n          {\nLABEL_70:\n            v30 = v18;\n            v31 = v24;\n            LODWORD(v13) = v16;\nLABEL_71:\n            v60 &= v31;\n            goto LABEL_72;\n          }\nLABEL_29:\n          v26 = v14 ^ 1;\n          if ( (v24 & ((unsigned __int8)v14 ^ 1)) != 0 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v15 + 1 < v10 )\n              v9[v15 + 1] = 36;\n            if ( v15 + 2 < v10 )\n              v9[v15 + 2] = 39;\n            v15 += 3LL;\n            LOBYTE(v26) = v24 & (v14 ^ 1);\n            v14 = v26;\n          }\nLABEL_37:\n          if ( v10 > v15 )\n            v9[v15] = 92;\n          ++v15;\n          ++v17;\n          goto LABEL_40;\n        }\nLABEL_49:\n        v24 = v18 == 2;\n        if ( v61 )\n          goto LABEL_28;\n        ++v17;\n        LOBYTE(v25) = v14 & ((unsigned __int8)v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v25 )\n        {\n          if ( v10 > v15 )\n            v9[v15] = 39;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 39;\n          v15 += 2LL;\n          v14 = 0;\n        }\nLABEL_40:\n        if ( v15 < v10 )\n          v9[v15] = v22;\n        v27 = v63;\n        ++v15;\n        if ( !(_BYTE)a5 )\n          v27 = 0;\n        v63 = v27;\n      }\n      LOBYTE(v22) = *v19;\n      switch ( *v19 )\n      {\n        case 0:\n          if ( !v60 )\n          {\n            if ( (a6 & 1) == 0 )\n            {\n              v61 = 0;\n              v24 = v18 == 2;\n              a5 = 0;\n              LOBYTE(v22) = 0;\n              goto LABEL_23;\n            }\n            ++v17;\n            goto LABEL_4;\n          }\nLABEL_85:\n          if ( v86 )\n          {\n            v30 = v18;\n            LODWORD(v13) = v16;\n            v60 = v30 == 2;\n            goto LABEL_72;\n          }\n          v61 = 0;\nLABEL_87:\n          v33 = v18 == 2;\n          LODWORD(v25) = v14 ^ 1;\n          LOBYTE(v25) = (v18 == 2) & (v14 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 36;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v34 = v15 + 3;\n            if ( v10 <= v15 + 3 )\n            {\n              v15 += 4LL;\n              v14 = (int)v25;\n              a5 = 0;\n              LOBYTE(v22) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_95;\n          }\n          v34 = v15;\n          if ( v10 > v15 )\n          {\n            LODWORD(v25) = v14;\nLABEL_95:\n            v9[v34] = 92;\n            v14 = (int)v25;\n          }\n          v15 = v34 + 1;\n          if ( v18 == 2 )\n          {\n            LOBYTE(v25) = a5;\n            LOBYTE(v22) = 48;\n            a5 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v22) = 48;\n          if ( v17 + 1 < v16 && (unsigned __int8)(*(_BYTE *)(a3 + v17 + 1) - 48) <= 9u )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 48;\n            if ( v10 > v34 + 2 )\n              v9[v34 + 2] = 48;\n            v15 = v34 + 3;\n            LOBYTE(v22) = 48;\n          }\nLABEL_99:\n          LOBYTE(v25) = a5;\n          a5 = 0;\n          if ( v33 | v60 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v22) = 7;\n          v29 = 97;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v22) = 8;\n          v29 = 98;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v22) = 9;\n          v29 = 116;\n          goto LABEL_108;\n        case 0xA:\n          LOBYTE(v22) = 10;\n          v29 = 110;\n          goto LABEL_108;\n        case 0xB:\n          LOBYTE(v22) = 11;\n          v29 = 118;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xC:\n          LOBYTE(v22) = 12;\n          v29 = 102;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xD:\n          LOBYTE(v22) = 13;\n          v29 = 114;\nLABEL_108:\n          v24 = v18 == 2;\n          v61 = v18 == 2 && v86;\n          if ( v61 )\n            goto LABEL_109;\n          goto LABEL_66;\n        case 0x20:\n          LOBYTE(v22) = 32;\n          v24 = v18 == 2;\n          goto LABEL_21;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2A:\n        case 0x3B:\n        case 0x3C:\n        case 0x3D:\n        case 0x3E:\n        case 0x5B:\n        case 0x5E:\n        case 0x60:\n        case 0x7C:\n          v24 = v18 == 2;\n          a5 = 0;\n          goto LABEL_21;\n        case 0x23:\n        case 0x7E:\n          v24 = v18 == 2;\n          goto LABEL_20;\n        case 0x25:\n        case 0x2B:\n        case 0x2C:\n        case 0x2D:\n        case 0x2E:\n        case 0x2F:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3A:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4A:\n        case 0x4B:\n        case 0x4C:\n        case 0x4D:\n        case 0x4E:\n        case 0x4F:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5A:\n        case 0x5D:\n        case 0x5F:\n        case 0x61:\n        case 0x62:\n        case 0x63:\n        case 0x64:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6A:\n        case 0x6B:\n        case 0x6C:\n        case 0x6D:\n        case 0x6E:\n        case 0x6F:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7A:\n          goto LABEL_105;\n        case 0x27:\nLABEL_62:\n          if ( v18 != 2 )\n          {\n            v87 = a5;\n            v24 = 0;\n            LOBYTE(v22) = 39;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_288;\n          if ( !v10 || (v28 = 0LL, v83) )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 92;\n            v28 = v10;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v10 = v83;\n          }\n          v87 = a5;\n          v15 += 3LL;\n          LOBYTE(v25) = 0;\n          v14 = 0;\n          v83 = v10;\n          LOBYTE(v22) = 39;\n          v10 = v28;\n          goto LABEL_49;\n        case 0x3F:\nLABEL_58:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n            {\nLABEL_288:\n              v30 = 2;\n              LODWORD(v13) = v16;\n              goto LABEL_72;\n            }\n            a5 = 0;\n            LOBYTE(v25) = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_49;\n          }\n          if ( v18 != 5 )\n          {\n            LOBYTE(v22) = 63;\n            v24 = v18 == 2;\n            a5 = 0;\n            goto LABEL_23;\n          }\n          if ( (a6 & 4) == 0\n            || v17 + 2 >= v16\n            || *(_BYTE *)(a3 + v17 + 1) != 63\n            || (v22 = *(unsigned __int8 *)(a3 + v17 + 2), (unsigned __int8)v22 > 0x3Eu)\n            || (v53 = 0x7000A38200000000LL, !_bittest64(&v53, v22)) )\n          {\n            v24 = 0;\n            a5 = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_277;\n          if ( v10 > v15 )\n            v9[v15] = 63;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 34;\n          if ( v10 > v15 + 2 )\n            v9[v15 + 2] = 34;\n          if ( v10 > v15 + 3 )\n            v9[v15 + 3] = 63;\n          v15 += 4LL;\n          v33 = 0;\n          LOBYTE(a5) = 0;\n          v17 += 2LL;\n          goto LABEL_99;\n        case 0x5C:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n              goto LABEL_288;\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            LOBYTE(v22) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LOBYTE(v22) = 92;\n          v29 = 92;\n          v24 = (n != 0) & v86 & v60;\n          if ( v24 )\n          {\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v60 )\n          {\nLABEL_67:\n            a5 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v22) = v29;\n          a5 = 0;\n          goto LABEL_28;\n        case 0x7B:\n        case 0x7D:\nLABEL_17:\n          v23 = v16 != 1;\n          if ( v16 == -1LL )\n            v23 = *(_BYTE *)(a3 + 1) != 0;\n          v24 = v18 == 2;\n          if ( v23 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v17 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v86 || !v24 )\n            goto LABEL_23;\nLABEL_109:\n          LODWORD(v13) = v16;\n          v30 = 2;\n          goto LABEL_72;\n        default:\nLABEL_102:\n          if ( mb_cur_max == 1 )\n          {\n            v77 = v18;\n            v72 = v16;\n            v67 = v14;\n            v25 = __ctype_b_loc();\n            v14 = v67;\n            v16 = v72;\n            v18 = v77;\n            v35 = 1LL;\n            LODWORD(v25) = (*v25)[(unsigned __int8)v22];\n            LOWORD(v25) = (unsigned __int16)v25 & 0x4000;\n            LOBYTE(a5) = (_WORD)v25 != 0;\n            LOBYTE(v36) = v60 & ((_WORD)v25 == 0);\nLABEL_104:\n            if ( (_BYTE)v36 )\n            {\n              v36 = v60;\n              LOBYTE(a5) = 0;\nLABEL_178:\n              v48 = 0;\n              v49 = v17 + v35;\n              v50 = v61;\n              while ( 1 )\n              {\n                if ( (_BYTE)v36 )\n                {\n                  if ( v86 )\n                  {\n                    v30 = v18;\n                    v60 = v18 == 2;\n                    LODWORD(v13) = v16;\n                    goto LABEL_72;\n                  }\n                  LOBYTE(v25) = (v14 ^ 1) & (v18 == 2);\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 36;\n                    if ( v10 > v15 + 2 )\n                      v9[v15 + 2] = 39;\n                    v15 += 3LL;\n                    v14 = (int)v25;\n                  }\n                  if ( v10 > v15 )\n                    v9[v15] = 92;\n                  if ( v10 > v15 + 1 )\n                    v9[v15 + 1] = ((unsigned __int8)v22 >> 6) + 48;\n                  LODWORD(v25) = v15 + 2;\n                  if ( v10 > v15 + 2 )\n                  {\n                    LODWORD(v25) = (((unsigned __int8)v22 >> 3) & 7) + 48;\n                    v9[v15 + 2] = (_BYTE)v25;\n                  }\n                  ++v17;\n                  v15 += 3LL;\n                  LOBYTE(v22) = (v22 & 7) + 48;\n                  if ( v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_40;\n                  }\n                  v48 = v36;\n                }\n                else\n                {\n                  LODWORD(v25) = v14 & (v48 ^ 1);\n                  if ( v50 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 92;\n                    ++v15;\n                  }\n                  if ( ++v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_51;\n                  }\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    LODWORD(v25) = v15 + 1;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 39;\n                    v15 += 2LL;\n                    v50 = 0;\n                    v14 = 0;\n                  }\n                  else\n                  {\n                    v50 = 0;\n                  }\n                }\n                if ( v10 > v15 )\n                  v9[v15] = v22;\n                LOBYTE(v22) = *(_BYTE *)(a3 + v17);\n                ++v15;\n              }\n            }\nLABEL_105:\n            v24 = v18 == 2;\nLABEL_23:\n            LOBYTE(v25) = v86 | (v24 | v60 ^ 1) ^ 1;\n            if ( !(_BYTE)v25 )\n              goto LABEL_49;\n            goto LABEL_24;\n          }\n          ps = 0LL;\n          if ( v16 == -1LL )\n          {\n            v78 = v18;\n            v73 = v14;\n            v68 = v19;\n            v43 = strlen((const char *)a3);\n            v18 = v78;\n            LOBYTE(v14) = v73;\n            v19 = v68;\n            v16 = v43;\n          }\n          v89 = v15;\n          v90 = v19;\n          v44 = 0LL;\n          v88 = v14;\n          v79 = v9;\n          v81 = v10;\n          v69 = v16;\n          v74 = v18;\n          break;\n      }\n      while ( 2 )\n      {\n        v45 = (char *)v44 + v17;\n        v25 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, (char *)v44 + v17 + a3);\n        v46 = v25;\n        if ( !v25 )\n        {\nLABEL_245:\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          v14 = v88;\n          v9 = v79;\n          v36 = a5 ^ 1;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          LOBYTE(v36) = v60 & (a5 ^ 1);\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-1LL )\n        {\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          a5 = 0;\n          v14 = v88;\n          v9 = v79;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          v36 = v60;\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-2LL )\n        {\n          v16 = v69;\n          v54 = (char *)v44 + v17;\n          v55 = (char *)v44 + v17 + a3;\n          v25 = v44;\n          v35 = (unsigned __int64)v44;\n          v14 = v88;\n          v15 = v89;\n          v9 = v79;\n          v10 = v81;\n          v18 = v74;\n          if ( (unsigned __int64)v54 < v69 && *v55 )\n          {\n            do\n              v25 = (const unsigned __int16 **)((char *)v25 + 1);\n            while ( (unsigned __int64)v25 + v17 < v69 && *((_BYTE *)v25 + (_QWORD)v90) );\n            v35 = (unsigned __int64)v25;\n          }\n          v36 = v60;\n          a5 = 0;\nLABEL_246:\n          if ( v35 > 1 )\n            goto LABEL_178;\n          goto LABEL_104;\n        }\n        if ( v74 != 2 || !v86 || v25 == (const unsigned __int16 **)1 )\n        {\nLABEL_152:\n          if ( !iswprint(wc) )\n            a5 = 0;\n          v44 = (const unsigned __int16 **)((char *)v44 + (_QWORD)v46);\n          LODWORD(v25) = mbsinit(&ps);\n          if ( (_DWORD)v25 )\n            goto LABEL_245;\n          continue;\n        }\n        break;\n      }\n      v47 = &v45[a3 + 1];\n      while ( (unsigned __int8)(*v47 - 91) > 0x21u || ((1LL << (*v47 - 91)) & 0x20000002BLL) == 0 )\n      {\n        if ( (char *)v46 + a3 + (_QWORD)v45 == ++v47 )\n          goto LABEL_152;\n      }\n      LODWORD(v9) = (_DWORD)v79;\n      LODWORD(v10) = v81;\n      v30 = 2;\n      LODWORD(v13) = v69;\nLABEL_72:\n      if ( v60 )\n        v30 = 4;\n      return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n    case 5:\n      if ( v12 )\n      {\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n          v83 = 0LL;\n        }\n        else\n        {\n          v83 = 0LL;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n        }\n        v86 = 0;\n        v15 = 1LL;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 5;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", a5);\n        v51 = (char *)sub_40DD00(\"'\", a5);\n        v13 = a4;\n        a9 = v51;\n      }\n      v15 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v15] )\n        {\n          if ( a2 > v15 )\n            a1[v15] = i;\n          ++v15;\n        }\n      }\n      v62 = v13;\n      v52 = strlen(a9);\n      v63 = 1;\n      v14 = 0;\n      v13 = v62;\n      n = v52;\n      v87 = 0;\n      s2 = a9;\n      v83 = 0LL;\n      v60 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n  }\n}\n\nunsigned __int64 __fastcall sub_40DE00(\n        _BYTE *a1,\n        unsigned __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        int a5,\n        int a6,\n        __int64 a7,\n        const char *a8,\n        char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v12; // ebp\n  unsigned __int64 v13; // r11\n  int v14; // r10d\n  unsigned __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  unsigned __int64 v17; // r12\n  int v18; // r11d\n  _BYTE *v19; // r8\n  size_t v20; // rax\n  int v21; // eax\n  unsigned __int64 v22; // rbp\n  bool v23; // al\n  unsigned __int8 v24; // dl\n  const unsigned __int16 **v25; // rax\n  int v26; // eax\n  char v27; // di\n  unsigned __int64 v28; // rdx\n  char v29; // cl\n  int v30; // r13d\n  unsigned __int8 v31; // al\n  bool v33; // dl\n  unsigned __int64 v34; // rcx\n  unsigned __int64 v35; // rdi\n  int v36; // edx\n  unsigned __int8 v37; // al\n  unsigned __int8 v38; // al\n  int v39; // r13d\n  bool v40; // dl\n  bool v41; // dl\n  bool v42; // al\n  size_t v43; // rax\n  const unsigned __int16 **v44; // rbx\n  char *v45; // r15\n  const unsigned __int16 **v46; // r14\n  char *v47; // rax\n  int v48; // esi\n  unsigned __int64 v49; // rcx\n  unsigned __int8 v50; // di\n  char *v51; // rax\n  size_t v52; // rax\n  __int64 v53; // rsi\n  char *v54; // rsi\n  _BYTE *v55; // rcx\n  char i; // al\n  char v57; // dl\n  const char *v58; // rax\n  unsigned __int8 v60; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v61; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v62; // [rsp+10h] [rbp-B8h]\n  char v63; // [rsp+1Fh] [rbp-A9h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  _BYTE *v66; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v67; // [rsp+30h] [rbp-98h]\n  _BYTE *v68; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v69; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v70; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v71; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v72; // [rsp+38h] [rbp-90h]\n  char v73; // [rsp+38h] [rbp-90h]\n  int v74; // [rsp+38h] [rbp-90h]\n  int v75; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v76; // [rsp+40h] [rbp-88h]\n  int v77; // [rsp+40h] [rbp-88h]\n  int v78; // [rsp+40h] [rbp-88h]\n  _BYTE *v79; // [rsp+40h] [rbp-88h]\n  int v80; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v81; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  unsigned __int64 v83; // [rsp+58h] [rbp-70h]\n  size_t mb_cur_max; // [rsp+60h] [rbp-68h]\n  bool v86; // [rsp+6Ch] [rbp-5Ch]\n  char v87; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v88; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v89; // [rsp+70h] [rbp-58h]\n  _BYTE *v90; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h] BYREF\n  mbstate_t ps; // [rsp+88h] [rbp-40h] BYREF\n\n  v9 = a1;\n  v10 = a2;\n  v12 = a6 & 2;\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v86 = v12 != 0;\n  v13 = a4;\n  switch ( a5 )\n  {\n    case 0:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v60 = 0;\n        goto LABEL_216;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 2;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        a5 = 2;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v60 = 1;\nLABEL_216:\n      if ( a2 )\n      {\n        v14 = 0;\n        v42 = 0;\n        v63 = 1;\n        v83 = 0LL;\n        goto LABEL_142;\n      }\n      v63 = 1;\n      v14 = 0;\n      v15 = 1LL;\n      a5 = 2;\n      v83 = 0LL;\n      v87 = 0;\n      v86 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v16 = v13;\n      v17 = 0LL;\n      v18 = a5;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(a5) = v16 != v17;\n        if ( v16 == -1LL )\n          LOBYTE(a5) = *(_BYTE *)(a3 + v17) != 0;\n        if ( !(_BYTE)a5 )\n        {\n          v39 = v18;\n          v13 = v16;\n          v40 = v39 == 2;\n          if ( !v15 && v40 && v86 )\n          {\n            v30 = 2;\n            goto LABEL_72;\n          }\n          v41 = !v86 && v40;\n          if ( v41 )\n          {\n            if ( v87 )\n            {\n              if ( v63 )\n                return sub_40DE00((int)v9, v83, a3, v16, 5, a6, a7, (__int64)a8, a9);\n              v42 = v83 != 0 && v10 == 0;\n              if ( v42 )\n              {\n                v10 = v83;\nLABEL_142:\n                *v9 = 39;\n                a5 = 2;\n                v15 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v86 = 0;\n                v87 = v42;\n                goto LABEL_3;\n              }\n              v41 = v87;\n            }\n          }\n          else\n          {\n            v41 = !v86;\n          }\n          if ( s2 )\n          {\n            if ( v41 )\n            {\n              v57 = *s2;\n              if ( *s2 )\n              {\n                v58 = &s2[-v15];\n                do\n                {\n                  if ( v10 > v15 )\n                    v9[v15] = v57;\n                  v57 = v58[++v15];\n                }\n                while ( v57 );\n              }\n            }\n          }\n          if ( v10 > v15 )\n            v9[v15] = 0;\n          return v15;\n        }\n        v19 = (_BYTE *)(a3 + v17);\n        v61 = v60 & (v18 != 2);\n        if ( !v61 )\n          break;\n        if ( n )\n        {\n          if ( v16 == -1LL && n > 1 )\n          {\n            v75 = v18;\n            v70 = v14;\n            v20 = strlen((const char *)a3);\n            v18 = v75;\n            v14 = v70;\n            v19 = (_BYTE *)(a3 + v17);\n            v16 = v20;\n          }\n          if ( v17 + n <= v16 )\n          {\n            v80 = v18;\n            v76 = v16;\n            v71 = v14;\n            v66 = v19;\n            v21 = memcmp(v19, s2, n);\n            v19 = v66;\n            v14 = v71;\n            v16 = v76;\n            v18 = v80;\n            if ( !v21 )\n            {\n              if ( !v86 )\n              {\n                LOBYTE(v22) = *v66;\n                switch ( *v66 )\n                {\n                  case 0:\n                    goto LABEL_87;\n                  case 7:\n                    LOBYTE(v22) = 97;\n                    goto LABEL_83;\n                  case 8:\n                    v24 = 0;\n                    a5 = 0;\n                    LOBYTE(v22) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_76;\n                  case 0xA:\n                    goto LABEL_68;\n                  case 0xB:\n                    goto LABEL_84;\n                  case 0xC:\n                    goto LABEL_81;\n                  case 0xD:\n                    goto LABEL_80;\n                  case 0x20:\n                    v37 = v61;\n                    goto LABEL_132;\n                  case 0x21:\n                  case 0x22:\n                  case 0x24:\n                  case 0x26:\n                  case 0x28:\n                  case 0x29:\n                  case 0x2A:\n                  case 0x3B:\n                  case 0x3C:\n                  case 0x3D:\n                  case 0x3E:\n                  case 0x5B:\n                  case 0x5E:\n                  case 0x60:\n                  case 0x7C:\n                    goto LABEL_78;\n                  case 0x23:\n                  case 0x7E:\n                    v38 = v61;\n                    goto LABEL_129;\n                  case 0x25:\n                  case 0x2B:\n                  case 0x2C:\n                  case 0x2D:\n                  case 0x2E:\n                  case 0x2F:\n                  case 0x30:\n                  case 0x31:\n                  case 0x32:\n                  case 0x33:\n                  case 0x34:\n                  case 0x35:\n                  case 0x36:\n                  case 0x37:\n                  case 0x38:\n                  case 0x39:\n                  case 0x3A:\n                  case 0x41:\n                  case 0x42:\n                  case 0x43:\n                  case 0x44:\n                  case 0x45:\n                  case 0x46:\n                  case 0x47:\n                  case 0x48:\n                  case 0x49:\n                  case 0x4A:\n                  case 0x4B:\n                  case 0x4C:\n                  case 0x4D:\n                  case 0x4E:\n                  case 0x4F:\n                  case 0x50:\n                  case 0x51:\n                  case 0x52:\n                  case 0x53:\n                  case 0x54:\n                  case 0x55:\n                  case 0x56:\n                  case 0x57:\n                  case 0x58:\n                  case 0x59:\n                  case 0x5A:\n                  case 0x5D:\n                  case 0x5F:\n                  case 0x61:\n                  case 0x62:\n                  case 0x63:\n                  case 0x64:\n                  case 0x65:\n                  case 0x66:\n                  case 0x67:\n                  case 0x68:\n                  case 0x69:\n                  case 0x6A:\n                  case 0x6B:\n                  case 0x6C:\n                  case 0x6D:\n                  case 0x6E:\n                  case 0x6F:\n                  case 0x70:\n                  case 0x71:\n                  case 0x72:\n                  case 0x73:\n                  case 0x74:\n                  case 0x75:\n                  case 0x76:\n                  case 0x77:\n                  case 0x78:\n                  case 0x79:\n                  case 0x7A:\n                    v37 = v61;\n                    goto LABEL_127;\n                  case 0x27:\n                    goto LABEL_62;\n                  case 0x3F:\n                    goto LABEL_58;\n                  case 0x5C:\n                    goto LABEL_65;\n                  case 0x7B:\n                  case 0x7D:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_102;\n                }\n              }\nLABEL_277:\n              v30 = v18;\n              LODWORD(v13) = v16;\n              return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n            }\n          }\n        }\n        LOBYTE(v22) = *v19;\n        switch ( *v19 )\n        {\n          case 0:\n            goto LABEL_85;\n          case 7:\n            LOBYTE(v22) = 97;\n            goto LABEL_82;\n          case 8:\n            LOBYTE(v22) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_76:\n            LOBYTE(v22) = 116;\n            goto LABEL_69;\n          case 0xA:\nLABEL_68:\n            LOBYTE(v22) = 110;\nLABEL_69:\n            v24 = 0;\n            a5 = 0;\n            if ( v86 )\n              goto LABEL_70;\n            goto LABEL_29;\n          case 0xB:\nLABEL_84:\n            LOBYTE(v22) = 118;\n            goto LABEL_82;\n          case 0xC:\nLABEL_81:\n            LOBYTE(v22) = 102;\nLABEL_82:\n            if ( v86 )\n            {\n              v30 = v18;\n              v31 = 0;\n              LODWORD(v13) = v16;\n              goto LABEL_71;\n            }\nLABEL_83:\n            a5 = 0;\n            goto LABEL_37;\n          case 0xD:\n            v61 = 0;\nLABEL_80:\n            LOBYTE(v22) = 13;\n            v29 = 114;\n            v24 = v18 == 2;\n            goto LABEL_66;\n          case 0x20:\n            v37 = 0;\nLABEL_132:\n            LOBYTE(v22) = 32;\n            goto LABEL_127;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2A:\n          case 0x3B:\n          case 0x3C:\n          case 0x3D:\n          case 0x3E:\n          case 0x5B:\n          case 0x5E:\n          case 0x60:\n          case 0x7C:\n            v61 = 0;\nLABEL_78:\n            v24 = 0;\n            goto LABEL_67;\n          case 0x23:\n          case 0x7E:\n            v38 = 0;\nLABEL_129:\n            if ( !v17 )\n            {\n              a5 = v61;\n              v24 = 0;\n              v61 = v38;\n              goto LABEL_23;\n            }\n            v61 = v38;\n            a5 = 0;\n            break;\n          case 0x25:\n          case 0x2B:\n          case 0x2C:\n          case 0x2D:\n          case 0x2E:\n          case 0x2F:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3A:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4A:\n          case 0x4B:\n          case 0x4C:\n          case 0x4D:\n          case 0x4E:\n          case 0x4F:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5A:\n          case 0x5D:\n          case 0x5F:\n          case 0x61:\n          case 0x62:\n          case 0x63:\n          case 0x64:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6A:\n          case 0x6B:\n          case 0x6C:\n          case 0x6D:\n          case 0x6E:\n          case 0x6F:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7A:\n            v37 = 0;\nLABEL_127:\n            a5 = v61;\n            v61 = v37;\n            LOBYTE(v25) = 0;\n            goto LABEL_25;\n          case 0x27:\n            v61 = 0;\n            goto LABEL_62;\n          case 0x3F:\n            v61 = 0;\n            goto LABEL_58;\n          case 0x5C:\n            v61 = 0;\n            goto LABEL_65;\n          case 0x7B:\n          case 0x7D:\n            v61 = 0;\n            goto LABEL_17;\n          default:\n            v61 = 0;\n            goto LABEL_102;\n        }\nLABEL_24:\n        LOBYTE(v25) = 0;\nLABEL_25:\n        if ( a7 && ((*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v22 >> 5)) >> v22) & 1) != 0 )\n        {\n          v24 = v18 == 2;\nLABEL_28:\n          if ( v86 )\n          {\nLABEL_70:\n            v30 = v18;\n            v31 = v24;\n            LODWORD(v13) = v16;\nLABEL_71:\n            v60 &= v31;\n            goto LABEL_72;\n          }\nLABEL_29:\n          v26 = v14 ^ 1;\n          if ( (v24 & ((unsigned __int8)v14 ^ 1)) != 0 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v15 + 1 < v10 )\n              v9[v15 + 1] = 36;\n            if ( v15 + 2 < v10 )\n              v9[v15 + 2] = 39;\n            v15 += 3LL;\n            LOBYTE(v26) = v24 & (v14 ^ 1);\n            v14 = v26;\n          }\nLABEL_37:\n          if ( v10 > v15 )\n            v9[v15] = 92;\n          ++v15;\n          ++v17;\n          goto LABEL_40;\n        }\nLABEL_49:\n        v24 = v18 == 2;\n        if ( v61 )\n          goto LABEL_28;\n        ++v17;\n        LOBYTE(v25) = v14 & ((unsigned __int8)v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v25 )\n        {\n          if ( v10 > v15 )\n            v9[v15] = 39;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 39;\n          v15 += 2LL;\n          v14 = 0;\n        }\nLABEL_40:\n        if ( v15 < v10 )\n          v9[v15] = v22;\n        v27 = v63;\n        ++v15;\n        if ( !(_BYTE)a5 )\n          v27 = 0;\n        v63 = v27;\n      }\n      LOBYTE(v22) = *v19;\n      switch ( *v19 )\n      {\n        case 0:\n          if ( !v60 )\n          {\n            if ( (a6 & 1) == 0 )\n            {\n              v61 = 0;\n              v24 = v18 == 2;\n              a5 = 0;\n              LOBYTE(v22) = 0;\n              goto LABEL_23;\n            }\n            ++v17;\n            goto LABEL_4;\n          }\nLABEL_85:\n          if ( v86 )\n          {\n            v30 = v18;\n            LODWORD(v13) = v16;\n            v60 = v30 == 2;\n            goto LABEL_72;\n          }\n          v61 = 0;\nLABEL_87:\n          v33 = v18 == 2;\n          LODWORD(v25) = v14 ^ 1;\n          LOBYTE(v25) = (v18 == 2) & (v14 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 36;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v34 = v15 + 3;\n            if ( v10 <= v15 + 3 )\n            {\n              v15 += 4LL;\n              v14 = (int)v25;\n              a5 = 0;\n              LOBYTE(v22) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_95;\n          }\n          v34 = v15;\n          if ( v10 > v15 )\n          {\n            LODWORD(v25) = v14;\nLABEL_95:\n            v9[v34] = 92;\n            v14 = (int)v25;\n          }\n          v15 = v34 + 1;\n          if ( v18 == 2 )\n          {\n            LOBYTE(v25) = a5;\n            LOBYTE(v22) = 48;\n            a5 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v22) = 48;\n          if ( v17 + 1 < v16 && (unsigned __int8)(*(_BYTE *)(a3 + v17 + 1) - 48) <= 9u )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 48;\n            if ( v10 > v34 + 2 )\n              v9[v34 + 2] = 48;\n            v15 = v34 + 3;\n            LOBYTE(v22) = 48;\n          }\nLABEL_99:\n          LOBYTE(v25) = a5;\n          a5 = 0;\n          if ( v33 | v60 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v22) = 7;\n          v29 = 97;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v22) = 8;\n          v29 = 98;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v22) = 9;\n          v29 = 116;\n          goto LABEL_108;\n        case 0xA:\n          LOBYTE(v22) = 10;\n          v29 = 110;\n          goto LABEL_108;\n        case 0xB:\n          LOBYTE(v22) = 11;\n          v29 = 118;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xC:\n          LOBYTE(v22) = 12;\n          v29 = 102;\n          v24 = v18 == 2;\n          goto LABEL_66;\n        case 0xD:\n          LOBYTE(v22) = 13;\n          v29 = 114;\nLABEL_108:\n          v24 = v18 == 2;\n          v61 = v18 == 2 && v86;\n          if ( v61 )\n            goto LABEL_109;\n          goto LABEL_66;\n        case 0x20:\n          LOBYTE(v22) = 32;\n          v24 = v18 == 2;\n          goto LABEL_21;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2A:\n        case 0x3B:\n        case 0x3C:\n        case 0x3D:\n        case 0x3E:\n        case 0x5B:\n        case 0x5E:\n        case 0x60:\n        case 0x7C:\n          v24 = v18 == 2;\n          a5 = 0;\n          goto LABEL_21;\n        case 0x23:\n        case 0x7E:\n          v24 = v18 == 2;\n          goto LABEL_20;\n        case 0x25:\n        case 0x2B:\n        case 0x2C:\n        case 0x2D:\n        case 0x2E:\n        case 0x2F:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3A:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4A:\n        case 0x4B:\n        case 0x4C:\n        case 0x4D:\n        case 0x4E:\n        case 0x4F:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5A:\n        case 0x5D:\n        case 0x5F:\n        case 0x61:\n        case 0x62:\n        case 0x63:\n        case 0x64:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6A:\n        case 0x6B:\n        case 0x6C:\n        case 0x6D:\n        case 0x6E:\n        case 0x6F:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7A:\n          goto LABEL_105;\n        case 0x27:\nLABEL_62:\n          if ( v18 != 2 )\n          {\n            v87 = a5;\n            v24 = 0;\n            LOBYTE(v22) = 39;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_288;\n          if ( !v10 || (v28 = 0LL, v83) )\n          {\n            if ( v10 > v15 )\n              v9[v15] = 39;\n            if ( v10 > v15 + 1 )\n              v9[v15 + 1] = 92;\n            v28 = v10;\n            if ( v10 > v15 + 2 )\n              v9[v15 + 2] = 39;\n            v10 = v83;\n          }\n          v87 = a5;\n          v15 += 3LL;\n          LOBYTE(v25) = 0;\n          v14 = 0;\n          v83 = v10;\n          LOBYTE(v22) = 39;\n          v10 = v28;\n          goto LABEL_49;\n        case 0x3F:\nLABEL_58:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n            {\nLABEL_288:\n              v30 = 2;\n              LODWORD(v13) = v16;\n              goto LABEL_72;\n            }\n            a5 = 0;\n            LOBYTE(v25) = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_49;\n          }\n          if ( v18 != 5 )\n          {\n            LOBYTE(v22) = 63;\n            v24 = v18 == 2;\n            a5 = 0;\n            goto LABEL_23;\n          }\n          if ( (a6 & 4) == 0\n            || v17 + 2 >= v16\n            || *(_BYTE *)(a3 + v17 + 1) != 63\n            || (v22 = *(unsigned __int8 *)(a3 + v17 + 2), (unsigned __int8)v22 > 0x3Eu)\n            || (v53 = 0x7000A38200000000LL, !_bittest64(&v53, v22)) )\n          {\n            v24 = 0;\n            a5 = 0;\n            LOBYTE(v22) = 63;\n            goto LABEL_23;\n          }\n          if ( v86 )\n            goto LABEL_277;\n          if ( v10 > v15 )\n            v9[v15] = 63;\n          if ( v10 > v15 + 1 )\n            v9[v15 + 1] = 34;\n          if ( v10 > v15 + 2 )\n            v9[v15 + 2] = 34;\n          if ( v10 > v15 + 3 )\n            v9[v15 + 3] = 63;\n          v15 += 4LL;\n          v33 = 0;\n          LOBYTE(a5) = 0;\n          v17 += 2LL;\n          goto LABEL_99;\n        case 0x5C:\n          if ( v18 == 2 )\n          {\n            if ( v86 )\n              goto LABEL_288;\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            LOBYTE(v22) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LOBYTE(v22) = 92;\n          v29 = 92;\n          v24 = (n != 0) & v86 & v60;\n          if ( v24 )\n          {\n            ++v17;\n            LOBYTE(v25) = v14;\n            a5 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v60 )\n          {\nLABEL_67:\n            a5 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v22) = v29;\n          a5 = 0;\n          goto LABEL_28;\n        case 0x7B:\n        case 0x7D:\nLABEL_17:\n          v23 = v16 != 1;\n          if ( v16 == -1LL )\n            v23 = *(_BYTE *)(a3 + 1) != 0;\n          v24 = v18 == 2;\n          if ( v23 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v17 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v86 || !v24 )\n            goto LABEL_23;\nLABEL_109:\n          LODWORD(v13) = v16;\n          v30 = 2;\n          goto LABEL_72;\n        default:\nLABEL_102:\n          if ( mb_cur_max == 1 )\n          {\n            v77 = v18;\n            v72 = v16;\n            v67 = v14;\n            v25 = __ctype_b_loc();\n            v14 = v67;\n            v16 = v72;\n            v18 = v77;\n            v35 = 1LL;\n            LODWORD(v25) = (*v25)[(unsigned __int8)v22];\n            LOWORD(v25) = (unsigned __int16)v25 & 0x4000;\n            LOBYTE(a5) = (_WORD)v25 != 0;\n            LOBYTE(v36) = v60 & ((_WORD)v25 == 0);\nLABEL_104:\n            if ( (_BYTE)v36 )\n            {\n              v36 = v60;\n              LOBYTE(a5) = 0;\nLABEL_178:\n              v48 = 0;\n              v49 = v17 + v35;\n              v50 = v61;\n              while ( 1 )\n              {\n                if ( (_BYTE)v36 )\n                {\n                  if ( v86 )\n                  {\n                    v30 = v18;\n                    v60 = v18 == 2;\n                    LODWORD(v13) = v16;\n                    goto LABEL_72;\n                  }\n                  LOBYTE(v25) = (v14 ^ 1) & (v18 == 2);\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 36;\n                    if ( v10 > v15 + 2 )\n                      v9[v15 + 2] = 39;\n                    v15 += 3LL;\n                    v14 = (int)v25;\n                  }\n                  if ( v10 > v15 )\n                    v9[v15] = 92;\n                  if ( v10 > v15 + 1 )\n                    v9[v15 + 1] = ((unsigned __int8)v22 >> 6) + 48;\n                  LODWORD(v25) = v15 + 2;\n                  if ( v10 > v15 + 2 )\n                  {\n                    LODWORD(v25) = (((unsigned __int8)v22 >> 3) & 7) + 48;\n                    v9[v15 + 2] = (_BYTE)v25;\n                  }\n                  ++v17;\n                  v15 += 3LL;\n                  LOBYTE(v22) = (v22 & 7) + 48;\n                  if ( v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_40;\n                  }\n                  v48 = v36;\n                }\n                else\n                {\n                  LODWORD(v25) = v14 & (v48 ^ 1);\n                  if ( v50 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 92;\n                    ++v15;\n                  }\n                  if ( ++v17 >= v49 )\n                  {\n                    a5 = (unsigned __int8)a5;\n                    goto LABEL_51;\n                  }\n                  if ( (_BYTE)v25 )\n                  {\n                    if ( v10 > v15 )\n                      v9[v15] = 39;\n                    LODWORD(v25) = v15 + 1;\n                    if ( v10 > v15 + 1 )\n                      v9[v15 + 1] = 39;\n                    v15 += 2LL;\n                    v50 = 0;\n                    v14 = 0;\n                  }\n                  else\n                  {\n                    v50 = 0;\n                  }\n                }\n                if ( v10 > v15 )\n                  v9[v15] = v22;\n                LOBYTE(v22) = *(_BYTE *)(a3 + v17);\n                ++v15;\n              }\n            }\nLABEL_105:\n            v24 = v18 == 2;\nLABEL_23:\n            LOBYTE(v25) = v86 | (v24 | v60 ^ 1) ^ 1;\n            if ( !(_BYTE)v25 )\n              goto LABEL_49;\n            goto LABEL_24;\n          }\n          ps = 0LL;\n          if ( v16 == -1LL )\n          {\n            v78 = v18;\n            v73 = v14;\n            v68 = v19;\n            v43 = strlen((const char *)a3);\n            v18 = v78;\n            LOBYTE(v14) = v73;\n            v19 = v68;\n            v16 = v43;\n          }\n          v89 = v15;\n          v90 = v19;\n          v44 = 0LL;\n          v88 = v14;\n          v79 = v9;\n          v81 = v10;\n          v69 = v16;\n          v74 = v18;\n          break;\n      }\n      while ( 2 )\n      {\n        v45 = (char *)v44 + v17;\n        v25 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, (char *)v44 + v17 + a3);\n        v46 = v25;\n        if ( !v25 )\n        {\nLABEL_245:\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          v14 = v88;\n          v9 = v79;\n          v36 = a5 ^ 1;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          LOBYTE(v36) = v60 & (a5 ^ 1);\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-1LL )\n        {\n          v35 = (unsigned __int64)v44;\n          v15 = v89;\n          a5 = 0;\n          v14 = v88;\n          v9 = v79;\n          v10 = v81;\n          v16 = v69;\n          v18 = v74;\n          v36 = v60;\n          goto LABEL_246;\n        }\n        if ( v25 == (const unsigned __int16 **)-2LL )\n        {\n          v16 = v69;\n          v54 = (char *)v44 + v17;\n          v55 = (char *)v44 + v17 + a3;\n          v25 = v44;\n          v35 = (unsigned __int64)v44;\n          v14 = v88;\n          v15 = v89;\n          v9 = v79;\n          v10 = v81;\n          v18 = v74;\n          if ( (unsigned __int64)v54 < v69 && *v55 )\n          {\n            do\n              v25 = (const unsigned __int16 **)((char *)v25 + 1);\n            while ( (unsigned __int64)v25 + v17 < v69 && *((_BYTE *)v25 + (_QWORD)v90) );\n            v35 = (unsigned __int64)v25;\n          }\n          v36 = v60;\n          a5 = 0;\nLABEL_246:\n          if ( v35 > 1 )\n            goto LABEL_178;\n          goto LABEL_104;\n        }\n        if ( v74 != 2 || !v86 || v25 == (const unsigned __int16 **)1 )\n        {\nLABEL_152:\n          if ( !iswprint(wc) )\n            a5 = 0;\n          v44 = (const unsigned __int16 **)((char *)v44 + (_QWORD)v46);\n          LODWORD(v25) = mbsinit(&ps);\n          if ( (_DWORD)v25 )\n            goto LABEL_245;\n          continue;\n        }\n        break;\n      }\n      v47 = &v45[a3 + 1];\n      while ( (unsigned __int8)(*v47 - 91) > 0x21u || ((1LL << (*v47 - 91)) & 0x20000002BLL) == 0 )\n      {\n        if ( (char *)v46 + a3 + (_QWORD)v45 == ++v47 )\n          goto LABEL_152;\n      }\n      LODWORD(v9) = (_DWORD)v79;\n      LODWORD(v10) = v81;\n      v30 = 2;\n      LODWORD(v13) = v69;\nLABEL_72:\n      if ( v60 )\n        v30 = 4;\n      return sub_40DE00((int)v9, v10, a3, v13, v30, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, a9);\n    case 5:\n      if ( v12 )\n      {\n        v63 = 1;\n        v14 = 0;\n        v15 = 0LL;\n        v87 = 0;\n        v83 = 0LL;\n        v86 = 1;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n          v83 = 0LL;\n        }\n        else\n        {\n          v83 = 0LL;\n          v14 = 0;\n          v63 = 1;\n          v87 = 0;\n        }\n        v86 = 0;\n        v15 = 1LL;\n        v60 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      a5 = 5;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 1;\n      v60 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v63 = 1;\n      v14 = 0;\n      v15 = 0LL;\n      v87 = 0;\n      v83 = 0LL;\n      v86 = 0;\n      v60 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", a5);\n        v51 = (char *)sub_40DD00(\"'\", a5);\n        v13 = a4;\n        a9 = v51;\n      }\n      v15 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v15] )\n        {\n          if ( a2 > v15 )\n            a1[v15] = i;\n          ++v15;\n        }\n      }\n      v62 = v13;\n      v52 = strlen(a9);\n      v63 = 1;\n      v14 = 0;\n      v13 = v62;\n      n = v52;\n      v87 = 0;\n      s2 = a9;\n      v83 = 0LL;\n      v60 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n  }\n}\n"
        },
        {
            "funcName": "sub_40F030",
            "funcStartAddr": "0x402f19",
            "funcEndAddr": "0x402f1e",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F030(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)\n{\n  int *v6; // rax\n  __int64 v7; // rdx\n  __m128i *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // r8d\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v6 = __errno_location();\n  v8 = (__m128i *)off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__m128i *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = _mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (void *)sub_411270(off_61C558, v10);\n      v8 = (__m128i *)off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(a4 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, a2, a3, *(_DWORD *)a4, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)a4;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, a2, a3, v16, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n\n_BYTE *__fastcall sub_40F030(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)\n{\n  int *v6; // rax\n  __int64 v7; // rdx\n  __m128i *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // r8d\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v6 = __errno_location();\n  v8 = (__m128i *)off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__m128i *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = _mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (void *)sub_411270(off_61C558, v10);\n      v8 = (__m128i *)off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(a4 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, a2, a3, *(_DWORD *)a4, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)a4;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, a2, a3, v16, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n"
        },
        {
            "funcName": "sub_40F030",
            "funcStartAddr": "0x402f19",
            "funcEndAddr": "0x402f1e",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F030(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)\n{\n  int *v6; // rax\n  __int64 v7; // rdx\n  __m128i *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // r8d\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v6 = __errno_location();\n  v8 = (__m128i *)off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__m128i *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = _mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (void *)sub_411270(off_61C558, v10);\n      v8 = (__m128i *)off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(a4 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, a2, a3, *(_DWORD *)a4, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)a4;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, a2, a3, v16, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n\n_BYTE *__fastcall sub_40F030(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)\n{\n  int *v6; // rax\n  __int64 v7; // rdx\n  __m128i *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // r8d\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v6 = __errno_location();\n  v8 = (__m128i *)off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__m128i *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = _mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (void *)sub_411270(off_61C558, v10);\n      v8 = (__m128i *)off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(a4 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, a2, a3, *(_DWORD *)a4, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)a4;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, a2, a3, v16, v22, a4 + 8, *(const char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n"
        },
        {
            "funcName": "sub_40F1D0",
            "funcStartAddr": "0x40f1d0",
            "funcEndAddr": "0x40f204",
            "decompiledFuncCode": "__int64 __fastcall sub_40F1D0(__int128 *a1)\n{\n  __int128 *v1; // rbx\n  int *v2; // rax\n  int v3; // r12d\n  int *v4; // rbp\n  __int64 result; // rax\n\n  v1 = a1;\n  v2 = __errno_location();\n  v3 = *v2;\n  v4 = v2;\n  if ( !a1 )\n    v1 = &xmmword_61CCE0;\n  result = sub_411410(v1, 0x38uLL);\n  *v4 = v3;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40F2C0",
            "funcStartAddr": "0x40f2c0",
            "funcEndAddr": "0x40f332",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40F2C0(_BYTE *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int128 *a5)\n{\n  __int128 *v6; // rbx\n  int *v7; // rax\n  int v8; // r12d\n  int *v9; // rbp\n  unsigned __int64 result; // rax\n\n  v6 = a5;\n  if ( !a5 )\n    v6 = &xmmword_61CCE0;\n  v7 = __errno_location();\n  v8 = *v7;\n  v9 = v7;\n  result = sub_40DE00(\n             a1,\n             a2,\n             a3,\n             a4,\n             *(_DWORD *)v6,\n             *((_DWORD *)v6 + 1),\n             (__int64)v6 + 8,\n             *((const char **)v6 + 5),\n             *((char **)v6 + 6));\n  *v9 = v8;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40F340",
            "funcStartAddr": "0x40f340",
            "funcEndAddr": "0x40f421",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F340(__int64 a1, unsigned __int64 a2, unsigned __int64 *a3, __int128 *a4)\n{\n  __int128 *v5; // rbx\n  int *v6; // r13\n  int v7; // ebp\n  int v9; // [rsp+Ch] [rbp-5Ch]\n  _BYTE *v10; // [rsp+10h] [rbp-58h]\n  unsigned __int64 v11; // [rsp+28h] [rbp-40h]\n\n  v5 = a4;\n  if ( !a4 )\n    v5 = &xmmword_61CCE0;\n  v6 = __errno_location();\n  v7 = *((_DWORD *)v5 + 1) | (a3 == 0LL);\n  v9 = *v6;\n  v11 = sub_40DE00(0LL, 0LL, a1, a2, *(_DWORD *)v5, v7, (__int64)v5 + 8, *((const char **)v5 + 5), *((char **)v5 + 6));\n  v10 = (_BYTE *)sub_411210(v11 + 1);\n  sub_40DE00(v10, v11 + 1, a1, a2, *(_DWORD *)v5, v7, (__int64)v5 + 8, *((const char **)v5 + 5), *((char **)v5 + 6));\n  *v6 = v9;\n  if ( a3 )\n    *a3 = v11;\n  return v10;\n}\n"
        },
        {
            "funcName": "sub_40F440",
            "funcStartAddr": "0x40f440",
            "funcEndAddr": "0x40f4d5",
            "decompiledFuncCode": "void sub_40F440()\n{\n  __int128 *v0; // r12\n  void **v1; // rbx\n  void **v2; // rbp\n  void *v3; // rdi\n  void *v4; // rdi\n\n  v0 = (__int128 *)off_61C558;\n  if ( dword_61C570 > 1 )\n  {\n    v1 = (void **)((char *)off_61C558 + 24);\n    v2 = (void **)((char *)off_61C558 + 16 * (unsigned int)(dword_61C570 - 2) + 40);\n    do\n    {\n      v3 = *v1;\n      v1 += 2;\n      free(v3);\n    }\n    while ( v1 != v2 );\n  }\n  v4 = (void *)*((_QWORD *)v0 + 1);\n  if ( v4 != &unk_61CBE0 )\n  {\n    free(v4);\n    *(_QWORD *)&xmmword_61C560 = 256LL;\n    *((_QWORD *)&xmmword_61C560 + 1) = &unk_61CBE0;\n  }\n  if ( v0 != &xmmword_61C560 )\n  {\n    free(v0);\n    off_61C558 = &xmmword_61C560;\n  }\n  dword_61C570 = 1;\n}\n"
        },
        {
            "funcName": "sub_40F550",
            "funcStartAddr": "0x402f1e",
            "funcEndAddr": "0x402f23",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F550(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v4[1] = 0;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n\n_BYTE *__fastcall sub_40F550(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v4[1] = 0;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n"
        },
        {
            "funcName": "sub_40F550",
            "funcStartAddr": "0x402f1e",
            "funcEndAddr": "0x402f23",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F550(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v4[1] = 0;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n\n_BYTE *__fastcall sub_40F550(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v4[1] = 0;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n"
        },
        {
            "funcName": "sub_40F5C0",
            "funcStartAddr": "0x402f23",
            "funcEndAddr": "0x402f28",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)\n{\n  int v5[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5[0] = a2;\n  v5[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)v5);\n}\n\n_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)\n{\n  int v5[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5[0] = a2;\n  v5[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)v5);\n}\n"
        },
        {
            "funcName": "sub_40F5C0",
            "funcStartAddr": "0x402f23",
            "funcEndAddr": "0x402f28",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)\n{\n  int v5[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5[0] = a2;\n  v5[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)v5);\n}\n\n_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4)\n{\n  int v5[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5[0] = a2;\n  v5[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)v5);\n}\n"
        },
        {
            "funcName": "sub_40F630",
            "funcStartAddr": "0x40f630",
            "funcEndAddr": "0x40f63c",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F630(int a1, __int64 a2)\n{\n  return sub_40F550(0LL, a1, a2);\n}\n"
        },
        {
            "funcName": "sub_40F650",
            "funcStartAddr": "0x40f650",
            "funcEndAddr": "0x40f6c0",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F650(__int64 a1, unsigned __int64 a2, unsigned __int8 a3)\n{\n  _DWORD *v3; // r8\n  __int128 v5[3]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v6; // [rsp+30h] [rbp-18h]\n\n  v6 = qword_61CD10;\n  v5[0] = (__int128)_mm_load_si128((const __m128i *)&xmmword_61CCE0);\n  v5[1] = (__int128)_mm_load_si128((const __m128i *)&xmmword_61CCF0);\n  v3 = (_DWORD *)v5 + (a3 >> 5) + 2;\n  v5[2] = (__int128)_mm_load_si128((const __m128i *)&xmmword_61CD00);\n  *v3 ^= (((*v3 >> (a3 & 0x1F)) & 1) == 0) << (a3 & 0x1F);\n  return sub_40F030(0LL, a1, a2, (__int64)v5);\n}\n"
        },
        {
            "funcName": "sub_40F6D0",
            "funcStartAddr": "0x40f6d0",
            "funcEndAddr": "0x40f6e1",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F6D0(__int64 a1)\n{\n  return sub_40F650(a1, 0xFFFFFFFFFFFFFFFFLL, 0x3Au);\n}\n"
        },
        {
            "funcName": "sub_40F700",
            "funcStartAddr": "0x402f28",
            "funcEndAddr": "0x402f2d",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F700(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v5 = 0x400000000000000LL;\n  v4[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n\n_BYTE *__fastcall sub_40F700(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v5 = 0x400000000000000LL;\n  v4[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n"
        },
        {
            "funcName": "sub_40F700",
            "funcStartAddr": "0x402f28",
            "funcEndAddr": "0x402f2d",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F700(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v5 = 0x400000000000000LL;\n  v4[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n\n_BYTE *__fastcall sub_40F700(__int64 a1, int a2, __int64 a3)\n{\n  int v4[2]; // [rsp+0h] [rbp-48h] BYREF\n  __int64 v5; // [rsp+8h] [rbp-40h]\n  __int64 v6; // [rsp+10h] [rbp-38h]\n  __int64 v7; // [rsp+18h] [rbp-30h]\n  __int64 v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+28h] [rbp-20h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4[0] = a2;\n  v5 = 0x400000000000000LL;\n  v4[1] = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v4);\n}\n"
        },
        {
            "funcName": "sub_40F770",
            "funcStartAddr": "0x40f770",
            "funcEndAddr": "0x40f7dc",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F770(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)\n{\n  __int128 v6[2]; // [rsp+0h] [rbp-48h] BYREF\n  __m128i si128; // [rsp+20h] [rbp-28h]\n  __int64 v8; // [rsp+30h] [rbp-18h]\n\n  v6[0] = (__int128)_mm_load_si128((const __m128i *)&xmmword_61CCE0);\n  v6[1] = (__int128)_mm_load_si128((const __m128i *)&xmmword_61CCF0);\n  si128 = _mm_load_si128((const __m128i *)&xmmword_61CD00);\n  v8 = qword_61CD10;\n  LODWORD(v6[0]) = 10;\n  if ( !a2 || !a3 )\n    abort();\n  si128.m128i_i64[1] = a2;\n  v8 = a3;\n  return sub_40F030(a1, a4, a5, (__int64)v6);\n}\n"
        },
        {
            "funcName": "sub_40F860",
            "funcStartAddr": "0x40f860",
            "funcEndAddr": "0x40f871",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F860(__int64 a1, __int64 a2)\n{\n  return sub_40F030(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_61C520);\n}\n"
        },
        {
            "funcName": "sub_40F880",
            "funcStartAddr": "0x40f880",
            "funcEndAddr": "0x40f896",
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F880(__int64 a1)\n{\n  return sub_40F030(0LL, a1, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_61C520);\n}\n"
        },
        {
            "funcName": "sub_40F8A0",
            "funcStartAddr": "0x402f2d",
            "funcEndAddr": "0x402f32",
            "decompiledFuncCode": "void __fastcall __noreturn sub_40F8A0(__int64 a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_40F8A0(__int64 a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n"
        },
        {
            "funcName": "sub_40F8A0",
            "funcStartAddr": "0x402f2d",
            "funcEndAddr": "0x402f32",
            "decompiledFuncCode": "void __fastcall __noreturn sub_40F8A0(__int64 a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_40F8A0(__int64 a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n"
        },
        {
            "funcName": "sub_40F900",
            "funcStartAddr": "0x40f900",
            "funcEndAddr": "0x40fbef",
            "decompiledFuncCode": "__m128i *__fastcall sub_40F900(__int64 a1, unsigned __int64 a2)\n{\n  FILE *v2; // r13\n  __int64 v3; // rax\n  size_t v4; // rcx\n  __m128i *v5; // rbx\n  __m128i *v7; // rax\n  __m128i *v8; // r13\n  int v9; // eax\n  int v10; // r15d\n  __int64 v11; // rdx\n  __int64 chk; // rbp\n  unsigned __int64 v13; // r14\n  __int64 v14; // rbp\n  unsigned int v15; // eax\n  __int64 v16; // rdx\n  unsigned __int64 v17; // rbp\n  __int64 v18; // r14\n  unsigned int v19; // eax\n  __int64 v20; // rdx\n  unsigned __int64 v21; // rbp\n  int v22; // eax\n  unsigned int v23; // edi\n  unsigned int v24; // eax\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  struct timeval *v27; // r15\n  __int64 v28; // rbp\n  __int64 v29; // r14\n  unsigned __int64 v30; // rcx\n  unsigned int v31; // [rsp+8h] [rbp-50h]\n  struct timeval tv; // [rsp+10h] [rbp-48h] BYREF\n\n  if ( !a2 )\n  {\n    v5 = (__m128i *)sub_411210(4152LL);\n    v5->m128i_i64[0] = 0LL;\n    v5->m128i_i64[1] = (__int64)sub_40F8A0;\n    v5[1].m128i_i64[0] = 0LL;\n    return v5;\n  }\n  if ( !a1 )\n  {\n    v7 = (__m128i *)sub_411210(4152LL);\n    v7->m128i_i64[0] = 0LL;\n    v5 = v7;\n    v8 = v7 + 2;\n    v7->m128i_i64[1] = (__int64)sub_40F8A0;\n    v7[1].m128i_i64[0] = 0LL;\n    v7[1].m128i_i64[1] = 0LL;\n    v9 = open(\"/dev/urandom\", 0);\n    v10 = v9;\n    if ( v9 < 0 )\n    {\n      v13 = 20LL;\n      gettimeofday(&tv, 0LL);\n      v5[2] = _mm_load_si128((const __m128i *)&tv);\n      LODWORD(tv.tv_sec) = getpid();\n      v5[3].m128i_i32[0] = tv.tv_sec;\n    }\n    else\n    {\n      v11 = a2;\n      if ( a2 > 0x800 )\n        v11 = 2048LL;\n      chk = __read_chk((unsigned int)v9, v8, v11, 4120LL);\n      close(v10);\n      if ( chk > 2047 )\n        goto LABEL_12;\n      if ( chk < 0 )\n        chk = 0LL;\n      v26 = 2048 - chk;\n      v27 = (struct timeval *)&v8->m128i_i8[chk];\n      if ( (unsigned __int64)(2048 - chk) > 0x10 )\n        v26 = 16LL;\n      v28 = v26 + chk;\n      v31 = v26;\n      gettimeofday(&tv, 0LL);\n      qmemcpy(v27, &tv, v31);\n      if ( v28 > 2047 )\n        goto LABEL_12;\n      v29 = 2048 - v28;\n      if ( (unsigned __int64)(2048 - v28) > 4 )\n        v29 = 4LL;\n      LODWORD(tv.tv_sec) = getpid();\n      v30 = (unsigned int)v29;\n      v13 = v28 + v29;\n      qmemcpy(&v8->m128i_i8[v28], &tv, v30);\n      if ( v13 > 0x7FF )\n        goto LABEL_12;\n    }\n    v14 = 2048 - v13;\n    if ( 2048 - v13 > 4 )\n      v14 = 4LL;\n    LODWORD(tv.tv_sec) = getppid();\n    if ( (_DWORD)v14 )\n    {\n      v15 = 0;\n      do\n      {\n        v16 = v15++;\n        v8->m128i_i8[v13 + v16] = *((_BYTE *)&tv.tv_sec + v16);\n      }\n      while ( v15 < (unsigned int)v14 );\n    }\n    v17 = v13 + v14;\n    if ( v17 <= 0x7FF )\n    {\n      v18 = 2048 - v17;\n      if ( 2048 - v17 > 4 )\n        v18 = 4LL;\n      LODWORD(tv.tv_sec) = getuid();\n      if ( (_DWORD)v18 )\n      {\n        v19 = 0;\n        do\n        {\n          v20 = v19++;\n          v8->m128i_i8[v17 + v20] = *((_BYTE *)&tv.tv_sec + v20);\n        }\n        while ( v19 < (unsigned int)v18 );\n      }\n      v21 = v18 + v17;\n      if ( v21 <= 0x7FF )\n      {\n        LODWORD(tv.tv_sec) = getgid();\n        v22 = 2048 - v21;\n        if ( 2048 - v21 > 4 )\n          v22 = 4;\n        v23 = v22;\n        if ( v22 )\n        {\n          v24 = 0;\n          do\n          {\n            v25 = v24++;\n            v8->m128i_i8[v21 + v25] = *((_BYTE *)&tv.tv_sec + v25);\n          }\n          while ( v24 < v23 );\n        }\n      }\n    }\nLABEL_12:\n    sub_410070(v8);\n    return v5;\n  }\n  v2 = (FILE *)sub_4136B0(a1, \"rb\");\n  if ( !v2 )\n    return 0LL;\n  v3 = sub_411210(4152LL);\n  v4 = 4096LL;\n  *(_QWORD *)v3 = v2;\n  if ( a2 <= 0x1000 )\n    v4 = a2;\n  *(_QWORD *)(v3 + 8) = sub_40F8A0;\n  v5 = (__m128i *)v3;\n  *(_QWORD *)(v3 + 16) = a1;\n  setvbuf(v2, (char *)(v3 + 24), 0, v4);\n  return v5;\n}\n"
        },
        {
            "funcName": "sub_40FC10",
            "funcStartAddr": "0x40fc10",
            "funcEndAddr": "0x40fd6c",
            "decompiledFuncCode": "__int64 __fastcall sub_40FC10(__int64 a1, char *a2, size_t a3)\n{\n  size_t v5; // rbx\n  FILE *v6; // r13\n  int *v7; // r14\n  __int64 v8; // rdi\n  int v9; // edx\n  __int64 result; // rax\n  size_t v11; // r15\n  char *v12; // r13\n  __int64 v13; // r14\n  void *v14; // rdi\n  char *v15; // rsi\n\n  v5 = a3;\n  v6 = *(FILE **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    v7 = __errno_location();\n    while ( 1 )\n    {\n      result = fread_unlocked(a2, 1uLL, v5, v6);\n      v9 = *v7;\n      a2 += result;\n      v5 -= result;\n      if ( !v5 )\n        break;\n      v8 = *(_QWORD *)(a1 + 16);\n      if ( (**(_BYTE **)a1 & 0x20) == 0 )\n        v9 = 0;\n      *v7 = v9;\n      (*(void (__fastcall **)(__int64))(a1 + 8))(v8);\n      v6 = *(FILE **)a1;\n    }\n  }\n  else\n  {\n    v11 = *(_QWORD *)(a1 + 24);\n    v12 = (char *)(a1 + 2104);\n    v13 = a1 + 32;\n    if ( a3 <= v11 )\n    {\n      v12 = &v12[-v11 + 2048];\nLABEL_16:\n      result = (__int64)memcpy(a2, v12, v5);\n      *(_QWORD *)(a1 + 24) = v11 - v5;\n    }\n    else\n    {\n      while ( 1 )\n      {\n        v14 = a2;\n        a2 += v11;\n        v5 -= v11;\n        memcpy(v14, &v12[2048 - v11], v11);\n        if ( ((unsigned __int8)a2 & 7) == 0 )\n          break;\n        v11 = 2048LL;\n        sub_40FDC0(v13, v12);\n        if ( v5 <= 0x800 )\n        {\nLABEL_15:\n          v11 = 2048LL;\n          goto LABEL_16;\n        }\n      }\n      do\n      {\n        if ( v5 <= 0x7FF )\n        {\n          sub_40FDC0(v13, v12);\n          goto LABEL_15;\n        }\n        v15 = a2;\n        a2 += 2048;\n        result = sub_40FDC0(v13, v15);\n        v5 -= 2048LL;\n      }\n      while ( v5 );\n      *(_QWORD *)(a1 + 24) = 0LL;\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_40FD70",
            "funcStartAddr": "0x40fd70",
            "funcEndAddr": "0x40fdb9",
            "decompiledFuncCode": "__int64 __fastcall sub_40FD70(FILE **ptr)\n{\n  FILE *v1; // rbp\n\n  v1 = *ptr;\n  __explicit_bzero_chk(ptr, 4152LL, -1LL);\n  free(ptr);\n  if ( v1 )\n    return sub_411F80(v1);\n  else\n    return 0LL;\n}\n"
        },
        {
            "funcName": "sub_40FDC0",
            "funcStartAddr": "0x40fdc0",
            "funcEndAddr": "0x410065",
            "decompiledFuncCode": "unsigned __int64 *__fastcall sub_40FDC0(unsigned __int64 *a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // r11\n  unsigned __int64 v3; // rdx\n  unsigned __int64 *v4; // r9\n  __int64 v5; // r8\n  unsigned __int64 *result; // rax\n  unsigned __int64 v7; // r11\n  unsigned __int64 v8; // rcx\n  unsigned __int64 v9; // rdx\n  unsigned __int64 v10; // r8\n  unsigned __int64 v11; // rbx\n  unsigned __int64 v12; // r8\n  unsigned __int64 v13; // r11\n  unsigned __int64 v14; // rcx\n  unsigned __int64 v15; // rbx\n  unsigned __int64 v16; // rcx\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18; // r8\n  unsigned __int64 v19; // rcx\n  unsigned __int64 v20; // r8\n  unsigned __int64 v21; // rcx\n  unsigned __int64 *v22; // rsi\n  unsigned __int64 v23; // rcx\n  unsigned __int64 v24; // rdx\n  unsigned __int64 v25; // rbx\n  unsigned __int64 v26; // rcx\n  unsigned __int64 v27; // r8\n  unsigned __int64 v28; // r10\n  unsigned __int64 v29; // rcx\n  unsigned __int64 v30; // r11\n  unsigned __int64 v31; // rcx\n  unsigned __int64 v32; // rdx\n  unsigned __int64 v33; // r8\n  unsigned __int64 v34; // rcx\n  unsigned __int64 v35; // r8\n  unsigned __int64 v36; // rcx\n\n  v2 = a1[257];\n  v3 = a1[256];\n  v4 = a2;\n  v5 = a1[258] + 1;\n  result = a1;\n  a1[258] = v5;\n  v7 = v5 + v2;\n  do\n  {\n    v8 = *result;\n    v9 = result[128] + ~((v3 << 21) ^ v3);\n    v10 = v7 + v9 + *(unsigned __int64 *)((char *)a1 + (*result & 0x7F8));\n    *result = v10;\n    v11 = v8 + *(unsigned __int64 *)((char *)a1 + ((v10 >> 8) & 0x7F8));\n    *v4 = v11;\n    v12 = result[1];\n    v13 = result[129] + ((v9 >> 5) ^ v9);\n    v14 = v11 + v13 + *(unsigned __int64 *)((char *)a1 + (v12 & 0x7F8));\n    result[1] = v14;\n    v15 = v12 + *(unsigned __int64 *)((char *)a1 + ((v14 >> 8) & 0x7F8));\n    v4[1] = v15;\n    v16 = result[2];\n    v17 = result[130] + (v13 ^ (v13 << 12));\n    v18 = v15 + v17 + *(unsigned __int64 *)((char *)a1 + (v16 & 0x7F8));\n    result[2] = v18;\n    v19 = *(unsigned __int64 *)((char *)a1 + ((v18 >> 8) & 0x7F8)) + v16;\n    v4[2] = v19;\n    v20 = result[3];\n    v3 = result[131] + ((v17 >> 33) ^ v17);\n    v21 = v19 + v3 + *(unsigned __int64 *)((char *)a1 + (v20 & 0x7F8));\n    result += 4;\n    v4 += 4;\n    *(result - 1) = v21;\n    v7 = v20 + *(unsigned __int64 *)((char *)a1 + ((v21 >> 8) & 0x7F8));\n    *(v4 - 1) = v7;\n  }\n  while ( result != a1 + 128 );\n  v22 = a2 + 128;\n  do\n  {\n    v23 = *result;\n    v24 = *(result - 128) + ~((v3 << 21) ^ v3);\n    v25 = v24 + *(unsigned __int64 *)((char *)a1 + (*result & 0x7F8));\n    *result = v7 + v25;\n    v26 = *(unsigned __int64 *)((char *)a1 + (((v7 + v25) >> 8) & 0x7F8)) + v23;\n    *v22 = v26;\n    v27 = result[1];\n    v28 = *(result - 127) + ((v24 >> 5) ^ v24);\n    v29 = v26 + v28 + *(unsigned __int64 *)((char *)a1 + (v27 & 0x7F8));\n    result[1] = v29;\n    v30 = v27 + *(unsigned __int64 *)((char *)a1 + ((v29 >> 8) & 0x7F8));\n    v22[1] = v30;\n    v31 = result[2];\n    v32 = *(result - 126) + (v28 ^ (v28 << 12));\n    v33 = v30 + v32 + *(unsigned __int64 *)((char *)a1 + (v31 & 0x7F8));\n    result[2] = v33;\n    v34 = *(unsigned __int64 *)((char *)a1 + ((v33 >> 8) & 0x7F8)) + v31;\n    v22[2] = v34;\n    v35 = result[3];\n    v3 = *(result - 125) + ((v32 >> 33) ^ v32);\n    v36 = v34 + v3 + *(unsigned __int64 *)((char *)a1 + (v35 & 0x7F8));\n    result += 4;\n    v22 += 4;\n    *(result - 1) = v36;\n    v7 = v35 + *(unsigned __int64 *)((char *)a1 + ((v36 >> 8) & 0x7F8));\n    *(v22 - 1) = v7;\n  }\n  while ( result != a1 + 256 );\n  a1[256] = v3;\n  a1[257] = v7;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_410070",
            "funcStartAddr": "0x410070",
            "funcEndAddr": "0x4102a4",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_410070(__int64 *a1)\n{\n  __int64 *v1; // rdx\n  __int64 *v2; // rax\n  unsigned __int64 v3; // rcx\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // r11\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // r10\n  unsigned __int64 v8; // r9\n  __int64 *v9; // rbp\n  __int64 v10; // r8\n  __int64 v11; // rbx\n  unsigned __int64 v12; // rsi\n  unsigned __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  unsigned __int64 v17; // r12\n  unsigned __int64 v18; // r10\n  unsigned __int64 v19; // rcx\n  unsigned __int64 v20; // r11\n  unsigned __int64 v21; // rsi\n  unsigned __int64 v22; // rbx\n  unsigned __int64 v23; // r13\n  unsigned __int64 v24; // r12\n  unsigned __int64 v25; // rcx\n  unsigned __int64 v26; // rsi\n  unsigned __int64 v27; // r8\n  __int64 v28; // rbx\n  unsigned __int64 v29; // r9\n  unsigned __int64 v30; // r12\n  unsigned __int64 v31; // r10\n  unsigned __int64 v32; // rcx\n  unsigned __int64 v33; // r11\n  unsigned __int64 v34; // rsi\n  unsigned __int64 v35; // rbx\n  unsigned __int64 result; // rax\n  unsigned __int64 v37; // r12\n\n  v1 = a1;\n  v2 = a1;\n  v3 = 0x98F5704F6C44C0ABLL;\n  v4 = 0x82F053DB8355E0CELL;\n  v5 = 0xB29B2E824A595524LL;\n  v6 = 0xAE985BF2CBFC89EDLL;\n  v7 = 0x8C0EA5053D4712A0LL;\n  v8 = 0xB9F8B322C73AC862LL;\n  v9 = a1 + 256;\n  v10 = 0x647C4677A2884B7CLL;\n  v11 = 0x48FE4A0FA5A09315LL;\n  do\n  {\n    v12 = v2[4] + v4;\n    v13 = v2[7] + v3;\n    v14 = *v2 - v12 + v10;\n    v15 = (v13 >> 9) ^ (v2[5] + v11);\n    v16 = v2[1] - v15 + v8;\n    v17 = (v14 << 9) ^ (v2[6] + v6);\n    v18 = v2[2] - v17 + v7;\n    v19 = (v16 >> 23) ^ (v14 + v13);\n    v20 = v2[3] - v19 + v5;\n    v10 = (v18 << 15) ^ (v16 + v14);\n    v21 = v12 - v10;\n    *v2 = v10;\n    v8 = (v20 >> 14) ^ (v18 + v16);\n    v22 = v15 - v8;\n    v2[1] = v8;\n    v7 = (v21 << 20) ^ (v20 + v18);\n    v23 = v21 + v22;\n    v24 = v17 - v7;\n    v2[2] = v7;\n    v2 += 8;\n    v5 = (v22 >> 17) ^ (v21 + v20);\n    v11 = v24 + v22;\n    v3 = v19 - v5;\n    *(v2 - 5) = v5;\n    v4 = v23 ^ (v24 << 14);\n    v6 = v3 + v24;\n    *(v2 - 3) = v11;\n    *(v2 - 4) = v4;\n    *(v2 - 2) = v6;\n    *(v2 - 1) = v3;\n  }\n  while ( v9 != v2 );\n  do\n  {\n    v25 = v1[7] + v3;\n    v26 = v1[4] + v4;\n    v27 = *v1 + v10 - v26;\n    v28 = (v25 >> 9) ^ (v1[5] + v11);\n    v29 = v1[1] + v8 - v28;\n    v30 = (v27 << 9) ^ (v1[6] + v6);\n    v31 = v1[2] + v7 - v30;\n    v32 = (v29 >> 23) ^ (v27 + v25);\n    v33 = v1[3] + v5 - v32;\n    v10 = (v31 << 15) ^ (v29 + v27);\n    v34 = v26 - v10;\n    *v1 = v10;\n    v8 = (v33 >> 14) ^ (v31 + v29);\n    v35 = v28 - v8;\n    v1[1] = v8;\n    v7 = (v34 << 20) ^ (v33 + v31);\n    result = v34 + v35;\n    v37 = v30 - v7;\n    v1[2] = v7;\n    v1 += 8;\n    v5 = (v35 >> 17) ^ (v34 + v33);\n    v11 = v37 + v35;\n    v3 = v32 - v5;\n    *(v1 - 5) = v5;\n    v4 = result ^ (v37 << 14);\n    v6 = v3 + v37;\n    *(v1 - 3) = v11;\n    *(v1 - 4) = v4;\n    *(v1 - 2) = v6;\n    *(v1 - 1) = v3;\n  }\n  while ( v9 != v1 );\n  a1[258] = 0LL;\n  a1[257] = 0LL;\n  a1[256] = 0LL;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4102B0",
            "funcStartAddr": "0x4102b0",
            "funcEndAddr": "0x410399",
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_4102B0(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // r12\n  __int64 v3; // rbp\n  __int64 v4; // rcx\n  __int64 v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  _QWORD *v9; // rdx\n  __int64 *v10; // rdx\n  __int64 v11; // rax\n  unsigned __int64 result; // rax\n\n  v1 = *(_QWORD *)(a1 + 48);\n  v2 = *(_QWORD *)(a1 + 40);\n  v3 = v1 - v2 - 1;\n  if ( v1 == v2 )\n    *(_BYTE *)(a1 + 104) |= 2u;\n  v4 = *(_QWORD *)(a1 + 72);\n  v5 = v1 + v4;\n  v6 = *(_QWORD *)(a1 + 56);\n  v7 = ~v4 & v5;\n  v8 = *(_QWORD *)(a1 + 32);\n  *(_QWORD *)(a1 + 48) = v7;\n  if ( v7 - v8 > (unsigned __int64)(v6 - v8) )\n  {\n    *(_QWORD *)(a1 + 48) = v6;\n    v7 = v6;\n  }\n  *(_QWORD *)(a1 + 40) = v7;\n  v9 = *(_QWORD **)(a1 + 136);\n  if ( *(_QWORD *)(a1 + 144) - (_QWORD)v9 <= 7uLL )\n  {\n    obstack_newchunk(a1 + 112, 8LL);\n    v9 = *(_QWORD **)(a1 + 136);\n  }\n  *v9 = v2;\n  v10 = *(__int64 **)(a1 + 224);\n  v11 = *(_QWORD *)(a1 + 232);\n  *(_QWORD *)(a1 + 136) += 8LL;\n  result = v11 - (_QWORD)v10;\n  if ( result <= 7 )\n  {\n    result = obstack_newchunk(a1 + 200, 8LL);\n    v10 = *(__int64 **)(a1 + 224);\n  }\n  *v10 = v3;\n  *(_QWORD *)(a1 + 224) += 8LL;\n  ++*(_QWORD *)a1;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4103A0",
            "funcStartAddr": "0x4103a0",
            "funcEndAddr": "0x410407",
            "decompiledFuncCode": "__int64 __fastcall sub_4103A0(_QWORD *a1)\n{\n  _QWORD *v2; // rdi\n\n  *a1 = 0LL;\n  v2 = a1 + 3;\n  *(v2 - 2) = 0LL;\n  *(v2 - 1) = 0LL;\n  obstack_begin(v2, 0LL, 0LL, malloc, free);\n  obstack_begin(a1 + 14, 0LL, 0LL, malloc, free);\n  return obstack_begin(a1 + 25, 0LL, 0LL, malloc, free);\n}\n"
        },
        {
            "funcName": "sub_410410",
            "funcStartAddr": "0x410410",
            "funcEndAddr": "0x410439",
            "decompiledFuncCode": "void __fastcall sub_410410(__int64 a1)\n{\n  obstack_free((struct obstack *)(a1 + 24), 0LL);\n  obstack_free((struct obstack *)(a1 + 112), 0LL);\n  obstack_free((struct obstack *)(a1 + 200), 0LL);\n}\n"
        },
        {
            "funcName": "sub_410440",
            "funcStartAddr": "0x410440",
            "funcEndAddr": "0x410653",
            "decompiledFuncCode": "bool __fastcall sub_410440(FILE *stream, __int64 a2)\n{\n  int i; // eax\n  _BYTE *v4; // rdx\n  _BYTE *v5; // rdx\n  _BYTE *v6; // rax\n  _QWORD *v7; // rdx\n  __int64 v8; // rsi\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  __int64 v14; // rcx\n  __int64 v15; // rdx\n  __int64 v16; // rsi\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rax\n  __int64 v21; // rcx\n  int v23; // [rsp+Ch] [rbp-1Ch]\n\nLABEL_3:\n  for ( i = fgetc(stream); i != -1; i = fgetc(stream) )\n  {\n    v4 = *(_BYTE **)(a2 + 48);\n    if ( *(_BYTE **)(a2 + 56) == v4 )\n    {\n      v23 = i;\n      obstack_newchunk(a2 + 24, 1LL);\n      v5 = *(_BYTE **)(a2 + 48);\n      *(_QWORD *)(a2 + 48) = v5 + 1;\n      *v5 = v23;\n      if ( v23 )\n        goto LABEL_3;\n    }\n    else\n    {\n      *(_QWORD *)(a2 + 48) = v4 + 1;\n      *v4 = i;\n      if ( i )\n        goto LABEL_3;\n    }\n    sub_4102B0(a2);\n  }\n  v6 = *(_BYTE **)(a2 + 48);\n  if ( v6 != *(_BYTE **)(a2 + 40) )\n  {\n    if ( v6 == *(_BYTE **)(a2 + 56) )\n    {\n      obstack_newchunk(a2 + 24, 1LL);\n      v6 = *(_BYTE **)(a2 + 48);\n    }\n    *(_QWORD *)(a2 + 48) = v6 + 1;\n    *v6 = 0;\n    sub_4102B0(a2);\n  }\n  v7 = *(_QWORD **)(a2 + 136);\n  if ( *(_QWORD *)(a2 + 144) - (_QWORD)v7 <= 7uLL )\n  {\n    obstack_newchunk(a2 + 112, 8LL);\n    v7 = *(_QWORD **)(a2 + 136);\n  }\n  *v7 = 0LL;\n  v8 = *(_QWORD *)(a2 + 128);\n  v9 = *(_QWORD *)(a2 + 136) + 8LL;\n  *(_QWORD *)(a2 + 136) = v9;\n  if ( v9 == v8 )\n    *(_BYTE *)(a2 + 192) |= 2u;\n  v10 = *(_QWORD *)(a2 + 160);\n  v11 = v9 + v10;\n  v12 = *(_QWORD *)(a2 + 120);\n  v13 = ~v10 & v11;\n  v14 = *(_QWORD *)(a2 + 144);\n  *(_QWORD *)(a2 + 136) = v13;\n  if ( v13 - v12 > (unsigned __int64)(v14 - v12) )\n  {\n    *(_QWORD *)(a2 + 136) = v14;\n    v13 = v14;\n  }\n  *(_QWORD *)(a2 + 8) = v8;\n  v15 = *(_QWORD *)(a2 + 224);\n  v16 = *(_QWORD *)(a2 + 216);\n  *(_QWORD *)(a2 + 128) = v13;\n  if ( v15 == v16 )\n    *(_BYTE *)(a2 + 280) |= 2u;\n  v17 = *(_QWORD *)(a2 + 248);\n  v18 = v15 + v17;\n  v19 = *(_QWORD *)(a2 + 208);\n  v20 = ~v17 & v18;\n  v21 = *(_QWORD *)(a2 + 232);\n  *(_QWORD *)(a2 + 224) = v20;\n  if ( v20 - v19 > (unsigned __int64)(v21 - v19) )\n  {\n    *(_QWORD *)(a2 + 224) = v21;\n    v20 = v21;\n  }\n  *(_QWORD *)(a2 + 216) = v20;\n  *(_QWORD *)(a2 + 16) = v16;\n  return ferror(stream) == 0;\n}\n"
        },
        {
            "funcName": "sub_410660",
            "funcStartAddr": "0x410660",
            "funcEndAddr": "0x410674",
            "decompiledFuncCode": "__int64 __fastcall sub_410660(char *a1)\n{\n  int v1; // eax\n\n  v1 = mkstemp(a1);\n  return sub_410C20(v1);\n}\n"
        },
        {
            "funcName": "sub_410680",
            "funcStartAddr": "0x410680",
            "funcEndAddr": "0x410692",
            "decompiledFuncCode": "__int64 __fastcall sub_410680(char *a1, int a2)\n{\n  int v2; // eax\n\n  v2 = mkostemp(a1, a2);\n  return sub_413640(v2);\n}\n"
        },
        {
            "funcName": "sub_4106A0",
            "funcStartAddr": "0x4106a0",
            "funcEndAddr": "0x410c1e",
            "decompiledFuncCode": "__int64 __fastcall sub_4106A0(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)\n{\n  unsigned __int8 v4; // r9\n  unsigned __int8 v5; // r8\n  int v6; // eax\n  unsigned int v7; // esi\n  __int64 result; // rax\n  unsigned __int8 v9; // al\n  int v10; // r9d\n  int v11; // r10d\n  int v12; // eax\n  int v13; // r10d\n  unsigned __int8 v14; // r8\n  int v15; // r10d\n  unsigned __int8 *v16; // rsi\n  int v17; // eax\n  unsigned int v18; // r8d\n  unsigned int v19; // r10d\n  unsigned __int64 v20; // r8\n  int v21; // edx\n  unsigned __int64 v22; // rdi\n  int v23; // edx\n  unsigned int v24; // r8d\n  int v25; // eax\n  unsigned int v26; // r10d\n  unsigned __int64 v27; // r8\n  int v28; // edx\n  int v29; // edx\n  unsigned __int8 v30; // r8\n  signed __int8 *v31; // rax\n  signed __int8 i; // dl\n  int v33; // eax\n  unsigned __int8 v34; // cl\n  int v35; // ecx\n  unsigned int v36; // r8d\n  unsigned int v37; // r10d\n  int v38; // eax\n  int v39; // ecx\n  unsigned int v40; // r8d\n  unsigned int v41; // edx\n\n  v4 = *a1;\n  v5 = *a2;\n  if ( *a1 != 45 )\n  {\n    if ( v5 == 45 )\n    {\n      do\n      {\n        do\n          v6 = *++a2;\n        while ( (_BYTE)v6 == 48 );\n      }\n      while ( a4 == v6 );\n      if ( a3 == v6 )\n      {\n        do\n        {\n          v16 = a2 + 1;\n          v6 = *v16;\n          if ( (_BYTE)v6 != 48 )\n            break;\n          a2 = v16 + 1;\n          v6 = *a2;\n        }\n        while ( (_BYTE)v6 == 48 );\n      }\n      v7 = v6 - 48;\n      result = 1LL;\n      if ( v7 <= 9 )\n        return result;\n      while ( 1 )\n      {\n        if ( v4 != 48 )\n        {\n          v17 = v4;\n          if ( a4 != v4 )\n            break;\n        }\n        v4 = *++a1;\n      }\n      if ( a3 == v4 )\n      {\n        do\n          ++a1;\n        while ( *a1 == 48 );\n        v17 = *a1;\n      }\n      return (unsigned int)(v17 - 48) <= 9;\n    }\n    while ( 1 )\n    {\n      if ( v4 != 48 )\n      {\n        v12 = v4;\n        if ( a4 != v4 )\n          break;\n      }\n      v4 = *++a1;\n    }\n    if ( v5 != 48 )\n      goto LABEL_24;\n    do\n    {\n      do\n        v5 = *++a2;\n      while ( *a2 == 48 );\nLABEL_24:\n      v13 = v5;\n    }\n    while ( a4 == v5 );\n    while ( v4 == v5 && (unsigned int)(v13 - 48) <= 9 )\n    {\n      do\n      {\n        v12 = *++a1;\n        v4 = *a1;\n      }\n      while ( a4 == v12 );\n      do\n      {\n        v13 = *++a2;\n        v5 = *a2;\n        if ( a4 != v13 )\n          break;\n        v13 = *++a2;\n        v5 = *a2;\n      }\n      while ( a4 == v13 );\n    }\n    if ( a3 == v12 && (unsigned int)(v13 - 48) > 9 )\n    {\nLABEL_80:\n      v30 = *a2;\n      if ( (_BYTE)a3 != *a1 )\n      {\n        result = 0LL;\n        if ( (_BYTE)a3 != v30 )\n          return result;\n        v31 = (signed __int8 *)(a2 + 1);\nLABEL_84:\n        for ( i = a2[1]; i == 48; i = *v31 )\n          ++v31;\n        v33 = i;\n        return (unsigned int)-((unsigned int)(v33 - 48) <= 9);\n      }\n      v35 = (char)a1[1];\n      if ( (_BYTE)a3 == v30 )\n      {\n        while ( 1 )\n        {\n          i = *++a2;\n          ++a1;\n          v36 = (char)v35 - 48;\n          if ( *a2 != (_BYTE)v35 )\n            break;\n          if ( v36 > 9 )\n            return 0LL;\n          v35 = (char)a1[1];\n        }\n        v37 = i - 48;\n        if ( v36 > 9 )\n        {\n          result = 0LL;\n          if ( v37 > 9 )\n            return result;\n          v31 = (signed __int8 *)a2;\n          goto LABEL_84;\n        }\n        if ( v37 <= 9 )\n          return (unsigned int)((char)v35 - i);\n      }\n      else\n      {\n        ++a1;\n      }\n      while ( (_BYTE)v35 == 48 )\n        v35 = (char)*++a1;\n      return (unsigned int)(v35 - 48) <= 9;\n    }\n    v18 = v12 - 48;\n    if ( a3 == v13 )\n    {\n      if ( v18 > 9 )\n        goto LABEL_80;\n      result = (unsigned int)(v12 - a3);\n      v19 = a3 - 48;\n      goto LABEL_54;\n    }\n    result = (unsigned int)(v12 - v13);\n    v19 = v13 - 48;\n    if ( v18 <= 9 )\n    {\nLABEL_54:\n      v20 = 0LL;\n      do\n      {\n        do\n          v21 = *++a1;\n        while ( a4 == v21 );\n        ++v20;\n      }\n      while ( (unsigned int)(v21 - 48) <= 9 );\n      if ( v19 > 9 )\n        return v20 != 0;\n      goto LABEL_58;\n    }\n    v20 = 0LL;\n    if ( v19 <= 9 )\n    {\nLABEL_58:\n      v22 = 0LL;\n      do\n      {\n        do\n          v23 = *++a2;\n        while ( a4 == v23 );\n        ++v22;\n      }\n      while ( (unsigned int)(v23 - 48) <= 9 );\n      if ( v22 != v20 )\n        return v20 < v22 ? -1 : 1;\nLABEL_74:\n      if ( !v22 )\n        return 0LL;\n      return result;\n    }\n    return 0LL;\n  }\n  do\n  {\n    do\n      v9 = *++a1;\n    while ( *a1 == 48 );\n    v10 = v9;\n  }\n  while ( a4 == v9 );\n  if ( v5 != 45 )\n  {\n    if ( a3 == v9 )\n    {\n      do\n        ++a1;\n      while ( *a1 == 48 );\n      v10 = *a1;\n    }\n    if ( (unsigned int)(v10 - 48) <= 9 )\n      return 0xFFFFFFFFLL;\n    while ( 1 )\n    {\n      if ( v5 != 48 )\n      {\n        v11 = v5;\n        if ( a4 != v5 )\n          break;\n      }\n      v5 = *++a2;\n    }\n    if ( a3 == v5 )\n    {\n      do\n        ++a2;\n      while ( *a2 == 48 );\n      v11 = *a2;\n    }\n    return (unsigned int)-((unsigned int)(v11 - 48) <= 9);\n  }\n  do\n  {\n    do\n      v14 = *++a2;\n    while ( *a2 == 48 );\n    v15 = v14;\n  }\n  while ( a4 == v14 );\n  while ( v9 == v14 && (unsigned int)(v15 - 48) <= 9 )\n  {\n    do\n    {\n      v10 = *++a1;\n      v9 = *a1;\n    }\n    while ( a4 == v10 );\n    do\n    {\n      v15 = *++a2;\n      v14 = *a2;\n      if ( a4 != v15 )\n        break;\n      v15 = *++a2;\n      v14 = *a2;\n    }\n    while ( a4 == v15 );\n  }\n  if ( a3 != v10 || (unsigned int)(v15 - 48) <= 9 )\n  {\n    v24 = v10 - 48;\n    if ( a3 == v15 )\n    {\n      if ( v24 > 9 )\n        goto LABEL_93;\n      v26 = a3 - 48;\n      result = (unsigned int)(a3 - v10);\n    }\n    else\n    {\n      v25 = v15;\n      v26 = v15 - 48;\n      result = (unsigned int)(v25 - v10);\n      if ( v24 > 9 )\n      {\n        v27 = 0LL;\n        if ( v26 > 9 )\n          return 0LL;\nLABEL_70:\n        v22 = 0LL;\n        do\n        {\n          do\n            v29 = *++a2;\n          while ( a4 == v29 );\n          ++v22;\n        }\n        while ( (unsigned int)(v29 - 48) <= 9 );\n        if ( v22 != v27 )\n          return v27 < v22 ? 1 : -1;\n        goto LABEL_74;\n      }\n    }\n    v27 = 0LL;\n    do\n    {\n      do\n        v28 = *++a1;\n      while ( a4 == v28 );\n      ++v27;\n    }\n    while ( (unsigned int)(v28 - 48) <= 9 );\n    if ( v26 > 9 )\n      return (unsigned int)-(v27 != 0);\n    goto LABEL_70;\n  }\nLABEL_93:\n  v34 = *a1;\n  if ( (_BYTE)a3 != *a2 )\n  {\n    result = 0LL;\n    if ( (_BYTE)a3 != v34 )\n      return result;\n    do\n    {\n      ++a1;\nLABEL_96:\n      v33 = (char)*a1;\n    }\n    while ( *a1 == 48 );\n    return (unsigned int)-((unsigned int)(v33 - 48) <= 9);\n  }\n  if ( (_BYTE)a3 != v34 )\n  {\n    do\n    {\n      ++a2;\nLABEL_117:\n      v17 = (char)*a2;\n    }\n    while ( *a2 == 48 );\n    return (unsigned int)(v17 - 48) <= 9;\n  }\n  while ( 1 )\n  {\n    ++a2;\n    ++a1;\n    v38 = (char)*a2;\n    v39 = (char)*a1;\n    v40 = v38 - 48;\n    if ( *a2 != *a1 )\n      break;\n    if ( v40 > 9 )\n      return 0LL;\n  }\n  v41 = v39 - 48;\n  if ( v40 > 9 )\n  {\n    result = 0LL;\n    if ( v41 <= 9 )\n      goto LABEL_96;\n  }\n  else\n  {\n    if ( v41 > 9 )\n      goto LABEL_117;\n    return (unsigned int)(v38 - v39);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_410C20",
            "funcStartAddr": "0x410c20",
            "funcEndAddr": "0x410c6e",
            "decompiledFuncCode": "__int64 __fastcall sub_410C20(unsigned int fd)\n{\n  __int64 result; // rax\n  unsigned int v2; // r12d\n  int *v3; // rax\n  int v4; // r13d\n  int *v5; // rbp\n\n  if ( fd > 2 )\n    return fd;\n  v2 = sub_413EA0();\n  v3 = __errno_location();\n  v4 = *v3;\n  v5 = v3;\n  close(fd);\n  result = v2;\n  *v5 = v4;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_410C70",
            "funcStartAddr": "0x402f32",
            "funcEndAddr": "0x402f37",
            "decompiledFuncCode": "__int64 __fastcall sub_410C70(FILE *stream, const char *a2, const char *a3, const char *a4, __int64 *a5, __int64 a6)\n{\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // r8\n  __int64 v12; // r13\n  __int64 v13; // r12\n  __int64 v14; // r15\n  __int64 v15; // r14\n  __int64 v16; // rbx\n  char *v17; // rax\n  const char *v19; // rsi\n  __int64 v20; // r8\n  __int64 v21; // r13\n  __int64 v22; // r12\n  __int64 v23; // r15\n  __int64 v24; // r14\n  __int64 v25; // rbx\n  char *v26; // rax\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r12\n  __int64 v30; // rbx\n  char *v31; // rax\n  __int64 v32; // r13\n  __int64 v33; // r12\n  __int64 v34; // rbx\n  char *v35; // rax\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r12\n  __int64 v42; // r15\n  __int64 v43; // r14\n  __int64 v44; // r13\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r13\n  __int64 v48; // r12\n  __int64 v49; // r15\n  __int64 v50; // r14\n  __int64 v51; // r8\n  __int64 v52; // rbx\n  char *v53; // rax\n  __int64 v54; // r8\n  __int64 v55; // [rsp-10h] [rbp-68h]\n  __int64 v56; // [rsp+0h] [rbp-58h]\n  __int64 v57; // [rsp+0h] [rbp-58h]\n  __int64 v58; // [rsp+0h] [rbp-58h]\n  __int64 v59; // [rsp+0h] [rbp-58h]\n  __int64 v60; // [rsp+8h] [rbp-50h]\n  __int64 v61; // [rsp+8h] [rbp-50h]\n  __int64 v62; // [rsp+8h] [rbp-50h]\n  __int64 v63; // [rsp+10h] [rbp-48h]\n  __int64 v64; // [rsp+10h] [rbp-48h]\n  __int64 v65; // [rsp+18h] [rbp-40h]\n\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3, a4);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8, 2017LL);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( a6 )\n  {\n    case 0LL:\n      abort();\n    case 1LL:\n      v27 = *a5;\n      v28 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v28, v27);\n    case 2LL:\n      v29 = a5[1];\n      v30 = *a5;\n      v31 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v31, v30, v29);\n    case 3LL:\n      v32 = a5[2];\n      v33 = a5[1];\n      v34 = *a5;\n      v35 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v35, v34, v33, v32);\n    case 4LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v40, v39, v38, v37, v36);\n      return v55;\n    case 6LL:\n      v41 = a5[5];\n      v42 = a5[4];\n      v43 = a5[3];\n      v58 = a5[1];\n      v44 = a5[2];\n      v45 = *a5;\n      v46 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v46, v45, v58, v44, v43, v42, v41);\n    case 7LL:\n      v47 = a5[6];\n      v48 = a5[5];\n      v49 = a5[4];\n      v50 = a5[3];\n      v51 = a5[1];\n      v62 = a5[2];\n      v52 = *a5;\n      v59 = v51;\n      v53 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v53, v52, v59, v62, v50, v49, v48, v47);\n    case 8LL:\n      v10 = a5[2];\n      v11 = a5[1];\n      v12 = a5[6];\n      v13 = a5[5];\n      v14 = a5[4];\n      v63 = a5[7];\n      v15 = a5[3];\n      v16 = *a5;\n      v56 = v10;\n      v60 = v11;\n      v17 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16, v60, v56, v15, v14, v13, v12, v63);\n    case 9LL:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v20 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v20;\n      goto LABEL_8;\n    default:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v54 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v54;\nLABEL_8:\n      v26 = dcgettext(0LL, v19, 5);\n      return __fprintf_chk(stream, 1LL, v26, v25, v61, v57, v24, v23, v22, v21, v64, v65);\n  }\n}\n\n__int64 __fastcall sub_410C70(FILE *stream, const char *a2, const char *a3, const char *a4, __int64 *a5, __int64 a6)\n{\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // r8\n  __int64 v12; // r13\n  __int64 v13; // r12\n  __int64 v14; // r15\n  __int64 v15; // r14\n  __int64 v16; // rbx\n  char *v17; // rax\n  const char *v19; // rsi\n  __int64 v20; // r8\n  __int64 v21; // r13\n  __int64 v22; // r12\n  __int64 v23; // r15\n  __int64 v24; // r14\n  __int64 v25; // rbx\n  char *v26; // rax\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r12\n  __int64 v30; // rbx\n  char *v31; // rax\n  __int64 v32; // r13\n  __int64 v33; // r12\n  __int64 v34; // rbx\n  char *v35; // rax\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r12\n  __int64 v42; // r15\n  __int64 v43; // r14\n  __int64 v44; // r13\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r13\n  __int64 v48; // r12\n  __int64 v49; // r15\n  __int64 v50; // r14\n  __int64 v51; // r8\n  __int64 v52; // rbx\n  char *v53; // rax\n  __int64 v54; // r8\n  __int64 v55; // [rsp-10h] [rbp-68h]\n  __int64 v56; // [rsp+0h] [rbp-58h]\n  __int64 v57; // [rsp+0h] [rbp-58h]\n  __int64 v58; // [rsp+0h] [rbp-58h]\n  __int64 v59; // [rsp+0h] [rbp-58h]\n  __int64 v60; // [rsp+8h] [rbp-50h]\n  __int64 v61; // [rsp+8h] [rbp-50h]\n  __int64 v62; // [rsp+8h] [rbp-50h]\n  __int64 v63; // [rsp+10h] [rbp-48h]\n  __int64 v64; // [rsp+10h] [rbp-48h]\n  __int64 v65; // [rsp+18h] [rbp-40h]\n\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3, a4);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8, 2017LL);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( a6 )\n  {\n    case 0LL:\n      abort();\n    case 1LL:\n      v27 = *a5;\n      v28 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v28, v27);\n    case 2LL:\n      v29 = a5[1];\n      v30 = *a5;\n      v31 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v31, v30, v29);\n    case 3LL:\n      v32 = a5[2];\n      v33 = a5[1];\n      v34 = *a5;\n      v35 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v35, v34, v33, v32);\n    case 4LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v40, v39, v38, v37, v36);\n      return v55;\n    case 6LL:\n      v41 = a5[5];\n      v42 = a5[4];\n      v43 = a5[3];\n      v58 = a5[1];\n      v44 = a5[2];\n      v45 = *a5;\n      v46 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v46, v45, v58, v44, v43, v42, v41);\n    case 7LL:\n      v47 = a5[6];\n      v48 = a5[5];\n      v49 = a5[4];\n      v50 = a5[3];\n      v51 = a5[1];\n      v62 = a5[2];\n      v52 = *a5;\n      v59 = v51;\n      v53 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v53, v52, v59, v62, v50, v49, v48, v47);\n    case 8LL:\n      v10 = a5[2];\n      v11 = a5[1];\n      v12 = a5[6];\n      v13 = a5[5];\n      v14 = a5[4];\n      v63 = a5[7];\n      v15 = a5[3];\n      v16 = *a5;\n      v56 = v10;\n      v60 = v11;\n      v17 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16, v60, v56, v15, v14, v13, v12, v63);\n    case 9LL:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v20 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v20;\n      goto LABEL_8;\n    default:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v54 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v54;\nLABEL_8:\n      v26 = dcgettext(0LL, v19, 5);\n      return __fprintf_chk(stream, 1LL, v26, v25, v61, v57, v24, v23, v22, v21, v64, v65);\n  }\n}\n"
        },
        {
            "funcName": "sub_410C70",
            "funcStartAddr": "0x402f32",
            "funcEndAddr": "0x402f37",
            "decompiledFuncCode": "__int64 __fastcall sub_410C70(FILE *stream, const char *a2, const char *a3, const char *a4, __int64 *a5, __int64 a6)\n{\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // r8\n  __int64 v12; // r13\n  __int64 v13; // r12\n  __int64 v14; // r15\n  __int64 v15; // r14\n  __int64 v16; // rbx\n  char *v17; // rax\n  const char *v19; // rsi\n  __int64 v20; // r8\n  __int64 v21; // r13\n  __int64 v22; // r12\n  __int64 v23; // r15\n  __int64 v24; // r14\n  __int64 v25; // rbx\n  char *v26; // rax\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r12\n  __int64 v30; // rbx\n  char *v31; // rax\n  __int64 v32; // r13\n  __int64 v33; // r12\n  __int64 v34; // rbx\n  char *v35; // rax\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r12\n  __int64 v42; // r15\n  __int64 v43; // r14\n  __int64 v44; // r13\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r13\n  __int64 v48; // r12\n  __int64 v49; // r15\n  __int64 v50; // r14\n  __int64 v51; // r8\n  __int64 v52; // rbx\n  char *v53; // rax\n  __int64 v54; // r8\n  __int64 v55; // [rsp-10h] [rbp-68h]\n  __int64 v56; // [rsp+0h] [rbp-58h]\n  __int64 v57; // [rsp+0h] [rbp-58h]\n  __int64 v58; // [rsp+0h] [rbp-58h]\n  __int64 v59; // [rsp+0h] [rbp-58h]\n  __int64 v60; // [rsp+8h] [rbp-50h]\n  __int64 v61; // [rsp+8h] [rbp-50h]\n  __int64 v62; // [rsp+8h] [rbp-50h]\n  __int64 v63; // [rsp+10h] [rbp-48h]\n  __int64 v64; // [rsp+10h] [rbp-48h]\n  __int64 v65; // [rsp+18h] [rbp-40h]\n\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3, a4);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8, 2017LL);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( a6 )\n  {\n    case 0LL:\n      abort();\n    case 1LL:\n      v27 = *a5;\n      v28 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v28, v27);\n    case 2LL:\n      v29 = a5[1];\n      v30 = *a5;\n      v31 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v31, v30, v29);\n    case 3LL:\n      v32 = a5[2];\n      v33 = a5[1];\n      v34 = *a5;\n      v35 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v35, v34, v33, v32);\n    case 4LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v40, v39, v38, v37, v36);\n      return v55;\n    case 6LL:\n      v41 = a5[5];\n      v42 = a5[4];\n      v43 = a5[3];\n      v58 = a5[1];\n      v44 = a5[2];\n      v45 = *a5;\n      v46 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v46, v45, v58, v44, v43, v42, v41);\n    case 7LL:\n      v47 = a5[6];\n      v48 = a5[5];\n      v49 = a5[4];\n      v50 = a5[3];\n      v51 = a5[1];\n      v62 = a5[2];\n      v52 = *a5;\n      v59 = v51;\n      v53 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v53, v52, v59, v62, v50, v49, v48, v47);\n    case 8LL:\n      v10 = a5[2];\n      v11 = a5[1];\n      v12 = a5[6];\n      v13 = a5[5];\n      v14 = a5[4];\n      v63 = a5[7];\n      v15 = a5[3];\n      v16 = *a5;\n      v56 = v10;\n      v60 = v11;\n      v17 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16, v60, v56, v15, v14, v13, v12, v63);\n    case 9LL:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v20 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v20;\n      goto LABEL_8;\n    default:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v54 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v54;\nLABEL_8:\n      v26 = dcgettext(0LL, v19, 5);\n      return __fprintf_chk(stream, 1LL, v26, v25, v61, v57, v24, v23, v22, v21, v64, v65);\n  }\n}\n\n__int64 __fastcall sub_410C70(FILE *stream, const char *a2, const char *a3, const char *a4, __int64 *a5, __int64 a6)\n{\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // r8\n  __int64 v12; // r13\n  __int64 v13; // r12\n  __int64 v14; // r15\n  __int64 v15; // r14\n  __int64 v16; // rbx\n  char *v17; // rax\n  const char *v19; // rsi\n  __int64 v20; // r8\n  __int64 v21; // r13\n  __int64 v22; // r12\n  __int64 v23; // r15\n  __int64 v24; // r14\n  __int64 v25; // rbx\n  char *v26; // rax\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r12\n  __int64 v30; // rbx\n  char *v31; // rax\n  __int64 v32; // r13\n  __int64 v33; // r12\n  __int64 v34; // rbx\n  char *v35; // rax\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r12\n  __int64 v42; // r15\n  __int64 v43; // r14\n  __int64 v44; // r13\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r13\n  __int64 v48; // r12\n  __int64 v49; // r15\n  __int64 v50; // r14\n  __int64 v51; // r8\n  __int64 v52; // rbx\n  char *v53; // rax\n  __int64 v54; // r8\n  __int64 v55; // [rsp-10h] [rbp-68h]\n  __int64 v56; // [rsp+0h] [rbp-58h]\n  __int64 v57; // [rsp+0h] [rbp-58h]\n  __int64 v58; // [rsp+0h] [rbp-58h]\n  __int64 v59; // [rsp+0h] [rbp-58h]\n  __int64 v60; // [rsp+8h] [rbp-50h]\n  __int64 v61; // [rsp+8h] [rbp-50h]\n  __int64 v62; // [rsp+8h] [rbp-50h]\n  __int64 v63; // [rsp+10h] [rbp-48h]\n  __int64 v64; // [rsp+10h] [rbp-48h]\n  __int64 v65; // [rsp+18h] [rbp-40h]\n\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3, a4);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8, 2017LL);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( a6 )\n  {\n    case 0LL:\n      abort();\n    case 1LL:\n      v27 = *a5;\n      v28 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v28, v27);\n    case 2LL:\n      v29 = a5[1];\n      v30 = *a5;\n      v31 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v31, v30, v29);\n    case 3LL:\n      v32 = a5[2];\n      v33 = a5[1];\n      v34 = *a5;\n      v35 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v35, v34, v33, v32);\n    case 4LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v36 = a5[3];\n      v37 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v40, v39, v38, v37, v36);\n      return v55;\n    case 6LL:\n      v41 = a5[5];\n      v42 = a5[4];\n      v43 = a5[3];\n      v58 = a5[1];\n      v44 = a5[2];\n      v45 = *a5;\n      v46 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v46, v45, v58, v44, v43, v42, v41);\n    case 7LL:\n      v47 = a5[6];\n      v48 = a5[5];\n      v49 = a5[4];\n      v50 = a5[3];\n      v51 = a5[1];\n      v62 = a5[2];\n      v52 = *a5;\n      v59 = v51;\n      v53 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v53, v52, v59, v62, v50, v49, v48, v47);\n    case 8LL:\n      v10 = a5[2];\n      v11 = a5[1];\n      v12 = a5[6];\n      v13 = a5[5];\n      v14 = a5[4];\n      v63 = a5[7];\n      v15 = a5[3];\n      v16 = *a5;\n      v56 = v10;\n      v60 = v11;\n      v17 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16, v60, v56, v15, v14, v13, v12, v63);\n    case 9LL:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v20 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v20;\n      goto LABEL_8;\n    default:\n      v19 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v54 = a5[1];\n      v21 = a5[6];\n      v22 = a5[5];\n      v65 = a5[8];\n      v23 = a5[4];\n      v24 = a5[3];\n      v64 = a5[7];\n      v57 = a5[2];\n      v25 = *a5;\n      v61 = v54;\nLABEL_8:\n      v26 = dcgettext(0LL, v19, 5);\n      return __fprintf_chk(stream, 1LL, v26, v25, v61, v57, v24, v23, v22, v21, v64, v65);\n  }\n}\n"
        },
        {
            "funcName": "sub_411070",
            "funcStartAddr": "0x411070",
            "funcEndAddr": "0x4110d0",
            "decompiledFuncCode": "__int64 __fastcall sub_411070(FILE *a1, const char *a2, const char *a3, const char *a4, int *a5)\n{\n  __int64 i; // r9\n  __int64 *v6; // r10\n  __int64 v7; // rax\n  unsigned int v8; // eax\n  __int64 *v9; // r10\n  __int64 v10; // rax\n  __int64 v12[11]; // [rsp+0h] [rbp-58h] BYREF\n\n  for ( i = 0LL; i != 10; ++i )\n  {\n    v8 = *a5;\n    if ( (unsigned int)*a5 <= 0x2F )\n    {\n      v6 = (__int64 *)(*((_QWORD *)a5 + 2) + v8);\n      *a5 = v8 + 8;\n      v7 = *v6;\n      v12[i] = *v6;\n      if ( !v7 )\n        return sub_410C70(a1, a2, a3, a4, v12, i);\n      continue;\n    }\n    v9 = (__int64 *)*((_QWORD *)a5 + 1);\n    *((_QWORD *)a5 + 1) = v9 + 1;\n    v10 = *v9;\n    v12[i] = *v9;\n    if ( !v10 )\n      break;\n  }\n  return sub_410C70(a1, a2, a3, a4, v12, i);\n}\n"
        },
        {
            "funcName": "sub_4110D0",
            "funcStartAddr": "0x4110d0",
            "funcEndAddr": "0x41118c",
            "decompiledFuncCode": "__int64 __fastcall sub_4110D0(\n        FILE *a1,\n        const char *a2,\n        const char *a3,\n        const char *a4,\n        __int64 a5,\n        __int64 a6,\n        char a7)\n{\n  char *v7; // r10\n  unsigned int v8; // r8d\n  __int64 i; // r9\n  __int64 v10; // rax\n  __int64 v11; // rax\n  __int64 *v12; // rax\n  __int64 v13; // rax\n  __int64 v15[17]; // [rsp+20h] [rbp-88h] BYREF\n\n  v15[14] = a5;\n  v7 = &a7;\n  v8 = 32;\n  v15[15] = a6;\n  for ( i = 0LL; i != 10; ++i )\n  {\n    if ( v8 <= 0x2F )\n    {\n      v10 = v8;\n      v8 += 8;\n      v11 = *(__int64 *)((char *)&v15[10] + v10);\n      v15[i] = v11;\n      if ( !v11 )\n        return sub_410C70(a1, a2, a3, a4, v15, i);\n      continue;\n    }\n    v12 = (__int64 *)v7;\n    v7 += 8;\n    v13 = *v12;\n    v15[i] = v13;\n    if ( !v13 )\n      break;\n  }\n  return sub_410C70(a1, a2, a3, a4, v15, i);\n}\n"
        },
        {
            "funcName": "sub_411190",
            "funcStartAddr": "0x411190",
            "funcEndAddr": "0x411204",
            "decompiledFuncCode": "int sub_411190()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n  __printf_chk(1LL, v0);\n  v1 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n  __printf_chk(1LL, v1);\n  v2 = stdout;\n  v3 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n  return fputs_unlocked(v3, v2);\n}\n"
        },
        {
            "funcName": "sub_411210",
            "funcStartAddr": "0x411210",
            "funcEndAddr": "0x41122a",
            "decompiledFuncCode": "void *__fastcall sub_411210(size_t a1, __int64 a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n\n  result = malloc(a1);\n  if ( !result )\n  {\n    if ( a1 )\n      sub_411460(a1, a2, v3);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_411260",
            "funcStartAddr": "0x411260",
            "funcEndAddr": "0x411262",
            "decompiledFuncCode": "// attributes: thunk\nvoid *__fastcall sub_411260(size_t a1, __int64 a2)\n{\n  return sub_411210(a1, a2);\n}\n"
        },
        {
            "funcName": "sub_411270",
            "funcStartAddr": "0x411270",
            "funcEndAddr": "0x4112a6",
            "decompiledFuncCode": "void *__fastcall sub_411270(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n\n  if ( !a2 && a1 )\n  {\n    free(a1);\n    return 0LL;\n  }\n  else\n  {\n    result = realloc(a1, a2);\n    if ( !result )\n    {\n      if ( a2 )\n        sub_411460(a1, a2, v3);\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4113C0",
            "funcStartAddr": "0x4113c0",
            "funcEndAddr": "0x4113d7",
            "decompiledFuncCode": "void *__fastcall sub_4113C0(size_t n, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_411210(n, a2);\n  return memset(v2, 0, n);\n}\n"
        },
        {
            "funcName": "sub_4113E0",
            "funcStartAddr": "0x4113e0",
            "funcEndAddr": "0x41140e",
            "decompiledFuncCode": "__int64 __fastcall sub_4113E0(unsigned __int64 a1, unsigned __int64 a2)\n{\n  unsigned __int128 v2; // rax\n\n  v2 = a2 * (unsigned __int128)a1;\n  BYTE8(v2) = *((_QWORD *)&v2 + 1) != 0LL;\n  if ( (v2 & 0x8000000000000000LL) != 0LL\n    || (*((_QWORD *)&v2 + 1) = BYTE8(v2), !is_mul_ok(a2, a1))\n    || (*(_QWORD *)&v2 = calloc(a1, a2), !(_QWORD)v2) )\n  {\n    sub_411460(a1, a2, *((_QWORD *)&v2 + 1));\n  }\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_411410",
            "funcStartAddr": "0x411410",
            "funcEndAddr": "0x411438",
            "decompiledFuncCode": "void *__fastcall sub_411410(void *src, size_t n)\n{\n  void *v2; // rax\n\n  v2 = sub_411210(n, n);\n  return memcpy(v2, src, n);\n}\n"
        },
        {
            "funcName": "sub_411440",
            "funcStartAddr": "0x411440",
            "funcEndAddr": "0x411453",
            "decompiledFuncCode": "void *__fastcall sub_411440(char *src)\n{\n  size_t v1; // rax\n\n  v1 = strlen(src);\n  return sub_411410(src, v1 + 1);\n}\n"
        },
        {
            "funcName": "sub_411460",
            "funcStartAddr": "0x411460",
            "funcEndAddr": "0x411491",
            "decompiledFuncCode": "void __noreturn sub_411460()\n{\n  char *v0; // rax\n\n  v0 = dcgettext(0LL, \"memory exhausted\", 5);\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"
        },
        {
            "funcName": "sub_4114A0",
            "funcStartAddr": "0x4114a0",
            "funcEndAddr": "0x411554",
            "decompiledFuncCode": "void __fastcall sub_4114A0(int errnum, __int64 a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5)\n{\n  char *v8; // rax\n  char *v9; // rax\n  _BYTE *v10; // rbp\n  _BYTE *v11; // rbx\n  char *v12; // rax\n\n  v8 = dcgettext(0LL, \"string comparison failed\", 5);\n  error(0, errnum, v8);\n  v9 = dcgettext(0LL, \"Set LC_ALL='C' to work around the problem.\", 5);\n  error(0, 0, v9);\n  v10 = sub_40F5C0(1LL, 8, a4, a5);\n  v11 = sub_40F5C0(0LL, 8, a2, a3);\n  v12 = dcgettext(0LL, \"The strings compared were %s and %s.\", 5);\n  error(status, 0, v12, v11, v10);\n}\n"
        },
        {
            "funcName": "sub_411560",
            "funcStartAddr": "0x411560",
            "funcEndAddr": "0x4115b5",
            "decompiledFuncCode": "__int64 __fastcall sub_411560(char *a1, size_t a2, void *a3, unsigned __int64 a4)\n{\n  unsigned int v7; // r14d\n  int v8; // edi\n\n  v7 = sub_413D80(a1, a2, a3);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4114A0(v8, (__int64)a1, a2, (__int64)a3, a4);\n  return v7;\n}\n"
        },
        {
            "funcName": "sub_4115C0",
            "funcStartAddr": "0x4115c0",
            "funcEndAddr": "0x411617",
            "decompiledFuncCode": "__int64 __fastcall sub_4115C0(char *a1, size_t a2, void *a3, __int64 a4)\n{\n  unsigned int v7; // r13d\n  int v8; // edi\n\n  v7 = sub_413E30(a1, a2, a3);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4114A0(v8, (__int64)a1, a2 - 1, (__int64)a3, a4 - 1);\n  return v7;\n}\n"
        },
        {
            "funcName": "sub_411620",
            "funcStartAddr": "0x411620",
            "funcEndAddr": "0x411673",
            "decompiledFuncCode": "__int64 sub_411620()\n{\n  __int64 v0; // rdx\n  int *v1; // rbx\n  __int64 result; // rax\n  __int64 v3[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  v3[0] = sub_413580();\n  v3[1] = v0;\n  v1 = __errno_location();\n  while ( 1 )\n  {\n    *v1 = 0;\n    result = sub_413140(v3, 0LL);\n    if ( !(_DWORD)result )\n      break;\n    if ( (*v1 & 0xFFFFFFFB) != 0 )\n      return 0xFFFFFFFFLL;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_411680",
            "funcStartAddr": "0x411680",
            "funcEndAddr": "0x411aa4",
            "decompiledFuncCode": "__int64 __fastcall sub_411680(char *nptr, char **a2, unsigned int a3, __int64 *a4, const char *a5)\n{\n  char **p_endptr; // r15\n  int *v8; // rax\n  int *v9; // r12\n  unsigned __int8 v10; // bl\n  const unsigned __int16 *v11; // rsi\n  char *v12; // rax\n  __int64 v13; // rbx\n  unsigned int v14; // ebp\n  int v15; // r12d\n  char *v17; // rax\n  char *v18; // r8\n  __int64 v19; // rax\n  char *v20; // rax\n  char v21; // al\n  int v22; // esi\n  unsigned __int64 v23; // rdx\n  char *v24; // r8\n  unsigned __int64 v25; // kr30_8\n  char *v26; // rax\n  int v27; // edi\n  int v28; // r9d\n  bool v29; // of\n  int v30; // edi\n  int v31; // edi\n  int v32; // edi\n  int v33; // edi\n  char *basea; // [rsp+0h] [rbp-58h]\n  char *baseb; // [rsp+0h] [rbp-58h]\n  char *v37; // [rsp+8h] [rbp-50h]\n  char *endptr; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a3 > 0x24 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"lib/xstrtol.c\", 0x60u, \"xstrtoul\");\n  p_endptr = a2;\n  if ( !a2 )\n    p_endptr = &endptr;\n  v8 = __errno_location();\n  *v8 = 0;\n  v9 = v8;\n  v10 = *nptr;\n  v11 = *__ctype_b_loc();\n  v12 = nptr;\n  while ( (v11[v10] & 0x2000) != 0 )\n    v10 = *++v12;\n  if ( v10 == 45 )\n    return 4;\n  v13 = strtoul(nptr, p_endptr, a3);\n  if ( *p_endptr == nptr )\n  {\n    basea = *p_endptr;\n    if ( a5 )\n    {\n      v15 = (unsigned __int8)*nptr;\n      if ( (_BYTE)v15 )\n      {\n        v14 = 0;\n        v13 = 1LL;\n        v17 = strchr(a5, (char)v15);\n        v18 = basea;\n        if ( v17 )\n          goto LABEL_20;\n      }\n    }\n    return 4;\n  }\n  if ( *v9 )\n  {\n    v14 = 1;\n    if ( *v9 == 34 )\n      goto LABEL_11;\n    return 4;\n  }\n  v14 = 0;\nLABEL_11:\n  if ( a5 )\n  {\n    v15 = (unsigned __int8)**p_endptr;\n    if ( (_BYTE)v15 )\n    {\n      baseb = *p_endptr;\n      v26 = strchr(a5, (char)v15);\n      v18 = baseb;\n      if ( !v26 )\n      {\nLABEL_40:\n        *a4 = v13;\n        v14 |= 2u;\n        return v14;\n      }\nLABEL_20:\n      if ( (unsigned __int8)(v15 - 69) > 0x2Fu\n        || (v19 = 0x814400308945LL, !_bittest64(&v19, (unsigned int)(v15 - 69)))\n        || (v37 = v18, v20 = strchr(a5, 48), v18 = v37, !v20) )\n      {\nLABEL_27:\n        v22 = 1;\n        v23 = 1024LL;\n        goto LABEL_28;\n      }\n      v21 = v37[1];\n      if ( v21 != 68 )\n      {\n        if ( v21 == 105 )\n        {\n          v23 = 1024LL;\n          v22 = 2 * (v37[2] == 66) + 1;\nLABEL_28:\n          switch ( (char)v15 )\n          {\n            case 'B':\n              if ( (unsigned __int64)v13 >> 54 )\n                goto LABEL_38;\n              v13 <<= 10;\n              break;\n            case 'E':\n              goto LABEL_71;\n            case 'G':\n            case 'g':\n              goto LABEL_77;\n            case 'K':\n            case 'k':\n              goto LABEL_37;\n            case 'M':\n            case 'm':\n              goto LABEL_30;\n            case 'P':\n              goto LABEL_65;\n            case 'T':\n            case 't':\n              goto LABEL_59;\n            case 'Y':\n              goto LABEL_53;\n            case 'Z':\n              goto LABEL_47;\n            case 'b':\n              goto LABEL_44;\n            case 'c':\n              break;\n            case 'w':\n              if ( v13 < 0 )\n                goto LABEL_38;\n              v13 *= 2LL;\n              break;\n            default:\n              goto LABEL_40;\n          }\nLABEL_33:\n          v24 = &v18[v22];\n          *p_endptr = v24;\n          if ( *v24 )\n            v14 |= 2u;\n          goto LABEL_13;\n        }\n        if ( v21 != 66 )\n        {\n          switch ( (char)v15 )\n          {\n            case 'E':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_71:\n              v33 = 6;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v33;\n              }\n              while ( v33 );\n              goto LABEL_51;\n            case 'F':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'L':\n            case 'N':\n            case 'O':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case '[':\n            case '\\\\':\n            case ']':\n            case '^':\n            case '_':\n            case '`':\n            case 'a':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'l':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n              goto LABEL_40;\n            case 'G':\n            case 'g':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_77:\n              if ( is_mul_ok((int)v23, v13)\n                && is_mul_ok((int)v23, (int)v23 * v13)\n                && is_mul_ok((int)v23, (int)v23 * (int)v23 * v13) )\n              {\n                v13 *= (int)v23 * (int)v23 * (__int64)(int)v23;\n              }\n              else\n              {\n                v13 = -1LL;\n                v14 |= 1u;\n              }\n              goto LABEL_33;\n            case 'K':\n            case 'k':\n              v22 = 1;\n              v23 = 1024LL;\nLABEL_37:\n              v25 = v13;\n              v13 *= v23;\n              if ( is_mul_ok(v23, v25) )\n                goto LABEL_33;\n              goto LABEL_38;\n            case 'M':\n            case 'm':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_30:\n              if ( !is_mul_ok((int)v23, v13) || !is_mul_ok((int)v23, (int)v23 * v13) )\n                goto LABEL_38;\n              v13 *= (int)v23 * (__int64)(int)v23;\n              break;\n            case 'P':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_65:\n              v32 = 5;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v32;\n              }\n              while ( v32 );\n              goto LABEL_51;\n            case 'T':\n            case 't':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_59:\n              v31 = 4;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v31;\n              }\n              while ( v31 );\n              goto LABEL_51;\n            case 'Y':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_53:\n              v30 = 8;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v30;\n              }\n              while ( v30 );\n              goto LABEL_51;\n            case 'Z':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_47:\n              v27 = 7;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v27;\n              }\n              while ( v27 );\nLABEL_51:\n              v14 |= v28;\n              break;\n            case 'b':\n              v22 = 1;\nLABEL_44:\n              if ( (unsigned __int64)v13 >> 55 )\n              {\nLABEL_38:\n                v14 = 1;\n                v13 = -1LL;\n              }\n              else\n              {\n                v13 <<= 9;\n              }\n              break;\n            case 'c':\n              v22 = 1;\n              goto LABEL_33;\n            default:\n              goto LABEL_27;\n          }\n          goto LABEL_33;\n        }\n      }\n      v22 = 2;\n      v23 = 1000LL;\n      goto LABEL_28;\n    }\n  }\nLABEL_13:\n  *a4 = v13;\n  return v14;\n}\n"
        },
        {
            "funcName": "sub_411AB0",
            "funcStartAddr": "0x402f37",
            "funcEndAddr": "0x402f3c",
            "decompiledFuncCode": "void __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13[42]; // [rsp+Eh] [rbp-2Ah] BYREF\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v9 = (&off_4181C0)[v5];\n    if ( a2 < 0 )\n    {\n      v13[0] = a3;\n      v11 = v13;\n      v10 = &asc_418149[-a2];\n      v13[1] = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * a2);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, a5);\n    abort();\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13[42]; // [rsp+Eh] [rbp-2Ah] BYREF\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v9 = (&off_4181C0)[v5];\n    if ( a2 < 0 )\n    {\n      v13[0] = a3;\n      v11 = v13;\n      v10 = &asc_418149[-a2];\n      v13[1] = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * a2);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, a5);\n    abort();\n  }\n  abort();\n}\n"
        },
        {
            "funcName": "sub_411AB0",
            "funcStartAddr": "0x402f37",
            "funcEndAddr": "0x402f3c",
            "decompiledFuncCode": "void __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13[42]; // [rsp+Eh] [rbp-2Ah] BYREF\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v9 = (&off_4181C0)[v5];\n    if ( a2 < 0 )\n    {\n      v13[0] = a3;\n      v11 = v13;\n      v10 = &asc_418149[-a2];\n      v13[1] = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * a2);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, a5);\n    abort();\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13[42]; // [rsp+Eh] [rbp-2Ah] BYREF\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v9 = (&off_4181C0)[v5];\n    if ( a2 < 0 )\n    {\n      v13[0] = a3;\n      v11 = v13;\n      v10 = &asc_418149[-a2];\n      v13[1] = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * a2);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, a5);\n    abort();\n  }\n  abort();\n}\n"
        },
        {
            "funcName": "sub_411B40",
            "funcStartAddr": "0x411b40",
            "funcEndAddr": "0x411f74",
            "decompiledFuncCode": "__int64 __fastcall sub_411B40(char *nptr, char **a2, unsigned int a3, __int64 *a4, const char *a5)\n{\n  char **p_endptr; // r15\n  int *v8; // rax\n  int *v9; // r12\n  unsigned __int8 v10; // bl\n  const unsigned __int16 *v11; // rsi\n  char *v12; // rax\n  __int64 v13; // rbx\n  unsigned int v14; // ebp\n  int v15; // r12d\n  char *v17; // rax\n  char *v18; // r8\n  __int64 v19; // rax\n  char *v20; // rax\n  char v21; // al\n  int v22; // esi\n  unsigned __int64 v23; // rdx\n  char *v24; // r8\n  unsigned __int64 v25; // kr30_8\n  char *v26; // rax\n  int v27; // edi\n  int v28; // r9d\n  bool v29; // of\n  int v30; // edi\n  int v31; // edi\n  int v32; // edi\n  int v33; // edi\n  char *basea; // [rsp+0h] [rbp-58h]\n  char *baseb; // [rsp+0h] [rbp-58h]\n  char *v37; // [rsp+8h] [rbp-50h]\n  char *endptr; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a3 > 0x24 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"lib/xstrtol.c\", 0x60u, \"xstrtoumax\");\n  p_endptr = a2;\n  if ( !a2 )\n    p_endptr = &endptr;\n  v8 = __errno_location();\n  *v8 = 0;\n  v9 = v8;\n  v10 = *nptr;\n  v11 = *__ctype_b_loc();\n  v12 = nptr;\n  while ( (v11[v10] & 0x2000) != 0 )\n    v10 = *++v12;\n  if ( v10 == 45 )\n    return 4;\n  v13 = __strtoul_internal(nptr, p_endptr, a3, 0);\n  if ( *p_endptr == nptr )\n  {\n    basea = *p_endptr;\n    if ( a5 )\n    {\n      v15 = (unsigned __int8)*nptr;\n      if ( (_BYTE)v15 )\n      {\n        v14 = 0;\n        v13 = 1LL;\n        v17 = strchr(a5, (char)v15);\n        v18 = basea;\n        if ( v17 )\n          goto LABEL_20;\n      }\n    }\n    return 4;\n  }\n  if ( *v9 )\n  {\n    v14 = 1;\n    if ( *v9 == 34 )\n      goto LABEL_11;\n    return 4;\n  }\n  v14 = 0;\nLABEL_11:\n  if ( a5 )\n  {\n    v15 = (unsigned __int8)**p_endptr;\n    if ( (_BYTE)v15 )\n    {\n      baseb = *p_endptr;\n      v26 = strchr(a5, (char)v15);\n      v18 = baseb;\n      if ( !v26 )\n      {\nLABEL_40:\n        *a4 = v13;\n        v14 |= 2u;\n        return v14;\n      }\nLABEL_20:\n      if ( (unsigned __int8)(v15 - 69) > 0x2Fu\n        || (v19 = 0x814400308945LL, !_bittest64(&v19, (unsigned int)(v15 - 69)))\n        || (v37 = v18, v20 = strchr(a5, 48), v18 = v37, !v20) )\n      {\nLABEL_27:\n        v22 = 1;\n        v23 = 1024LL;\n        goto LABEL_28;\n      }\n      v21 = v37[1];\n      if ( v21 != 68 )\n      {\n        if ( v21 == 105 )\n        {\n          v23 = 1024LL;\n          v22 = 2 * (v37[2] == 66) + 1;\nLABEL_28:\n          switch ( (char)v15 )\n          {\n            case 'B':\n              if ( (unsigned __int64)v13 >> 54 )\n                goto LABEL_38;\n              v13 <<= 10;\n              break;\n            case 'E':\n              goto LABEL_71;\n            case 'G':\n            case 'g':\n              goto LABEL_77;\n            case 'K':\n            case 'k':\n              goto LABEL_37;\n            case 'M':\n            case 'm':\n              goto LABEL_30;\n            case 'P':\n              goto LABEL_65;\n            case 'T':\n            case 't':\n              goto LABEL_59;\n            case 'Y':\n              goto LABEL_53;\n            case 'Z':\n              goto LABEL_47;\n            case 'b':\n              goto LABEL_44;\n            case 'c':\n              break;\n            case 'w':\n              if ( v13 < 0 )\n                goto LABEL_38;\n              v13 *= 2LL;\n              break;\n            default:\n              goto LABEL_40;\n          }\nLABEL_33:\n          v24 = &v18[v22];\n          *p_endptr = v24;\n          if ( *v24 )\n            v14 |= 2u;\n          goto LABEL_13;\n        }\n        if ( v21 != 66 )\n        {\n          switch ( (char)v15 )\n          {\n            case 'E':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_71:\n              v33 = 6;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v33;\n              }\n              while ( v33 );\n              goto LABEL_51;\n            case 'F':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'L':\n            case 'N':\n            case 'O':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case '[':\n            case '\\\\':\n            case ']':\n            case '^':\n            case '_':\n            case '`':\n            case 'a':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'l':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n              goto LABEL_40;\n            case 'G':\n            case 'g':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_77:\n              if ( is_mul_ok((int)v23, v13)\n                && is_mul_ok((int)v23, (int)v23 * v13)\n                && is_mul_ok((int)v23, (int)v23 * (int)v23 * v13) )\n              {\n                v13 *= (int)v23 * (int)v23 * (__int64)(int)v23;\n              }\n              else\n              {\n                v13 = -1LL;\n                v14 |= 1u;\n              }\n              goto LABEL_33;\n            case 'K':\n            case 'k':\n              v22 = 1;\n              v23 = 1024LL;\nLABEL_37:\n              v25 = v13;\n              v13 *= v23;\n              if ( is_mul_ok(v23, v25) )\n                goto LABEL_33;\n              goto LABEL_38;\n            case 'M':\n            case 'm':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_30:\n              if ( !is_mul_ok((int)v23, v13) || !is_mul_ok((int)v23, (int)v23 * v13) )\n                goto LABEL_38;\n              v13 *= (int)v23 * (__int64)(int)v23;\n              break;\n            case 'P':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_65:\n              v32 = 5;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v32;\n              }\n              while ( v32 );\n              goto LABEL_51;\n            case 'T':\n            case 't':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_59:\n              v31 = 4;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v31;\n              }\n              while ( v31 );\n              goto LABEL_51;\n            case 'Y':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_53:\n              v30 = 8;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v30;\n              }\n              while ( v30 );\n              goto LABEL_51;\n            case 'Z':\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_47:\n              v27 = 7;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)(unsigned __int64)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v27;\n              }\n              while ( v27 );\nLABEL_51:\n              v14 |= v28;\n              break;\n            case 'b':\n              v22 = 1;\nLABEL_44:\n              if ( (unsigned __int64)v13 >> 55 )\n              {\nLABEL_38:\n                v14 = 1;\n                v13 = -1LL;\n              }\n              else\n              {\n                v13 <<= 9;\n              }\n              break;\n            case 'c':\n              v22 = 1;\n              goto LABEL_33;\n            default:\n              goto LABEL_27;\n          }\n          goto LABEL_33;\n        }\n      }\n      v22 = 2;\n      v23 = 1000LL;\n      goto LABEL_28;\n    }\n  }\nLABEL_13:\n  *a4 = v13;\n  return v14;\n}\n"
        },
        {
            "funcName": "sub_411F80",
            "funcStartAddr": "0x411f80",
            "funcEndAddr": "0x411ffb",
            "decompiledFuncCode": "int __fastcall sub_411F80(FILE *stream)\n{\n  int *v1; // rax\n  int v2; // r12d\n  int *v3; // rbp\n  int result; // eax\n  int v5; // eax\n\n  if ( fileno(stream) < 0 )\n    return fclose(stream);\n  if ( __freading(stream) )\n  {\n    v5 = fileno(stream);\n    if ( lseek(v5, 0LL, 1) == -1 )\n      return fclose(stream);\n  }\n  if ( !(unsigned int)sub_412140(stream) )\n    return fclose(stream);\n  v1 = __errno_location();\n  v2 = *v1;\n  v3 = v1;\n  result = fclose(stream);\n  if ( v2 )\n  {\n    *v3 = v2;\n    return -1;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_412000",
            "funcStartAddr": "0x412000",
            "funcEndAddr": "0x412135",
            "decompiledFuncCode": "__int64 __fastcall sub_412000(int a1, int a2, __int64 a3, int a4, int a5, int a6)\n{\n  int v6; // ebx\n  int v8; // eax\n  int *v9; // rax\n  int v10; // edi\n  int v11; // r12d\n  int *v12; // rbp\n  int v13; // ecx\n  int v14; // r8d\n  int v15; // r9d\n  int v16; // [rsp+30h] [rbp-38h]\n\n  v16 = a3;\n  if ( a2 == 1030 )\n  {\n    if ( dword_61CD18 < 0 )\n    {\n      v6 = sub_412000(a1, 0, a3, a4, a5, a6);\n      if ( v6 >= 0 && dword_61CD18 == -1 )\n      {\nLABEL_8:\n        v8 = fcntl(v6, 1);\n        if ( v8 < 0 || fcntl(v6, 2, v8 | 1u) == -1 )\n        {\n          v9 = __errno_location();\n          v10 = v6;\n          v6 = -1;\n          v11 = *v9;\n          v12 = v9;\n          close(v10);\n          *v12 = v11;\n        }\n      }\n    }\n    else\n    {\n      v6 = fcntl(a1, 1030, (unsigned int)a3);\n      if ( v6 < 0 && *__errno_location() == 22 )\n      {\n        v6 = sub_412000(a1, 0, v16, v13, v14, v15);\n        if ( v6 >= 0 )\n        {\n          dword_61CD18 = -1;\n          goto LABEL_8;\n        }\n      }\n      else\n      {\n        dword_61CD18 = 1;\n      }\n    }\n    return (unsigned int)v6;\n  }\n  return (unsigned int)fcntl(a1, a2, a3);\n}\n"
        },
        {
            "funcName": "sub_412140",
            "funcStartAddr": "0x412140",
            "funcEndAddr": "0x412180",
            "decompiledFuncCode": "int __fastcall sub_412140(FILE *stream)\n{\n  if ( !stream || !__freading(stream) || (stream->_flags & 0x100) == 0 )\n    return fflush(stream);\n  sub_412180(stream, 0LL, 1LL);\n  return fflush(stream);\n}\n"
        },
        {
            "funcName": "sub_412180",
            "funcStartAddr": "0x412180",
            "funcEndAddr": "0x4121d7",
            "decompiledFuncCode": "int __fastcall sub_412180(FILE *a1, __off_t a2, int a3)\n{\n  __off_t v3; // rax\n  int v5; // eax\n\n  if ( a1->_IO_read_end == a1->_IO_read_ptr && a1->_IO_write_ptr == a1->_IO_write_base && !a1->_IO_save_base )\n  {\n    v5 = fileno(a1);\n    v3 = lseek(v5, a2, a3);\n    if ( v3 != -1 )\n    {\n      a1->_flags &= ~0x10u;\n      a1->_offset = v3;\n      LODWORD(v3) = 0;\n    }\n  }\n  else\n  {\n    LODWORD(v3) = fseeko(a1, a2, a3);\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "sub_4121E0",
            "funcStartAddr": "0x4121e0",
            "funcEndAddr": "0x4122bf",
            "decompiledFuncCode": "__int64 __fastcall sub_4121E0(__int64 a1, int *a2)\n{\n  __int64 v2; // r11\n  int v3; // r12d\n  int v4; // ebp\n  __int64 v5; // rbx\n  int v6; // r9d\n  int v7; // r10d\n  int v8; // r8d\n  int v9; // r14d\n  int v10; // edx\n  __int64 *v11; // rax\n  __int64 *v12; // r13\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 result; // rax\n  __int64 *v16; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n\n  v2 = a1 + 8;\n  v3 = a2[11];\n  v4 = *a2;\n  v5 = a2[12];\n  v6 = v3;\n  v7 = *a2;\n  v8 = a2[12];\nLABEL_2:\n  if ( v7 > v8 )\n  {\n    while ( v6 < v8 )\n    {\n      v9 = v7 - v8;\n      v10 = v8 - v6;\n      if ( v7 - v8 <= v8 - v6 )\n      {\n        v16 = (__int64 *)(a1 + 8LL * v6);\n        v17 = v5 - v6;\n        do\n        {\n          v18 = *v16;\n          *v16 = v16[v17];\n          v16[v17] = v18;\n          ++v16;\n        }\n        while ( v16 != (__int64 *)(v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v9 - 1))) );\n        v6 += v9;\n        goto LABEL_2;\n      }\n      v7 -= v10;\n      v11 = (__int64 *)(a1 + 8LL * v6);\n      v12 = (__int64 *)(v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v10 - 1)));\n      v13 = v7 - (__int64)v6;\n      do\n      {\n        v14 = *v11;\n        *v11 = v11[v13];\n        v11[v13] = v14;\n        ++v11;\n      }\n      while ( v12 != v11 );\n      if ( v7 <= v8 )\n        break;\n    }\n  }\n  a2[12] = v4;\n  result = (unsigned int)(v4 - v8);\n  a2[11] = result + v3;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4122C0",
            "funcStartAddr": "0x4122c0",
            "funcEndAddr": "0x4128dc",
            "decompiledFuncCode": "__int64 __fastcall sub_4122C0(\n        int a1,\n        __int64 *a2,\n        const char *a3,\n        char **a4,\n        _DWORD *a5,\n        int a6,\n        int *a7,\n        int a8,\n        const char *a9)\n{\n  const char *v9; // r14\n  char *v10; // rbp\n  size_t v11; // r13\n  char **v12; // rbx\n  __int64 v13; // r12\n  const char *v14; // r15\n  const char *v15; // rdi\n  __int64 v16; // r15\n  char **v17; // rbp\n  char *v18; // rdx\n  __int64 result; // rax\n  int v20; // edx\n  int v21; // eax\n  int v22; // ecx\n  char *v23; // rdx\n  __int64 v24; // rbx\n  char *v25; // rax\n  __int64 v26; // rbx\n  char *v27; // rax\n  const char *v28; // r12\n  __int64 v29; // rbp\n  char *v30; // rax\n  __int64 v31; // rbx\n  __int64 v32; // rbp\n  char *v33; // rax\n  FILE *v34; // rdi\n  const char **v35; // rbx\n  _BYTE *v36; // rbp\n  __int64 v37; // r12\n  const char *v38; // r12\n  __int64 v39; // rbp\n  char *v40; // rax\n  char *s1; // [rsp+10h] [rbp-78h]\n  char *s1a; // [rsp+10h] [rbp-78h]\n  _BYTE *ptr; // [rsp+18h] [rbp-70h]\n  int v48; // [rsp+38h] [rbp-50h]\n  char v49; // [rsp+3Fh] [rbp-49h]\n  int v51; // [rsp+44h] [rbp-44h]\n  int v52; // [rsp+48h] [rbp-40h]\n\n  v9 = (const char *)*((_QWORD *)a7 + 4);\n  v10 = (char *)v9;\n  v49 = *v9;\n  if ( *v9 == 61 || !*v9 )\n  {\n    v11 = 0LL;\n  }\n  else\n  {\n    do\n      ++v10;\n    while ( *v10 && *v10 != 61 );\n    v11 = v10 - v9;\n  }\n  v12 = a4;\n  v13 = 0LL;\n  s1 = *a4;\n  v14 = *a4;\n  if ( !*a4 )\n  {\nLABEL_24:\n    if ( !a6 || *(_BYTE *)(a2[*a7] + 1) == 45 || (v18 = strchr(a3, v49), result = 0xFFFFFFFFLL, !v18) )\n    {\n      if ( a8 )\n      {\n        v24 = *a2;\n        v25 = dcgettext(0LL, \"%s: unrecognized option '%s%s'\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v25, v24, a9, v9);\n      }\n      *((_QWORD *)a7 + 4) = 0LL;\n      ++*a7;\n      a7[2] = 0;\n      return 63LL;\n    }\n    return result;\n  }\n  while ( 1 )\n  {\n    if ( !strncmp(v14, v9, v11) && strlen(v14) == v11 )\n      goto LABEL_31;\n    v12 += 4;\n    v14 = *v12;\n    if ( !*v12 )\n      break;\n    v13 = (int)v13 + 1;\n  }\n  v12 = 0LL;\n  v51 = -1;\n  v15 = s1;\n  v16 = 0LL;\n  v48 = 0;\n  v52 = 0;\n  ptr = 0LL;\n  s1a = v10;\n  v17 = a4;\n  do\n  {\n    if ( strncmp(v15, v9, v11) )\n      goto LABEL_20;\n    if ( v12 )\n    {\n      if ( (a6\n         || *((_DWORD *)v12 + 2) != *((_DWORD *)v17 + 2)\n         || v12[2] != v17[2]\n         || *((_DWORD *)v12 + 6) != *((_DWORD *)v17 + 6))\n        && !v48 )\n      {\n        if ( a8 )\n        {\n          if ( ptr )\n            goto LABEL_19;\n          ptr = calloc((int)v13 + 1, 1uLL);\n          if ( ptr )\n          {\n            v52 = 1;\n            ptr[v51] = 1;\nLABEL_19:\n            ptr[v16] = 1;\n            goto LABEL_20;\n          }\n          v48 = 1;\n        }\n        else\n        {\n          v48 = 1;\n          if ( ptr )\n            goto LABEL_19;\n        }\n      }\n    }\n    else\n    {\n      v51 = v16;\n      v12 = v17;\n    }\nLABEL_20:\n    v17 += 4;\n    v15 = *v17;\n    ++v16;\n  }\n  while ( *v17 );\n  v10 = s1a;\n  if ( ptr || v48 )\n  {\n    if ( a8 )\n    {\n      if ( v48 )\n      {\n        v26 = *a2;\n        v27 = dcgettext(0LL, \"%s: option '%s%s' is ambiguous\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v27, v26, a9, v9);\n        v9 = (const char *)*((_QWORD *)a7 + 4);\n      }\n      else\n      {\n        flockfile(stderr);\n        v31 = *((_QWORD *)a7 + 4);\n        v32 = *a2;\n        v33 = dcgettext(0LL, \"%s: option '%s%s' is ambiguous; possibilities:\", 5);\n        __fprintf_chk(stderr, 1LL, v33, v32, a9, v31);\n        v34 = stderr;\n        v35 = (const char **)a4;\n        v36 = ptr;\n        v37 = (__int64)&ptr[v13 + 1];\n        do\n        {\n          if ( *v36 )\n          {\n            __fprintf_chk(v34, 1LL, \" '%s%s'\", a9, *v35);\n            v34 = stderr;\n          }\n          ++v36;\n          v35 += 4;\n        }\n        while ( (_BYTE *)v37 != v36 );\n        fputc(10, v34);\n        funlockfile(stderr);\n        v9 = (const char *)*((_QWORD *)a7 + 4);\n      }\n    }\n    if ( v52 )\n      free(ptr);\n    *((_QWORD *)a7 + 4) = &v9[strlen(v9)];\n    ++*a7;\n    a7[2] = 0;\n    return 63LL;\n  }\n  else\n  {\n    if ( !v12 )\n      goto LABEL_24;\n    LODWORD(v13) = v51;\nLABEL_31:\n    v20 = *a7;\n    *((_QWORD *)a7 + 4) = 0LL;\n    v21 = v20 + 1;\n    *a7 = v20 + 1;\n    v22 = *((_DWORD *)v12 + 2);\n    if ( *v10 )\n    {\n      if ( v22 )\n      {\n        *((_QWORD *)a7 + 2) = v10 + 1;\n        goto LABEL_33;\n      }\n      if ( a8 )\n      {\n        v28 = *v12;\n        v29 = *a2;\n        v30 = dcgettext(0LL, \"%s: option '%s%s' doesn't allow an argument\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v30, v29, a9, v28);\n      }\n      a7[2] = *((_DWORD *)v12 + 6);\n      return 63LL;\n    }\n    else\n    {\n      if ( v22 != 1 )\n        goto LABEL_33;\n      if ( v21 >= a1 )\n      {\n        if ( a8 )\n        {\n          v38 = *v12;\n          v39 = *a2;\n          v40 = dcgettext(0LL, \"%s: option '%s%s' requires an argument\\n\", 5);\n          __fprintf_chk(stderr, 1LL, v40, v39, a9, v38);\n        }\n        a7[2] = *((_DWORD *)v12 + 6);\n        return 5 * (unsigned int)(*a3 != 58) + 58;\n      }\n      else\n      {\n        *a7 = v20 + 2;\n        *((_QWORD *)a7 + 2) = a2[v21];\nLABEL_33:\n        if ( a5 )\n          *a5 = v13;\n        v23 = v12[2];\n        result = *((unsigned int *)v12 + 6);\n        if ( v23 )\n        {\n          *(_DWORD *)v23 = result;\n          return 0LL;\n        }\n      }\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4128E0",
            "funcStartAddr": "0x4128e0",
            "funcEndAddr": "0x412ea6",
            "decompiledFuncCode": "__int64 __fastcall sub_4128E0(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5, int a6, int *a7, int a8)\n{\n  int v8; // r13d\n  int v9; // eax\n  int v10; // ebp\n  const char *v12; // r15\n  _BYTE *v13; // rdx\n  char v14; // al\n  char v15; // al\n  int v16; // eax\n  __int64 v17; // r14\n  int v18; // edx\n  int v19; // ecx\n  int v20; // eax\n  unsigned int v21; // r14d\n  char *v22; // rax\n  __int64 v23; // r8\n  char v24; // cl\n  int v26; // edx\n  __int64 v27; // rax\n  _BYTE *v28; // rcx\n  int v29; // esi\n  char v30; // cl\n  char *v31; // rax\n  __int64 v32; // rax\n  char *v34; // rax\n  char v35; // dl\n  __int64 v36; // rax\n  int v37; // edx\n  __int64 v38; // rax\n  __int64 v39; // rbp\n  char *v40; // rax\n  __int64 v41; // rbp\n  char *v42; // rax\n  __int64 v43; // rbp\n  char *v44; // rax\n  char v47; // [rsp+1Ch] [rbp-4Ch]\n  int v48; // [rsp+1Ch] [rbp-4Ch]\n  int v49; // [rsp+1Ch] [rbp-4Ch]\n  int v50; // [rsp+1Ch] [rbp-4Ch]\n  _BYTE *v51; // [rsp+20h] [rbp-48h]\n  _BYTE *v52; // [rsp+28h] [rbp-40h]\n\n  v8 = a7[1];\n  if ( a1 <= 0 )\n    return (unsigned int)-1;\n  v9 = *a7;\n  v10 = a1;\n  v12 = a3;\n  *((_QWORD *)a7 + 2) = 0LL;\n  if ( !v9 )\n  {\n    *a7 = 1;\n    v9 = 1;\nLABEL_4:\n    a7[12] = v9;\n    a7[11] = v9;\n    *((_QWORD *)a7 + 4) = 0LL;\n    if ( *a3 == 45 )\n    {\n      a7[10] = 2;\n      v12 = a3 + 1;\n      v13 = 0LL;\n    }\n    else if ( *a3 == 43 )\n    {\n      a7[10] = 0;\n      v12 = a3 + 1;\n      v13 = 0LL;\n    }\n    else\n    {\n      v13 = 0LL;\n      if ( !a8 )\n      {\n        v50 = a6;\n        v34 = getenv(\"POSIXLY_CORRECT\");\n        a6 = v50;\n        if ( !v34 )\n        {\n          a7[10] = 1;\n          v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n          goto LABEL_24;\n        }\n        v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n      }\n      a7[10] = 0;\n    }\nLABEL_24:\n    a7[6] = 1;\n    v14 = *v12;\n    goto LABEL_25;\n  }\n  if ( !a7[6] )\n    goto LABEL_4;\n  v14 = *a3;\n  v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n  if ( ((v14 - 43) & 0xFD) == 0 )\n  {\n    v15 = *++v12;\n    if ( v15 == 58 )\n      v8 = 0;\n    if ( !v13 )\n      goto LABEL_12;\n    goto LABEL_28;\n  }\nLABEL_25:\n  if ( v14 == 58 )\n    v8 = 0;\n  if ( !v13 )\n    goto LABEL_12;\nLABEL_28:\n  if ( !*v13 )\n  {\nLABEL_12:\n    v16 = *a7;\n    if ( a7[12] > *a7 )\n      a7[12] = v16;\n    if ( v16 < a7[11] )\n      a7[11] = v16;\n    if ( a7[10] == 1 )\n    {\n      v26 = a7[12];\n      if ( a7[11] == v26 )\n      {\n        if ( v16 != v26 )\n        {\n          a7[11] = v16;\n          v26 = v16;\n        }\n      }\n      else if ( v16 != v26 )\n      {\n        v48 = a6;\n        sub_4121E0((__int64)a2, a7);\n        v26 = *a7;\n        a6 = v48;\n      }\n      if ( a1 <= v26 )\n      {\nLABEL_79:\n        v16 = v26;\n      }\n      else\n      {\n        v27 = v26;\n        while ( 1 )\n        {\n          v28 = (_BYTE *)a2[v27];\n          v29 = v27;\n          v26 = v27;\n          if ( *v28 == 45 )\n          {\n            if ( v28[1] )\n              break;\n          }\n          v26 = ++v27;\n          *a7 = v29 + 1;\n          if ( a1 <= (int)v27 )\n            goto LABEL_79;\n        }\n        v16 = *a7;\n      }\n      a7[12] = v26;\n    }\n    if ( a1 == v16 )\n    {\n      v10 = a7[12];\n      v18 = a7[11];\nLABEL_41:\n      if ( v18 != v10 )\n        *a7 = v18;\n      return (unsigned int)-1;\n    }\n    v17 = a2[v16];\n    if ( !strcmp((const char *)v17, \"--\") )\n    {\n      v18 = a7[11];\n      v19 = a7[12];\n      v20 = v16 + 1;\n      *a7 = v20;\n      if ( v18 == v19 )\n      {\n        a7[11] = v20;\n        v18 = v20;\n      }\n      else if ( v20 != v19 )\n      {\n        sub_4121E0((__int64)a2, a7);\n        v18 = a7[11];\n      }\n      a7[12] = a1;\n      *a7 = a1;\n      goto LABEL_41;\n    }\n    if ( *(_BYTE *)v17 == 45 )\n    {\n      v30 = *(_BYTE *)(v17 + 1);\n      if ( v30 )\n      {\n        if ( a4 )\n        {\n          if ( v30 == 45 )\n          {\n            *((_QWORD *)a7 + 4) = v17 + 2;\n            return (unsigned int)sub_4122C0(a1, a2, v12, a4, a5, a6, a7, v8, \"--\");\n          }\n          if ( a6 )\n          {\n            if ( *(_BYTE *)(v17 + 2) || (v49 = a6, v31 = strchr(v12, v30), a6 = v49, !v31) )\n            {\n              *((_QWORD *)a7 + 4) = v17 + 1;\n              v21 = sub_4122C0(a1, a2, v12, a4, a5, a6, a7, v8, \"-\");\n              if ( v21 != -1 )\n                return v21;\n              v17 = a2[*a7];\n            }\n          }\n        }\n        v13 = (_BYTE *)(v17 + 1);\n        goto LABEL_29;\n      }\n    }\n    if ( a7[10] )\n    {\n      *((_QWORD *)a7 + 2) = v17;\n      v21 = 1;\n      *a7 = v16 + 1;\n      return v21;\n    }\n    return (unsigned int)-1;\n  }\nLABEL_29:\n  v51 = v13;\n  *((_QWORD *)a7 + 4) = v13 + 1;\n  v21 = (char)*v13;\n  v52 = v13 + 1;\n  v47 = *v13;\n  v22 = strchr(v12, v21);\n  v23 = (__int64)v52;\n  if ( !v51[1] )\n    ++*a7;\n  if ( (unsigned __int8)(v47 - 58) > 1u && v22 )\n  {\n    v24 = v22[1];\n    if ( *v22 == 87 && a4 && v24 == 59 )\n    {\n      if ( v51[1] )\n      {\nLABEL_68:\n        *((_QWORD *)a7 + 4) = v23;\n        *((_QWORD *)a7 + 2) = 0LL;\n        return (unsigned int)sub_4122C0(a1, a2, v12, a4, a5, 0, a7, v8, \"-W \");\n      }\n      v32 = *a7;\n      if ( (_DWORD)v32 != a1 )\n      {\n        v23 = a2[v32];\n        goto LABEL_68;\n      }\n      if ( v8 )\n      {\n        v43 = *a2;\n        v44 = dcgettext(0LL, \"%s: option requires an argument -- '%c'\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v44, v43, v21);\n      }\n      a7[2] = v21;\n      return 5 * (unsigned int)(*v12 != 58) + 58;\n    }\n    else if ( v24 == 58 )\n    {\n      v35 = v51[1];\n      if ( v22[2] == 58 )\n      {\n        if ( v35 )\n        {\n          *((_QWORD *)a7 + 2) = v52;\n          ++*a7;\n        }\n        else\n        {\n          *((_QWORD *)a7 + 2) = 0LL;\n        }\n      }\n      else\n      {\n        v36 = *a7;\n        if ( v35 )\n        {\n          *((_QWORD *)a7 + 2) = v52;\n          *a7 = v36 + 1;\n        }\n        else if ( a1 == (_DWORD)v36 )\n        {\n          if ( v8 )\n          {\n            v41 = *a2;\n            v42 = dcgettext(0LL, \"%s: option requires an argument -- '%c'\\n\", 5);\n            __fprintf_chk(stderr, 1LL, v42, v41, v21);\n          }\n          a7[2] = v21;\n          v21 = 5 * (*v12 != 58) + 58;\n        }\n        else\n        {\n          v37 = v36 + 1;\n          v38 = a2[v36];\n          *a7 = v37;\n          *((_QWORD *)a7 + 2) = v38;\n        }\n      }\n      *((_QWORD *)a7 + 4) = 0LL;\n    }\n  }\n  else\n  {\n    if ( v8 )\n    {\n      v39 = *a2;\n      v40 = dcgettext(0LL, \"%s: invalid option -- '%c'\\n\", 5);\n      __fprintf_chk(stderr, 1LL, v40, v39, v21);\n    }\n    a7[2] = v21;\n    return 63;\n  }\n  return v21;\n}\n"
        },
        {
            "funcName": "sub_412EB0",
            "funcStartAddr": "0x412eb0",
            "funcEndAddr": "0x412f06",
            "decompiledFuncCode": "__int64 __fastcall sub_412EB0(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5, int a6, int a7)\n{\n  __int64 result; // rax\n\n  dword_61CD20 = dword_61C57C;\n  dword_61CD24 = dword_61C578;\n  result = sub_4128E0(a1, a2, a3, a4, a5, a6, &dword_61CD20, a7);\n  dword_61C57C = dword_61CD20;\n  nptr = (char *)qword_61CD30;\n  dword_61C574 = dword_61CD28;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_412F10",
            "funcStartAddr": "0x412f10",
            "funcEndAddr": "0x412f28",
            "decompiledFuncCode": "__int64 __fastcall sub_412F10(int a1, __int64 *a2, const char *a3)\n{\n  return sub_412EB0(a1, a2, a3, 0LL, 0LL, 0, 1);\n}\n"
        },
        {
            "funcName": "sub_412F30",
            "funcStartAddr": "0x412f30",
            "funcEndAddr": "0x412f43",
            "decompiledFuncCode": "__int64 __fastcall sub_412F30(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5)\n{\n  return sub_412EB0(a1, a2, a3, a4, a5, 0, 0);\n}\n"
        },
        {
            "funcName": "sub_412F50",
            "funcStartAddr": "0x412f50",
            "funcEndAddr": "0x412f65",
            "decompiledFuncCode": "__int64 __fastcall sub_412F50(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5, int *a6)\n{\n  return sub_4128E0(a1, a2, a3, a4, a5, 0, a6, 0);\n}\n"
        },
        {
            "funcName": "sub_412F70",
            "funcStartAddr": "0x412f70",
            "funcEndAddr": "0x412f86",
            "decompiledFuncCode": "__int64 __fastcall sub_412F70(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5)\n{\n  return sub_412EB0(a1, a2, a3, a4, a5, 1, 0);\n}\n"
        },
        {
            "funcName": "sub_412F90",
            "funcStartAddr": "0x412f90",
            "funcEndAddr": "0x412fa8",
            "decompiledFuncCode": "__int64 __fastcall sub_412F90(int a1, __int64 *a2, const char *a3, char **a4, _DWORD *a5, int *a6)\n{\n  return sub_4128E0(a1, a2, a3, a4, a5, 1, a6, 0);\n}\n"
        },
        {
            "funcName": "sub_412FB0",
            "funcStartAddr": "0x412fb0",
            "funcEndAddr": "0x41302a",
            "decompiledFuncCode": "size_t __fastcall sub_412FB0(wchar_t *pwc, char *s, size_t a3, mbstate_t *a4)\n{\n  size_t v4; // rbx\n  wchar_t *v5; // r12\n  const char *v6; // rbp\n  char v8; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  if ( !s )\n  {\n    a3 = 1LL;\n    v6 = \"Ordering options:\\n\\n\" + 19;\nLABEL_7:\n    v5 = (wchar_t *)&v8;\n    goto LABEL_4;\n  }\n  v4 = -2LL;\n  if ( !a3 )\n    return v4;\n  v5 = pwc;\n  v6 = s;\n  if ( !pwc )\n    goto LABEL_7;\nLABEL_4:\n  v4 = mbrtowc(v5, v6, a3, a4);\n  if ( v4 > 0xFFFFFFFFFFFFFFFDLL && !sub_40BD10(0) )\n  {\n    v4 = 1LL;\n    *v5 = *(unsigned __int8 *)v6;\n  }\n  return v4;\n}\n"
        },
        {
            "funcName": "sub_413030",
            "funcStartAddr": "0x413030",
            "funcEndAddr": "0x413134",
            "decompiledFuncCode": "_BYTE *__fastcall sub_413030(_BYTE *a1, __int16 a2, unsigned __int64 a3)\n{\n  _BYTE *result; // rax\n  __int64 v4; // r9\n  _BYTE *v5; // rcx\n  _BYTE *v6; // rdi\n\n  if ( !a3 )\n    return 0LL;\n  if ( ((unsigned __int8)a1 & 7) != 0 )\n  {\n    if ( (_BYTE)a2 == *a1 )\n      return a1;\n    while ( 1 )\n    {\n      ++a1;\n      if ( !--a3 )\n        return 0LL;\n      if ( ((unsigned __int8)a1 & 7) == 0 )\n        break;\n      if ( *a1 == (_BYTE)a2 )\n        return a1;\n    }\n  }\n  v4 = ((((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 32) | ((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8);\n  if ( a3 > 7 && (((v4 ^ *(_QWORD *)a1) - 0x101010101010101LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL) == 0 )\n  {\n    while ( 1 )\n    {\n      a3 -= 8LL;\n      a1 += 8;\n      if ( a3 <= 7 )\n        break;\n      if ( (((v4 ^ *(_QWORD *)a1) - 0x101010101010101LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL) != 0 )\n        goto LABEL_15;\n    }\n    if ( !a3 )\n      return 0LL;\n  }\nLABEL_15:\n  if ( (_BYTE)a2 != *a1 )\n  {\n    v5 = a1 + 1;\n    v6 = &a1[a3];\n    while ( 1 )\n    {\n      result = v5;\n      if ( v5 == v6 )\n        break;\n      if ( *v5++ == (_BYTE)a2 )\n        return result;\n    }\n    return 0LL;\n  }\n  return a1;\n}\n"
        },
        {
            "funcName": "sub_413140",
            "funcStartAddr": "0x413140",
            "funcEndAddr": "0x4131e2",
            "decompiledFuncCode": "int __fastcall sub_413140(__time_t *a1, struct timespec *a2)\n{\n  __time_t v2; // rbx\n  int result; // eax\n  struct timespec v4[2]; // [rsp+0h] [rbp-28h] BYREF\n\n  if ( (unsigned __int64)a1[1] > 0x3B9AC9FF )\n  {\n    *__errno_location() = 22;\n    return -1;\n  }\n  else\n  {\n    v2 = *a1;\n    v4[0].tv_nsec = a1[1];\n    if ( v2 > 2073600 )\n    {\n      while ( 1 )\n      {\n        v4[0].tv_sec = 2073600LL;\n        v2 -= 2073600LL;\n        result = nanosleep(v4, a2);\n        if ( result )\n          break;\n        v4[0].tv_nsec = 0LL;\n        if ( v2 <= 2073600 )\n          goto LABEL_8;\n      }\n      if ( a2 )\n        a2->tv_sec += v2;\n    }\n    else\n    {\nLABEL_8:\n      v4[0].tv_sec = v2;\n      return nanosleep(v4, a2);\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_4131F0",
            "funcStartAddr": "0x4131f0",
            "funcEndAddr": "0x41322b",
            "decompiledFuncCode": "void __noreturn sub_4131F0()\n{\n  char *v0; // rax\n\n  v0 = dcgettext(0LL, \"memory exhausted\", 5);\n  __fprintf_chk(stderr, 1LL, \"%s\\n\", v0);\n  exit(status);\n}\n"
        },
        {
            "funcName": "sub_413230",
            "funcStartAddr": "0x413230",
            "funcEndAddr": "0x413245",
            "decompiledFuncCode": "__int64 __fastcall sub_413230(__int64 a1, __int64 a2)\n{\n  __int64 (__fastcall *v2)(__int64); // rax\n\n  v2 = *(__int64 (__fastcall **)(__int64))(a1 + 56);\n  if ( (*(_BYTE *)(a1 + 80) & 1) != 0 )\n    return v2(*(_QWORD *)(a1 + 72));\n  else\n    return v2(a2);\n}\n"
        },
        {
            "funcName": "sub_413250",
            "funcStartAddr": "0x413250",
            "funcEndAddr": "0x413265",
            "decompiledFuncCode": "__int64 __fastcall sub_413250(__int64 a1, __int64 a2)\n{\n  __int64 (__fastcall *v2)(__int64); // rax\n\n  v2 = *(__int64 (__fastcall **)(__int64))(a1 + 64);\n  if ( (*(_BYTE *)(a1 + 80) & 1) != 0 )\n    return v2(*(_QWORD *)(a1 + 72));\n  else\n    return v2(a2);\n}\n"
        },
        {
            "funcName": "sub_413270",
            "funcStartAddr": "0x413270",
            "funcEndAddr": "0x4132f3",
            "decompiledFuncCode": "__int64 __fastcall sub_413270(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // rbp\n  __int64 v4; // r12\n  _QWORD *v5; // rax\n  __int64 v6; // rbp\n  __int64 v7; // rdx\n  char *v8; // rdx\n  __int64 result; // rax\n\n  if ( a3 )\n  {\n    v3 = a3;\n    v4 = a3 - 1;\n  }\n  else\n  {\n    v4 = 15LL;\n    v3 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v4;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v5 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v5;\n  if ( !v5 )\n    obstack_alloc_failed_handler();\n  v6 = ((unsigned __int64)v5 + v4 + 16) & -v3;\n  v7 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v6;\n  v8 = (char *)v5 + v7;\n  *(_QWORD *)(a1 + 24) = v6;\n  *v5 = v8;\n  *(_QWORD *)(a1 + 32) = v8;\n  v5[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n"
        },
        {
            "funcName": "obstack_begin",
            "funcStartAddr": "0x413300",
            "funcEndAddr": "0x413311",
            "decompiledFuncCode": "__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  *(_BYTE *)(a1 + 80) &= ~1u;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  return sub_413270(a1, a2, a3);\n}\n"
        },
        {
            "funcName": "obstack_begin_1",
            "funcStartAddr": "0x413320",
            "funcEndAddr": "0x413335",
            "decompiledFuncCode": "__int64 __fastcall obstack_begin_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  *(_BYTE *)(a1 + 80) |= 1u;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  *(_QWORD *)(a1 + 72) = a6;\n  return sub_413270(a1, a2, a3);\n}\n"
        },
        {
            "funcName": "obstack_newchunk",
            "funcStartAddr": "0x413340",
            "funcEndAddr": "0x41343b",
            "decompiledFuncCode": "__int64 __fastcall obstack_newchunk(__int64 a1, __int64 a2, __int64 a3, _BOOL8 a4)\n{\n  size_t v4; // r13\n  __int64 v5; // rbp\n  size_t v6; // rsi\n  _BOOL8 v7; // rax\n  bool v8; // cf\n  unsigned __int64 v9; // rsi\n  size_t v10; // rdx\n  unsigned __int64 v11; // rbx\n  _QWORD *v12; // rax\n  _QWORD *v13; // r14\n  char *v14; // rbx\n  __int64 result; // rax\n\n  v4 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);\n  v5 = *(_QWORD *)(a1 + 8);\n  v8 = __CFADD__(v4, a2);\n  v6 = v4 + a2;\n  v7 = v8;\n  v8 = __CFADD__(*(_QWORD *)(a1 + 48), v6);\n  v9 = *(_QWORD *)(a1 + 48) + v6;\n  LOBYTE(a4) = v8;\n  v10 = v4 >> 3;\n  v11 = v9 + (v4 >> 3) + 100;\n  if ( *(_QWORD *)a1 >= v9 )\n    v9 = *(_QWORD *)a1;\n  if ( v9 >= v11 )\n    v11 = v9;\n  if ( v7 || (a4 = v8) || (v9 = v11, v12 = (_QWORD *)sub_413230(a1, v11), (v13 = v12) == 0LL) )\n    obstack_alloc_failed_handler(a1, v9, v10, a4);\n  *(_QWORD *)(a1 + 8) = v12;\n  v12[1] = v5;\n  *(_QWORD *)(a1 + 32) = (char *)v12 + v11;\n  *v12 = (char *)v12 + v11;\n  v14 = (char *)(~*(_QWORD *)(a1 + 48) & ((unsigned __int64)v12 + *(_QWORD *)(a1 + 48) + 16));\n  result = (__int64)memcpy(v14, *(const void **)(a1 + 16), v4);\n  if ( (*(_BYTE *)(a1 + 80) & 2) == 0 )\n  {\n    result = (v5 + *(_QWORD *)(a1 + 48) + 16) & ~*(_QWORD *)(a1 + 48);\n    if ( *(_QWORD *)(a1 + 16) == result )\n    {\n      v13[1] = *(_QWORD *)(v5 + 8);\n      result = sub_413250(a1, v5);\n    }\n  }\n  *(_QWORD *)(a1 + 16) = v14;\n  *(_QWORD *)(a1 + 24) = &v14[v4];\n  *(_BYTE *)(a1 + 80) &= ~2u;\n  return result;\n}\n"
        },
        {
            "funcName": "obstack_allocated_p",
            "funcStartAddr": "0x413440",
            "funcEndAddr": "0x413477",
            "decompiledFuncCode": "unsigned __int64 __fastcall obstack_allocated_p(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 result; // rax\n\n  result = *(_QWORD *)(a1 + 8);\n  if ( result )\n  {\n    while ( a2 <= result || *(_QWORD *)result < a2 )\n    {\n      result = *(_QWORD *)(result + 8);\n      if ( !result )\n        return 0LL;\n    }\n    return 1LL;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "obstack_free",
            "funcStartAddr": "0x402f3c",
            "funcEndAddr": "0x402f41",
            "decompiledFuncCode": "void obstack_free(struct obstack *obstack, void *block)\n{\n  struct _obstack_chunk *chunk; // rsi\n  char *limit; // rax\n  struct _obstack_chunk *prev; // r12\n\n  chunk = obstack->chunk;\n  if ( chunk )\n  {\n    while ( 1 )\n    {\n      if ( chunk < block )\n      {\n        limit = chunk->limit;\n        if ( chunk->limit >= block )\n          break;\n      }\n      prev = chunk->prev;\n      sub_413250((__int64)obstack, (__int64)chunk);\n      *((_BYTE *)obstack + 80) |= 2u;\n      chunk = prev;\n      if ( !prev )\n        goto LABEL_5;\n    }\n    obstack->next_free = (char *)block;\n    obstack->object_base = (char *)block;\n    obstack->chunk_limit = limit;\n    obstack->chunk = chunk;\n  }\n  else\n  {\nLABEL_5:\n    if ( block )\n      abort();\n  }\n}\n\nvoid obstack_free(struct obstack *obstack, void *block)\n{\n  struct _obstack_chunk *chunk; // rsi\n  char *limit; // rax\n  struct _obstack_chunk *prev; // r12\n\n  chunk = obstack->chunk;\n  if ( chunk )\n  {\n    while ( 1 )\n    {\n      if ( chunk < block )\n      {\n        limit = chunk->limit;\n        if ( chunk->limit >= block )\n          break;\n      }\n      prev = chunk->prev;\n      sub_413250((__int64)obstack, (__int64)chunk);\n      *((_BYTE *)obstack + 80) |= 2u;\n      chunk = prev;\n      if ( !prev )\n        goto LABEL_5;\n    }\n    obstack->next_free = (char *)block;\n    obstack->object_base = (char *)block;\n    obstack->chunk_limit = limit;\n    obstack->chunk = chunk;\n  }\n  else\n  {\nLABEL_5:\n    if ( block )\n      abort();\n  }\n}\n"
        },
        {
            "funcName": "obstack_free",
            "funcStartAddr": "0x402f3c",
            "funcEndAddr": "0x402f41",
            "decompiledFuncCode": "void obstack_free(struct obstack *obstack, void *block)\n{\n  struct _obstack_chunk *chunk; // rsi\n  char *limit; // rax\n  struct _obstack_chunk *prev; // r12\n\n  chunk = obstack->chunk;\n  if ( chunk )\n  {\n    while ( 1 )\n    {\n      if ( chunk < block )\n      {\n        limit = chunk->limit;\n        if ( chunk->limit >= block )\n          break;\n      }\n      prev = chunk->prev;\n      sub_413250((__int64)obstack, (__int64)chunk);\n      *((_BYTE *)obstack + 80) |= 2u;\n      chunk = prev;\n      if ( !prev )\n        goto LABEL_5;\n    }\n    obstack->next_free = (char *)block;\n    obstack->object_base = (char *)block;\n    obstack->chunk_limit = limit;\n    obstack->chunk = chunk;\n  }\n  else\n  {\nLABEL_5:\n    if ( block )\n      abort();\n  }\n}\n\nvoid obstack_free(struct obstack *obstack, void *block)\n{\n  struct _obstack_chunk *chunk; // rsi\n  char *limit; // rax\n  struct _obstack_chunk *prev; // r12\n\n  chunk = obstack->chunk;\n  if ( chunk )\n  {\n    while ( 1 )\n    {\n      if ( chunk < block )\n      {\n        limit = chunk->limit;\n        if ( chunk->limit >= block )\n          break;\n      }\n      prev = chunk->prev;\n      sub_413250((__int64)obstack, (__int64)chunk);\n      *((_BYTE *)obstack + 80) |= 2u;\n      chunk = prev;\n      if ( !prev )\n        goto LABEL_5;\n    }\n    obstack->next_free = (char *)block;\n    obstack->object_base = (char *)block;\n    obstack->chunk_limit = limit;\n    obstack->chunk = chunk;\n  }\n  else\n  {\nLABEL_5:\n    if ( block )\n      abort();\n  }\n}\n"
        },
        {
            "funcName": "obstack_memory_used",
            "funcStartAddr": "0x4134f0",
            "funcEndAddr": "0x413519",
            "decompiledFuncCode": "__int64 __fastcall obstack_memory_used(__int64 a1)\n{\n  _QWORD *v1; // rdx\n  __int64 result; // rax\n  __int64 v3; // rcx\n\n  v1 = *(_QWORD **)(a1 + 8);\n  for ( result = 0LL; v1; result += v3 )\n  {\n    v3 = *v1 - (_QWORD)v1;\n    v1 = (_QWORD *)v1[1];\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_413520",
            "funcStartAddr": "0x413520",
            "funcEndAddr": "0x41357d",
            "decompiledFuncCode": "int __fastcall sub_413520(FILE *stream)\n{\n  size_t v1; // r12\n  int v2; // ebx\n  int result; // eax\n\n  v1 = __fpending(stream);\n  v2 = stream->_flags & 0x20;\n  result = sub_411F80(stream);\n  if ( v2 )\n  {\n    if ( !result )\n    {\n      *__errno_location() = 0;\n      return -1;\n    }\n    return -1;\n  }\n  if ( !result )\n    return result;\n  if ( v1 )\n    return -1;\n  return -(*__errno_location() != 9);\n}\n"
        },
        {
            "funcName": "sub_413580",
            "funcStartAddr": "0x413580",
            "funcEndAddr": "0x41363c",
            "decompiledFuncCode": "__int64 __fastcall sub_413580(double a1)\n{\n  __int64 result; // rax\n  __int64 v2; // rsi\n  signed __int64 v3; // rcx\n\n  if ( a1 <= -9.223372036854776e18 )\n    return 0x8000000000000000LL;\n  if ( a1 >= 9.223372036854776e18 )\n    return 0x7FFFFFFFFFFFFFFFLL;\n  v2 = (unsigned int)(int)a1;\n  v3 = (unsigned int)(int)((a1 - (double)(int)v2) * 1000000000.0)\n     + (unsigned __int64)((a1 - (double)(int)v2) * 1000000000.0 > (double)(int)((a1 - (double)(int)v2) * 1000000000.0));\n  result = v3 / 1000000000 + v2;\n  if ( v3 % 1000000000 < 0 )\n    --result;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_413640",
            "funcStartAddr": "0x413640",
            "funcEndAddr": "0x41368e",
            "decompiledFuncCode": "__int64 __fastcall sub_413640(unsigned int fd)\n{\n  __int64 result; // rax\n  unsigned int v2; // r12d\n  int *v3; // rax\n  int v4; // r13d\n  int *v5; // rbp\n\n  if ( fd > 2 )\n    return fd;\n  v2 = sub_413690();\n  v3 = __errno_location();\n  v4 = *v3;\n  v5 = v3;\n  close(fd);\n  result = v2;\n  *v5 = v4;\n  return result;\n}\n"
        },
        {
            "funcName": "sub_413690",
            "funcStartAddr": "0x413690",
            "funcEndAddr": "0x4136aa",
            "decompiledFuncCode": "__int64 __fastcall sub_413690(int a1, int a2, __int64 a3, int a4, int a5, int a6)\n{\n  int v6; // esi\n\n  v6 = a2 & 0x80000;\n  if ( v6 )\n    v6 = 1030;\n  return sub_412000(a1, v6, 3LL, a4, a5, a6);\n}\n"
        },
        {
            "funcName": "sub_4136B0",
            "funcStartAddr": "0x4136b0",
            "funcEndAddr": "0x413743",
            "decompiledFuncCode": "FILE *__fastcall sub_4136B0(const char *a1, const char *a2)\n{\n  FILE *v2; // rax\n  FILE *v3; // rbx\n  unsigned int v4; // eax\n  int v6; // r12d\n  int *v7; // rax\n  int v8; // ebp\n  int *v9; // rbx\n  int *v10; // rax\n  FILE *v11; // rdi\n  int v12; // r12d\n  int *v13; // rbp\n\n  v2 = fopen(a1, a2);\n  v3 = v2;\n  if ( v2 )\n  {\n    v4 = fileno(v2);\n    if ( v4 <= 2 )\n    {\n      v6 = sub_413EA0(v4);\n      if ( v6 < 0 )\n      {\n        v10 = __errno_location();\n        v11 = v3;\n        v3 = 0LL;\n        v12 = *v10;\n        v13 = v10;\n        sub_411F80(v11);\n        *v13 = v12;\n      }\n      else if ( sub_411F80(v3) || (v3 = fdopen(v6, a2)) == 0LL )\n      {\n        v7 = __errno_location();\n        v8 = *v7;\n        v9 = v7;\n        close(v6);\n        *v9 = v8;\n        return 0LL;\n      }\n    }\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "sub_413750",
            "funcStartAddr": "0x413750",
            "funcEndAddr": "0x413cb2",
            "decompiledFuncCode": "const char *sub_413750()\n{\n  char *v0; // rax\n  char *v1; // r15\n  const char *v2; // rbx\n  char v3; // bp\n  const char *v4; // rbp\n  char *v6; // rax\n  const char *v7; // r13\n  size_t v8; // rax\n  __int64 v9; // r12\n  size_t v10; // r14\n  size_t v11; // rdi\n  char *v12; // rax\n  char *v13; // rbp\n  size_t v14; // rdi\n  char *v15; // rax\n  int v16; // eax\n  int v17; // r12d\n  FILE *v18; // r13\n  const char *v19; // rax\n  FILE *v20; // rbx\n  const char *v21; // r13\n  char *IO_read_ptr; // rax\n  int v23; // edi\n  char *v24; // kr00_8\n  int *v25; // rdx\n  int v26; // esi\n  unsigned int v27; // eax\n  __int64 v28; // rdx\n  signed __int64 v29; // rax\n  char *v30; // rax\n  __int64 v31; // rcx\n  __int64 v32; // rdx\n  __int64 v33; // rsi\n  unsigned int v34; // ecx\n  signed __int64 v35; // rdi\n  char *v36; // rsi\n  unsigned int v37; // edx\n  char *v38; // rcx\n  FILE *v39; // rdi\n  int v40; // eax\n  bool v41; // dl\n  char *v42; // rax\n  signed __int64 v43; // rax\n  unsigned __int64 v44; // r9\n  char *v45; // rsi\n  char *v46; // r10\n  unsigned int v47; // ecx\n  unsigned int v48; // ecx\n  unsigned int v49; // esi\n  __int64 v50; // r8\n  unsigned __int64 v51; // rdi\n  char *v52; // rcx\n  char *v53; // r9\n  unsigned int v54; // edx\n  unsigned int v55; // edx\n  unsigned int v56; // ecx\n  __int64 v57; // rsi\n  const char *v58; // rax\n  char *v59; // rdi\n  FILE *v60; // r13\n  signed __int64 v61; // [rsp+8h] [rbp-D0h]\n  __int64 v62; // [rsp+18h] [rbp-C0h]\n  char v63[64]; // [rsp+20h] [rbp-B8h] BYREF\n  _QWORD v64[15]; // [rsp+60h] [rbp-78h] BYREF\n\n  v0 = nl_langinfo(14);\n  v1 = s;\n  v2 = v0;\n  if ( !v0 )\n    v2 = \"\";\n  if ( !s )\n  {\n    v6 = getenv(\"CHARSETALIASDIR\");\n    v7 = v6;\n    if ( v6 && *v6 )\n    {\n      v8 = strlen(v6);\n      v9 = v8;\n      v10 = v8;\n      if ( !v8 )\n      {\n        v11 = 14LL;\nLABEL_18:\n        v12 = (char *)malloc(v11);\n        v13 = v12;\n        if ( !v12 )\n        {\nLABEL_19:\n          v1 = (_BYTE *)(\"Ordering options:\\n\\n\" + 19);\nLABEL_20:\n          s = v1;\n          goto LABEL_4;\n        }\n        memcpy(v12, v7, v10);\nLABEL_24:\n        strcpy(&v13[v9], \"charset.alias\");\n        v16 = open(v13, 0);\n        v17 = v16;\n        if ( v16 >= 0 )\n        {\n          v1 = 0LL;\n          v61 = 0LL;\n          v18 = fdopen(v16, \"r\");\n          if ( v18 )\n          {\n            v19 = v2;\n            v20 = v18;\n            v21 = v19;\nLABEL_30:\n            IO_read_ptr = v20->_IO_read_ptr;\n            if ( IO_read_ptr < v20->_IO_read_end )\n            {\nLABEL_31:\n              v20->_IO_read_ptr = IO_read_ptr + 1;\n              v23 = (unsigned __int8)*IO_read_ptr;\n              goto LABEL_32;\n            }\n            while ( 1 )\n            {\n              v23 = __uflow(v20);\n              if ( v23 == -1 )\n                break;\nLABEL_32:\n              if ( (unsigned int)(v23 - 9) <= 1 || v23 == 32 )\n                goto LABEL_30;\n              if ( v23 == 35 )\n              {\n                do\n                {\n                  v42 = v20->_IO_read_ptr;\n                  if ( v42 < v20->_IO_read_end )\n                  {\n                    v20->_IO_read_ptr = v42 + 1;\n                    v40 = (unsigned __int8)*v42;\n                    v41 = 1;\n                  }\n                  else\n                  {\n                    v40 = __uflow(v20);\n                    v41 = v40 != -1;\n                  }\n                }\n                while ( v40 != 10 && v41 );\n                if ( v40 == -1 )\n                  break;\n                goto LABEL_30;\n              }\n              ungetc(v23, v20);\n              if ( fscanf(v20, \"%50s %50s\", v63, v64) <= 1 )\n                break;\n              v24 = &v63[strlen(v63)];\n              v25 = (int *)v64;\n              do\n              {\n                v26 = *v25++;\n                v27 = ~v26 & (v26 - 16843009) & 0x80808080;\n              }\n              while ( !v27 );\n              if ( (~v26 & (v26 - 16843009) & 0x8080) == 0 )\n              {\n                v27 >>= 16;\n                v25 = (int *)((char *)v25 + 2);\n              }\n              v28 = (char *)v25 - __CFADD__((_BYTE)v27, (_BYTE)v27) - 3 - (char *)v64;\n              v29 = v24 - v63 + v28;\n              v62 = v28;\n              if ( v61 )\n              {\n                v43 = v61 + v29;\n                v61 = v43 + 2;\n                v30 = (char *)realloc(v1, v43 + 3);\n                v32 = v62;\n                v31 = v24 - v63;\n              }\n              else\n              {\n                v61 = v29 + 2;\n                v30 = (char *)malloc(v29 + 3);\n                v31 = v24 - v63;\n                v32 = v62;\n              }\n              if ( !v30 )\n              {\n                v58 = v21;\n                v59 = v1;\n                v60 = v20;\n                v1 = (_BYTE *)(\"Ordering options:\\n\\n\" + 19);\n                v2 = v58;\n                free(v59);\n                sub_411F80(v60);\n                goto LABEL_26;\n              }\n              v33 = -2 - v31;\n              v34 = v31 + 1;\n              v35 = v61 - v32;\n              v36 = &v30[v61 - v32 + v33];\n              if ( v34 >= 8 )\n              {\n                *(_QWORD *)v36 = *(_QWORD *)v63;\n                *(_QWORD *)&v36[v34 - 8] = *(_QWORD *)&v63[v34 - 8];\n                v44 = (unsigned __int64)(v36 + 8) & 0xFFFFFFFFFFFFFFF8LL;\n                v45 = &v36[-v44];\n                v46 = (char *)(v63 - v45);\n                v47 = ((_DWORD)v45 + v34) & 0xFFFFFFF8;\n                if ( v47 >= 8 )\n                {\n                  v48 = v47 & 0xFFFFFFF8;\n                  v49 = 0;\n                  do\n                  {\n                    v50 = v49;\n                    v49 += 8;\n                    *(_QWORD *)(v44 + v50) = *(_QWORD *)&v46[v50];\n                  }\n                  while ( v49 < v48 );\n                }\n              }\n              else if ( (v34 & 4) != 0 )\n              {\n                *(_DWORD *)v36 = *(_DWORD *)v63;\n                *(_DWORD *)&v36[v34 - 4] = *(_DWORD *)&v63[v34 - 4];\n              }\n              else if ( v34 )\n              {\n                *v36 = v63[0];\n                if ( (v34 & 2) != 0 )\n                  *(_WORD *)&v36[v34 - 2] = *(_WORD *)&v63[v34 - 2];\n              }\n              v37 = v32 + 1;\n              v38 = &v30[v35 - 1];\n              if ( v37 >= 8 )\n              {\n                *(_QWORD *)v38 = v64[0];\n                *(_QWORD *)&v38[v37 - 8] = *(_QWORD *)&v63[v37 + 56];\n                v51 = (unsigned __int64)(v38 + 8) & 0xFFFFFFFFFFFFFFF8LL;\n                v52 = &v38[-v51];\n                v53 = (char *)((char *)v64 - v52);\n                v54 = ((_DWORD)v52 + v37) & 0xFFFFFFF8;\n                if ( v54 >= 8 )\n                {\n                  v55 = v54 & 0xFFFFFFF8;\n                  v56 = 0;\n                  do\n                  {\n                    v57 = v56;\n                    v56 += 8;\n                    *(_QWORD *)(v51 + v57) = *(_QWORD *)&v53[v57];\n                  }\n                  while ( v56 < v55 );\n                }\n              }\n              else if ( (v37 & 4) != 0 )\n              {\n                *(_DWORD *)v38 = v64[0];\n                *(_DWORD *)&v38[v37 - 4] = *(_DWORD *)&v63[v37 + 60];\n              }\n              else if ( v37 )\n              {\n                *v38 = v64[0];\n                if ( (v37 & 2) != 0 )\n                  *(_WORD *)&v38[v37 - 2] = *(_WORD *)&v63[v37 + 62];\n              }\n              v1 = v30;\n              IO_read_ptr = v20->_IO_read_ptr;\n              if ( IO_read_ptr < v20->_IO_read_end )\n                goto LABEL_31;\n            }\n            v39 = v20;\n            v2 = v21;\n            sub_411F80(v39);\n            if ( !v61 )\n              goto LABEL_25;\n            v1[v61] = 0;\n            goto LABEL_26;\n          }\n          close(v17);\n        }\nLABEL_25:\n        v1 = (_BYTE *)(\"Ordering options:\\n\\n\" + 19);\nLABEL_26:\n        free(v13);\n        goto LABEL_20;\n      }\n      if ( v7[v8 - 1] == 47 )\n      {\n        v11 = v8 + 14;\n        goto LABEL_18;\n      }\n      v14 = v8 + 15;\n      v9 = v8 + 1;\n    }\n    else\n    {\n      v14 = 115LL;\n      v9 = 101LL;\n      v10 = 100LL;\n      v7 = \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\";\n    }\n    v15 = (char *)malloc(v14);\n    v13 = v15;\n    if ( !v15 )\n      goto LABEL_19;\n    memcpy(v15, v7, v10);\n    v13[v10] = 47;\n    goto LABEL_24;\n  }\nLABEL_4:\n  v3 = *v1;\n  if ( *v1 )\n  {\n    while ( strcmp(v2, v1) && (v3 != 42 || v1[1]) )\n    {\n      v4 = &v1[strlen(v1) + 1];\n      v1 = (char *)&v4[strlen(v4) + 1];\n      v3 = *v1;\n      if ( !*v1 )\n        goto LABEL_11;\n    }\n    v2 = &v1[strlen(v1) + 1];\n  }\nLABEL_11:\n  if ( !*v2 )\n    return \"ASCII\";\n  return v2;\n}\n"
        },
        {
            "funcName": "sub_413CC0",
            "funcStartAddr": "0x413cc0",
            "funcEndAddr": "0x413d74",
            "decompiledFuncCode": "int __fastcall sub_413CC0(char *s1, __int64 a2, const char *a3, __int64 a4)\n{\n  int *v8; // r15\n  size_t v9; // rbx\n  size_t v10; // rax\n  int result; // eax\n\n  v8 = __errno_location();\n  while ( 1 )\n  {\n    *v8 = 0;\n    result = strcoll(s1, a3);\n    if ( result )\n      break;\n    v9 = strlen(s1) + 1;\n    s1 += v9;\n    v10 = strlen(a3) + 1;\n    a3 += v10;\n    a4 -= v10;\n    a2 -= v9;\n    if ( !a2 )\n      return -(a4 != 0);\n    if ( !a4 )\n      return 1;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "sub_413D80",
            "funcStartAddr": "0x413d80",
            "funcEndAddr": "0x413e21",
            "decompiledFuncCode": "__int64 __fastcall sub_413D80(char *s1, size_t n, const char *s2, __int64 a4)\n{\n  char v6; // r9\n  char v7; // r8\n  unsigned int v8; // edx\n  int *v10; // rax\n  char v11; // [rsp+8h] [rbp-40h]\n  char v12; // [rsp+Fh] [rbp-39h]\n\n  if ( n == a4 && !memcmp(s1, s2, n) )\n  {\n    v10 = __errno_location();\n    v8 = 0;\n    *v10 = 0;\n  }\n  else\n  {\n    v6 = s1[n];\n    v7 = s2[a4];\n    s1[n] = 0;\n    s2[a4] = 0;\n    v12 = v6;\n    v11 = v7;\n    v8 = sub_413CC0(s1, n + 1, s2, a4 + 1);\n    s1[n] = v12;\n    s2[a4] = v11;\n  }\n  return v8;\n}\n"
        },
        {
            "funcName": "sub_413E30",
            "funcStartAddr": "0x413e30",
            "funcEndAddr": "0x413e93",
            "decompiledFuncCode": "int __fastcall sub_413E30(char *s1, size_t n, const char *s2, __int64 a4)\n{\n  if ( n != a4 || memcmp(s1, s2, n) )\n    return sub_413CC0(s1, n, s2, a4);\n  *__errno_location() = 0;\n  return 0;\n}\n"
        },
        {
            "funcName": "sub_413EA0",
            "funcStartAddr": "0x413ea0",
            "funcEndAddr": "0x413eae",
            "decompiledFuncCode": "__int64 __fastcall sub_413EA0(int a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  return sub_412000(a1, 0, 3LL, a4, a5, a6);\n}\n"
        },
        {
            "funcName": "sub_413F20",
            "funcStartAddr": "0x413f20",
            "funcEndAddr": "0x413f38",
            "decompiledFuncCode": "int __fastcall sub_413F20(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  v1 = 0LL;\n  if ( qword_61C3E8 )\n    v1 = (void *)qword_61C3E8[0];\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"
        },
        {
            "funcName": "sub_413F38",
            "funcStartAddr": "0x413f38",
            "funcEndAddr": "0x413f58",
            "decompiledFuncCode": "__int64 __fastcall sub_413F38(__int64 a1, __int64 a2, __int64 a3)\n{\n  void (**i)(void); // rbx\n\n  for ( i = (void (**)(void))&qword_61BE20; *i != (void (*)(void))-1LL; --i )\n    (*i)();\n  return a3;\n}\n"
        }
    ],
    "funcCount": 211
}