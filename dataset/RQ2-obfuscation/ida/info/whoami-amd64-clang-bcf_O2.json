{
    "binaryInfo": {
        "binaryName": "whoami-amd64-clang-bcf_O2",
        "isStripped": "True"
    },
    "buildInfo": {
        "decompilerName": "IDA Pro",
        "compilerName": "gcc",
        "compilerVersion": "9.4.0",
        "Optlevel": "-O"
    },
    "funcInfo": [
        {
            "funcName": "_dl_relocate_static_pie",
            "funcStartAddr": "0x402300",
            "funcEndAddr": "0x402305",
            "decompiledFuncCode": "void dl_relocate_static_pie()\n{\n  ;\n}\n"
        },
        {
            "funcName": "usage",
            "funcStartAddr": "0x4023c0",
            "funcEndAddr": "0x4025c3",
            "decompiledFuncCode": "void __fastcall __noreturn usage(int status)\n{\n  FILE *v2; // rbx\n  char *v3; // rax\n  FILE *v4; // rbx\n  char *v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  char *v8; // rax\n  char *v9; // rdi\n  char *v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  char *v13; // rdi\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( status )\n  {\n    while ( 1 )\n    {\n      v4 = stderr;\n      v5 = dcgettext(0LL, \"Try '%s --help' for more information.\\n\", 5);\n      __fprintf_chk(v4, 1LL, v5, program_name);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\n      v2 = stderr;\n      v3 = dcgettext(0LL, \"Try '%s --help' for more information.\\n\", 5);\n      __fprintf_chk(v2, 1LL, v3, program_name);\n    }\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v10 = dcgettext(0LL, \"Usage: %s [OPTION]...\\n\", 5);\n      __printf_chk(1LL, v10, program_name);\n      v11 = dcgettext(0LL, \"Print the user name associated with the current effective user ID.\\nSame as id -un.\\n\\n\", 5);\n      fputs_unlocked(v11, stdout);\n      v12 = dcgettext(0LL, \"      --help     display this help and exit\\n\", 5);\n      fputs_unlocked(v12, stdout);\n      v13 = dcgettext(0LL, \"      --version  output version information and exit\\n\", 5);\n      fputs_unlocked(v13, stdout);\n      emit_ancillary_info(v13);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\n      v6 = dcgettext(0LL, \"Usage: %s [OPTION]...\\n\", 5);\n      __printf_chk(1LL, v6, program_name);\n      v7 = dcgettext(0LL, \"Print the user name associated with the current effective user ID.\\nSame as id -un.\\n\\n\", 5);\n      fputs_unlocked(v7, stdout);\n      v8 = dcgettext(0LL, \"      --help     display this help and exit\\n\", 5);\n      fputs_unlocked(v8, stdout);\n      v9 = dcgettext(0LL, \"      --version  output version information and exit\\n\", 5);\n      fputs_unlocked(v9, stdout);\n      emit_ancillary_info(v9);\n    }\n  }\n  exit(status);\n}\n"
        },
        {
            "funcName": "emit_ancillary_info",
            "funcStartAddr": "0x4025d0",
            "funcEndAddr": "0x402743",
            "decompiledFuncCode": "void __fastcall emit_ancillary_info(const char *program)\n{\n  const char *node; // rbx\n  char *v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  char *v7; // rdx\n\n  if ( y_29 >= 10 && (((_BYTE)x_28 * ((_BYTE)x_28 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  node = \"whoami\";\n  if ( emit_ancillary_info_infomap[6].node )\n    node = emit_ancillary_info_infomap[6].node;\n  while ( 1 )\n  {\n    v3 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v3, \"GNU coreutils\");\n    v4 = setlocale(5, 0LL);\n    if ( y_29 < 10 || (((_BYTE)x_28 * ((_BYTE)x_28 - 1)) & 1) == 0 )\n      break;\n    v2 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v2, \"GNU coreutils\");\n    setlocale(5, 0LL);\n  }\n  if ( v4 && strncmp(v4, \"en_\", 3uLL) )\n  {\n    v5 = dcgettext(0LL, \"Report any translation bugs to <https://translationproject.org/team/>\\n\", 5);\n    fputs_unlocked(v5, stdout);\n  }\n  v6 = dcgettext(0LL, \"Full documentation <%s%s>\\n\", 5);\n  __printf_chk(1LL, v6, \"https://www.gnu.org/software/coreutils/\");\n  v7 = dcgettext(0LL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5);\n  __printf_chk(1LL, v7, node);\n}\n"
        },
        {
            "funcName": "main",
            "funcStartAddr": "0x402750",
            "funcEndAddr": "0x40290b",
            "decompiledFuncCode": "int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r14\n  __uid_t v4; // ebp\n  char v5; // dl\n  int v6; // ecx\n  char *v7; // rbp\n  const char *v8; // rax\n  struct passwd *v9; // rax\n  int v11; // ebx\n  char *v12; // rax\n  int v13; // ebx\n  char *v14; // rax\n\n  set_program_name(*argv);\n  setlocale(6, \"\");\n  bindtextdomain(\"coreutils\", \"/home/yujeong/binary_gen/coreutils-8.31/tmp/_install/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  parse_gnu_standard_options_only(\n    argc,\n    (char **)argv,\n    \"whoami\",\n    \"GNU coreutils\",\n    Version,\n    1,\n    (void (*)(int))usage,\n    \"Richard Mlynarik\",\n    0LL);\n  if ( optind != argc )\n  {\n    v7 = dcgettext(0LL, \"extra operand %s\", 5);\n    v8 = quote(argv[optind]);\n    error(0, 0, v7, v8);\n    usage(1);\n  }\n  v3 = __errno_location();\n  *v3 = 0;\n  v4 = geteuid();\n  if ( v4 == -1 && *v3 )\n  {\n    v5 = x_30;\n    v6 = y_31;\n    goto LABEL_14;\n  }\n  if ( y_31 >= 10 && (((_BYTE)x_30 * ((_BYTE)x_30 - 1)) & 1) != 0 )\n    goto LABEL_11;\n  while ( 1 )\n  {\n    v9 = getpwuid(v4);\n    v5 = x_30;\n    v6 = y_31;\n    if ( y_31 < 10 || (((_BYTE)x_30 * ((_BYTE)x_30 - 1)) & 1) == 0 )\n      break;\nLABEL_11:\n    getpwuid(v4);\n  }\n  if ( !v9 )\n  {\nLABEL_14:\n    if ( v6 >= 10 && ((v5 * (v5 - 1)) & 1) != 0 )\n      goto LABEL_17;\n    while ( 1 )\n    {\n      v11 = *v3;\n      v12 = dcgettext(0LL, \"cannot find name for user ID %lu\", 5);\n      error(1, v11, v12, v4);\nLABEL_17:\n      v13 = *v3;\n      v14 = dcgettext(0LL, \"cannot find name for user ID %lu\", 5);\n      error(1, v13, v14, v4);\n    }\n  }\n  puts(v9->pw_name);\n  return 0;\n}\n"
        },
        {
            "funcName": "close_stdout_set_file_name",
            "funcStartAddr": "0x402910",
            "funcEndAddr": "0x402948",
            "decompiledFuncCode": "void __fastcall close_stdout_set_file_name(const char *file)\n{\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    file_name = file;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    file_name = file;\n  }\n}\n"
        },
        {
            "funcName": "close_stdout_set_ignore_EPIPE",
            "funcStartAddr": "0x402950",
            "funcEndAddr": "0x402988",
            "decompiledFuncCode": "void __fastcall close_stdout_set_ignore_EPIPE(bool ignore)\n{\n  if ( y_4 >= 10 && (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    ignore_EPIPE = ignore;\n    if ( y_4 < 10 || (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    ignore_EPIPE = ignore;\n  }\n}\n"
        },
        {
            "funcName": "close_stdout",
            "funcStartAddr": "0x402990",
            "funcEndAddr": "0x402b0b",
            "decompiledFuncCode": "void __cdecl close_stdout()\n{\n  int v0; // eax\n  bool v1; // bl\n  int *v2; // rax\n  int *v3; // rbp\n  char *v4; // rbx\n  int v5; // ebp\n  int v6; // eax\n  char *v7; // rax\n\n  if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v0 = close_stream(stdout);\n    if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    close_stream(stdout);\n  }\n  if ( v0 )\n  {\n    v1 = ignore_EPIPE;\n    v2 = __errno_location();\n    v3 = v2;\n    if ( !v1 || *v2 != 32 )\n    {\n      v4 = dcgettext(0LL, \"write error\", 5);\n      v5 = *v3;\n      if ( file_name )\n      {\n        v7 = quotearg_colon(file_name);\n        error(0, v5, \"%s: %s\", v7, v4);\n        _exit(exit_failure);\n      }\n      if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n        goto LABEL_21;\n      while ( 1 )\n      {\n        error(0, v5, \"%s\", v4);\n        if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n          _exit(exit_failure);\nLABEL_21:\n        error(0, v5, \"%s\", v4);\n      }\n    }\n  }\n  while ( 1 )\n  {\n    v6 = close_stream(stderr);\n    if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n      break;\n    close_stream(stderr);\n  }\n  if ( v6 )\n    _exit(exit_failure);\n}\n"
        },
        {
            "funcName": "parse_long_options",
            "funcStartAddr": "0x402b10",
            "funcEndAddr": "0x402c90",
            "decompiledFuncCode": "void parse_long_options(\n        int argc,\n        char **argv,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        void (*usage_func)(int),\n        ...)\n{\n  __int128 v6; // xmm0\n  __int128 v7; // xmm1\n  __int128 v8; // xmm2\n  __int128 v9; // xmm3\n  __int128 v10; // xmm4\n  __int128 v11; // xmm5\n  __int128 v12; // xmm6\n  __int128 v13; // xmm7\n  int i; // r15d\n  char *v16; // r14\n  int v18; // eax\n  char *v19; // rdx\n  char *v20; // rsi\n  char v21[48]; // [rsp+0h] [rbp-F0h] BYREF\n  __int128 v22; // [rsp+30h] [rbp-C0h]\n  __int128 v23; // [rsp+40h] [rbp-B0h]\n  __int128 v24; // [rsp+50h] [rbp-A0h]\n  __int128 v25; // [rsp+60h] [rbp-90h]\n  __int128 v26; // [rsp+70h] [rbp-80h]\n  __int128 v27; // [rsp+80h] [rbp-70h]\n  __int128 v28; // [rsp+90h] [rbp-60h]\n  __int128 v29; // [rsp+A0h] [rbp-50h]\n  char *v30; // [rsp+B8h] [rbp-38h]\n  char *v31; // [rsp+C0h] [rbp-30h]\n  char v32; // [rsp+100h] [rbp+10h] BYREF\n\n  v22 = v6;\n  v23 = v7;\n  v24 = v8;\n  v25 = v9;\n  v26 = v10;\n  v27 = v11;\n  v28 = v12;\n  v29 = v13;\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_6;\n  for ( i = opterr; ; i = 0 )\n  {\n    v16 = &v21[-32];\n    opterr = 0;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_6:\n    opterr = 0;\n  }\n  if ( argc == 2 )\n  {\n    v31 = (char *)command_name;\n    v30 = (char *)package;\n    while ( 1 )\n    {\n      v18 = getopt_long(2, argv, \"+\", long_options, 0LL);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\n      getopt_long(2, argv, \"+\", long_options, 0LL);\n    }\n    if ( v18 == 104 )\n    {\n      usage_func(0);\n    }\n    else\n    {\n      v19 = v30;\n      v20 = v31;\n      if ( v18 == 118 )\n      {\n        *((_QWORD *)v16 + 2) = v21;\n        *((_QWORD *)v16 + 1) = &v32;\n        *((_DWORD *)v16 + 1) = 48;\n        *(_DWORD *)v16 = 48;\n        version_etc_va(stdout, v20, v19, version, (__va_list_tag *)&v21[-32]);\n        exit(0);\n      }\n    }\n  }\n  opterr = i;\n  optind = 0;\n}\n"
        },
        {
            "funcName": "parse_gnu_standard_options_only",
            "funcStartAddr": "0x402c90",
            "funcEndAddr": "0x402e26",
            "decompiledFuncCode": "void parse_gnu_standard_options_only(\n        int argc,\n        char **argv,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        bool scan_all,\n        void (*usage_func)(int),\n        ...)\n{\n  __int128 v7; // xmm0\n  __int128 v8; // xmm1\n  __int128 v9; // xmm2\n  __int128 v10; // xmm3\n  __int128 v11; // xmm4\n  __int128 v12; // xmm5\n  __int128 v13; // xmm6\n  __int128 v14; // xmm7\n  const char *v15; // r14\n  char *v16; // r15\n  int v17; // r12d\n  int v18; // eax\n  char v19[48]; // [rsp+0h] [rbp-F0h] BYREF\n  __int128 v20; // [rsp+30h] [rbp-C0h]\n  __int128 v21; // [rsp+40h] [rbp-B0h]\n  __int128 v22; // [rsp+50h] [rbp-A0h]\n  __int128 v23; // [rsp+60h] [rbp-90h]\n  __int128 v24; // [rsp+70h] [rbp-80h]\n  __int128 v25; // [rsp+80h] [rbp-70h]\n  __int128 v26; // [rsp+90h] [rbp-60h]\n  __int128 v27; // [rsp+A0h] [rbp-50h]\n  const char *versiona; // [rsp+B0h] [rbp-40h]\n  const char *packagea; // [rsp+B8h] [rbp-38h]\n  const char *command_namea; // [rsp+C0h] [rbp-30h]\n  char v31; // [rsp+108h] [rbp+18h] BYREF\n\n  v20 = v7;\n  v21 = v8;\n  v22 = v9;\n  v23 = v10;\n  v24 = v11;\n  v25 = v12;\n  v26 = v13;\n  v27 = v14;\n  versiona = version;\n  packagea = package;\n  command_namea = command_name;\n  v15 = \"+\";\n  if ( scan_all )\n    v15 = \"\";\n  if ( y_5 >= 10 && (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) != 0 )\n    goto LABEL_7;\n  while ( 1 )\n  {\n    v16 = &v19[-32];\n    v17 = opterr;\n    opterr = 1;\n    v18 = getopt_long(argc, argv, v15, long_options, 0LL);\n    if ( y_5 < 10 || (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 )\n      break;\nLABEL_7:\n    opterr = 1;\n    getopt_long(argc, argv, v15, long_options, 0LL);\n  }\n  if ( v18 != -1 )\n  {\n    if ( v18 == 104 )\n    {\n      usage_func(0);\n    }\n    else\n    {\n      if ( v18 == 118 )\n      {\n        *((_QWORD *)v16 + 2) = v19;\n        *((_QWORD *)v16 + 1) = &v31;\n        *((_DWORD *)v16 + 1) = 48;\n        *(_DWORD *)v16 = 48;\n        version_etc_va(stdout, command_namea, packagea, versiona, (__va_list_tag *)&v19[-32]);\n        exit(0);\n      }\n      while ( 1 )\n      {\n        usage_func(exit_failure);\n        if ( y_5 < 10 || (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 )\n          break;\n        usage_func(exit_failure);\n      }\n    }\n  }\n  opterr = v17;\n}\n"
        },
        {
            "funcName": "set_program_name",
            "funcStartAddr": "0x402e30",
            "funcEndAddr": "0x402ef3",
            "decompiledFuncCode": "void __fastcall set_program_name(const char *argv0)\n{\n  const char *v1; // rbx\n  char *v2; // rax\n  const char *v3; // r14\n\n  v1 = argv0;\n  if ( !argv0 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 0x37uLL, 1uLL, stderr);\n    abort();\n  }\n  v2 = strrchr(argv0, 47);\n  v3 = v2 + 1;\n  if ( !v2 )\n    v3 = argv0;\n  if ( v3 - argv0 >= 7 )\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( !strncmp(v3 - 7, \"/.libs/\", 7uLL) )\n    {\n      if ( !strncmp(v3, \"lt-\", 3uLL) )\n      {\n        v3 += 3;\n        _bss_start = (__int64)v3;\n      }\n      v1 = v3;\n    }\n  }\n  program_name = v1;\n  program_invocation_name = (__int64)v1;\n}\n"
        },
        {
            "funcName": "clone_quoting_options",
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f33",
            "decompiledFuncCode": "quoting_options *__fastcall clone_quoting_options(quoting_options *o)\n{\n  quoting_options *v1; // rbx\n  int *v2; // r14\n  int v3; // ebp\n  quoting_options *result; // rax\n\n  v1 = o;\n  v2 = __errno_location();\n  v3 = *v2;\n  if ( !o )\n    v1 = &default_quoting_options;\n  result = (quoting_options *)xmemdup(v1, 0x38uLL);\n  *v2 = v3;\n  return result;\n}\n"
        },
        {
            "funcName": "get_quoting_style",
            "funcStartAddr": "0x402f40",
            "funcEndAddr": "0x402f4f",
            "decompiledFuncCode": "quoting_style __fastcall get_quoting_style(const quoting_options *o)\n{\n  const quoting_options *v1; // rax\n\n  v1 = &default_quoting_options;\n  if ( o )\n    v1 = o;\n  return v1->style;\n}\n"
        },
        {
            "funcName": "set_quoting_style",
            "funcStartAddr": "0x402f50",
            "funcEndAddr": "0x402fa3",
            "decompiledFuncCode": "void __fastcall set_quoting_style(quoting_options *o, quoting_style s)\n{\n  quoting_options *v2; // rax\n  quoting_options *v3; // rax\n\n  if ( y_22 >= 10 && (((_BYTE)x_21 * ((_BYTE)x_21 - 1)) & 1) != 0 )\n    goto LABEL_7;\n  while ( 1 )\n  {\n    v2 = &default_quoting_options;\n    if ( o )\n      v2 = o;\n    v2->style = s;\n    if ( y_22 < 10 || (((_BYTE)x_21 * ((_BYTE)x_21 - 1)) & 1) == 0 )\n      break;\nLABEL_7:\n    v3 = &default_quoting_options;\n    if ( o )\n      v3 = o;\n    v3->style = s;\n  }\n}\n"
        },
        {
            "funcName": "set_char_quoting",
            "funcStartAddr": "0x402fb0",
            "funcEndAddr": "0x402fe6",
            "decompiledFuncCode": "int __fastcall set_char_quoting(quoting_options *o, char c, int i)\n{\n  quoting_options *v4; // rsi\n  __int64 v5; // r8\n  int result; // eax\n\n  v4 = &default_quoting_options;\n  if ( o )\n    v4 = o;\n  v5 = (unsigned __int8)c >> 5;\n  result = (v4->quote_these_too[v5] >> c) & 1;\n  v4->quote_these_too[v5] ^= (((unsigned __int8)i ^ (unsigned __int8)(v4->quote_these_too[v5] >> c)) & 1) << c;\n  return result;\n}\n"
        },
        {
            "funcName": "set_quoting_flags",
            "funcStartAddr": "0x402ff0",
            "funcEndAddr": "0x403003",
            "decompiledFuncCode": "int __fastcall set_quoting_flags(quoting_options *o, int i)\n{\n  quoting_options *v2; // rcx\n  int result; // eax\n\n  v2 = &default_quoting_options;\n  if ( o )\n    v2 = o;\n  result = v2->flags;\n  v2->flags = i;\n  return result;\n}\n"
        },
        {
            "funcName": "set_custom_quoting",
            "funcStartAddr": "0x403010",
            "funcEndAddr": "0x40303b",
            "decompiledFuncCode": "void __fastcall set_custom_quoting(quoting_options *o, const char *left_quote, const char *right_quote)\n{\n  quoting_options *v3; // rax\n\n  v3 = &default_quoting_options;\n  if ( o )\n    v3 = o;\n  v3->style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v3->left_quote = left_quote;\n  v3->right_quote = right_quote;\n}\n"
        },
        {
            "funcName": "quotearg_buffer",
            "funcStartAddr": "0x403040",
            "funcEndAddr": "0x4030b2",
            "decompiledFuncCode": "size_t __fastcall quotearg_buffer(\n        char *buffer,\n        size_t buffersize,\n        const char *arg,\n        size_t argsize,\n        const quoting_options *o)\n{\n  const quoting_options *v7; // rbp\n  int *v8; // rbx\n  size_t result; // rax\n  int v10; // [rsp+0h] [rbp-34h]\n\n  v7 = &default_quoting_options;\n  if ( o )\n    v7 = o;\n  v8 = __errno_location();\n  v10 = *v8;\n  result = quotearg_buffer_restyled(\n             buffer,\n             buffersize,\n             arg,\n             argsize,\n             v7->style,\n             v7->flags,\n             v7->quote_these_too,\n             v7->left_quote,\n             v7->right_quote);\n  *v8 = v10;\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_buffer_restyled",
            "funcStartAddr": "0x4030c0",
            "funcEndAddr": "0x4048f8",
            "decompiledFuncCode": "size_t __fastcall quotearg_buffer_restyled(\n        char *buffer,\n        size_t buffersize,\n        const char *arg,\n        size_t argsize,\n        unsigned int quoting_style,\n        int flags,\n        const unsigned int *quote_these_too,\n        char *left_quote,\n        const char *right_quote)\n{\n  size_t v13; // rdx\n  char v14; // r13\n  int v15; // r10d\n  size_t v16; // rax\n  quoting_style v17; // ecx\n  __int64 v18; // rbx\n  __int64 v19; // rsi\n  char *v20; // rdi\n  size_t v21; // r8\n  size_t v22; // r11\n  char v23; // al\n  const char *v24; // rax\n  int v25; // ebx\n  int v26; // ebx\n  unsigned __int64 v27; // rdx\n  char v28; // al\n  int v29; // r14d\n  size_t v30; // rax\n  __int64 v31; // r14\n  size_t v32; // rbp\n  unsigned __int64 v33; // r9\n  size_t i; // r11\n  char *v35; // rdi\n  int v36; // edx\n  unsigned __int64 v37; // r13\n  const char *v38; // r15\n  int v39; // ecx\n  int v40; // ecx\n  size_t v41; // rax\n  char v42; // al\n  __int64 v43; // r12\n  size_t v44; // rax\n  size_t v45; // r12\n  const char *v46; // rdi\n  size_t v47; // rbx\n  char v48; // r15\n  size_t v49; // rax\n  bool v50; // bl\n  char v51; // cl\n  char v52; // si\n  char v53; // dl\n  const char *v54; // rax\n  size_t v55; // r15\n  char v56; // r12\n  unsigned __int64 v57; // rbx\n  unsigned __int64 v58; // rcx\n  const char *v59; // r13\n  unsigned __int64 v60; // r14\n  bool v61; // al\n  size_t v62; // rax\n  size_t v63; // rcx\n  size_t v64; // rdx\n  bool v65; // zf\n  char v66; // al\n  int v67; // ecx\n  const unsigned __int16 **v68; // rax\n  const unsigned __int16 *v69; // rax\n  unsigned __int64 v70; // rcx\n  int v71; // eax\n  unsigned __int64 v72; // r14\n  unsigned __int64 v73; // rbp\n  const char *v74; // rsi\n  unsigned __int64 v75; // r13\n  size_t v76; // rbx\n  __int64 v77; // rsi\n  __int64 v78; // rcx\n  unsigned __int64 v79; // rdx\n  unsigned __int64 v80; // rdx\n  __int64 v81; // rsi\n  size_t v82; // rax\n  unsigned int v83; // ecx\n  size_t v84; // rax\n  unsigned __int64 v85; // rax\n  int v86; // ecx\n  int v87; // eax\n  quoting_style v88; // ebp\n  int v89; // r13d\n  size_t v90; // r15\n  unsigned __int64 v91; // r12\n  int v92; // edx\n  char v93; // al\n  char *v94; // rcx\n  char v96; // [rsp+Eh] [rbp-FAh]\n  char v97; // [rsp+Fh] [rbp-F9h]\n  int v98; // [rsp+10h] [rbp-F8h]\n  unsigned __int64 v99; // [rsp+10h] [rbp-F8h]\n  int v100; // [rsp+10h] [rbp-F8h]\n  int v101; // [rsp+1Ch] [rbp-ECh]\n  char v102; // [rsp+23h] [rbp-E5h]\n  quoting_style v103; // [rsp+24h] [rbp-E4h]\n  char v104; // [rsp+2Bh] [rbp-DDh]\n  unsigned __int8 v105; // [rsp+2Ch] [rbp-DCh]\n  bool v106; // [rsp+2Dh] [rbp-DBh]\n  char v107; // [rsp+2Eh] [rbp-DAh]\n  unsigned __int8 v108; // [rsp+2Fh] [rbp-D9h]\n  size_t n; // [rsp+30h] [rbp-D8h]\n  const char *s2; // [rsp+38h] [rbp-D0h]\n  size_t v113; // [rsp+50h] [rbp-B8h]\n  __int64 v114; // [rsp+58h] [rbp-B0h]\n  int v115; // [rsp+58h] [rbp-B0h]\n  unsigned __int64 v116; // [rsp+60h] [rbp-A8h]\n  size_t v117; // [rsp+68h] [rbp-A0h]\n  char *v118; // [rsp+70h] [rbp-98h]\n  char *v119; // [rsp+70h] [rbp-98h]\n  int v122; // [rsp+8Ch] [rbp-7Ch]\n  char v123; // [rsp+90h] [rbp-78h]\n  size_t v124; // [rsp+98h] [rbp-70h]\n  bool v125; // [rsp+A0h] [rbp-68h]\n  int v126; // [rsp+A4h] [rbp-64h]\n  int v127; // [rsp+A8h] [rbp-60h]\n  wchar_t pwc; // [rsp+ACh] [rbp-5Ch] BYREF\n  const char *v129; // [rsp+B0h] [rbp-58h]\n  size_t v130; // [rsp+B8h] [rbp-50h]\n  mbstate_t ps; // [rsp+C0h] [rbp-48h] BYREF\n  size_t mb_cur_max; // [rsp+C8h] [rbp-40h]\n  __int64 v133; // [rsp+D0h] [rbp-38h]\n\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v14 = (flags & 2) != 0;\n  v127 = flags & 1;\n  v122 = flags;\n  v126 = flags & 4;\n  LOBYTE(v15) = 1;\n  v117 = 0LL;\n  s2 = 0LL;\n  n = 0LL;\n  v113 = 0LL;\n  v101 = 0;\n  v123 = 0;\nLABEL_2:\n  v16 = quoting_style;\n  v17 = literal_quoting_style;\n  v18 = 0LL;\n  v19 = 0LL;\n  v20 = buffer;\n  v21 = buffersize;\n  v22 = argsize;\n  switch ( quoting_style )\n  {\n    case 0u:\n      goto LABEL_53;\n    case 1u:\n      goto LABEL_10;\n    case 2u:\n      v23 = x_31;\n      if ( y_32 < 10 )\n        goto LABEL_17;\n      goto LABEL_16;\n    case 3u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\nLABEL_10:\n      v14 = 1;\n      goto LABEL_11;\n    case 4u:\nLABEL_11:\n      v23 = x_31;\n      if ( y_32 >= 10 )\n      {\n        v13 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      LOBYTE(v13) = 1;\n      if ( (v14 & 1) != 0 )\n        v13 = v113;\n      v113 = v13;\n      if ( y_32 >= 10 )\n      {\nLABEL_16:\n        if ( ((v23 * (v23 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\nLABEL_17:\n      v17 = shell_always_quoting_style;\n      if ( (v14 & 1) != 0 )\n      {\n        v18 = 0LL;\n        v24 = \"'\";\nLABEL_35:\n        s2 = v24;\n        n = 1LL;\n        LOBYTE(v19) = v14;\n        goto LABEL_53;\n      }\n      if ( !buffersize || (*buffer = 39, y_32 < 10) )\n      {\n        v18 = 1LL;\n        v24 = \"'\";\n        goto LABEL_35;\n      }\n      do\n      {\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n          break;\n        *buffer = 39;\n      }\n      while ( y_32 >= 10 );\n      v18 = 1LL;\n      s2 = \"'\";\n      n = 1LL;\n      LOBYTE(v19) = v14;\n      v17 = shell_always_quoting_style;\n      goto LABEL_53;\n    case 5u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = c_quoting_style;\n      if ( (v14 & 1) != 0 )\n      {\n        v18 = 0LL;\n      }\n      else\n      {\n        if ( buffersize )\n          *buffer = 34;\n        v18 = 1LL;\n      }\n      v24 = \"\\\"\";\n      goto LABEL_35;\n    case 6u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = c_quoting_style;\n      v18 = 0LL;\n      s2 = \"\\\"\";\n      n = 1LL;\n      LOBYTE(v19) = 1;\n      goto LABEL_53;\n    case 7u:\n      v18 = 0LL;\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = escape_quoting_style;\n      v19 = 0LL;\n      if ( y_32 >= 10 )\n      {\n        v17 = escape_quoting_style;\n        v19 = 0LL;\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      goto LABEL_53;\n    case 8u:\n    case 9u:\n      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n        goto LABEL_36;\n      break;\n    case 0xAu:\n      goto LABEL_40;\n    default:\n      abort();\n  }\n  while ( 1 )\n  {\n    v26 = v15;\n    gettext_quote(\"`\", (quoting_style)quoting_style);\n    gettext_quote(\"'\", (quoting_style)quoting_style);\n    v15 = v26;\nLABEL_36:\n    v25 = v15;\n    left_quote = (char *)gettext_quote(\"`\", (quoting_style)quoting_style);\n    v19 = quoting_style;\n    right_quote = gettext_quote(\"'\", (quoting_style)quoting_style);\n    if ( y_32 < 10 )\n      break;\n    v20 = buffer;\n    v21 = buffersize;\n    v15 = v25;\n    if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n      goto LABEL_40;\n  }\n  v20 = buffer;\n  v21 = buffersize;\n  v15 = v25;\nLABEL_40:\n  if ( (v14 & 1) != 0 )\n  {\n    v118 = left_quote;\n    v29 = v15;\n    v18 = 0LL;\n  }\n  else\n  {\n    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      goto LABEL_369;\n    v27 = 0LL;\n    while ( 1 )\n    {\n      v28 = left_quote[v27];\n      if ( !v28 )\n        break;\n      if ( v27 < v21 )\n        v20[v27] = v28;\n      ++v27;\n      if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\nLABEL_369:\n          ;\n      }\n    }\n    v118 = left_quote;\n    v18 = v27;\n    v29 = v15;\n  }\n  v30 = strlen(right_quote);\n  n = v30;\n  LOBYTE(v30) = 1;\n  v113 = v30;\n  s2 = right_quote;\n  LOBYTE(v19) = v14;\n  v21 = buffersize;\n  v22 = argsize;\n  v15 = v29;\n  v17 = quoting_style;\n  left_quote = v118;\nLABEL_53:\n  v119 = left_quote;\n  v31 = (unsigned int)x_31;\n  if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  LODWORD(v32) = v113;\n  v97 = v113 & 1;\n  v108 = v113 & 1 & (v17 != shell_always_quoting_style);\n  v105 = v19 & 1 & (v17 == shell_always_quoting_style);\n  v96 = v19 & 1;\n  v103 = v17;\n  v33 = v22;\n  i = v18;\n  v35 = buffer;\n  v107 = v19 & 1 & (quote_these_too != 0LL);\n  v36 = y_32;\n  v106 = v17 != shell_always_quoting_style || (v19 & 1) == 0;\n  v133 = v19;\n  v104 = (n != 0) & v19 & v113;\n  v37 = 0LL;\n  v38 = arg;\n  while ( 1 )\n  {\n    v100 = v36;\n    if ( v33 == -1LL )\n    {\n      if ( !v38[v37] )\n      {\n        v33 = -1LL;\n        goto LABEL_356;\n      }\n    }\n    else if ( v37 == v33 )\n    {\n      v33 = v37;\nLABEL_356:\n      v13 = (unsigned int)v103;\n      if ( v96 && i == 0 && v103 == shell_always_quoting_style )\n        goto LABEL_394;\n      if ( (v123 & 1) == 0 || v96 != 0 || v103 != shell_always_quoting_style )\n      {\nLABEL_402:\n        v92 = v100;\n        if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( s2 )\n        {\n          if ( !v96 )\n          {\n            v93 = *s2;\n            if ( *s2 )\n            {\n              v94 = (char *)(s2 + 1);\n              do\n              {\n                if ( i < v21 )\n                {\n                  v35[i] = v93;\n                  LOBYTE(v31) = x_31;\n                  v92 = y_32;\n                }\n                if ( v92 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                ++i;\n                v93 = *v94++;\n              }\n              while ( v93 );\n            }\n          }\n        }\n        if ( v92 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( i < v21 )\n        {\n          do\n            v35[i] = 0;\n          while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n        }\n        return i;\n      }\n      if ( (v15 & 1) != 0 )\n        return quotearg_buffer_restyled(v35, v117, v38, v33, c_quoting_style, v122, quote_these_too, v119, right_quote);\n      if ( !v117 || v21 )\n        goto LABEL_402;\n      argsize = v33;\n      quoting_style = v103;\n      v14 = v133;\n      buffersize = v117;\n      left_quote = v119;\n      if ( v100 >= 10 )\n      {\n        quoting_style = v103;\n        v14 = v133;\n        buffersize = v117;\n        if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      goto LABEL_2;\n    }\n    if ( (v108 & (n != 0)) == 0 )\n    {\nLABEL_112:\n      v50 = 0;\n      goto LABEL_113;\n    }\n    v45 = v37 + n;\n    if ( n >= 2 && v33 == -1LL )\n    {\n      v46 = v38;\n      v47 = v21;\n      v48 = v15;\n      v32 = i;\n      v49 = strlen(v46);\n      v36 = v100;\n      i = v32;\n      LOBYTE(v15) = v48;\n      v21 = v47;\n      v38 = arg;\n      v35 = buffer;\n      v33 = v49;\n      if ( v45 > v49 )\n        goto LABEL_112;\n    }\n    else\n    {\n      if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( v45 > v33 )\n        goto LABEL_112;\n    }\n    if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    v114 = v31;\n    v54 = v38;\n    v55 = i;\n    v56 = v15;\n    v57 = v33;\n    v32 = v21;\n    v58 = v37;\n    v59 = v54;\n    v60 = v58;\n    v61 = memcmp(&v54[v58], s2, n) == 0;\n    if ( !v61 )\n    {\n      v35 = buffer;\n      v21 = v32;\n      v33 = v57;\n      LOBYTE(v15) = v56;\n      i = v55;\n      v38 = v59;\n      v37 = v60;\n      v50 = v61;\n      v31 = v114;\n      if ( v100 < 10 )\n        goto LABEL_115;\n      goto LABEL_114;\n    }\n    v40 = 16;\n    v35 = buffer;\n    v21 = v32;\n    v33 = v57;\n    LOBYTE(v15) = v56;\n    i = v55;\n    v38 = v59;\n    v37 = v60;\n    v50 = v61;\n    v31 = v114;\n    v36 = v100;\n    if ( v96 )\n    {\nLABEL_58:\n      LOBYTE(v32) = v15;\n      if ( v36 < 10 )\n        goto LABEL_72;\n      goto LABEL_71;\n    }\nLABEL_113:\n    if ( v36 < 10 )\n      goto LABEL_115;\nLABEL_114:\n    if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\nLABEL_115:\n    v43 = (unsigned __int8)v38[v37];\n    LOBYTE(v32) = 1;\n    v51 = 116;\n    v52 = 98;\n    v53 = 0;\n    v42 = 0;\n    switch ( v38[v37] )\n    {\n      case 0:\n        if ( !v97 )\n        {\n          v40 = 15;\n          v36 = v100;\n          if ( v127 )\n            goto LABEL_58;\n          LOBYTE(v43) = 0;\n          goto LABEL_245;\n        }\n        v40 = 16;\n        v36 = v100;\n        if ( v96 )\n          goto LABEL_58;\n        if ( v103 == shell_always_quoting_style && (v101 & 1) == 0 )\n        {\n          if ( i < v21 )\n          {\n            v35[i] = 39;\n            LOBYTE(v31) = x_31;\n            v36 = y_32;\n          }\n          if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( i + 1 < v21 )\n          {\n            do\n              v35[i + 1] = 36;\n            while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n          }\n          v62 = i + 2;\n          if ( i + 2 < v21 )\n            v35[v62] = 39;\n          i += 3LL;\n          LOBYTE(v62) = 1;\n          v101 = v62;\n        }\n        v63 = i;\n        if ( i < v21 )\n          v35[i] = 92;\n        ++i;\n        v42 = 1;\n        LOBYTE(v43) = 48;\n        if ( v103 == shell_always_quoting_style )\n          goto LABEL_246;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( v37 + 1 >= v33 || (unsigned __int8)(v38[v37 + 1] - 48) > 9u )\n          goto LABEL_246;\n        if ( i < v21 )\n          v35[i] = 48;\n        if ( v63 + 2 < v21 )\n          v35[v63 + 2] = 48;\n        LODWORD(v32) = 0;\n        i = v63 + 3;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      case 7:\n        v52 = 97;\n        goto LABEL_207;\n      case 8:\n        goto LABEL_207;\n      case 9:\n        goto LABEL_206;\n      case 0xA:\n        v51 = 110;\n        goto LABEL_206;\n      case 0xB:\n        v52 = 118;\n        goto LABEL_207;\n      case 0xC:\n        v52 = 102;\n        goto LABEL_207;\n      case 0xD:\n        v51 = 114;\n        goto LABEL_206;\n      case 0x20:\n        goto LABEL_193;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2A:\n      case 0x3B:\n      case 0x3C:\n      case 0x3D:\n      case 0x3E:\n      case 0x5B:\n      case 0x5E:\n      case 0x60:\n      case 0x7C:\n        goto LABEL_194;\n      case 0x23:\n      case 0x7E:\n        if ( !v37 )\n          goto LABEL_193;\n        goto LABEL_245;\n      case 0x25:\n      case 0x2B:\n      case 0x2C:\n      case 0x2D:\n      case 0x2E:\n      case 0x2F:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3A:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4A:\n      case 0x4B:\n      case 0x4C:\n      case 0x4D:\n      case 0x4E:\n      case 0x4F:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5A:\n      case 0x5D:\n      case 0x5F:\n      case 0x61:\n      case 0x62:\n      case 0x63:\n      case 0x64:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6A:\n      case 0x6B:\n      case 0x6C:\n      case 0x6D:\n      case 0x6E:\n      case 0x6F:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7A:\n        goto LABEL_116;\n      case 0x27:\n        LOBYTE(v43) = 39;\n        if ( v103 == shell_always_quoting_style )\n        {\n          if ( v96 )\n          {\n            v40 = 16;\n            v123 = 1;\n            goto LABEL_270;\n          }\n          v64 = v117;\n          v65 = v21 != 0 && v117 == 0;\n          if ( v21 != 0 && v117 == 0 )\n            v64 = v21;\n          v117 = v64;\n          if ( v65 )\n            v21 = 0LL;\n          if ( i < v21 )\n            v35[i] = 39;\n          if ( i + 1 < v21 )\n            v35[i + 1] = 92;\n          v66 = x_31;\n          v67 = y_32;\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( i + 2 < v21 )\n          {\n            do\n            {\n              v35[i + 2] = 39;\n              v66 = x_31;\n              v67 = y_32;\n            }\n            while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n          }\n          if ( v67 >= 10 && ((v66 * (v66 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          i += 3LL;\n          v123 = 1;\n          v101 = 0;\n        }\n        else\n        {\n          v123 = 1;\n        }\n        v42 = 0;\n        LOBYTE(v32) = 1;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      case 0x3F:\n        LOBYTE(v43) = 63;\n        if ( v103 == c_quoting_style )\n        {\n          if ( v126 && v37 + 2 < v33 && v38[v37 + 1] == 63 )\n          {\n            v80 = (unsigned int)v38[v37 + 2];\n            v42 = 0;\n            if ( (unsigned int)v80 <= 0x3E )\n            {\n              v81 = 0x7000A38200000000LL;\n              if ( _bittest64(&v81, v80) )\n              {\n                if ( !v96 )\n                {\n                  if ( i < v21 )\n                  {\n                    do\n                    {\n                      v35[i] = 63;\n                      LOBYTE(v31) = x_31;\n                      v100 = y_32;\n                    }\n                    while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                  }\n                  if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                  {\n                    while ( 1 )\n                      ;\n                  }\n                  if ( i + 1 < v21 )\n                    v35[i + 1] = 34;\n                  v82 = i + 2;\n                  if ( i + 2 < v21 )\n                  {\n                    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n                      goto LABEL_62;\n                    while ( 1 )\n                    {\n                      v35[v82] = 34;\n                      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                        break;\nLABEL_62:\n                      v35[v82] = 34;\n                    }\n                  }\n                  v41 = i + 3;\n                  if ( i + 3 < v21 )\n                  {\n                    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n                      goto LABEL_68;\n                    while ( 1 )\n                    {\n                      v35[v41] = 63;\n                      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                        break;\nLABEL_68:\n                      v35[v41] = 63;\n                    }\n                  }\n                  i += 4LL;\n                  v42 = 0;\n                  v37 += 2LL;\n                  LOBYTE(v43) = v80;\n                  goto LABEL_246;\n                }\n                goto LABEL_267;\n              }\n            }\n          }\n          else\n          {\nLABEL_245:\n            v42 = 0;\n          }\nLABEL_246:\n          LODWORD(v32) = 0;\n          if ( v108 )\n            goto LABEL_117;\n          goto LABEL_247;\n        }\n        if ( v103 != shell_always_quoting_style )\n          goto LABEL_245;\n        v40 = 16;\n        if ( !v96 )\n          goto LABEL_245;\nLABEL_270:\n        LOBYTE(v32) = v15;\n        v36 = v100;\n        if ( v100 >= 10 )\n          break;\n        goto LABEL_72;\n      case 0x5C:\n        if ( v103 == shell_always_quoting_style )\n        {\n          v40 = 16;\n          if ( v96 )\n            goto LABEL_270;\n          LOBYTE(v43) = 92;\n          v42 = 0;\n          goto LABEL_205;\n        }\n        v51 = 92;\n        if ( v104 )\n        {\n          v42 = 0;\n          LOBYTE(v43) = 92;\nLABEL_205:\n          LODWORD(v32) = 0;\n          goto LABEL_345;\n        }\nLABEL_206:\n        v52 = v51;\n        if ( !v106 )\n        {\nLABEL_267:\n          LOBYTE(v32) = v15;\n          v36 = v100;\n          v40 = 16;\n          if ( v100 >= 10 )\n            break;\n          goto LABEL_72;\n        }\nLABEL_207:\n        v42 = 0;\n        LODWORD(v32) = 0;\n        if ( v97 )\n          goto LABEL_253;\nLABEL_116:\n        if ( !v108 )\n          goto LABEL_247;\nLABEL_117:\n        if ( !quote_these_too )\n          goto LABEL_250;\nLABEL_248:\n        v83 = quote_these_too[(unsigned __int8)v43 >> 5];\n        if ( _bittest((const int *)&v83, (unsigned __int8)v43) )\n        {\n          v52 = v43;\nLABEL_253:\n          v31 = (unsigned int)x_31;\n          v40 = 16;\n          v36 = y_32;\n          if ( v96 )\n            goto LABEL_58;\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( v103 == shell_always_quoting_style )\n          {\n            v39 = v101;\n            if ( (v101 & 1) == 0 )\n            {\n              if ( i < v21 )\n              {\n                do\n                {\n                  v35[i] = 39;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                }\n                while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n              }\n              v84 = i + 1;\n              if ( i + 1 < v21 )\n              {\n                if ( v36 >= 10 )\n                {\n                  v39 = ((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1;\n                  if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                    goto LABEL_77;\n                }\n                while ( 1 )\n                {\n                  v35[v84] = 36;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                  if ( y_32 < 10 )\n                    break;\n                  v39 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                    break;\nLABEL_77:\n                  v35[v84] = 36;\n                }\n              }\n              v44 = i + 2;\n              if ( i + 2 < v21 )\n              {\n                if ( v36 >= 10 )\n                {\n                  v39 = ((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1;\n                  if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                    goto LABEL_83;\n                }\n                while ( 1 )\n                {\n                  v35[v44] = 39;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                  if ( y_32 < 10 )\n                    break;\n                  v39 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                    break;\nLABEL_83:\n                  v35[v44] = 39;\n                }\n              }\n              i += 3LL;\n              LOBYTE(v39) = 1;\n            }\n            if ( v36 >= 10 )\n            {\nLABEL_86:\n              if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n            }\n          }\n          else\n          {\n            v39 = v101;\n            if ( y_32 >= 10 )\n              goto LABEL_86;\n          }\n          if ( i < v21 )\n            v35[i] = 92;\n          ++i;\n          LOBYTE(v43) = v52;\n          goto LABEL_90;\n        }\nLABEL_250:\n        LOBYTE(v31) = x_31;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        v100 = y_32;\n        v52 = v43;\n        if ( v50 )\n          goto LABEL_253;\nLABEL_345:\n        v39 = v101;\n        if ( (v101 & 1) != 0 )\n        {\n          v65 = (v42 & 1) == 0;\n          v87 = v100;\n          if ( v65 )\n          {\n            if ( i < v21 )\n            {\n              v35[i] = 39;\n              LOBYTE(v31) = x_31;\n              v87 = y_32;\n            }\n            if ( v87 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            if ( i + 1 < v21 )\n            {\n              do\n                v35[i + 1] = 39;\n              while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n            }\n            i += 2LL;\n            v39 = 0;\n          }\n        }\nLABEL_90:\n        v31 = (unsigned int)x_31;\n        v36 = y_32;\n        if ( i >= v21 )\n          goto LABEL_96;\n        if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n          goto LABEL_93;\n        do\n        {\n          v35[i] = v43;\nLABEL_93:\n          v35[i] = v43;\n          v31 = (unsigned int)x_31;\n          v36 = y_32;\n        }\n        while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\nLABEL_96:\n        v101 = v39;\n        ++i;\n        LOBYTE(v32) = v15 & -(char)v32;\n        v40 = 0;\n        if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( v36 < 10 )\n          goto LABEL_72;\n        break;\n      case 0x7B:\n      case 0x7D:\n        v42 = 0;\n        if ( v33 == -1LL )\n        {\n          if ( v37 || v38[1] )\n          {\n            v33 = -1LL;\n            goto LABEL_246;\n          }\n        }\n        else if ( v37 || v33 != 1 )\n        {\n          goto LABEL_246;\n        }\nLABEL_193:\n        v53 = 1;\nLABEL_194:\n        if ( v103 == shell_always_quoting_style )\n        {\n          v40 = 16;\n          if ( v96 )\n            goto LABEL_270;\n        }\n        v42 = 0;\n        LOBYTE(v32) = v53;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      default:\n        v124 = i;\n        v102 = v15;\n        v130 = v21;\n        if ( mb_cur_max == 1 )\n        {\n          v32 = v33;\n          v68 = __ctype_b_loc();\n          v33 = v32;\n          v69 = *v68;\n          LODWORD(v32) = v69[v43] >> 14;\n          LOBYTE(v32) = (v69[v43] & 0x4000) != 0;\n          v70 = 1LL;\n          v36 = v100;\n          goto LABEL_287;\n        }\n        v125 = v50;\n        ps = 0LL;\n        if ( v33 == -1LL )\n          v33 = strlen(v38);\n        v71 = (_DWORD)v38 + v37;\n        v129 = &v38[v37];\n        LOBYTE(v71) = 1;\n        v70 = 0LL;\n        v116 = v37;\n        while ( 2 )\n        {\n          v98 = v71;\n          v72 = v70;\n          v73 = v70 + v37;\n          v74 = &v38[v70 + v37];\n          v75 = v33;\n          v76 = rpl_mbrtowc(&pwc, v74, v33 - v73, &ps);\n          if ( !v76 )\n          {\n            v38 = arg;\n            v33 = v75;\n            v37 = v116;\n            v70 = v72;\n            LODWORD(v32) = v98;\nLABEL_281:\n            v115 = 0;\n            goto LABEL_282;\n          }\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( v76 == -1LL )\n          {\n            LODWORD(v32) = 0;\n            v38 = arg;\n            v33 = v75;\nLABEL_280:\n            v37 = v116;\n            v70 = v72;\n            goto LABEL_281;\n          }\n          v33 = v75;\n          if ( v76 == -2LL )\n          {\n            if ( v75 > v73 )\n            {\n              v38 = arg;\n              v37 = v116;\n              v70 = v72;\n              do\n              {\n                if ( !v129[v70] )\n                  break;\n                v85 = v116 + v70++ + 1;\n              }\n              while ( v85 < v33 );\n              LODWORD(v32) = 0;\n              goto LABEL_281;\n            }\n            LODWORD(v32) = 0;\n            v38 = arg;\n            goto LABEL_280;\n          }\n          v77 = 0x20000002BLL;\n          if ( (v105 & (v76 > 1)) != 1 )\n          {\nLABEL_222:\n            v115 = 0;\n            LODWORD(v32) = 0;\n            if ( iswprint(pwc) )\n              LODWORD(v32) = v98;\n            v71 = mbsinit(&ps);\n            v70 = v76 + v72;\n            v65 = v71 == 0;\n            LOBYTE(v71) = v32;\n            v38 = arg;\n            v33 = v75;\n            v37 = v116;\n            if ( !v65 )\n              goto LABEL_282;\n            continue;\n          }\n          break;\n        }\n        v78 = 1LL;\n        while ( 1 )\n        {\n          v79 = (unsigned int)(v129[v72 + v78] - 91);\n          if ( (unsigned int)v79 <= 0x21 )\n          {\n            if ( _bittest64(&v77, v79) )\n              break;\n          }\n          if ( ++v78 >= v76 )\n            goto LABEL_222;\n        }\n        v115 = 16;\n        LODWORD(v32) = v98;\n        v38 = arg;\n        v37 = v116;\n        v70 = v72;\nLABEL_282:\n        v31 = (unsigned int)x_31;\n        v36 = y_32;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        v50 = v125;\n        if ( v115 )\n        {\n          LOBYTE(v32) = v102;\n          v35 = buffer;\n          v21 = v130;\n          i = v124;\n          v40 = v115;\n          if ( y_32 >= 10 )\n            break;\n          goto LABEL_72;\n        }\nLABEL_287:\n        LOBYTE(v15) = v102;\n        if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        LOBYTE(v32) = v32 & 1;\n        v21 = v130;\n        if ( v70 > 1 || !(((v113 & 1) == 0) | (unsigned __int8)v32) )\n        {\n          v99 = v37 + v70;\n          v42 = 0;\n          v35 = buffer;\n          for ( i = v124; ; ++i )\n          {\n            v86 = v101;\n            if ( !v97 )\n              goto LABEL_430;\n            if ( v36 >= 10 )\n            {\n              v86 = v101;\n              if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n            }\n            if ( !(_BYTE)v32 )\n            {\n              if ( v96 )\n              {\n                v40 = 16;\n                goto LABEL_58;\n              }\n              if ( v103 == shell_always_quoting_style && (v86 & 1) == 0 )\n              {\n                if ( i < v21 )\n                {\n                  do\n                  {\n                    buffer[i] = 39;\n                    LOBYTE(v31) = x_31;\n                    v36 = y_32;\n                  }\n                  while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                }\n                if ( i + 1 < v21 )\n                {\n                  buffer[i + 1] = 36;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                }\n                if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                if ( i + 2 < v21 )\n                {\n                  do\n                  {\n                    buffer[i + 2] = 39;\n                    LOBYTE(v31) = x_31;\n                    v36 = y_32;\n                    if ( y_32 < 10 )\n                      break;\n                    v86 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  }\n                  while ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                }\n                if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                i += 3LL;\n                LOBYTE(v86) = 1;\n              }\n              if ( i < v21 )\n              {\n                buffer[i] = 92;\n                LOBYTE(v31) = x_31;\n                v36 = y_32;\n              }\n              if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n              v101 = v86;\n              if ( i + 1 < v21 )\n              {\n                do\n                  buffer[i + 1] = ((unsigned __int8)v43 >> 6) | 0x30;\n                while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n              }\n              if ( i + 2 < v21 )\n                buffer[i + 2] = ((unsigned __int8)v43 >> 3) & 7 | 0x30;\n              i += 3LL;\n              LOBYTE(v43) = v43 & 7 | 0x30;\n              v42 = 1;\n            }\n            else\n            {\nLABEL_430:\n              if ( v50 )\n              {\n                if ( i < v21 )\n                  buffer[i] = 92;\n                ++i;\n                v50 = 0;\n              }\n            }\n            LOBYTE(v31) = x_31;\n            if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            if ( v99 <= v37 + 1 )\n              break;\n            if ( (v101 & 1) != 0 && (v42 & 1) == 0 )\n            {\n              if ( i < v21 )\n                buffer[i] = 39;\n              if ( i + 1 < v21 )\n                buffer[i + 1] = 39;\n              i += 2LL;\n              v101 = 0;\n            }\n            if ( i < v21 )\n              buffer[i] = v43;\n            v31 = (unsigned int)x_31;\n            v36 = y_32;\n            if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            LOBYTE(v43) = v38[++v37];\n          }\n          v100 = y_32;\n          goto LABEL_345;\n        }\n        v42 = 0;\n        v35 = buffer;\n        i = v124;\n        if ( v108 )\n          goto LABEL_117;\nLABEL_247:\n        if ( v107 )\n          goto LABEL_248;\n        goto LABEL_250;\n    }\nLABEL_71:\n    if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\nLABEL_72:\n    if ( v40 && v40 != 15 )\n      break;\n    ++v37;\n    v15 = v32;\n  }\n  v100 = v36;\n  LODWORD(v13) = v103;\nLABEL_394:\n  v88 = shell_escape_always_quoting_style;\n  if ( !v97 )\n    v88 = (int)v13;\n  if ( (_DWORD)v13 != 2 )\n    v88 = (int)v13;\n  v89 = v122 & 0xFFFFFFFD;\n  v90 = v21;\n  v91 = v33;\n  if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    goto LABEL_426;\n  while ( 1 )\n  {\n    i = quotearg_buffer_restyled(v35, v21, arg, v33, v88, v89, 0LL, v119, right_quote);\n    if ( y_32 < 10 )\n      break;\n    v35 = buffer;\n    v21 = v90;\n    v33 = v91;\n    if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n      break;\nLABEL_426:\n    quotearg_buffer_restyled(v35, v21, arg, v33, v88, v89, 0LL, v119, right_quote);\n    v33 = v91;\n    v21 = v90;\n    v35 = buffer;\n  }\n  return i;\n}\n"
        },
        {
            "funcName": "quotearg_alloc",
            "funcStartAddr": "0x404900",
            "funcEndAddr": "0x4049c1",
            "decompiledFuncCode": "char *__fastcall quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o)\n{\n  const quoting_options *v3; // r14\n  int v4; // ebp\n  size_t v5; // rbx\n  char *v6; // r13\n  int v8; // [rsp+4h] [rbp-44h]\n  int *v9; // [rsp+10h] [rbp-38h]\n\n  v3 = &default_quoting_options;\n  if ( o )\n    v3 = o;\n  v9 = __errno_location();\n  v8 = *v9;\n  v4 = v3->flags | 1;\n  v5 = quotearg_buffer_restyled(\n         0LL,\n         0LL,\n         arg,\n         argsize,\n         v3->style,\n         v4,\n         v3->quote_these_too,\n         (char *)v3->left_quote,\n         v3->right_quote)\n     + 1;\n  v6 = (char *)xmalloc(v5);\n  quotearg_buffer_restyled(\n    v6,\n    v5,\n    arg,\n    argsize,\n    v3->style,\n    v4,\n    v3->quote_these_too,\n    (char *)v3->left_quote,\n    v3->right_quote);\n  *v9 = v8;\n  return v6;\n}\n"
        },
        {
            "funcName": "quotearg_alloc_mem",
            "funcStartAddr": "0x4049d0",
            "funcEndAddr": "0x404abc",
            "decompiledFuncCode": "char *__fastcall quotearg_alloc_mem(const char *arg, size_t argsize, size_t *size, const quoting_options *o)\n{\n  const quoting_options *v5; // r12\n  int v6; // ebp\n  size_t v7; // rbx\n  char *v8; // r14\n  int v10; // [rsp+4h] [rbp-54h]\n  int *v12; // [rsp+20h] [rbp-38h]\n\n  v5 = &default_quoting_options;\n  if ( o )\n    v5 = o;\n  v12 = __errno_location();\n  v10 = *v12;\n  v6 = v5->flags | (size == 0LL);\n  v7 = quotearg_buffer_restyled(\n         0LL,\n         0LL,\n         arg,\n         argsize,\n         v5->style,\n         v6,\n         v5->quote_these_too,\n         (char *)v5->left_quote,\n         v5->right_quote);\n  v8 = (char *)xmalloc(v7 + 1);\n  quotearg_buffer_restyled(\n    v8,\n    v7 + 1,\n    arg,\n    argsize,\n    v5->style,\n    v6,\n    v5->quote_these_too,\n    (char *)v5->left_quote,\n    v5->right_quote);\n  *v12 = v10;\n  if ( size )\n    *size = v7;\n  return v8;\n}\n"
        },
        {
            "funcName": "quotearg_free",
            "funcStartAddr": "0x404ac0",
            "funcEndAddr": "0x404c12",
            "decompiledFuncCode": "void __cdecl quotearg_free()\n{\n  slotvec *v0; // r14\n  char v1; // al\n  int v2; // ecx\n  void **p_val; // rbx\n  __int64 i; // r15\n  char *val; // rdi\n  char v6; // al\n  int v7; // ecx\n\n  v0 = slotvec_0;\n  if ( nslots >= 2 )\n  {\n    v1 = x_37;\n    v2 = y_38;\n    p_val = (void **)&slotvec_0[1].val;\n    for ( i = 1LL; i < nslots; ++i )\n    {\n      if ( v2 >= 10 && ((v1 * (v1 - 1)) & 1) != 0 )\nLABEL_7:\n        free(*p_val);\n      free(*p_val);\n      v1 = x_37;\n      v2 = y_38;\n      if ( y_38 >= 10 && (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) != 0 )\n        goto LABEL_7;\n      p_val += 2;\n    }\n  }\n  val = v0->val;\n  if ( val != slot0 )\n  {\n    free(val);\n    slotvec0.size = 256LL;\n    slotvec0.val = slot0;\n  }\n  v6 = x_37;\n  v7 = y_38;\n  if ( v0 != &slotvec0 )\n  {\n    if ( y_38 >= 10 && (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) != 0 )\n      goto LABEL_16;\n    while ( 1 )\n    {\n      free(v0);\n      slotvec_0 = &slotvec0;\n      v6 = x_37;\n      v7 = y_38;\n      if ( y_38 < 10 || (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) == 0 )\n        break;\nLABEL_16:\n      free(v0);\n      slotvec_0 = &slotvec0;\n    }\n  }\n  if ( v7 >= 10 && ((v6 * (v6 - 1)) & 1) != 0 )\n    goto LABEL_21;\n  while ( 1 )\n  {\n    nslots = 1;\n    if ( v7 < 10 || ((v6 * (v6 - 1)) & 1) == 0 )\n      break;\nLABEL_21:\n    nslots = 1;\n  }\n}\n"
        },
        {
            "funcName": "quotearg_n",
            "funcStartAddr": "0x404c20",
            "funcEndAddr": "0x404c2e",
            "decompiledFuncCode": "char *__fastcall quotearg_n(int n, const char *arg)\n{\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_n_options",
            "funcStartAddr": "0x404c30",
            "funcEndAddr": "0x404e62",
            "decompiledFuncCode": "char *__fastcall quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options)\n{\n  const char *v6; // rbx\n  int *v8; // rax\n  slotvec *v9; // r15\n  slotvec *v10; // rdi\n  slotvec *v11; // rax\n  slotvec *v12; // r14\n  __int64 v13; // r13\n  size_t size; // r14\n  size_t v15; // r12\n  int *v16; // rax\n  int v17; // ecx\n  char *v18; // rbx\n  slotvec *v19; // rax\n  size_t v20; // r12\n  int v22; // [rsp+0h] [rbp-68h]\n  int v23; // [rsp+4h] [rbp-64h]\n  char *ptr; // [rsp+8h] [rbp-60h]\n  size_t v25; // [rsp+18h] [rbp-50h]\n  int *v26; // [rsp+20h] [rbp-48h]\n\n  v6 = arg;\n  if ( y_42 >= 10 && (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v8 = __errno_location();\n  if ( n < 0 )\n    abort();\n  v9 = slotvec_0;\n  v25 = argsize;\n  v26 = v8;\n  v22 = *v8;\n  if ( nslots <= n )\n  {\n    if ( n == 0x7FFFFFFF )\n      xalloc_die();\n    v10 = 0LL;\n    if ( slotvec_0 != &slotvec0 )\n      v10 = slotvec_0;\n    v11 = (slotvec *)xrealloc(v10, 16LL * n + 16);\n    v12 = v11;\n    slotvec_0 = v11;\n    if ( v9 == &slotvec0 )\n      *v11 = slotvec0;\n    memset(&v11[nslots], 0, 16 * (n + 1 - (__int64)nslots));\n    nslots = n + 1;\n    v9 = v12;\n    v6 = arg;\n  }\n  v13 = n;\n  size = v9[v13].size;\n  ptr = v9[v13].val;\n  v23 = options->flags | 1;\n  v15 = quotearg_buffer_restyled(\n          ptr,\n          size,\n          v6,\n          argsize,\n          options->style,\n          v23,\n          options->quote_these_too,\n          (char *)options->left_quote,\n          options->right_quote);\n  if ( size <= v15 )\n  {\n    v19 = &v9[v13];\n    v20 = v15 + 1;\n    if ( y_42 >= 10 && (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) != 0 )\n      goto LABEL_21;\n    while ( 1 )\n    {\n      v19->size = v20;\n      if ( y_42 < 10 || (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) == 0 )\n        break;\nLABEL_21:\n      v19->size = v20;\n    }\n    if ( ptr != slot0 )\n      free(ptr);\n    v18 = (char *)xmalloc(v20);\n    v9[v13].val = v18;\n    quotearg_buffer_restyled(\n      v18,\n      v20,\n      arg,\n      v25,\n      options->style,\n      v23,\n      options->quote_these_too,\n      (char *)options->left_quote,\n      options->right_quote);\n    v16 = v26;\n    v17 = v22;\n  }\n  else\n  {\n    v16 = v26;\n    v17 = v22;\n    v18 = ptr;\n  }\n  *v16 = v17;\n  return v18;\n}\n"
        },
        {
            "funcName": "quotearg_n_mem",
            "funcStartAddr": "0x404e70",
            "funcEndAddr": "0x404e7a",
            "decompiledFuncCode": "char *__fastcall quotearg_n_mem(int n, const char *arg, size_t argsize)\n{\n  return quotearg_n_options(n, arg, argsize, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg",
            "funcStartAddr": "0x404e80",
            "funcEndAddr": "0x404e99",
            "decompiledFuncCode": "char *__fastcall quotearg(const char *arg)\n{\n  return quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_mem",
            "funcStartAddr": "0x404ea0",
            "funcEndAddr": "0x404eb8",
            "decompiledFuncCode": "char *__fastcall quotearg_mem(const char *arg, size_t argsize)\n{\n  return quotearg_n_options(0, arg, argsize, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_n_style",
            "funcStartAddr": "0x404ec0",
            "funcEndAddr": "0x404fd5",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style(int n, quoting_style s, const char *arg)\n{\n  __int128 *v4; // rcx\n  __int128 v5; // xmm0\n  __int128 v6; // xmm1\n  char *result; // rax\n  __int128 *v8; // rcx\n  __int128 v9; // xmm0\n  __int128 v10; // xmm1\n  __int128 v11; // [rsp+0h] [rbp-50h] BYREF\n  __int128 v12; // [rsp+10h] [rbp-40h]\n  __int128 v13; // [rsp+20h] [rbp-30h]\n  int v14; // [rsp+30h] [rbp-20h]\n\n  if ( y_50 >= 10 && (((_BYTE)x_49 * ((_BYTE)x_49 - 1)) & 1) != 0 )\n    goto LABEL_6;\n  while ( 1 )\n  {\n    v4 = &v11 - 4;\n    v13 = 0LL;\n    v12 = 0LL;\n    v11 = 0LL;\n    v14 = 0;\n    if ( s == custom_quoting_style )\n      abort();\n    *(_DWORD *)v4 = s;\n    *((_DWORD *)v4 + 13) = v14;\n    v5 = v11;\n    v6 = v12;\n    *(__int128 *)((char *)v4 + 36) = v13;\n    *(__int128 *)((char *)v4 + 20) = v6;\n    *(__int128 *)((char *)v4 + 4) = v5;\n    result = quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, (const quoting_options *)v4);\n    if ( y_50 < 10 || (((_BYTE)x_49 * ((_BYTE)x_49 - 1)) & 1) == 0 )\n      break;\nLABEL_6:\n    v8 = &v11 - 4;\n    v13 = 0LL;\n    v12 = 0LL;\n    v11 = 0LL;\n    v14 = 0;\n    if ( s == custom_quoting_style )\n      abort();\n    *(_DWORD *)v8 = s;\n    *((_DWORD *)v8 + 13) = v14;\n    v9 = v11;\n    v10 = v12;\n    *(__int128 *)((char *)v8 + 36) = v13;\n    *(__int128 *)((char *)v8 + 20) = v10;\n    *(__int128 *)((char *)v8 + 4) = v9;\n    quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, (const quoting_options *)v8);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_n_style_mem",
            "funcStartAddr": "0x404fe0",
            "funcEndAddr": "0x405048",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize)\n{\n  quoting_options options; // [rsp+40h] [rbp-38h] BYREF\n\n  if ( s == custom_quoting_style )\n    abort();\n  options.style = s;\n  memset(&options.flags, 0, 52);\n  return quotearg_n_options(n, arg, argsize, &options);\n}\n"
        },
        {
            "funcName": "quotearg_style",
            "funcStartAddr": "0x405050",
            "funcEndAddr": "0x405061",
            "decompiledFuncCode": "char *__fastcall quotearg_style(quoting_style s, const char *arg)\n{\n  return quotearg_n_style(0, s, arg);\n}\n"
        },
        {
            "funcName": "quotearg_style_mem",
            "funcStartAddr": "0x405070",
            "funcEndAddr": "0x4050d1",
            "decompiledFuncCode": "char *__fastcall quotearg_style_mem(quoting_style s, const char *arg, size_t argsize)\n{\n  quoting_options options; // [rsp+40h] [rbp-38h] BYREF\n\n  if ( s == custom_quoting_style )\n    abort();\n  options.style = s;\n  memset(&options.flags, 0, 52);\n  return quotearg_n_options(0, arg, argsize, &options);\n}\n"
        },
        {
            "funcName": "quotearg_char_mem",
            "funcStartAddr": "0x4050e0",
            "funcEndAddr": "0x405203",
            "decompiledFuncCode": "char *__fastcall quotearg_char_mem(const char *arg, size_t argsize, unsigned __int8 ch_0)\n{\n  char v3; // bl\n  __int64 v4; // r12\n  char *result; // rax\n  _DWORD v6[8]; // [rsp+0h] [rbp-20h] BYREF\n\n  v3 = ch_0 & 0x1F;\n  v4 = ch_0 >> 5;\n  if ( y_60 >= 10 && (((_BYTE)x_59 * ((_BYTE)x_59 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    *(quoting_options *)&v6[-16] = default_quoting_options;\n    v6[v4 - 14] ^= (((v6[v4 - 14] >> v3) & 1) == 0) << v3;\n    result = quotearg_n_options(0, arg, argsize, (const quoting_options *)&v6[-16]);\n    if ( y_60 < 10 || (((_BYTE)x_59 * ((_BYTE)x_59 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    *(quoting_options *)&v6[-16] = default_quoting_options;\n    v6[v4 - 14] ^= (((v6[v4 - 14] >> v3) & 1) == 0) << v3;\n    quotearg_n_options(0, arg, argsize, (const quoting_options *)&v6[-16]);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_char",
            "funcStartAddr": "0x405210",
            "funcEndAddr": "0x405220",
            "decompiledFuncCode": "char *__fastcall quotearg_char(const char *arg, char ch_0)\n{\n  return quotearg_char_mem(arg, 0xFFFFFFFFFFFFFFFFLL, ch_0);\n}\n"
        },
        {
            "funcName": "quotearg_colon",
            "funcStartAddr": "0x405220",
            "funcEndAddr": "0x405231",
            "decompiledFuncCode": "char *__fastcall quotearg_colon(const char *arg)\n{\n  return quotearg_char_mem(arg, 0xFFFFFFFFFFFFFFFFLL, 0x3Au);\n}\n"
        },
        {
            "funcName": "quotearg_colon_mem",
            "funcStartAddr": "0x405240",
            "funcEndAddr": "0x4052a8",
            "decompiledFuncCode": "char *__fastcall quotearg_colon_mem(const char *arg, size_t argsize)\n{\n  char *result; // rax\n\n  if ( y_66 >= 10 && (((_BYTE)x_65 * ((_BYTE)x_65 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_char_mem(arg, argsize, 0x3Au);\n    if ( y_66 < 10 || (((_BYTE)x_65 * ((_BYTE)x_65 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_char_mem(arg, argsize, 0x3Au);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_n_style_colon",
            "funcStartAddr": "0x4052b0",
            "funcEndAddr": "0x405344",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style_colon(int n, quoting_style s, const char *arg)\n{\n  quoting_options v4; // [rsp+0h] [rbp-78h] BYREF\n  __int128 v5; // [rsp+40h] [rbp-38h]\n  __int128 v6; // [rsp+50h] [rbp-28h]\n  __int128 v7; // [rsp+60h] [rbp-18h]\n  int right_quote; // [rsp+70h] [rbp-8h]\n\n  memset(&v4, 0, 52);\n  if ( s == custom_quoting_style )\n    abort();\n  right_quote = (int)v4.right_quote;\n  v7 = *(_OWORD *)&v4.quote_these_too[6];\n  v6 = *(_OWORD *)&v4.quote_these_too[2];\n  v5 = *(_OWORD *)&v4.style;\n  v4.style = s;\n  HIDWORD(v4.right_quote) = v4.right_quote;\n  *(_OWORD *)&v4.quote_these_too[7] = *(_OWORD *)&v4.quote_these_too[6];\n  *(_OWORD *)&v4.quote_these_too[3] = *(_OWORD *)&v4.quote_these_too[2];\n  *(_OWORD *)&v4.flags = v5;\n  HIBYTE(v4.quote_these_too[1]) = BYTE11(v5) | 4;\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &v4);\n}\n"
        },
        {
            "funcName": "quotearg_n_custom",
            "funcStartAddr": "0x405350",
            "funcEndAddr": "0x4053bd",
            "decompiledFuncCode": "char *__fastcall quotearg_n_custom(int n, const char *left_quote, const char *right_quote, const char *arg)\n{\n  quoting_options v5; // [rsp+0h] [rbp-38h] BYREF\n\n  v5 = default_quoting_options;\n  v5.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v5.left_quote = left_quote;\n  v5.right_quote = right_quote;\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &v5);\n}\n"
        },
        {
            "funcName": "quotearg_n_custom_mem",
            "funcStartAddr": "0x4053c0",
            "funcEndAddr": "0x405429",
            "decompiledFuncCode": "char *__fastcall quotearg_n_custom_mem(\n        int n,\n        const char *left_quote,\n        const char *right_quote,\n        const char *arg,\n        size_t argsize)\n{\n  quoting_options v6; // [rsp+0h] [rbp-38h] BYREF\n\n  v6 = default_quoting_options;\n  v6.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v6.left_quote = left_quote;\n  v6.right_quote = right_quote;\n  return quotearg_n_options(n, arg, argsize, &v6);\n}\n"
        },
        {
            "funcName": "quotearg_custom",
            "funcStartAddr": "0x405430",
            "funcEndAddr": "0x40549f",
            "decompiledFuncCode": "char *__fastcall quotearg_custom(const char *left_quote, const char *right_quote, const char *arg)\n{\n  quoting_options v4; // [rsp+0h] [rbp-38h] BYREF\n\n  v4 = default_quoting_options;\n  v4.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v4.left_quote = left_quote;\n  v4.right_quote = right_quote;\n  return quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &v4);\n}\n"
        },
        {
            "funcName": "quotearg_custom_mem",
            "funcStartAddr": "0x4054a0",
            "funcEndAddr": "0x40550b",
            "decompiledFuncCode": "char *__fastcall quotearg_custom_mem(const char *left_quote, const char *right_quote, const char *arg, size_t argsize)\n{\n  quoting_options v5; // [rsp+0h] [rbp-38h] BYREF\n\n  v5 = default_quoting_options;\n  v5.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v5.left_quote = left_quote;\n  v5.right_quote = right_quote;\n  return quotearg_n_options(0, arg, argsize, &v5);\n}\n"
        },
        {
            "funcName": "quote_n_mem",
            "funcStartAddr": "0x405510",
            "funcEndAddr": "0x40557b",
            "decompiledFuncCode": "const char *__fastcall quote_n_mem(int n, const char *arg, size_t argsize)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(n, arg, argsize, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(n, arg, argsize, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote_mem",
            "funcStartAddr": "0x405580",
            "funcEndAddr": "0x4055ec",
            "decompiledFuncCode": "const char *__fastcall quote_mem(const char *arg, size_t argsize)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(0, arg, argsize, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(0, arg, argsize, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote_n",
            "funcStartAddr": "0x4055f0",
            "funcEndAddr": "0x405661",
            "decompiledFuncCode": "const char *__fastcall quote_n(int n, const char *arg)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote",
            "funcStartAddr": "0x405670",
            "funcEndAddr": "0x4056d8",
            "decompiledFuncCode": "const char *__fastcall quote(const char *arg)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "gettext_quote",
            "funcStartAddr": "0x4056e0",
            "funcEndAddr": "0x4057e6",
            "decompiledFuncCode": "const char *__fastcall gettext_quote(const char *msgid, quoting_style s)\n{\n  const char *result; // rax\n  const char *v3; // rbp\n  bool v4; // zf\n  const char *v5; // rcx\n  char v6; // [rsp+0h] [rbp-18h]\n  char v7; // [rsp+0h] [rbp-18h]\n  char v8; // [rsp+8h] [rbp-10h]\n  char v9; // [rsp+8h] [rbp-10h]\n  char v10; // [rsp+10h] [rbp-8h]\n  char v11; // [rsp+10h] [rbp-8h]\n\n  result = dcgettext(0LL, msgid, 5);\n  if ( result == msgid )\n  {\n    v3 = locale_charset();\n    if ( strcaseeq0(v3, (const char *)0x55, 84, 70, 45, 56, 0, 0, v6, v8, v10) )\n    {\n      v4 = *msgid == 96;\n      v5 = (const char *)&unk_40894C;\n      result = (const char *)&unk_408950;\n    }\n    else\n    {\n      if ( y_86 >= 10 && (((_BYTE)x_85 * ((_BYTE)x_85 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( strcaseeq0(v3, (const char *)0x47, 66, 49, 56, 48, 51, 48, v7, v9, v11) )\n      {\n        v4 = *msgid == 96;\n        v5 = (const char *)&unk_408954;\n        result = (const char *)&unk_408958;\n      }\n      else\n      {\n        v4 = s == clocale_quoting_style;\n        v5 = \"\\\"\";\n        result = \"'\";\n      }\n    }\n    if ( v4 )\n      result = v5;\n  }\n  if ( y_86 >= 10 && (((_BYTE)x_85 * ((_BYTE)x_85 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "strcaseeq0",
            "funcStartAddr": "0x4057f0",
            "funcEndAddr": "0x405cf2",
            "decompiledFuncCode": "__int64 __fastcall strcaseeq0(\n        const char *s1,\n        const char *s2,\n        char s20,\n        unsigned __int8 s21,\n        unsigned __int8 s22,\n        unsigned __int8 s23,\n        unsigned __int8 s24,\n        unsigned __int8 s25)\n{\n  int v8; // ebp\n  __int64 result; // rax\n  int v10; // esi\n  bool v11; // r15\n  bool v12; // r13\n  __int64 v13; // rbx\n  int v14; // edx\n  int v15; // ebp\n  bool v16; // r14\n  __int64 v17; // r10\n  int v18; // ebx\n  unsigned int v19; // ebx\n  bool v20; // zf\n  int v21; // ebx\n  unsigned int v22; // ebx\n  int v23; // ebx\n  unsigned int v24; // ebx\n  int v25; // ebx\n  unsigned int v26; // ebx\n  bool v27; // [rsp+0h] [rbp-6Ch]\n  unsigned int v28; // [rsp+18h] [rbp-54h]\n\n  if ( y_88 >= 10 && (((_BYTE)x_87 * ((_BYTE)x_87 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v8 = *s1;\n  if ( (unsigned int)((char)s2 - 65) > 0x19 )\n  {\n    result = 0LL;\n    if ( (_BYTE)v8 != (_BYTE)s2 )\n      return result;\n  }\n  else\n  {\n    result = 0LL;\n    if ( (v8 & 0xFFFFFFDF) != (char)s2 )\n      return result;\n  }\n  if ( !(_BYTE)s2 )\n    return 1LL;\n  v10 = s1[1];\n  if ( (unsigned int)(s20 - 65) > 0x19 )\n  {\n    result = 0LL;\n    if ( (_BYTE)v10 != s20 )\n      return result;\n  }\n  else\n  {\n    result = 0LL;\n    if ( (v10 & 0xFFFFFFDF) != s20 )\n      return result;\n  }\n  if ( s20 )\n  {\n    v27 = (((_BYTE)x_99 * ((_BYTE)x_99 - 1)) & 1) == 0 || y_100 < 10;\n    v11 = (((_BYTE)x_89 * ((_BYTE)x_89 - 1)) & 1) == 0 || y_90 < 10;\n    v12 = (((_BYTE)x_91 * ((_BYTE)x_91 - 1)) & 1) == 0 || y_92 < 10;\n    v13 = (unsigned int)(char)s25;\n    v14 = (char)s24;\n    v15 = (char)s23;\n    v28 = v13 - 65;\n    while ( (unsigned int)((char)s21 - 65) < 0x1A )\n    {\n      if ( (s1[2] & 0xFFFFFFDF) == (char)s21 )\n      {\n        if ( !v12 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( s21 )\n        {\nLABEL_23:\n          v17 = v13;\n          v18 = s1[3];\n          if ( (unsigned int)((char)s22 - 65) >= 0x1A )\n          {\n            if ( (((_BYTE)x_93 * ((_BYTE)x_93 - 1)) & 1) != 0 && y_94 >= 10 )\n            {\n              while ( 1 )\n                ;\n            }\n            v16 = (_BYTE)v18 == s22;\n            if ( s22 )\n            {\n              v20 = (_BYTE)v18 == s22;\n              v13 = v17;\n              if ( !v20 )\n                goto LABEL_65;\n              goto LABEL_33;\n            }\n            v13 = v17;\n            if ( v11 )\n              return v16;\n          }\n          else\n          {\n            v19 = v18 & 0xFFFFFFDF;\n            v16 = v19 == (char)s22;\n            if ( !s22 )\n              goto LABEL_63;\n            v20 = v19 == (char)s22;\n            v15 = (char)s23;\n            v14 = (char)s24;\n            v13 = v17;\n            if ( !v20 )\n              goto LABEL_65;\nLABEL_33:\n            v21 = s1[4];\n            if ( (unsigned int)((char)s23 - 65) > 0x19 )\n            {\n              v16 = (_BYTE)v21 == s23;\n              if ( s23 )\n              {\n                v20 = (_BYTE)v21 == s23;\n                v13 = v17;\n                if ( !v20 )\n                  goto LABEL_65;\nLABEL_39:\n                v23 = s1[5];\n                if ( (unsigned int)((char)s24 - 65) > 0x19 )\n                {\n                  v16 = (_BYTE)v23 == s24;\n                  if ( !s24 )\n                    goto LABEL_64;\n                  v20 = (_BYTE)v23 == s24;\n                  v14 = (char)s24;\n                  v13 = v17;\n                  if ( !v20 )\n                    goto LABEL_65;\n                  goto LABEL_46;\n                }\n                if ( (((_BYTE)x_97 * ((_BYTE)x_97 - 1)) & 1) != 0 && y_98 >= 10 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                v24 = v23 & 0xFFFFFFDF;\n                v16 = v24 == v14;\n                if ( s24 )\n                {\n                  v20 = v24 == v14;\n                  v13 = v17;\n                  if ( !v20 )\n                    goto LABEL_65;\nLABEL_46:\n                  v25 = s1[6];\n                  if ( v28 > 0x19 )\n                  {\n                    v16 = (_BYTE)v25 == s25;\n                    if ( !s25 )\n                    {\nLABEL_63:\n                      v15 = (char)s23;\nLABEL_64:\n                      v14 = (char)s24;\n                      v13 = v17;\n                      goto LABEL_65;\n                    }\n                    v20 = (_BYTE)v25 == s25;\n                    v15 = (char)s23;\n                    v14 = (char)s24;\n                    v13 = v17;\n                    if ( v20 )\n                      goto LABEL_59;\nLABEL_65:\n                    if ( v11 )\n                      return v16;\n                  }\n                  else\n                  {\n                    if ( !v27 )\n                    {\n                      while ( 1 )\n                        ;\n                    }\n                    v26 = v25 & 0xFFFFFFDF;\n                    v16 = v26 == (_DWORD)v17;\n                    if ( s25 )\n                    {\n                      v20 = v26 == (_DWORD)v17;\n                      v13 = v17;\n                      if ( !v20 )\n                        goto LABEL_65;\nLABEL_59:\n                      if ( (((_BYTE)x_101 * ((_BYTE)x_101 - 1)) & 1) != 0 && y_102 >= 10 )\n                      {\n                        while ( 1 )\n                          ;\n                      }\n                      if ( !v27 )\n                      {\n                        while ( 1 )\n                          ;\n                      }\n                      v16 = s1[7] == 0;\n                      if ( v11 )\n                        return v16;\n                    }\n                    else\n                    {\n                      v13 = v17;\n                      if ( v11 )\n                        return v16;\n                    }\n                  }\n                }\n                else\n                {\n                  v13 = v17;\n                  if ( v11 )\n                    return v16;\n                }\n              }\n              else\n              {\n                v13 = v17;\n                if ( v11 )\n                  return v16;\n              }\n            }\n            else\n            {\n              v22 = v21 & 0xFFFFFFDF;\n              v16 = v22 == v15;\n              if ( s23 )\n              {\n                v20 = v22 == v15;\n                v13 = v17;\n                if ( !v20 )\n                  goto LABEL_65;\n                goto LABEL_39;\n              }\n              v13 = v17;\n              if ( v11 )\n                return v16;\n            }\n          }\n        }\n        else\n        {\n          v16 = 1;\n          if ( v11 )\n            return v16;\n        }\n      }\n      else\n      {\n        if ( !v12 )\n        {\n          while ( 1 )\n            ;\n        }\n        v16 = 0;\n        if ( v11 )\n          return v16;\n      }\n    }\n    if ( !v12 )\n    {\n      while ( 1 )\n        ;\n    }\n    v16 = s1[2] == s21;\n    if ( s21 == 0 || s1[2] != s21 )\n      goto LABEL_65;\n    goto LABEL_23;\n  }\n  if ( y_90 < 10 )\n    return 1LL;\n  result = 1LL;\n  if ( (((_BYTE)x_89 * ((_BYTE)x_89 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "version_etc_arn",
            "funcStartAddr": "0x405d00",
            "funcEndAddr": "0x4062ce",
            "decompiledFuncCode": "void __fastcall version_etc_arn(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        const char *const *authors,\n        size_t n_authors)\n{\n  char *v9; // rax\n  char *v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  char *v13; // rax\n  char *v14; // rax\n  char *v15; // rax\n  char *v16; // rax\n  char *v17; // rax\n  char *v18; // rax\n  char *v19; // rax\n  char *v20; // rax\n  char *v21; // rax\n  char *v22; // rax\n  char *v23; // rax\n  char *v24; // rax\n\n  if ( command_name )\n  {\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", command_name);\n  }\n  else\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      goto LABEL_7;\n    while ( 1 )\n    {\n      __fprintf_chk(stream, 1LL, \"%s %s\\n\", package);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\nLABEL_7:\n      __fprintf_chk(stream, 1LL, \"%s %s\\n\", package);\n    }\n  }\n  v9 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v9);\n  v10 = dcgettext(\n          0LL,\n          \"\\n\"\n          \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n          \"This is free software: you are free to change and redistribute it.\\n\"\n          \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n          \"\\n\",\n          5);\n  fputs_unlocked(v10, stream);\n  switch ( n_authors )\n  {\n    case 0uLL:\n      return;\n    case 1uLL:\n      v11 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v11, *authors);\n      break;\n    case 2uLL:\n      v12 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v12, *authors);\n      break;\n    case 3uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_29;\n      while ( 1 )\n      {\n        v17 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v17, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_29:\n        v18 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v18, *authors);\n      }\n      break;\n    case 4uLL:\n      v13 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v13, *authors);\n      break;\n    case 5uLL:\n      v14 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v14, *authors);\n      break;\n    case 6uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_32;\n      while ( 1 )\n      {\n        v19 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v19, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_32:\n        v20 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v20, *authors);\n      }\n      break;\n    case 7uLL:\n      v15 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v15, *authors);\n      break;\n    case 8uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_35;\n      while ( 1 )\n      {\n        v21 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v21, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_35:\n        v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v22, *authors);\n      }\n      break;\n    case 9uLL:\n      v16 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v16, *authors);\n      break;\n    default:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_38;\n      while ( 1 )\n      {\n        v23 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v23, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_38:\n        v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v24, *authors);\n      }\n      break;\n  }\n}\n"
        },
        {
            "funcName": "version_etc_ar",
            "funcStartAddr": "0x4062d0",
            "funcEndAddr": "0x406322",
            "decompiledFuncCode": "void __fastcall version_etc_ar(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        const char *const *authors)\n{\n  size_t v5; // r9\n\n  v5 = -1LL;\n  do\n  {\n    if ( (((_BYTE)x_20 * ((_BYTE)x_20 - 1)) & 1) != 0 && y_21 >= 10 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  while ( authors[++v5] != 0LL );\n  version_etc_arn(stream, command_name, package, version, authors, v5);\n}\n"
        },
        {
            "funcName": "version_etc_va",
            "funcStartAddr": "0x406330",
            "funcEndAddr": "0x4063f1",
            "decompiledFuncCode": "void __fastcall version_etc_va(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        __va_list_tag *authors)\n{\n  __int64 v5; // rax\n  size_t v6; // r9\n  unsigned __int64 gp_offset; // r11\n  __int64 *overflow_arg_area; // r10\n  __int64 v9; // rax\n  _QWORD v10[2]; // [rsp-8h] [rbp-10h] BYREF\n\n  v10[0] = v5;\n  while ( (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 && y_23 >= 10 )\n    ;\n  if ( y_23 >= 10 && (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\nLABEL_13:\n      ;\n  }\n  v6 = 0LL;\n  while ( v6 <= 9 )\n  {\n    gp_offset = (int)authors->gp_offset;\n    if ( gp_offset > 0x28 )\n    {\n      overflow_arg_area = (__int64 *)authors->overflow_arg_area;\n      authors->overflow_arg_area = overflow_arg_area + 1;\n    }\n    else\n    {\n      overflow_arg_area = (__int64 *)((char *)authors->reg_save_area + gp_offset);\n      authors->gp_offset = gp_offset + 8;\n    }\n    v9 = *overflow_arg_area;\n    v10[v6 - 10] = *overflow_arg_area;\n    if ( !v9 )\n      break;\n    ++v6;\n    if ( y_23 >= 10 && (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 )\n      goto LABEL_13;\n  }\n  version_etc_arn(stream, command_name, package, version, (const char *const *)&v10[-10], v6);\n}\n"
        },
        {
            "funcName": "version_etc",
            "funcStartAddr": "0x406400",
            "funcEndAddr": "0x406482",
            "decompiledFuncCode": "void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...)\n{\n  va_list va; // [rsp+0h] [rbp-D8h] BYREF\n\n  va_start(va, version);\n  version_etc_va(stream, command_name, package, version, va);\n}\n"
        },
        {
            "funcName": "emit_bug_reporting_address",
            "funcStartAddr": "0x406490",
            "funcEndAddr": "0x4065b8",
            "decompiledFuncCode": "void __cdecl emit_bug_reporting_address()\n{\n  char *v0; // rax\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n\n  if ( y_27 >= 10 && (((_BYTE)x_26 * ((_BYTE)x_26 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v0 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n    __printf_chk(1LL, v0, \"bug-coreutils@gnu.org\");\n    v1 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n    __printf_chk(1LL, v1, \"GNU coreutils\");\n    v2 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n    fputs_unlocked(v2, stdout);\n    if ( y_27 < 10 || (((_BYTE)x_26 * ((_BYTE)x_26 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    v3 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n    __printf_chk(1LL, v3, \"bug-coreutils@gnu.org\");\n    v4 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n    __printf_chk(1LL, v4, \"GNU coreutils\");\n    v5 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n    fputs_unlocked(v5, stdout);\n  }\n}\n"
        },
        {
            "funcName": "xnmalloc",
            "funcStartAddr": "0x4065c0",
            "funcEndAddr": "0x406653",
            "decompiledFuncCode": "void *__fastcall xnmalloc(size_t n, size_t s)\n{\n  size_t v2; // r14\n  bool v3; // bl\n  void *result; // rax\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n )\n    goto LABEL_10;\n  v2 = n * s;\n  v3 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = malloc(v2);\n  while ( !v3 );\n  if ( v2 && !result )\nLABEL_10:\n    xalloc_die();\n  return result;\n}\n"
        },
        {
            "funcName": "xmalloc",
            "funcStartAddr": "0x406660",
            "funcEndAddr": "0x4066b3",
            "decompiledFuncCode": "void *__fastcall xmalloc(size_t n)\n{\n  bool v1; // bl\n  void *result; // rax\n\n  v1 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = malloc(n);\n  while ( !v1 );\n  if ( n )\n  {\n    if ( !result )\n      xalloc_die();\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xnrealloc",
            "funcStartAddr": "0x4066c0",
            "funcEndAddr": "0x40673d",
            "decompiledFuncCode": "void *__fastcall xnrealloc(void *p, size_t n, size_t s)\n{\n  size_t v3; // rbx\n  void *result; // rax\n\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n )\n    xalloc_die();\n  v3 = n * s;\n  if ( y_4 >= 10 && (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) != 0 )\n    goto LABEL_8;\n  while ( 1 )\n  {\n    result = xrealloc(p, v3);\n    if ( y_4 < 10 || (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) == 0 )\n      break;\nLABEL_8:\n    xrealloc(p, v3);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xrealloc",
            "funcStartAddr": "0x406740",
            "funcEndAddr": "0x4067c0",
            "decompiledFuncCode": "void *__fastcall xrealloc(void *p, size_t n)\n{\n  void *result; // rax\n\n  if ( !p || n )\n  {\n    result = realloc(p, n);\n    if ( n && !result )\n      xalloc_die();\n  }\n  else\n  {\n    if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n      goto LABEL_11;\n    while ( 1 )\n    {\n      free(p);\n      result = 0LL;\n      if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n        break;\nLABEL_11:\n      free(p);\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "x2nrealloc",
            "funcStartAddr": "0x4067c0",
            "funcEndAddr": "0x40688a",
            "decompiledFuncCode": "void *__fastcall x2nrealloc(void *p, size_t *pn, size_t s)\n{\n  size_t v3; // rcx\n\n  v3 = *pn;\n  if ( p )\n  {\n    if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( 0x5555555555555554LL / s <= v3 )\n      xalloc_die();\n    v3 += (v3 >> 1) + 1;\n  }\n  else\n  {\n    if ( !v3 )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      v3 = 0x80 / s + (s > 0x80);\n    }\n    if ( 0x7FFFFFFFFFFFFFFFLL / s < v3 )\n      xalloc_die();\n  }\n  *pn = v3;\n  return xrealloc(p, v3 * s);\n}\n"
        },
        {
            "funcName": "xcharalloc",
            "funcStartAddr": "0x406890",
            "funcEndAddr": "0x4068e3",
            "decompiledFuncCode": "char *__fastcall xcharalloc(size_t n)\n{\n  bool v1; // bl\n  char *result; // rax\n\n  v1 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = (char *)malloc(n);\n  while ( !v1 );\n  if ( n )\n  {\n    if ( !result )\n      xalloc_die();\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "x2realloc",
            "funcStartAddr": "0x4068f0",
            "funcEndAddr": "0x406a5c",
            "decompiledFuncCode": "void *__fastcall x2realloc(void *p, size_t *pn)\n{\n  __int64 v3; // rsi\n  void *result; // rax\n  __int64 v5; // rsi\n\n  if ( y_12 >= 10 && (((_BYTE)x_11 * ((_BYTE)x_11 - 1)) & 1) != 0 )\n    goto LABEL_14;\n  while ( 1 )\n  {\n    v3 = *pn;\n    if ( p )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( (unsigned __int64)v3 >= 0x5555555555555554LL )\n        xalloc_die();\n      v3 += ((unsigned __int64)v3 >> 1) + 1;\n    }\n    else if ( v3 )\n    {\n      if ( v3 < 0 )\n        xalloc_die();\n    }\n    else\n    {\n      v3 = 128LL;\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n    }\n    *pn = v3;\n    result = xrealloc(p, v3);\n    if ( y_12 < 10 || (((_BYTE)x_11 * ((_BYTE)x_11 - 1)) & 1) == 0 )\n      break;\nLABEL_14:\n    v5 = *pn;\n    if ( p )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( (unsigned __int64)v5 >= 0x5555555555555554LL )\n        xalloc_die();\n      v5 += ((unsigned __int64)v5 >> 1) + 1;\n    }\n    else if ( v5 )\n    {\n      if ( v5 < 0 )\n        xalloc_die();\n    }\n    else\n    {\n      v5 = 128LL;\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n    }\n    *pn = v5;\n    xrealloc(p, v5);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xzalloc",
            "funcStartAddr": "0x406a60",
            "funcEndAddr": "0x406b29",
            "decompiledFuncCode": "void *__fastcall xzalloc(size_t s)\n{\n  int v1; // ecx\n  int v2; // ebp\n  char v3; // r12\n  int v4; // r13d\n  void *v5; // rax\n  void *v6; // rbx\n  int v8; // [rsp+0h] [rbp-34h]\n\n  v1 = y_14;\n  v2 = ((_BYTE)x_13 * ((_BYTE)x_13 - 1)) & 1;\n  v3 = x_1;\n  v4 = y_2;\n  if ( y_14 >= 10 && (((_BYTE)x_13 * ((_BYTE)x_13 - 1)) & 1) != 0 )\n    goto LABEL_9;\n  while ( 1 )\n  {\n    v8 = v1;\n    do\n    {\n      v5 = malloc(s);\n      v6 = v5;\n    }\n    while ( ((v3 * (v3 - 1)) & 1) != 0 && v4 >= 10 );\n    if ( s && !v5 )\n      xalloc_die();\n    memset(v5, 0, s);\n    v1 = v8;\n    if ( v8 < 10 || !v2 )\n      break;\nLABEL_9:\n    if ( v4 >= 10 && ((v3 * (v3 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "xcalloc",
            "funcStartAddr": "0x406b30",
            "funcEndAddr": "0x406b56",
            "decompiledFuncCode": "void *__fastcall xcalloc(size_t n, size_t s)\n{\n  void *result; // rax\n\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n || (result = rpl_calloc(n, s)) == 0LL )\n    xalloc_die();\n  return result;\n}\n"
        },
        {
            "funcName": "xmemdup",
            "funcStartAddr": "0x406b60",
            "funcEndAddr": "0x406bcb",
            "decompiledFuncCode": "void *__fastcall xmemdup(const void *p, size_t s)\n{\n  bool v2; // bp\n  void *v3; // rax\n  void *v4; // rbx\n\n  v2 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n  {\n    v3 = malloc(s);\n    v4 = v3;\n  }\n  while ( !v2 );\n  if ( s && !v3 )\n    xalloc_die();\n  memcpy(v3, p, s);\n  return v4;\n}\n"
        },
        {
            "funcName": "xstrdup",
            "funcStartAddr": "0x406bd0",
            "funcEndAddr": "0x406c4b",
            "decompiledFuncCode": "char *__fastcall xstrdup(const char *string)\n{\n  size_t v1; // r15\n  bool v2; // bp\n  char *v3; // rax\n  char *v4; // rbx\n\n  v1 = strlen(string) + 1;\n  v2 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n  {\n    v3 = (char *)malloc(v1);\n    v4 = v3;\n  }\n  while ( !v2 );\n  if ( v1 && !v3 )\n    xalloc_die();\n  memcpy(v3, string, v1);\n  return v4;\n}\n"
        },
        {
            "funcName": "xalloc_die",
            "funcStartAddr": "0x406c50",
            "funcEndAddr": "0x406c80",
            "decompiledFuncCode": "void __cdecl __noreturn xalloc_die()\n{\n  int v0; // ebx\n  char *v1; // rax\n\n  v0 = exit_failure;\n  v1 = dcgettext(0LL, \"memory exhausted\", 5);\n  error(v0, 0, \"%s\", v1);\n  abort();\n}\n"
        },
        {
            "funcName": "rpl_calloc",
            "funcStartAddr": "0x406c80",
            "funcEndAddr": "0x406d24",
            "decompiledFuncCode": "void *__fastcall rpl_calloc(size_t n, size_t s)\n{\n  size_t v2; // r14\n  size_t v3; // r15\n  bool v4; // bl\n  void *result; // rax\n\n  v2 = 1LL;\n  if ( n )\n  {\n    v3 = 1LL;\n    if ( s )\n    {\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      v2 = s;\n      v3 = n;\n      if ( n * s / s != n )\n      {\n        *__errno_location() = 12;\n        return 0LL;\n      }\n    }\n  }\n  else\n  {\n    v3 = 1LL;\n  }\n  v4 = (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 || y < 10;\n  do\n    result = calloc(v3, v2);\n  while ( !v4 );\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_mbrtowc",
            "funcStartAddr": "0x406d30",
            "funcEndAddr": "0x406db8",
            "decompiledFuncCode": "size_t __fastcall rpl_mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  wchar_t *v5; // rbx\n  size_t v6; // rax\n  size_t v7; // r12\n  __int64 v9; // [rsp+0h] [rbp-20h] BYREF\n\n  do\n    v5 = (wchar_t *)(&v9 - 2);\n  while ( (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 && y >= 10 );\n  if ( pwc )\n    v5 = pwc;\n  v6 = mbrtowc(v5, s, n, ps);\n  v7 = v6;\n  if ( n && v6 >= 0xFFFFFFFFFFFFFFFELL && !hard_locale(0) )\n  {\n    *v5 = *(unsigned __int8 *)s;\n    return 1LL;\n  }\n  return v7;\n}\n"
        },
        {
            "funcName": "close_stream",
            "funcStartAddr": "0x406dc0",
            "funcEndAddr": "0x406e8d",
            "decompiledFuncCode": "int __fastcall close_stream(FILE *stream)\n{\n  size_t v1; // r14\n  int flags; // r12d\n  int v3; // eax\n  char v4; // r15\n  int v5; // ebp\n  int v6; // ebx\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v1 = __fpending(stream);\n    flags = stream->_flags;\n    v3 = rpl_fclose(stream);\n    v4 = x;\n    v5 = y;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    __fpending(stream);\n    rpl_fclose(stream);\n  }\n  if ( (flags & 0x20) != 0 )\n  {\n    if ( !v3 )\n    {\n      *__errno_location() = 0;\n      v4 = x;\n      v5 = y;\n    }\n  }\n  else\n  {\n    v6 = 0;\n    if ( !v3 || !v1 && *__errno_location() == 9 )\n      return v6;\n  }\n  v6 = -1;\n  if ( v5 >= 10 && ((v4 * (v4 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "hard_locale",
            "funcStartAddr": "0x406e90",
            "funcEndAddr": "0x406efb",
            "decompiledFuncCode": "bool __fastcall hard_locale(int category)\n{\n  char *v1; // rax\n  const char *v2; // rbx\n  bool v3; // bp\n\n  v1 = setlocale(category, 0LL);\n  v2 = v1;\n  v3 = 1;\n  if ( v1 && (!strcmp(v1, \"C\") || !strcmp(v2, \"POSIX\")) )\n  {\n    v3 = 0;\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "locale_charset",
            "funcStartAddr": "0x406f00",
            "funcEndAddr": "0x406f25",
            "decompiledFuncCode": "const char *__cdecl locale_charset()\n{\n  char *v0; // rax\n  const char *v1; // rcx\n  const char *result; // rax\n\n  v0 = nl_langinfo(14);\n  v1 = \"Print the user name associated with the current effective user ID.\\nSame as id -un.\\n\\n\" + 84;\n  if ( v0 )\n    v1 = v0;\n  result = \"ASCII\";\n  if ( *v1 )\n    return v1;\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fclose",
            "funcStartAddr": "0x406f30",
            "funcEndAddr": "0x40703b",
            "decompiledFuncCode": "int __fastcall rpl_fclose(FILE *fp)\n{\n  int v1; // eax\n  int v2; // eax\n  int result; // eax\n  int *v4; // r14\n  int v5; // ebp\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v1 = fileno(fp);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    fileno(fp);\n  }\n  if ( v1 < 0 )\n    return fclose(fp);\n  if ( __freading(fp) )\n  {\n    v2 = fileno(fp);\n    if ( lseek(v2, 0LL, 1) == -1 )\n      return fclose(fp);\n  }\n  if ( !rpl_fflush(fp) )\n    return fclose(fp);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v4 = __errno_location();\n  v5 = *v4;\n  result = fclose(fp);\n  if ( v5 )\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      goto LABEL_19;\n    while ( 1 )\n    {\n      *v4 = v5;\n      result = -1;\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\nLABEL_19:\n      *v4 = v5;\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fflush",
            "funcStartAddr": "0x407040",
            "funcEndAddr": "0x407144",
            "decompiledFuncCode": "int __fastcall rpl_fflush(FILE *stream)\n{\n  int v1; // eax\n  int result; // eax\n\n  if ( !stream )\n    return fflush(stream);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_6;\n  while ( 1 )\n  {\n    v1 = __freading(stream);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_6:\n    __freading(stream);\n  }\n  if ( !v1 )\n    return fflush(stream);\n  while ( 1 )\n  {\n    if ( (stream->_flags & 0x100) != 0 )\n      rpl_fseeko(stream, 0LL, 1);\n    if ( y_2 >= 10 && (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    result = fflush(stream);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\n    if ( (stream->_flags & 0x100) != 0 )\n      rpl_fseeko(stream, 0LL, 1);\n    if ( y_2 >= 10 && (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    fflush(stream);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fseeko",
            "funcStartAddr": "0x407150",
            "funcEndAddr": "0x407202",
            "decompiledFuncCode": "int __fastcall rpl_fseeko(FILE *fp, off_t offset, int whence)\n{\n  int result; // eax\n  int v5; // eax\n  __off_t v6; // rax\n\n  if ( fp->_IO_read_end != fp->_IO_read_ptr )\n    return fseeko(fp, offset, whence);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( fp->_IO_write_ptr != fp->_IO_write_base || fp->_IO_save_base )\n    return fseeko(fp, offset, whence);\n  v5 = fileno(fp);\n  v6 = lseek(v5, offset, whence);\n  if ( v6 == -1 )\n  {\n    result = -1;\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  else\n  {\n    LOBYTE(fp->_flags) &= ~0x10u;\n    fp->_offset = v6;\n    return 0;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "atexit",
            "funcStartAddr": "0x407290",
            "funcEndAddr": "0x4072a2",
            "decompiledFuncCode": "int __fastcall atexit(void (__fastcall *a1)(void *))\n{\n  return __cxa_atexit(a1, 0LL, _dso_handle);\n}\n"
        }
    ],
    "funcCount": 71
}