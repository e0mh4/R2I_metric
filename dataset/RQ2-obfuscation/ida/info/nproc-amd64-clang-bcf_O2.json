{
    "binaryInfo": {
        "binaryName": "nproc-amd64-clang-bcf_O2",
        "isStripped": "True"
    },
    "buildInfo": {
        "decompilerName": "IDA Pro",
        "compilerName": "gcc",
        "compilerVersion": "9.4.0",
        "Optlevel": "-O"
    },
    "funcInfo": [
        {
            "funcName": "_dl_relocate_static_pie",
            "funcStartAddr": "0x402350",
            "funcEndAddr": "0x402355",
            "decompiledFuncCode": "void dl_relocate_static_pie()\n{\n  ;\n}\n"
        },
        {
            "funcName": "usage",
            "funcStartAddr": "0x402410",
            "funcEndAddr": "0x4026d1",
            "decompiledFuncCode": "void __fastcall __noreturn usage(int status)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  bool v6; // bl\n  const char **v7; // rbp\n  bool v8; // al\n  const char *v9; // rbx\n  char *v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  char *v13; // rax\n  char *v14; // rax\n  char *v15; // rdx\n  FILE *v16; // rbx\n  char *v17; // rax\n\n  if ( status )\n  {\n    v16 = stderr;\n    v17 = dcgettext(0LL, \"Try '%s --help' for more information.\\n\", 5);\n    __fprintf_chk(v16, 1LL, v17, program_name);\n    exit(status);\n  }\n  v1 = dcgettext(0LL, \"Usage: %s [OPTION]...\\n\", 5);\n  __printf_chk(1LL, v1, program_name);\n  v2 = dcgettext(\n         0LL,\n         \"Print the number of processing units available to the current process,\\n\"\n         \"which may be less than the number of online processors\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v2, stdout);\n  v3 = dcgettext(\n         0LL,\n         \"      --all      print the number of installed processors\\n\"\n         \"      --ignore=N  if possible, exclude N processing units\\n\",\n         5);\n  fputs_unlocked(v3, stdout);\n  v4 = dcgettext(0LL, \"      --help     display this help and exit\\n\", 5);\n  fputs_unlocked(v4, stdout);\n  v5 = dcgettext(0LL, \"      --version  output version information and exit\\n\", 5);\n  fputs_unlocked(v5, stdout);\n  v6 = (((_BYTE)x_34 * ((_BYTE)x_34 - 1)) & 1) == 0 || y_35 < 10;\n  v7 = (const char **)emit_ancillary_info_infomap;\n  while ( 1 )\n  {\n    if ( *v7 )\n    {\n      v8 = strcmp(\"nproc\", *v7) != 0;\n      if ( !v6 )\n        goto LABEL_14;\n    }\n    else\n    {\n      v8 = 0;\n      if ( !v6 )\n      {\n        while ( 1 )\nLABEL_14:\n          ;\n      }\n    }\n    v7 += 2;\n    if ( !v8 )\n    {\n      v9 = \"nproc\";\n      if ( *(v7 - 1) )\n        v9 = *(v7 - 1);\n      v10 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n      __printf_chk(1LL, v10, \"GNU coreutils\");\n      v11 = setlocale(5, 0LL);\n      if ( v11 )\n      {\n        if ( y_35 >= 10 && (((_BYTE)x_34 * ((_BYTE)x_34 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( strncmp(v11, \"en_\", 3uLL) )\n        {\n          while ( 1 )\n          {\n            v13 = dcgettext(0LL, \"Report any translation bugs to <https://translationproject.org/team/>\\n\", 5);\n            fputs_unlocked(v13, stdout);\n            if ( y_35 < 10 || (((_BYTE)x_34 * ((_BYTE)x_34 - 1)) & 1) == 0 )\n              break;\n            v12 = dcgettext(0LL, \"Report any translation bugs to <https://translationproject.org/team/>\\n\", 5);\n            fputs_unlocked(v12, stdout);\n          }\n        }\n      }\n      v14 = dcgettext(0LL, \"Full documentation <%s%s>\\n\", 5);\n      __printf_chk(1LL, v14, \"https://www.gnu.org/software/coreutils/\");\n      v15 = dcgettext(0LL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5);\n      __printf_chk(1LL, v15, v9);\n      exit(status);\n    }\n  }\n}\n"
        },
        {
            "funcName": "main",
            "funcStartAddr": "0x4026e0",
            "funcEndAddr": "0x40294b",
            "decompiledFuncCode": "int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  nproc_query v3; // ebx\n  uintmax_t v4; // r15\n  const char *v5; // rbp\n  char *v6; // rax\n  int v7; // eax\n  bool v8; // cl\n  unsigned __int64 v9; // rax\n  __int64 v10; // rbx\n  char v11; // al\n  char *v12; // rbx\n  const char *v13; // rax\n\n  set_program_name(*argv);\n  setlocale(6, \"\");\n  bindtextdomain(\"coreutils\", \"/home/yujeong/binary_gen/coreutils-8.31/tmp/_install/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  v3 = NPROC_CURRENT_OVERRIDABLE;\n  v4 = 0LL;\n  while ( 1 )\n  {\n    v7 = getopt_long(argc, (char *const *)argv, \"\", longopts, 0LL);\n    v8 = (((_BYTE)x_36 * ((_BYTE)x_36 - 1)) & 1) == 0 || y_37 < 10;\n    if ( v7 == -1 )\n      break;\n    if ( !v8 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( v7 > 128 )\n    {\n      if ( v7 != 129 )\n        goto LABEL_27;\n      v5 = optarg;\n      v6 = dcgettext(0LL, \"invalid number\", 5);\n      v4 = xdectoumax(v5, 0LL, 0xFFFFFFFFFFFFFFFFLL, \"\", v6, 0);\n    }\n    else\n    {\n      v3 = NPROC_ALL;\n      if ( v7 != 128 )\n      {\n        if ( v7 == -131 )\n        {\n          version_etc(stdout, \"nproc\", \"GNU coreutils\", Version, \"Giuseppe Scrivano\", 0LL);\n          exit(0);\n        }\n        if ( v7 == -130 )\n          usage(0);\nLABEL_27:\n        usage(1);\n      }\n    }\n  }\n  if ( !v8 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( optind != argc )\n  {\n    v12 = dcgettext(0LL, \"extra operand %s\", 5);\n    v13 = quote(argv[optind]);\n    error(0, 0, v12, v13);\n    usage(1);\n  }\n  v9 = num_processors(v3);\n  v10 = v9 - v4;\n  if ( v9 <= v4 )\n  {\n    v11 = x_36;\n    v10 = 1LL;\n    if ( y_37 >= 10 && (((_BYTE)x_36 * ((_BYTE)x_36 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( y_37 < 10 )\n      goto LABEL_29;\n  }\n  else\n  {\n    v11 = x_36;\n    if ( y_37 < 10 )\n      goto LABEL_29;\n  }\n  if ( ((v11 * (v11 - 1)) & 1) != 0 )\n    goto LABEL_31;\nLABEL_29:\n  while ( 1 )\n  {\n    __printf_chk(1LL, \"%lu\\n\", v10);\n    if ( y_37 < 10 || (((_BYTE)x_36 * ((_BYTE)x_36 - 1)) & 1) == 0 )\n      break;\nLABEL_31:\n    __printf_chk(1LL, \"%lu\\n\", v10);\n  }\n  return 0;\n}\n"
        },
        {
            "funcName": "close_stdout_set_file_name",
            "funcStartAddr": "0x402950",
            "funcEndAddr": "0x402988",
            "decompiledFuncCode": "void __fastcall close_stdout_set_file_name(const char *file)\n{\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    file_name = file;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    file_name = file;\n  }\n}\n"
        },
        {
            "funcName": "close_stdout_set_ignore_EPIPE",
            "funcStartAddr": "0x402990",
            "funcEndAddr": "0x4029c8",
            "decompiledFuncCode": "void __fastcall close_stdout_set_ignore_EPIPE(bool ignore)\n{\n  if ( y_4 >= 10 && (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    ignore_EPIPE = ignore;\n    if ( y_4 < 10 || (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    ignore_EPIPE = ignore;\n  }\n}\n"
        },
        {
            "funcName": "close_stdout",
            "funcStartAddr": "0x4029d0",
            "funcEndAddr": "0x402b4b",
            "decompiledFuncCode": "void __cdecl close_stdout()\n{\n  int v0; // eax\n  bool v1; // bl\n  int *v2; // rax\n  int *v3; // rbp\n  char *v4; // rbx\n  int v5; // ebp\n  int v6; // eax\n  char *v7; // rax\n\n  if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v0 = close_stream(stdout);\n    if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    close_stream(stdout);\n  }\n  if ( v0 )\n  {\n    v1 = ignore_EPIPE;\n    v2 = __errno_location();\n    v3 = v2;\n    if ( !v1 || *v2 != 32 )\n    {\n      v4 = dcgettext(0LL, \"write error\", 5);\n      v5 = *v3;\n      if ( file_name )\n      {\n        v7 = quotearg_colon(file_name);\n        error(0, v5, \"%s: %s\", v7, v4);\n        _exit(exit_failure);\n      }\n      if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n        goto LABEL_21;\n      while ( 1 )\n      {\n        error(0, v5, \"%s\", v4);\n        if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n          _exit(exit_failure);\nLABEL_21:\n        error(0, v5, \"%s\", v4);\n      }\n    }\n  }\n  while ( 1 )\n  {\n    v6 = close_stream(stderr);\n    if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n      break;\n    close_stream(stderr);\n  }\n  if ( v6 )\n    _exit(exit_failure);\n}\n"
        },
        {
            "funcName": "num_processors",
            "funcStartAddr": "0x402b50",
            "funcEndAddr": "0x402dd0",
            "decompiledFuncCode": "unsigned __int64 __fastcall num_processors(nproc_query query)\n{\n  char *v1; // rax\n  unsigned __int64 v2; // r14\n  char *v3; // rax\n  unsigned __int64 v4; // rax\n  unsigned __int64 v5; // rbx\n  char v6; // al\n  __int64 v7; // rax\n  int v8; // edx\n  cpu_set_t cpuset; // [rsp+8h] [rbp-90h] BYREF\n\n  if ( query == NPROC_CURRENT )\n  {\n    v5 = -1LL;\n    goto LABEL_8;\n  }\n  if ( query != NPROC_CURRENT_OVERRIDABLE )\n  {\n    if ( y_5 >= 10 && (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) != 0 )\n      goto LABEL_35;\n    while ( 1 )\n    {\n      v7 = sysconf(83);\n      if ( y_5 < 10 || (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 )\n        break;\nLABEL_35:\n      sysconf(83);\n    }\n    if ( v7 != 1 )\n      goto LABEL_45;\n    if ( sched_getaffinity(0, 0x80uLL, &cpuset) || (LODWORD(v7) = __sched_cpucount(0x80uLL, &cpuset), !(_DWORD)v7) )\n    {\n      v7 = 0LL;\n      if ( y_7 < 10 )\n        goto LABEL_44;\n    }\n    else\n    {\n      v7 = (int)v7;\n      if ( y_7 < 10 )\n        goto LABEL_44;\n    }\n    if ( (((_BYTE)x_6 * ((_BYTE)x_6 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\nLABEL_44:\n    if ( !v7 )\n    {\n      v5 = -1LL;\nLABEL_48:\n      v7 = 1LL;\n      goto LABEL_49;\n    }\nLABEL_45:\n    v5 = -1LL;\n    if ( v7 > 0 )\n      goto LABEL_49;\n    goto LABEL_48;\n  }\n  v1 = getenv(\"OMP_NUM_THREADS\");\n  v2 = parse_omp_threads(v1);\n  v3 = getenv(\"OMP_THREAD_LIMIT\");\n  v4 = parse_omp_threads(v3);\n  v5 = v4 | -(__int64)(v4 == 0);\n  if ( v2 )\n  {\n    v6 = x;\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( v2 < v5 )\n      v5 = v2;\n    if ( y < 10 )\n      return v5;\nLABEL_52:\n    if ( ((v6 * (v6 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    return v5;\n  }\nLABEL_8:\n  if ( sched_getaffinity(0, 0x80uLL, &cpuset) || (LODWORD(v7) = __sched_cpucount(0x80uLL, &cpuset), !(_DWORD)v7) )\n  {\n    v7 = 0LL;\n    if ( y_7 < 10 )\n      goto LABEL_18;\n  }\n  else\n  {\n    v7 = (int)v7;\n    if ( y_7 < 10 )\n      goto LABEL_18;\n  }\n  if ( (((_BYTE)x_6 * ((_BYTE)x_6 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\nLABEL_18:\n  if ( v7 )\n  {\n    v8 = 1;\n    if ( y_5 >= 10 && (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  else\n  {\n    v8 = 0;\n  }\n  if ( y_5 >= 10 && (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( !v8 )\n  {\n    v7 = sysconf(84);\n    if ( v7 <= 0 )\n      goto LABEL_48;\n  }\nLABEL_49:\n  if ( v7 < v5 )\n    v5 = v7;\n  v6 = x;\n  if ( y >= 10 )\n    goto LABEL_52;\n  return v5;\n}\n"
        },
        {
            "funcName": "parse_omp_threads",
            "funcStartAddr": "0x402dd0",
            "funcEndAddr": "0x402f0b",
            "decompiledFuncCode": "unsigned __int64 __fastcall parse_omp_threads(const char *threads)\n{\n  char v2; // cl\n  int v3; // edi\n  char **v4; // rbx\n  char v5; // al\n  int v6; // esi\n  unsigned int v7; // edx\n  unsigned __int64 result; // rax\n  char *v9; // rsi\n  char v10; // dl\n  int v11; // r8d\n  unsigned int v12; // edx\n  _BYTE v13[16]; // [rsp+0h] [rbp-10h] BYREF\n\n  v2 = x_2;\n  v3 = y_3;\n  do\n    v4 = (char **)&v13[-16];\n  while ( (((_BYTE)x_2 * ((_BYTE)x_2 - 1)) & 1) != 0 && y_3 >= 10 );\n  if ( !threads )\n    goto LABEL_23;\n  v5 = *threads;\n  if ( *threads )\n  {\n    v6 = 8388639;\n    while ( 1 )\n    {\n      v7 = v5 - 9;\n      if ( v7 > 0x17 || !_bittest(&v6, v7) )\n        break;\n      v5 = *++threads;\n      if ( !v5 )\n        goto LABEL_9;\n    }\n  }\n  else\n  {\nLABEL_9:\n    v5 = 0;\n  }\n  if ( (unsigned int)(v5 - 48) > 9 )\n    goto LABEL_23;\n  while ( 1 )\n  {\n    *v4 = 0LL;\n    result = strtoul(threads, (char **)&v13[-16], 10);\n    v2 = x_2;\n    v3 = y_3;\n    if ( y_3 < 10 || (((_BYTE)x_2 * ((_BYTE)x_2 - 1)) & 1) == 0 )\n      break;\n    *v4 = 0LL;\n    strtoul(threads, (char **)&v13[-16], 10);\n  }\n  v9 = *v4;\n  if ( !*v4 )\n    goto LABEL_23;\n  v10 = *v9;\n  if ( *v9 )\n  {\n    v11 = 8388639;\n    do\n    {\n      v12 = v10 - 9;\n      if ( v12 > 0x17 )\n        break;\n      if ( !_bittest(&v11, v12) )\n        break;\n      v10 = *++v9;\n    }\n    while ( v10 );\n  }\n  *v4 = v9;\n  if ( *v9 != 44 )\n  {\n    if ( *v9 )\nLABEL_23:\n      result = 0LL;\n  }\n  if ( v3 >= 10 && ((v2 * (v2 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "set_program_name",
            "funcStartAddr": "0x402f10",
            "funcEndAddr": "0x402fd3",
            "decompiledFuncCode": "void __fastcall set_program_name(const char *argv0)\n{\n  const char *v1; // rbx\n  char *v2; // rax\n  const char *v3; // r14\n\n  v1 = argv0;\n  if ( !argv0 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 0x37uLL, 1uLL, stderr);\n    abort();\n  }\n  v2 = strrchr(argv0, 47);\n  v3 = v2 + 1;\n  if ( !v2 )\n    v3 = argv0;\n  if ( v3 - argv0 >= 7 )\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( !strncmp(v3 - 7, \"/.libs/\", 7uLL) )\n    {\n      if ( !strncmp(v3, \"lt-\", 3uLL) )\n      {\n        v3 += 3;\n        program_invocation_short_name = (__int64)v3;\n      }\n      v1 = v3;\n    }\n  }\n  program_name = v1;\n  program_invocation_name = (__int64)v1;\n}\n"
        },
        {
            "funcName": "clone_quoting_options",
            "funcStartAddr": "0x402fe0",
            "funcEndAddr": "0x403013",
            "decompiledFuncCode": "quoting_options *__fastcall clone_quoting_options(quoting_options *o)\n{\n  quoting_options *v1; // rbx\n  int *v2; // r14\n  int v3; // ebp\n  quoting_options *result; // rax\n\n  v1 = o;\n  v2 = __errno_location();\n  v3 = *v2;\n  if ( !o )\n    v1 = &default_quoting_options;\n  result = (quoting_options *)xmemdup(v1, 0x38uLL);\n  *v2 = v3;\n  return result;\n}\n"
        },
        {
            "funcName": "get_quoting_style",
            "funcStartAddr": "0x403020",
            "funcEndAddr": "0x40302f",
            "decompiledFuncCode": "quoting_style __fastcall get_quoting_style(const quoting_options *o)\n{\n  const quoting_options *v1; // rax\n\n  v1 = &default_quoting_options;\n  if ( o )\n    v1 = o;\n  return v1->style;\n}\n"
        },
        {
            "funcName": "set_quoting_style",
            "funcStartAddr": "0x403030",
            "funcEndAddr": "0x403083",
            "decompiledFuncCode": "void __fastcall set_quoting_style(quoting_options *o, quoting_style s)\n{\n  quoting_options *v2; // rax\n  quoting_options *v3; // rax\n\n  if ( y_22 >= 10 && (((_BYTE)x_21 * ((_BYTE)x_21 - 1)) & 1) != 0 )\n    goto LABEL_7;\n  while ( 1 )\n  {\n    v2 = &default_quoting_options;\n    if ( o )\n      v2 = o;\n    v2->style = s;\n    if ( y_22 < 10 || (((_BYTE)x_21 * ((_BYTE)x_21 - 1)) & 1) == 0 )\n      break;\nLABEL_7:\n    v3 = &default_quoting_options;\n    if ( o )\n      v3 = o;\n    v3->style = s;\n  }\n}\n"
        },
        {
            "funcName": "set_char_quoting",
            "funcStartAddr": "0x403090",
            "funcEndAddr": "0x4030c6",
            "decompiledFuncCode": "int __fastcall set_char_quoting(quoting_options *o, char c, int i)\n{\n  quoting_options *v4; // rsi\n  __int64 v5; // r8\n  int result; // eax\n\n  v4 = &default_quoting_options;\n  if ( o )\n    v4 = o;\n  v5 = (unsigned __int8)c >> 5;\n  result = (v4->quote_these_too[v5] >> c) & 1;\n  v4->quote_these_too[v5] ^= (((unsigned __int8)i ^ (unsigned __int8)(v4->quote_these_too[v5] >> c)) & 1) << c;\n  return result;\n}\n"
        },
        {
            "funcName": "set_quoting_flags",
            "funcStartAddr": "0x4030d0",
            "funcEndAddr": "0x4030e3",
            "decompiledFuncCode": "int __fastcall set_quoting_flags(quoting_options *o, int i)\n{\n  quoting_options *v2; // rcx\n  int result; // eax\n\n  v2 = &default_quoting_options;\n  if ( o )\n    v2 = o;\n  result = v2->flags;\n  v2->flags = i;\n  return result;\n}\n"
        },
        {
            "funcName": "set_custom_quoting",
            "funcStartAddr": "0x4030f0",
            "funcEndAddr": "0x40311b",
            "decompiledFuncCode": "void __fastcall set_custom_quoting(quoting_options *o, const char *left_quote, const char *right_quote)\n{\n  quoting_options *v3; // rax\n\n  v3 = &default_quoting_options;\n  if ( o )\n    v3 = o;\n  v3->style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v3->left_quote = left_quote;\n  v3->right_quote = right_quote;\n}\n"
        },
        {
            "funcName": "quotearg_buffer",
            "funcStartAddr": "0x403120",
            "funcEndAddr": "0x403192",
            "decompiledFuncCode": "size_t __fastcall quotearg_buffer(\n        char *buffer,\n        size_t buffersize,\n        const char *arg,\n        size_t argsize,\n        const quoting_options *o)\n{\n  const quoting_options *v7; // rbp\n  int *v8; // rbx\n  size_t result; // rax\n  int v10; // [rsp+0h] [rbp-34h]\n\n  v7 = &default_quoting_options;\n  if ( o )\n    v7 = o;\n  v8 = __errno_location();\n  v10 = *v8;\n  result = quotearg_buffer_restyled(\n             buffer,\n             buffersize,\n             arg,\n             argsize,\n             v7->style,\n             v7->flags,\n             v7->quote_these_too,\n             v7->left_quote,\n             v7->right_quote);\n  *v8 = v10;\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_buffer_restyled",
            "funcStartAddr": "0x4031a0",
            "funcEndAddr": "0x4049d8",
            "decompiledFuncCode": "size_t __fastcall quotearg_buffer_restyled(\n        char *buffer,\n        size_t buffersize,\n        const char *arg,\n        size_t argsize,\n        unsigned int quoting_style,\n        int flags,\n        const unsigned int *quote_these_too,\n        char *left_quote,\n        char *right_quote)\n{\n  size_t v13; // rdx\n  char v14; // r13\n  int v15; // r10d\n  size_t v16; // rax\n  quoting_style v17; // ecx\n  __int64 v18; // rbx\n  __int64 v19; // rsi\n  char *v20; // rdi\n  size_t v21; // r8\n  size_t v22; // r11\n  char v23; // al\n  __int16 *v24; // rax\n  int v25; // ebx\n  int v26; // ebx\n  unsigned __int64 v27; // rdx\n  char v28; // al\n  int v29; // r14d\n  size_t v30; // rax\n  __int64 v31; // r14\n  size_t v32; // rbp\n  unsigned __int64 v33; // r9\n  size_t i; // r11\n  char *v35; // rdi\n  int v36; // edx\n  unsigned __int64 v37; // r13\n  const char *v38; // r15\n  int v39; // ecx\n  int v40; // ecx\n  size_t v41; // rax\n  char v42; // al\n  __int64 v43; // r12\n  size_t v44; // rax\n  size_t v45; // r12\n  const char *v46; // rdi\n  size_t v47; // rbx\n  char v48; // r15\n  size_t v49; // rax\n  bool v50; // bl\n  char v51; // cl\n  char v52; // si\n  char v53; // dl\n  const char *v54; // rax\n  size_t v55; // r15\n  char v56; // r12\n  unsigned __int64 v57; // rbx\n  unsigned __int64 v58; // rcx\n  const char *v59; // r13\n  unsigned __int64 v60; // r14\n  bool v61; // al\n  size_t v62; // rax\n  size_t v63; // rcx\n  size_t v64; // rdx\n  bool v65; // zf\n  char v66; // al\n  int v67; // ecx\n  const unsigned __int16 **v68; // rax\n  const unsigned __int16 *v69; // rax\n  unsigned __int64 v70; // rcx\n  int v71; // eax\n  unsigned __int64 v72; // r14\n  unsigned __int64 v73; // rbp\n  const char *v74; // rsi\n  unsigned __int64 v75; // r13\n  size_t v76; // rbx\n  __int64 v77; // rsi\n  __int64 v78; // rcx\n  unsigned __int64 v79; // rdx\n  unsigned __int64 v80; // rdx\n  __int64 v81; // rsi\n  size_t v82; // rax\n  unsigned int v83; // ecx\n  size_t v84; // rax\n  unsigned __int64 v85; // rax\n  int v86; // ecx\n  int v87; // eax\n  quoting_style v88; // ebp\n  int v89; // r13d\n  size_t v90; // r15\n  unsigned __int64 v91; // r12\n  int v92; // edx\n  char v93; // al\n  char *v94; // rcx\n  char v96; // [rsp+Eh] [rbp-FAh]\n  char v97; // [rsp+Fh] [rbp-F9h]\n  int v98; // [rsp+10h] [rbp-F8h]\n  unsigned __int64 v99; // [rsp+10h] [rbp-F8h]\n  int v100; // [rsp+10h] [rbp-F8h]\n  int v101; // [rsp+1Ch] [rbp-ECh]\n  char v102; // [rsp+23h] [rbp-E5h]\n  quoting_style v103; // [rsp+24h] [rbp-E4h]\n  char v104; // [rsp+2Bh] [rbp-DDh]\n  unsigned __int8 v105; // [rsp+2Ch] [rbp-DCh]\n  bool v106; // [rsp+2Dh] [rbp-DBh]\n  char v107; // [rsp+2Eh] [rbp-DAh]\n  unsigned __int8 v108; // [rsp+2Fh] [rbp-D9h]\n  size_t n; // [rsp+30h] [rbp-D8h]\n  __int16 *s2; // [rsp+38h] [rbp-D0h]\n  size_t v113; // [rsp+50h] [rbp-B8h]\n  __int64 v114; // [rsp+58h] [rbp-B0h]\n  int v115; // [rsp+58h] [rbp-B0h]\n  unsigned __int64 v116; // [rsp+60h] [rbp-A8h]\n  size_t v117; // [rsp+68h] [rbp-A0h]\n  char *v118; // [rsp+70h] [rbp-98h]\n  char *v119; // [rsp+70h] [rbp-98h]\n  int v122; // [rsp+8Ch] [rbp-7Ch]\n  char v123; // [rsp+90h] [rbp-78h]\n  size_t v124; // [rsp+98h] [rbp-70h]\n  bool v125; // [rsp+A0h] [rbp-68h]\n  int v126; // [rsp+A4h] [rbp-64h]\n  int v127; // [rsp+A8h] [rbp-60h]\n  wchar_t pwc; // [rsp+ACh] [rbp-5Ch] BYREF\n  const char *v129; // [rsp+B0h] [rbp-58h]\n  size_t v130; // [rsp+B8h] [rbp-50h]\n  mbstate_t ps; // [rsp+C0h] [rbp-48h] BYREF\n  size_t mb_cur_max; // [rsp+C8h] [rbp-40h]\n  __int64 v133; // [rsp+D0h] [rbp-38h]\n\n  mb_cur_max = __ctype_get_mb_cur_max();\n  v14 = (flags & 2) != 0;\n  v127 = flags & 1;\n  v122 = flags;\n  v126 = flags & 4;\n  LOBYTE(v15) = 1;\n  v117 = 0LL;\n  s2 = 0LL;\n  n = 0LL;\n  v113 = 0LL;\n  v101 = 0;\n  v123 = 0;\nLABEL_2:\n  v16 = quoting_style;\n  v17 = literal_quoting_style;\n  v18 = 0LL;\n  v19 = 0LL;\n  v20 = buffer;\n  v21 = buffersize;\n  v22 = argsize;\n  switch ( quoting_style )\n  {\n    case 0u:\n      goto LABEL_53;\n    case 1u:\n      goto LABEL_10;\n    case 2u:\n      v23 = x_31;\n      if ( y_32 < 10 )\n        goto LABEL_17;\n      goto LABEL_16;\n    case 3u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\nLABEL_10:\n      v14 = 1;\n      goto LABEL_11;\n    case 4u:\nLABEL_11:\n      v23 = x_31;\n      if ( y_32 >= 10 )\n      {\n        v13 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      LOBYTE(v13) = 1;\n      if ( (v14 & 1) != 0 )\n        v13 = v113;\n      v113 = v13;\n      if ( y_32 >= 10 )\n      {\nLABEL_16:\n        if ( ((v23 * (v23 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\nLABEL_17:\n      v17 = shell_always_quoting_style;\n      if ( (v14 & 1) != 0 )\n      {\n        v18 = 0LL;\n        v24 = &asc_409A34[2];\nLABEL_35:\n        s2 = v24;\n        n = 1LL;\n        LOBYTE(v19) = v14;\n        goto LABEL_53;\n      }\n      if ( !buffersize || (*buffer = 39, y_32 < 10) )\n      {\n        v18 = 1LL;\n        v24 = asc_409A34 + 4;\n        goto LABEL_35;\n      }\n      do\n      {\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n          break;\n        *buffer = 39;\n      }\n      while ( y_32 >= 10 );\n      v18 = 1LL;\n      s2 = &asc_409A34[2];\n      n = 1LL;\n      LOBYTE(v19) = v14;\n      v17 = shell_always_quoting_style;\n      goto LABEL_53;\n    case 5u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = c_quoting_style;\n      if ( (v14 & 1) != 0 )\n      {\n        v18 = 0LL;\n      }\n      else\n      {\n        if ( buffersize )\n          *buffer = 34;\n        v18 = 1LL;\n      }\n      v24 = asc_409A34;\n      goto LABEL_35;\n    case 6u:\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = c_quoting_style;\n      v18 = 0LL;\n      s2 = asc_409A34;\n      n = 1LL;\n      LOBYTE(v19) = 1;\n      goto LABEL_53;\n    case 7u:\n      v18 = 0LL;\n      LOBYTE(v16) = 1;\n      v113 = v16;\n      v17 = escape_quoting_style;\n      v19 = 0LL;\n      if ( y_32 >= 10 )\n      {\n        v17 = escape_quoting_style;\n        v19 = 0LL;\n        if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      goto LABEL_53;\n    case 8u:\n    case 9u:\n      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n        goto LABEL_36;\n      break;\n    case 0xAu:\n      goto LABEL_40;\n    default:\n      abort();\n  }\n  while ( 1 )\n  {\n    v26 = v15;\n    gettext_quote((const char *)&asc_409A34[1], (quoting_style)quoting_style);\n    gettext_quote((const char *)&asc_409A34[2], (quoting_style)quoting_style);\n    v15 = v26;\nLABEL_36:\n    v25 = v15;\n    left_quote = (char *)gettext_quote((const char *)&asc_409A34[1], (quoting_style)quoting_style);\n    v19 = quoting_style;\n    right_quote = (char *)gettext_quote((const char *)&asc_409A34[2], (quoting_style)quoting_style);\n    if ( y_32 < 10 )\n      break;\n    v20 = buffer;\n    v21 = buffersize;\n    v15 = v25;\n    if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n      goto LABEL_40;\n  }\n  v20 = buffer;\n  v21 = buffersize;\n  v15 = v25;\nLABEL_40:\n  if ( (v14 & 1) != 0 )\n  {\n    v118 = left_quote;\n    v29 = v15;\n    v18 = 0LL;\n  }\n  else\n  {\n    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      goto LABEL_369;\n    v27 = 0LL;\n    while ( 1 )\n    {\n      v28 = left_quote[v27];\n      if ( !v28 )\n        break;\n      if ( v27 < v21 )\n        v20[v27] = v28;\n      ++v27;\n      if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\nLABEL_369:\n          ;\n      }\n    }\n    v118 = left_quote;\n    v18 = v27;\n    v29 = v15;\n  }\n  v30 = strlen(right_quote);\n  n = v30;\n  LOBYTE(v30) = 1;\n  v113 = v30;\n  s2 = (__int16 *)right_quote;\n  LOBYTE(v19) = v14;\n  v21 = buffersize;\n  v22 = argsize;\n  v15 = v29;\n  v17 = quoting_style;\n  left_quote = v118;\nLABEL_53:\n  v119 = left_quote;\n  v31 = (unsigned int)x_31;\n  if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  LODWORD(v32) = v113;\n  v97 = v113 & 1;\n  v108 = v113 & 1 & (v17 != shell_always_quoting_style);\n  v105 = v19 & 1 & (v17 == shell_always_quoting_style);\n  v96 = v19 & 1;\n  v103 = v17;\n  v33 = v22;\n  i = v18;\n  v35 = buffer;\n  v107 = v19 & 1 & (quote_these_too != 0LL);\n  v36 = y_32;\n  v106 = v17 != shell_always_quoting_style || (v19 & 1) == 0;\n  v133 = v19;\n  v104 = (n != 0) & v19 & v113;\n  v37 = 0LL;\n  v38 = arg;\n  while ( 1 )\n  {\n    v100 = v36;\n    if ( v33 == -1LL )\n    {\n      if ( !v38[v37] )\n      {\n        v33 = -1LL;\n        goto LABEL_356;\n      }\n    }\n    else if ( v37 == v33 )\n    {\n      v33 = v37;\nLABEL_356:\n      v13 = (unsigned int)v103;\n      if ( v96 && i == 0 && v103 == shell_always_quoting_style )\n        goto LABEL_394;\n      if ( (v123 & 1) == 0 || v96 != 0 || v103 != shell_always_quoting_style )\n      {\nLABEL_402:\n        v92 = v100;\n        if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( s2 )\n        {\n          if ( !v96 )\n          {\n            v93 = *(_BYTE *)s2;\n            if ( *(_BYTE *)s2 )\n            {\n              v94 = (char *)s2 + 1;\n              do\n              {\n                if ( i < v21 )\n                {\n                  v35[i] = v93;\n                  LOBYTE(v31) = x_31;\n                  v92 = y_32;\n                }\n                if ( v92 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                ++i;\n                v93 = *v94++;\n              }\n              while ( v93 );\n            }\n          }\n        }\n        if ( v92 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( i < v21 )\n        {\n          do\n            v35[i] = 0;\n          while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n        }\n        return i;\n      }\n      if ( (v15 & 1) != 0 )\n        return quotearg_buffer_restyled(v35, v117, v38, v33, c_quoting_style, v122, quote_these_too, v119, right_quote);\n      if ( !v117 || v21 )\n        goto LABEL_402;\n      argsize = v33;\n      quoting_style = v103;\n      v14 = v133;\n      buffersize = v117;\n      left_quote = v119;\n      if ( v100 >= 10 )\n      {\n        quoting_style = v103;\n        v14 = v133;\n        buffersize = v117;\n        if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n      }\n      goto LABEL_2;\n    }\n    if ( (v108 & (n != 0)) == 0 )\n    {\nLABEL_112:\n      v50 = 0;\n      goto LABEL_113;\n    }\n    v45 = v37 + n;\n    if ( n >= 2 && v33 == -1LL )\n    {\n      v46 = v38;\n      v47 = v21;\n      v48 = v15;\n      v32 = i;\n      v49 = strlen(v46);\n      v36 = v100;\n      i = v32;\n      LOBYTE(v15) = v48;\n      v21 = v47;\n      v38 = arg;\n      v35 = buffer;\n      v33 = v49;\n      if ( v45 > v49 )\n        goto LABEL_112;\n    }\n    else\n    {\n      if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( v45 > v33 )\n        goto LABEL_112;\n    }\n    if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    v114 = v31;\n    v54 = v38;\n    v55 = i;\n    v56 = v15;\n    v57 = v33;\n    v32 = v21;\n    v58 = v37;\n    v59 = v54;\n    v60 = v58;\n    v61 = memcmp(&v54[v58], s2, n) == 0;\n    if ( !v61 )\n    {\n      v35 = buffer;\n      v21 = v32;\n      v33 = v57;\n      LOBYTE(v15) = v56;\n      i = v55;\n      v38 = v59;\n      v37 = v60;\n      v50 = v61;\n      v31 = v114;\n      if ( v100 < 10 )\n        goto LABEL_115;\n      goto LABEL_114;\n    }\n    v40 = 16;\n    v35 = buffer;\n    v21 = v32;\n    v33 = v57;\n    LOBYTE(v15) = v56;\n    i = v55;\n    v38 = v59;\n    v37 = v60;\n    v50 = v61;\n    v31 = v114;\n    v36 = v100;\n    if ( v96 )\n    {\nLABEL_58:\n      LOBYTE(v32) = v15;\n      if ( v36 < 10 )\n        goto LABEL_72;\n      goto LABEL_71;\n    }\nLABEL_113:\n    if ( v36 < 10 )\n      goto LABEL_115;\nLABEL_114:\n    if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\nLABEL_115:\n    v43 = (unsigned __int8)v38[v37];\n    LOBYTE(v32) = 1;\n    v51 = 116;\n    v52 = 98;\n    v53 = 0;\n    v42 = 0;\n    switch ( v38[v37] )\n    {\n      case 0:\n        if ( !v97 )\n        {\n          v40 = 15;\n          v36 = v100;\n          if ( v127 )\n            goto LABEL_58;\n          LOBYTE(v43) = 0;\n          goto LABEL_245;\n        }\n        v40 = 16;\n        v36 = v100;\n        if ( v96 )\n          goto LABEL_58;\n        if ( v103 == shell_always_quoting_style && (v101 & 1) == 0 )\n        {\n          if ( i < v21 )\n          {\n            v35[i] = 39;\n            LOBYTE(v31) = x_31;\n            v36 = y_32;\n          }\n          if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( i + 1 < v21 )\n          {\n            do\n              v35[i + 1] = 36;\n            while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n          }\n          v62 = i + 2;\n          if ( i + 2 < v21 )\n            v35[v62] = 39;\n          i += 3LL;\n          LOBYTE(v62) = 1;\n          v101 = v62;\n        }\n        v63 = i;\n        if ( i < v21 )\n          v35[i] = 92;\n        ++i;\n        v42 = 1;\n        LOBYTE(v43) = 48;\n        if ( v103 == shell_always_quoting_style )\n          goto LABEL_246;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( v37 + 1 >= v33 || (unsigned __int8)(v38[v37 + 1] - 48) > 9u )\n          goto LABEL_246;\n        if ( i < v21 )\n          v35[i] = 48;\n        if ( v63 + 2 < v21 )\n          v35[v63 + 2] = 48;\n        LODWORD(v32) = 0;\n        i = v63 + 3;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      case 7:\n        v52 = 97;\n        goto LABEL_207;\n      case 8:\n        goto LABEL_207;\n      case 9:\n        goto LABEL_206;\n      case 0xA:\n        v51 = 110;\n        goto LABEL_206;\n      case 0xB:\n        v52 = 118;\n        goto LABEL_207;\n      case 0xC:\n        v52 = 102;\n        goto LABEL_207;\n      case 0xD:\n        v51 = 114;\n        goto LABEL_206;\n      case 0x20:\n        goto LABEL_193;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2A:\n      case 0x3B:\n      case 0x3C:\n      case 0x3D:\n      case 0x3E:\n      case 0x5B:\n      case 0x5E:\n      case 0x60:\n      case 0x7C:\n        goto LABEL_194;\n      case 0x23:\n      case 0x7E:\n        if ( !v37 )\n          goto LABEL_193;\n        goto LABEL_245;\n      case 0x25:\n      case 0x2B:\n      case 0x2C:\n      case 0x2D:\n      case 0x2E:\n      case 0x2F:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3A:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4A:\n      case 0x4B:\n      case 0x4C:\n      case 0x4D:\n      case 0x4E:\n      case 0x4F:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5A:\n      case 0x5D:\n      case 0x5F:\n      case 0x61:\n      case 0x62:\n      case 0x63:\n      case 0x64:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6A:\n      case 0x6B:\n      case 0x6C:\n      case 0x6D:\n      case 0x6E:\n      case 0x6F:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7A:\n        goto LABEL_116;\n      case 0x27:\n        LOBYTE(v43) = 39;\n        if ( v103 == shell_always_quoting_style )\n        {\n          if ( v96 )\n          {\n            v40 = 16;\n            v123 = 1;\n            goto LABEL_270;\n          }\n          v64 = v117;\n          v65 = v21 != 0 && v117 == 0;\n          if ( v21 != 0 && v117 == 0 )\n            v64 = v21;\n          v117 = v64;\n          if ( v65 )\n            v21 = 0LL;\n          if ( i < v21 )\n            v35[i] = 39;\n          if ( i + 1 < v21 )\n            v35[i + 1] = 92;\n          v66 = x_31;\n          v67 = y_32;\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( i + 2 < v21 )\n          {\n            do\n            {\n              v35[i + 2] = 39;\n              v66 = x_31;\n              v67 = y_32;\n            }\n            while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n          }\n          if ( v67 >= 10 && ((v66 * (v66 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          i += 3LL;\n          v123 = 1;\n          v101 = 0;\n        }\n        else\n        {\n          v123 = 1;\n        }\n        v42 = 0;\n        LOBYTE(v32) = 1;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      case 0x3F:\n        LOBYTE(v43) = 63;\n        if ( v103 == c_quoting_style )\n        {\n          if ( v126 && v37 + 2 < v33 && v38[v37 + 1] == 63 )\n          {\n            v80 = (unsigned int)v38[v37 + 2];\n            v42 = 0;\n            if ( (unsigned int)v80 <= 0x3E )\n            {\n              v81 = 0x7000A38200000000LL;\n              if ( _bittest64(&v81, v80) )\n              {\n                if ( !v96 )\n                {\n                  if ( i < v21 )\n                  {\n                    do\n                    {\n                      v35[i] = 63;\n                      LOBYTE(v31) = x_31;\n                      v100 = y_32;\n                    }\n                    while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                  }\n                  if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                  {\n                    while ( 1 )\n                      ;\n                  }\n                  if ( i + 1 < v21 )\n                    v35[i + 1] = 34;\n                  v82 = i + 2;\n                  if ( i + 2 < v21 )\n                  {\n                    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n                      goto LABEL_62;\n                    while ( 1 )\n                    {\n                      v35[v82] = 34;\n                      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                        break;\nLABEL_62:\n                      v35[v82] = 34;\n                    }\n                  }\n                  v41 = i + 3;\n                  if ( i + 3 < v21 )\n                  {\n                    if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n                      goto LABEL_68;\n                    while ( 1 )\n                    {\n                      v35[v41] = 63;\n                      if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                        break;\nLABEL_68:\n                      v35[v41] = 63;\n                    }\n                  }\n                  i += 4LL;\n                  v42 = 0;\n                  v37 += 2LL;\n                  LOBYTE(v43) = v80;\n                  goto LABEL_246;\n                }\n                goto LABEL_267;\n              }\n            }\n          }\n          else\n          {\nLABEL_245:\n            v42 = 0;\n          }\nLABEL_246:\n          LODWORD(v32) = 0;\n          if ( v108 )\n            goto LABEL_117;\n          goto LABEL_247;\n        }\n        if ( v103 != shell_always_quoting_style )\n          goto LABEL_245;\n        v40 = 16;\n        if ( !v96 )\n          goto LABEL_245;\nLABEL_270:\n        LOBYTE(v32) = v15;\n        v36 = v100;\n        if ( v100 >= 10 )\n          break;\n        goto LABEL_72;\n      case 0x5C:\n        if ( v103 == shell_always_quoting_style )\n        {\n          v40 = 16;\n          if ( v96 )\n            goto LABEL_270;\n          LOBYTE(v43) = 92;\n          v42 = 0;\n          goto LABEL_205;\n        }\n        v51 = 92;\n        if ( v104 )\n        {\n          v42 = 0;\n          LOBYTE(v43) = 92;\nLABEL_205:\n          LODWORD(v32) = 0;\n          goto LABEL_345;\n        }\nLABEL_206:\n        v52 = v51;\n        if ( !v106 )\n        {\nLABEL_267:\n          LOBYTE(v32) = v15;\n          v36 = v100;\n          v40 = 16;\n          if ( v100 >= 10 )\n            break;\n          goto LABEL_72;\n        }\nLABEL_207:\n        v42 = 0;\n        LODWORD(v32) = 0;\n        if ( v97 )\n          goto LABEL_253;\nLABEL_116:\n        if ( !v108 )\n          goto LABEL_247;\nLABEL_117:\n        if ( !quote_these_too )\n          goto LABEL_250;\nLABEL_248:\n        v83 = quote_these_too[(unsigned __int8)v43 >> 5];\n        if ( _bittest((const int *)&v83, (unsigned __int8)v43) )\n        {\n          v52 = v43;\nLABEL_253:\n          v31 = (unsigned int)x_31;\n          v40 = 16;\n          v36 = y_32;\n          if ( v96 )\n            goto LABEL_58;\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( v103 == shell_always_quoting_style )\n          {\n            v39 = v101;\n            if ( (v101 & 1) == 0 )\n            {\n              if ( i < v21 )\n              {\n                do\n                {\n                  v35[i] = 39;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                }\n                while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n              }\n              v84 = i + 1;\n              if ( i + 1 < v21 )\n              {\n                if ( v36 >= 10 )\n                {\n                  v39 = ((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1;\n                  if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                    goto LABEL_77;\n                }\n                while ( 1 )\n                {\n                  v35[v84] = 36;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                  if ( y_32 < 10 )\n                    break;\n                  v39 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                    break;\nLABEL_77:\n                  v35[v84] = 36;\n                }\n              }\n              v44 = i + 2;\n              if ( i + 2 < v21 )\n              {\n                if ( v36 >= 10 )\n                {\n                  v39 = ((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1;\n                  if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                    goto LABEL_83;\n                }\n                while ( 1 )\n                {\n                  v35[v44] = 39;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                  if ( y_32 < 10 )\n                    break;\n                  v39 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n                    break;\nLABEL_83:\n                  v35[v44] = 39;\n                }\n              }\n              i += 3LL;\n              LOBYTE(v39) = 1;\n            }\n            if ( v36 >= 10 )\n            {\nLABEL_86:\n              if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n            }\n          }\n          else\n          {\n            v39 = v101;\n            if ( y_32 >= 10 )\n              goto LABEL_86;\n          }\n          if ( i < v21 )\n            v35[i] = 92;\n          ++i;\n          LOBYTE(v43) = v52;\n          goto LABEL_90;\n        }\nLABEL_250:\n        LOBYTE(v31) = x_31;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        v100 = y_32;\n        v52 = v43;\n        if ( v50 )\n          goto LABEL_253;\nLABEL_345:\n        v39 = v101;\n        if ( (v101 & 1) != 0 )\n        {\n          v65 = (v42 & 1) == 0;\n          v87 = v100;\n          if ( v65 )\n          {\n            if ( i < v21 )\n            {\n              v35[i] = 39;\n              LOBYTE(v31) = x_31;\n              v87 = y_32;\n            }\n            if ( v87 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            if ( i + 1 < v21 )\n            {\n              do\n                v35[i + 1] = 39;\n              while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n            }\n            i += 2LL;\n            v39 = 0;\n          }\n        }\nLABEL_90:\n        v31 = (unsigned int)x_31;\n        v36 = y_32;\n        if ( i >= v21 )\n          goto LABEL_96;\n        if ( y_32 < 10 || (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n          goto LABEL_93;\n        do\n        {\n          v35[i] = v43;\nLABEL_93:\n          v35[i] = v43;\n          v31 = (unsigned int)x_31;\n          v36 = y_32;\n        }\n        while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\nLABEL_96:\n        v101 = v39;\n        ++i;\n        LOBYTE(v32) = v15 & -(char)v32;\n        v40 = 0;\n        if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( v36 < 10 )\n          goto LABEL_72;\n        break;\n      case 0x7B:\n      case 0x7D:\n        v42 = 0;\n        if ( v33 == -1LL )\n        {\n          if ( v37 || v38[1] )\n          {\n            v33 = -1LL;\n            goto LABEL_246;\n          }\n        }\n        else if ( v37 || v33 != 1 )\n        {\n          goto LABEL_246;\n        }\nLABEL_193:\n        v53 = 1;\nLABEL_194:\n        if ( v103 == shell_always_quoting_style )\n        {\n          v40 = 16;\n          if ( v96 )\n            goto LABEL_270;\n        }\n        v42 = 0;\n        LOBYTE(v32) = v53;\n        if ( v108 )\n          goto LABEL_117;\n        goto LABEL_247;\n      default:\n        v124 = i;\n        v102 = v15;\n        v130 = v21;\n        if ( mb_cur_max == 1 )\n        {\n          v32 = v33;\n          v68 = __ctype_b_loc();\n          v33 = v32;\n          v69 = *v68;\n          LODWORD(v32) = v69[v43] >> 14;\n          LOBYTE(v32) = (v69[v43] & 0x4000) != 0;\n          v70 = 1LL;\n          v36 = v100;\n          goto LABEL_287;\n        }\n        v125 = v50;\n        ps = 0LL;\n        if ( v33 == -1LL )\n          v33 = strlen(v38);\n        v71 = (_DWORD)v38 + v37;\n        v129 = &v38[v37];\n        LOBYTE(v71) = 1;\n        v70 = 0LL;\n        v116 = v37;\n        while ( 2 )\n        {\n          v98 = v71;\n          v72 = v70;\n          v73 = v70 + v37;\n          v74 = &v38[v70 + v37];\n          v75 = v33;\n          v76 = rpl_mbrtowc(&pwc, v74, v33 - v73, &ps);\n          if ( !v76 )\n          {\n            v38 = arg;\n            v33 = v75;\n            v37 = v116;\n            v70 = v72;\n            LODWORD(v32) = v98;\nLABEL_281:\n            v115 = 0;\n            goto LABEL_282;\n          }\n          if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n          {\n            while ( 1 )\n              ;\n          }\n          if ( v76 == -1LL )\n          {\n            LODWORD(v32) = 0;\n            v38 = arg;\n            v33 = v75;\nLABEL_280:\n            v37 = v116;\n            v70 = v72;\n            goto LABEL_281;\n          }\n          v33 = v75;\n          if ( v76 == -2LL )\n          {\n            if ( v75 > v73 )\n            {\n              v38 = arg;\n              v37 = v116;\n              v70 = v72;\n              do\n              {\n                if ( !v129[v70] )\n                  break;\n                v85 = v116 + v70++ + 1;\n              }\n              while ( v85 < v33 );\n              LODWORD(v32) = 0;\n              goto LABEL_281;\n            }\n            LODWORD(v32) = 0;\n            v38 = arg;\n            goto LABEL_280;\n          }\n          v77 = 0x20000002BLL;\n          if ( (v105 & (v76 > 1)) != 1 )\n          {\nLABEL_222:\n            v115 = 0;\n            LODWORD(v32) = 0;\n            if ( iswprint(pwc) )\n              LODWORD(v32) = v98;\n            v71 = mbsinit(&ps);\n            v70 = v76 + v72;\n            v65 = v71 == 0;\n            LOBYTE(v71) = v32;\n            v38 = arg;\n            v33 = v75;\n            v37 = v116;\n            if ( !v65 )\n              goto LABEL_282;\n            continue;\n          }\n          break;\n        }\n        v78 = 1LL;\n        while ( 1 )\n        {\n          v79 = (unsigned int)(v129[v72 + v78] - 91);\n          if ( (unsigned int)v79 <= 0x21 )\n          {\n            if ( _bittest64(&v77, v79) )\n              break;\n          }\n          if ( ++v78 >= v76 )\n            goto LABEL_222;\n        }\n        v115 = 16;\n        LODWORD(v32) = v98;\n        v38 = arg;\n        v37 = v116;\n        v70 = v72;\nLABEL_282:\n        v31 = (unsigned int)x_31;\n        v36 = y_32;\n        if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        v50 = v125;\n        if ( v115 )\n        {\n          LOBYTE(v32) = v102;\n          v35 = buffer;\n          v21 = v130;\n          i = v124;\n          v40 = v115;\n          if ( y_32 >= 10 )\n            break;\n          goto LABEL_72;\n        }\nLABEL_287:\n        LOBYTE(v15) = v102;\n        if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n        {\n          while ( 1 )\n            ;\n        }\n        LOBYTE(v32) = v32 & 1;\n        v21 = v130;\n        if ( v70 > 1 || !(((v113 & 1) == 0) | (unsigned __int8)v32) )\n        {\n          v99 = v37 + v70;\n          v42 = 0;\n          v35 = buffer;\n          for ( i = v124; ; ++i )\n          {\n            v86 = v101;\n            if ( !v97 )\n              goto LABEL_430;\n            if ( v36 >= 10 )\n            {\n              v86 = v101;\n              if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n            }\n            if ( !(_BYTE)v32 )\n            {\n              if ( v96 )\n              {\n                v40 = 16;\n                goto LABEL_58;\n              }\n              if ( v103 == shell_always_quoting_style && (v86 & 1) == 0 )\n              {\n                if ( i < v21 )\n                {\n                  do\n                  {\n                    buffer[i] = 39;\n                    LOBYTE(v31) = x_31;\n                    v36 = y_32;\n                  }\n                  while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                }\n                if ( i + 1 < v21 )\n                {\n                  buffer[i + 1] = 36;\n                  LOBYTE(v31) = x_31;\n                  v36 = y_32;\n                }\n                if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                if ( i + 2 < v21 )\n                {\n                  do\n                  {\n                    buffer[i + 2] = 39;\n                    LOBYTE(v31) = x_31;\n                    v36 = y_32;\n                    if ( y_32 < 10 )\n                      break;\n                    v86 = ((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1;\n                  }\n                  while ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n                }\n                if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                i += 3LL;\n                LOBYTE(v86) = 1;\n              }\n              if ( i < v21 )\n              {\n                buffer[i] = 92;\n                LOBYTE(v31) = x_31;\n                v36 = y_32;\n              }\n              if ( v36 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n              {\n                while ( 1 )\n                  ;\n              }\n              v101 = v86;\n              if ( i + 1 < v21 )\n              {\n                do\n                  buffer[i + 1] = ((unsigned __int8)v43 >> 6) | 0x30;\n                while ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 );\n              }\n              if ( i + 2 < v21 )\n                buffer[i + 2] = ((unsigned __int8)v43 >> 3) & 7 | 0x30;\n              i += 3LL;\n              LOBYTE(v43) = v43 & 7 | 0x30;\n              v42 = 1;\n            }\n            else\n            {\nLABEL_430:\n              if ( v50 )\n              {\n                if ( i < v21 )\n                  buffer[i] = 92;\n                ++i;\n                v50 = 0;\n              }\n            }\n            LOBYTE(v31) = x_31;\n            if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            if ( v99 <= v37 + 1 )\n              break;\n            if ( (v101 & 1) != 0 && (v42 & 1) == 0 )\n            {\n              if ( i < v21 )\n                buffer[i] = 39;\n              if ( i + 1 < v21 )\n                buffer[i + 1] = 39;\n              i += 2LL;\n              v101 = 0;\n            }\n            if ( i < v21 )\n              buffer[i] = v43;\n            v31 = (unsigned int)x_31;\n            v36 = y_32;\n            if ( y_32 >= 10 && (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) != 0 )\n            {\n              while ( 1 )\n                ;\n            }\n            LOBYTE(v43) = v38[++v37];\n          }\n          v100 = y_32;\n          goto LABEL_345;\n        }\n        v42 = 0;\n        v35 = buffer;\n        i = v124;\n        if ( v108 )\n          goto LABEL_117;\nLABEL_247:\n        if ( v107 )\n          goto LABEL_248;\n        goto LABEL_250;\n    }\nLABEL_71:\n    if ( (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\nLABEL_72:\n    if ( v40 && v40 != 15 )\n      break;\n    ++v37;\n    v15 = v32;\n  }\n  v100 = v36;\n  LODWORD(v13) = v103;\nLABEL_394:\n  v88 = shell_escape_always_quoting_style;\n  if ( !v97 )\n    v88 = (int)v13;\n  if ( (_DWORD)v13 != 2 )\n    v88 = (int)v13;\n  v89 = v122 & 0xFFFFFFFD;\n  v90 = v21;\n  v91 = v33;\n  if ( v100 >= 10 && (((_BYTE)v31 * ((_BYTE)v31 - 1)) & 1) != 0 )\n    goto LABEL_426;\n  while ( 1 )\n  {\n    i = quotearg_buffer_restyled(v35, v21, arg, v33, v88, v89, 0LL, v119, right_quote);\n    if ( y_32 < 10 )\n      break;\n    v35 = buffer;\n    v21 = v90;\n    v33 = v91;\n    if ( (((_BYTE)x_31 * ((_BYTE)x_31 - 1)) & 1) == 0 )\n      break;\nLABEL_426:\n    quotearg_buffer_restyled(v35, v21, arg, v33, v88, v89, 0LL, v119, right_quote);\n    v33 = v91;\n    v21 = v90;\n    v35 = buffer;\n  }\n  return i;\n}\n"
        },
        {
            "funcName": "quotearg_alloc",
            "funcStartAddr": "0x4049e0",
            "funcEndAddr": "0x404aa1",
            "decompiledFuncCode": "char *__fastcall quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o)\n{\n  const quoting_options *v3; // r14\n  int v4; // ebp\n  size_t v5; // rbx\n  char *v6; // r13\n  int v8; // [rsp+4h] [rbp-44h]\n  int *v9; // [rsp+10h] [rbp-38h]\n\n  v3 = &default_quoting_options;\n  if ( o )\n    v3 = o;\n  v9 = __errno_location();\n  v8 = *v9;\n  v4 = v3->flags | 1;\n  v5 = quotearg_buffer_restyled(\n         0LL,\n         0LL,\n         arg,\n         argsize,\n         v3->style,\n         v4,\n         v3->quote_these_too,\n         (char *)v3->left_quote,\n         (char *)v3->right_quote)\n     + 1;\n  v6 = (char *)xmalloc(v5);\n  quotearg_buffer_restyled(\n    v6,\n    v5,\n    arg,\n    argsize,\n    v3->style,\n    v4,\n    v3->quote_these_too,\n    (char *)v3->left_quote,\n    (char *)v3->right_quote);\n  *v9 = v8;\n  return v6;\n}\n"
        },
        {
            "funcName": "quotearg_alloc_mem",
            "funcStartAddr": "0x404ab0",
            "funcEndAddr": "0x404b9c",
            "decompiledFuncCode": "char *__fastcall quotearg_alloc_mem(const char *arg, size_t argsize, size_t *size, const quoting_options *o)\n{\n  const quoting_options *v5; // r12\n  int v6; // ebp\n  size_t v7; // rbx\n  char *v8; // r14\n  int v10; // [rsp+4h] [rbp-54h]\n  int *v12; // [rsp+20h] [rbp-38h]\n\n  v5 = &default_quoting_options;\n  if ( o )\n    v5 = o;\n  v12 = __errno_location();\n  v10 = *v12;\n  v6 = v5->flags | (size == 0LL);\n  v7 = quotearg_buffer_restyled(\n         0LL,\n         0LL,\n         arg,\n         argsize,\n         v5->style,\n         v6,\n         v5->quote_these_too,\n         (char *)v5->left_quote,\n         (char *)v5->right_quote);\n  v8 = (char *)xmalloc(v7 + 1);\n  quotearg_buffer_restyled(\n    v8,\n    v7 + 1,\n    arg,\n    argsize,\n    v5->style,\n    v6,\n    v5->quote_these_too,\n    (char *)v5->left_quote,\n    (char *)v5->right_quote);\n  *v12 = v10;\n  if ( size )\n    *size = v7;\n  return v8;\n}\n"
        },
        {
            "funcName": "quotearg_free",
            "funcStartAddr": "0x404ba0",
            "funcEndAddr": "0x404cf2",
            "decompiledFuncCode": "void __cdecl quotearg_free()\n{\n  slotvec *v0; // r14\n  char v1; // al\n  int v2; // ecx\n  void **p_val; // rbx\n  __int64 i; // r15\n  char *val; // rdi\n  char v6; // al\n  int v7; // ecx\n\n  v0 = slotvec_0;\n  if ( nslots >= 2 )\n  {\n    v1 = x_37;\n    v2 = y_38;\n    p_val = (void **)&slotvec_0[1].val;\n    for ( i = 1LL; i < nslots; ++i )\n    {\n      if ( v2 >= 10 && ((v1 * (v1 - 1)) & 1) != 0 )\nLABEL_7:\n        free(*p_val);\n      free(*p_val);\n      v1 = x_37;\n      v2 = y_38;\n      if ( y_38 >= 10 && (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) != 0 )\n        goto LABEL_7;\n      p_val += 2;\n    }\n  }\n  val = v0->val;\n  if ( val != slot0 )\n  {\n    free(val);\n    slotvec0.size = 256LL;\n    slotvec0.val = slot0;\n  }\n  v6 = x_37;\n  v7 = y_38;\n  if ( v0 != &slotvec0 )\n  {\n    if ( y_38 >= 10 && (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) != 0 )\n      goto LABEL_16;\n    while ( 1 )\n    {\n      free(v0);\n      slotvec_0 = &slotvec0;\n      v6 = x_37;\n      v7 = y_38;\n      if ( y_38 < 10 || (((_BYTE)x_37 * ((_BYTE)x_37 - 1)) & 1) == 0 )\n        break;\nLABEL_16:\n      free(v0);\n      slotvec_0 = &slotvec0;\n    }\n  }\n  if ( v7 >= 10 && ((v6 * (v6 - 1)) & 1) != 0 )\n    goto LABEL_21;\n  while ( 1 )\n  {\n    nslots = 1;\n    if ( v7 < 10 || ((v6 * (v6 - 1)) & 1) == 0 )\n      break;\nLABEL_21:\n    nslots = 1;\n  }\n}\n"
        },
        {
            "funcName": "quotearg_n",
            "funcStartAddr": "0x404d00",
            "funcEndAddr": "0x404d0e",
            "decompiledFuncCode": "char *__fastcall quotearg_n(int n, const char *arg)\n{\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_n_options",
            "funcStartAddr": "0x404d10",
            "funcEndAddr": "0x404f42",
            "decompiledFuncCode": "char *__fastcall quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options)\n{\n  const char *v6; // rbx\n  int *v8; // rax\n  slotvec *v9; // r15\n  slotvec *v10; // rdi\n  slotvec *v11; // rax\n  slotvec *v12; // r14\n  __int64 v13; // r13\n  size_t size; // r14\n  size_t v15; // r12\n  int *v16; // rax\n  int v17; // ecx\n  char *v18; // rbx\n  slotvec *v19; // rax\n  size_t v20; // r12\n  int v22; // [rsp+0h] [rbp-68h]\n  int v23; // [rsp+4h] [rbp-64h]\n  char *ptr; // [rsp+8h] [rbp-60h]\n  size_t v25; // [rsp+18h] [rbp-50h]\n  int *v26; // [rsp+20h] [rbp-48h]\n\n  v6 = arg;\n  if ( y_42 >= 10 && (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v8 = __errno_location();\n  if ( n < 0 )\n    abort();\n  v9 = slotvec_0;\n  v25 = argsize;\n  v26 = v8;\n  v22 = *v8;\n  if ( nslots <= n )\n  {\n    if ( n == 0x7FFFFFFF )\n      xalloc_die();\n    v10 = 0LL;\n    if ( slotvec_0 != &slotvec0 )\n      v10 = slotvec_0;\n    v11 = (slotvec *)xrealloc(v10, 16LL * n + 16);\n    v12 = v11;\n    slotvec_0 = v11;\n    if ( v9 == &slotvec0 )\n      *v11 = slotvec0;\n    memset(&v11[nslots], 0, 16 * (n + 1 - (__int64)nslots));\n    nslots = n + 1;\n    v9 = v12;\n    v6 = arg;\n  }\n  v13 = n;\n  size = v9[v13].size;\n  ptr = v9[v13].val;\n  v23 = options->flags | 1;\n  v15 = quotearg_buffer_restyled(\n          ptr,\n          size,\n          v6,\n          argsize,\n          options->style,\n          v23,\n          options->quote_these_too,\n          (char *)options->left_quote,\n          (char *)options->right_quote);\n  if ( size <= v15 )\n  {\n    v19 = &v9[v13];\n    v20 = v15 + 1;\n    if ( y_42 >= 10 && (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) != 0 )\n      goto LABEL_21;\n    while ( 1 )\n    {\n      v19->size = v20;\n      if ( y_42 < 10 || (((_BYTE)x_41 * ((_BYTE)x_41 - 1)) & 1) == 0 )\n        break;\nLABEL_21:\n      v19->size = v20;\n    }\n    if ( ptr != slot0 )\n      free(ptr);\n    v18 = (char *)xmalloc(v20);\n    v9[v13].val = v18;\n    quotearg_buffer_restyled(\n      v18,\n      v20,\n      arg,\n      v25,\n      options->style,\n      v23,\n      options->quote_these_too,\n      (char *)options->left_quote,\n      (char *)options->right_quote);\n    v16 = v26;\n    v17 = v22;\n  }\n  else\n  {\n    v16 = v26;\n    v17 = v22;\n    v18 = ptr;\n  }\n  *v16 = v17;\n  return v18;\n}\n"
        },
        {
            "funcName": "quotearg_n_mem",
            "funcStartAddr": "0x404f50",
            "funcEndAddr": "0x404f5a",
            "decompiledFuncCode": "char *__fastcall quotearg_n_mem(int n, const char *arg, size_t argsize)\n{\n  return quotearg_n_options(n, arg, argsize, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg",
            "funcStartAddr": "0x404f60",
            "funcEndAddr": "0x404f79",
            "decompiledFuncCode": "char *__fastcall quotearg(const char *arg)\n{\n  return quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_mem",
            "funcStartAddr": "0x404f80",
            "funcEndAddr": "0x404f98",
            "decompiledFuncCode": "char *__fastcall quotearg_mem(const char *arg, size_t argsize)\n{\n  return quotearg_n_options(0, arg, argsize, &default_quoting_options);\n}\n"
        },
        {
            "funcName": "quotearg_n_style",
            "funcStartAddr": "0x404fa0",
            "funcEndAddr": "0x4050b5",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style(int n, quoting_style s, const char *arg)\n{\n  __int128 *v4; // rcx\n  __int128 v5; // xmm0\n  __int128 v6; // xmm1\n  char *result; // rax\n  __int128 *v8; // rcx\n  __int128 v9; // xmm0\n  __int128 v10; // xmm1\n  __int128 v11; // [rsp+0h] [rbp-50h] BYREF\n  __int128 v12; // [rsp+10h] [rbp-40h]\n  __int128 v13; // [rsp+20h] [rbp-30h]\n  int v14; // [rsp+30h] [rbp-20h]\n\n  if ( y_50 >= 10 && (((_BYTE)x_49 * ((_BYTE)x_49 - 1)) & 1) != 0 )\n    goto LABEL_6;\n  while ( 1 )\n  {\n    v4 = &v11 - 4;\n    v13 = 0LL;\n    v12 = 0LL;\n    v11 = 0LL;\n    v14 = 0;\n    if ( s == custom_quoting_style )\n      abort();\n    *(_DWORD *)v4 = s;\n    *((_DWORD *)v4 + 13) = v14;\n    v5 = v11;\n    v6 = v12;\n    *(__int128 *)((char *)v4 + 36) = v13;\n    *(__int128 *)((char *)v4 + 20) = v6;\n    *(__int128 *)((char *)v4 + 4) = v5;\n    result = quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, (const quoting_options *)v4);\n    if ( y_50 < 10 || (((_BYTE)x_49 * ((_BYTE)x_49 - 1)) & 1) == 0 )\n      break;\nLABEL_6:\n    v8 = &v11 - 4;\n    v13 = 0LL;\n    v12 = 0LL;\n    v11 = 0LL;\n    v14 = 0;\n    if ( s == custom_quoting_style )\n      abort();\n    *(_DWORD *)v8 = s;\n    *((_DWORD *)v8 + 13) = v14;\n    v9 = v11;\n    v10 = v12;\n    *(__int128 *)((char *)v8 + 36) = v13;\n    *(__int128 *)((char *)v8 + 20) = v10;\n    *(__int128 *)((char *)v8 + 4) = v9;\n    quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, (const quoting_options *)v8);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_n_style_mem",
            "funcStartAddr": "0x4050c0",
            "funcEndAddr": "0x405128",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize)\n{\n  quoting_options options; // [rsp+40h] [rbp-38h] BYREF\n\n  if ( s == custom_quoting_style )\n    abort();\n  options.style = s;\n  memset(&options.flags, 0, 52);\n  return quotearg_n_options(n, arg, argsize, &options);\n}\n"
        },
        {
            "funcName": "quotearg_style",
            "funcStartAddr": "0x405130",
            "funcEndAddr": "0x405141",
            "decompiledFuncCode": "char *__fastcall quotearg_style(quoting_style s, const char *arg)\n{\n  return quotearg_n_style(0, s, arg);\n}\n"
        },
        {
            "funcName": "quotearg_style_mem",
            "funcStartAddr": "0x405150",
            "funcEndAddr": "0x4051b1",
            "decompiledFuncCode": "char *__fastcall quotearg_style_mem(quoting_style s, const char *arg, size_t argsize)\n{\n  quoting_options options; // [rsp+40h] [rbp-38h] BYREF\n\n  if ( s == custom_quoting_style )\n    abort();\n  options.style = s;\n  memset(&options.flags, 0, 52);\n  return quotearg_n_options(0, arg, argsize, &options);\n}\n"
        },
        {
            "funcName": "quotearg_char_mem",
            "funcStartAddr": "0x4051c0",
            "funcEndAddr": "0x4052e3",
            "decompiledFuncCode": "char *__fastcall quotearg_char_mem(const char *arg, size_t argsize, unsigned __int8 ch_0)\n{\n  char v3; // bl\n  __int64 v4; // r12\n  char *result; // rax\n  _DWORD v6[8]; // [rsp+0h] [rbp-20h] BYREF\n\n  v3 = ch_0 & 0x1F;\n  v4 = ch_0 >> 5;\n  if ( y_60 >= 10 && (((_BYTE)x_59 * ((_BYTE)x_59 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    *(quoting_options *)&v6[-16] = default_quoting_options;\n    v6[v4 - 14] ^= (((v6[v4 - 14] >> v3) & 1) == 0) << v3;\n    result = quotearg_n_options(0, arg, argsize, (const quoting_options *)&v6[-16]);\n    if ( y_60 < 10 || (((_BYTE)x_59 * ((_BYTE)x_59 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    *(quoting_options *)&v6[-16] = default_quoting_options;\n    v6[v4 - 14] ^= (((v6[v4 - 14] >> v3) & 1) == 0) << v3;\n    quotearg_n_options(0, arg, argsize, (const quoting_options *)&v6[-16]);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_char",
            "funcStartAddr": "0x4052f0",
            "funcEndAddr": "0x405300",
            "decompiledFuncCode": "char *__fastcall quotearg_char(const char *arg, char ch_0)\n{\n  return quotearg_char_mem(arg, 0xFFFFFFFFFFFFFFFFLL, ch_0);\n}\n"
        },
        {
            "funcName": "quotearg_colon",
            "funcStartAddr": "0x405300",
            "funcEndAddr": "0x405311",
            "decompiledFuncCode": "char *__fastcall quotearg_colon(const char *arg)\n{\n  return quotearg_char_mem(arg, 0xFFFFFFFFFFFFFFFFLL, 0x3Au);\n}\n"
        },
        {
            "funcName": "quotearg_colon_mem",
            "funcStartAddr": "0x405320",
            "funcEndAddr": "0x405388",
            "decompiledFuncCode": "char *__fastcall quotearg_colon_mem(const char *arg, size_t argsize)\n{\n  char *result; // rax\n\n  if ( y_66 >= 10 && (((_BYTE)x_65 * ((_BYTE)x_65 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_char_mem(arg, argsize, 0x3Au);\n    if ( y_66 < 10 || (((_BYTE)x_65 * ((_BYTE)x_65 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_char_mem(arg, argsize, 0x3Au);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quotearg_n_style_colon",
            "funcStartAddr": "0x405390",
            "funcEndAddr": "0x405424",
            "decompiledFuncCode": "char *__fastcall quotearg_n_style_colon(int n, quoting_style s, const char *arg)\n{\n  quoting_options v4; // [rsp+0h] [rbp-78h] BYREF\n  __int128 v5; // [rsp+40h] [rbp-38h]\n  __int128 v6; // [rsp+50h] [rbp-28h]\n  __int128 v7; // [rsp+60h] [rbp-18h]\n  int right_quote; // [rsp+70h] [rbp-8h]\n\n  memset(&v4, 0, 52);\n  if ( s == custom_quoting_style )\n    abort();\n  right_quote = (int)v4.right_quote;\n  v7 = *(_OWORD *)&v4.quote_these_too[6];\n  v6 = *(_OWORD *)&v4.quote_these_too[2];\n  v5 = *(_OWORD *)&v4.style;\n  v4.style = s;\n  HIDWORD(v4.right_quote) = v4.right_quote;\n  *(_OWORD *)&v4.quote_these_too[7] = *(_OWORD *)&v4.quote_these_too[6];\n  *(_OWORD *)&v4.quote_these_too[3] = *(_OWORD *)&v4.quote_these_too[2];\n  *(_OWORD *)&v4.flags = v5;\n  HIBYTE(v4.quote_these_too[1]) = BYTE11(v5) | 4;\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &v4);\n}\n"
        },
        {
            "funcName": "quotearg_n_custom",
            "funcStartAddr": "0x405430",
            "funcEndAddr": "0x40549d",
            "decompiledFuncCode": "char *__fastcall quotearg_n_custom(int n, const char *left_quote, const char *right_quote, const char *arg)\n{\n  quoting_options v5; // [rsp+0h] [rbp-38h] BYREF\n\n  v5 = default_quoting_options;\n  v5.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v5.left_quote = left_quote;\n  v5.right_quote = right_quote;\n  return quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &v5);\n}\n"
        },
        {
            "funcName": "quotearg_n_custom_mem",
            "funcStartAddr": "0x4054a0",
            "funcEndAddr": "0x405509",
            "decompiledFuncCode": "char *__fastcall quotearg_n_custom_mem(\n        int n,\n        const char *left_quote,\n        const char *right_quote,\n        const char *arg,\n        size_t argsize)\n{\n  quoting_options v6; // [rsp+0h] [rbp-38h] BYREF\n\n  v6 = default_quoting_options;\n  v6.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v6.left_quote = left_quote;\n  v6.right_quote = right_quote;\n  return quotearg_n_options(n, arg, argsize, &v6);\n}\n"
        },
        {
            "funcName": "quotearg_custom",
            "funcStartAddr": "0x405510",
            "funcEndAddr": "0x40557f",
            "decompiledFuncCode": "char *__fastcall quotearg_custom(const char *left_quote, const char *right_quote, const char *arg)\n{\n  quoting_options v4; // [rsp+0h] [rbp-38h] BYREF\n\n  v4 = default_quoting_options;\n  v4.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v4.left_quote = left_quote;\n  v4.right_quote = right_quote;\n  return quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &v4);\n}\n"
        },
        {
            "funcName": "quotearg_custom_mem",
            "funcStartAddr": "0x405580",
            "funcEndAddr": "0x4055eb",
            "decompiledFuncCode": "char *__fastcall quotearg_custom_mem(const char *left_quote, const char *right_quote, const char *arg, size_t argsize)\n{\n  quoting_options v5; // [rsp+0h] [rbp-38h] BYREF\n\n  v5 = default_quoting_options;\n  v5.style = custom_quoting_style;\n  if ( !left_quote || !right_quote )\n    abort();\n  v5.left_quote = left_quote;\n  v5.right_quote = right_quote;\n  return quotearg_n_options(0, arg, argsize, &v5);\n}\n"
        },
        {
            "funcName": "quote_n_mem",
            "funcStartAddr": "0x4055f0",
            "funcEndAddr": "0x40565b",
            "decompiledFuncCode": "const char *__fastcall quote_n_mem(int n, const char *arg, size_t argsize)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(n, arg, argsize, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(n, arg, argsize, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote_mem",
            "funcStartAddr": "0x405660",
            "funcEndAddr": "0x4056cc",
            "decompiledFuncCode": "const char *__fastcall quote_mem(const char *arg, size_t argsize)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(0, arg, argsize, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(0, arg, argsize, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote_n",
            "funcStartAddr": "0x4056d0",
            "funcEndAddr": "0x405741",
            "decompiledFuncCode": "const char *__fastcall quote_n(int n, const char *arg)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(n, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "quote",
            "funcStartAddr": "0x405750",
            "funcEndAddr": "0x4057b8",
            "decompiledFuncCode": "const char *__fastcall quote(const char *arg)\n{\n  const char *result; // rax\n\n  if ( y_78 >= 10 && (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    result = quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n    if ( y_78 < 10 || (((_BYTE)x_77 * ((_BYTE)x_77 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    quotearg_n_options(0, arg, 0xFFFFFFFFFFFFFFFFLL, &quote_quoting_options);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "gettext_quote",
            "funcStartAddr": "0x4057c0",
            "funcEndAddr": "0x4058c6",
            "decompiledFuncCode": "const char *__fastcall gettext_quote(const char *msgid, quoting_style s)\n{\n  const char *result; // rax\n  const char *v3; // rbp\n  bool v4; // zf\n  const char *v5; // rcx\n  char v6; // [rsp+0h] [rbp-18h]\n  char v7; // [rsp+0h] [rbp-18h]\n  char v8; // [rsp+8h] [rbp-10h]\n  char v9; // [rsp+8h] [rbp-10h]\n  char v10; // [rsp+10h] [rbp-8h]\n  char v11; // [rsp+10h] [rbp-8h]\n\n  result = dcgettext(0LL, msgid, 5);\n  if ( result == msgid )\n  {\n    v3 = locale_charset();\n    if ( strcaseeq0(v3, (const char *)0x55, 84, 70, 45, 56, 0, 0, v6, v8, v10) )\n    {\n      v4 = *msgid == 96;\n      v5 = (const char *)&unk_409A3A;\n      result = (const char *)&unk_409A3E;\n    }\n    else\n    {\n      if ( y_86 >= 10 && (((_BYTE)x_85 * ((_BYTE)x_85 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( strcaseeq0(v3, (const char *)0x47, 66, 49, 56, 48, 51, 48, v7, v9, v11) )\n      {\n        v4 = *msgid == 96;\n        v5 = (const char *)&unk_409A42;\n        result = (const char *)&unk_409A46;\n      }\n      else\n      {\n        v4 = s == clocale_quoting_style;\n        v5 = (const char *)asc_409A34;\n        result = (_BYTE *)(asc_409A34 + 4);\n      }\n    }\n    if ( v4 )\n      result = v5;\n  }\n  if ( y_86 >= 10 && (((_BYTE)x_85 * ((_BYTE)x_85 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "strcaseeq0",
            "funcStartAddr": "0x4058d0",
            "funcEndAddr": "0x405dd2",
            "decompiledFuncCode": "__int64 __fastcall strcaseeq0(\n        const char *s1,\n        const char *s2,\n        char s20,\n        unsigned __int8 s21,\n        unsigned __int8 s22,\n        unsigned __int8 s23,\n        unsigned __int8 s24,\n        unsigned __int8 s25)\n{\n  int v8; // ebp\n  __int64 result; // rax\n  int v10; // esi\n  bool v11; // r15\n  bool v12; // r13\n  __int64 v13; // rbx\n  int v14; // edx\n  int v15; // ebp\n  bool v16; // r14\n  __int64 v17; // r10\n  int v18; // ebx\n  unsigned int v19; // ebx\n  bool v20; // zf\n  int v21; // ebx\n  unsigned int v22; // ebx\n  int v23; // ebx\n  unsigned int v24; // ebx\n  int v25; // ebx\n  unsigned int v26; // ebx\n  bool v27; // [rsp+0h] [rbp-6Ch]\n  unsigned int v28; // [rsp+18h] [rbp-54h]\n\n  if ( y_88 >= 10 && (((_BYTE)x_87 * ((_BYTE)x_87 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v8 = *s1;\n  if ( (unsigned int)((char)s2 - 65) > 0x19 )\n  {\n    result = 0LL;\n    if ( (_BYTE)v8 != (_BYTE)s2 )\n      return result;\n  }\n  else\n  {\n    result = 0LL;\n    if ( (v8 & 0xFFFFFFDF) != (char)s2 )\n      return result;\n  }\n  if ( !(_BYTE)s2 )\n    return 1LL;\n  v10 = s1[1];\n  if ( (unsigned int)(s20 - 65) > 0x19 )\n  {\n    result = 0LL;\n    if ( (_BYTE)v10 != s20 )\n      return result;\n  }\n  else\n  {\n    result = 0LL;\n    if ( (v10 & 0xFFFFFFDF) != s20 )\n      return result;\n  }\n  if ( s20 )\n  {\n    v27 = (((_BYTE)x_99 * ((_BYTE)x_99 - 1)) & 1) == 0 || y_100 < 10;\n    v11 = (((_BYTE)x_89 * ((_BYTE)x_89 - 1)) & 1) == 0 || y_90 < 10;\n    v12 = (((_BYTE)x_91 * ((_BYTE)x_91 - 1)) & 1) == 0 || y_92 < 10;\n    v13 = (unsigned int)(char)s25;\n    v14 = (char)s24;\n    v15 = (char)s23;\n    v28 = v13 - 65;\n    while ( (unsigned int)((char)s21 - 65) < 0x1A )\n    {\n      if ( (s1[2] & 0xFFFFFFDF) == (char)s21 )\n      {\n        if ( !v12 )\n        {\n          while ( 1 )\n            ;\n        }\n        if ( s21 )\n        {\nLABEL_23:\n          v17 = v13;\n          v18 = s1[3];\n          if ( (unsigned int)((char)s22 - 65) >= 0x1A )\n          {\n            if ( (((_BYTE)x_93 * ((_BYTE)x_93 - 1)) & 1) != 0 && y_94 >= 10 )\n            {\n              while ( 1 )\n                ;\n            }\n            v16 = (_BYTE)v18 == s22;\n            if ( s22 )\n            {\n              v20 = (_BYTE)v18 == s22;\n              v13 = v17;\n              if ( !v20 )\n                goto LABEL_65;\n              goto LABEL_33;\n            }\n            v13 = v17;\n            if ( v11 )\n              return v16;\n          }\n          else\n          {\n            v19 = v18 & 0xFFFFFFDF;\n            v16 = v19 == (char)s22;\n            if ( !s22 )\n              goto LABEL_63;\n            v20 = v19 == (char)s22;\n            v15 = (char)s23;\n            v14 = (char)s24;\n            v13 = v17;\n            if ( !v20 )\n              goto LABEL_65;\nLABEL_33:\n            v21 = s1[4];\n            if ( (unsigned int)((char)s23 - 65) > 0x19 )\n            {\n              v16 = (_BYTE)v21 == s23;\n              if ( s23 )\n              {\n                v20 = (_BYTE)v21 == s23;\n                v13 = v17;\n                if ( !v20 )\n                  goto LABEL_65;\nLABEL_39:\n                v23 = s1[5];\n                if ( (unsigned int)((char)s24 - 65) > 0x19 )\n                {\n                  v16 = (_BYTE)v23 == s24;\n                  if ( !s24 )\n                    goto LABEL_64;\n                  v20 = (_BYTE)v23 == s24;\n                  v14 = (char)s24;\n                  v13 = v17;\n                  if ( !v20 )\n                    goto LABEL_65;\n                  goto LABEL_46;\n                }\n                if ( (((_BYTE)x_97 * ((_BYTE)x_97 - 1)) & 1) != 0 && y_98 >= 10 )\n                {\n                  while ( 1 )\n                    ;\n                }\n                v24 = v23 & 0xFFFFFFDF;\n                v16 = v24 == v14;\n                if ( s24 )\n                {\n                  v20 = v24 == v14;\n                  v13 = v17;\n                  if ( !v20 )\n                    goto LABEL_65;\nLABEL_46:\n                  v25 = s1[6];\n                  if ( v28 > 0x19 )\n                  {\n                    v16 = (_BYTE)v25 == s25;\n                    if ( !s25 )\n                    {\nLABEL_63:\n                      v15 = (char)s23;\nLABEL_64:\n                      v14 = (char)s24;\n                      v13 = v17;\n                      goto LABEL_65;\n                    }\n                    v20 = (_BYTE)v25 == s25;\n                    v15 = (char)s23;\n                    v14 = (char)s24;\n                    v13 = v17;\n                    if ( v20 )\n                      goto LABEL_59;\nLABEL_65:\n                    if ( v11 )\n                      return v16;\n                  }\n                  else\n                  {\n                    if ( !v27 )\n                    {\n                      while ( 1 )\n                        ;\n                    }\n                    v26 = v25 & 0xFFFFFFDF;\n                    v16 = v26 == (_DWORD)v17;\n                    if ( s25 )\n                    {\n                      v20 = v26 == (_DWORD)v17;\n                      v13 = v17;\n                      if ( !v20 )\n                        goto LABEL_65;\nLABEL_59:\n                      if ( (((_BYTE)x_101 * ((_BYTE)x_101 - 1)) & 1) != 0 && y_102 >= 10 )\n                      {\n                        while ( 1 )\n                          ;\n                      }\n                      if ( !v27 )\n                      {\n                        while ( 1 )\n                          ;\n                      }\n                      v16 = s1[7] == 0;\n                      if ( v11 )\n                        return v16;\n                    }\n                    else\n                    {\n                      v13 = v17;\n                      if ( v11 )\n                        return v16;\n                    }\n                  }\n                }\n                else\n                {\n                  v13 = v17;\n                  if ( v11 )\n                    return v16;\n                }\n              }\n              else\n              {\n                v13 = v17;\n                if ( v11 )\n                  return v16;\n              }\n            }\n            else\n            {\n              v22 = v21 & 0xFFFFFFDF;\n              v16 = v22 == v15;\n              if ( s23 )\n              {\n                v20 = v22 == v15;\n                v13 = v17;\n                if ( !v20 )\n                  goto LABEL_65;\n                goto LABEL_39;\n              }\n              v13 = v17;\n              if ( v11 )\n                return v16;\n            }\n          }\n        }\n        else\n        {\n          v16 = 1;\n          if ( v11 )\n            return v16;\n        }\n      }\n      else\n      {\n        if ( !v12 )\n        {\n          while ( 1 )\n            ;\n        }\n        v16 = 0;\n        if ( v11 )\n          return v16;\n      }\n    }\n    if ( !v12 )\n    {\n      while ( 1 )\n        ;\n    }\n    v16 = s1[2] == s21;\n    if ( s21 == 0 || s1[2] != s21 )\n      goto LABEL_65;\n    goto LABEL_23;\n  }\n  if ( y_90 < 10 )\n    return 1LL;\n  result = 1LL;\n  if ( (((_BYTE)x_89 * ((_BYTE)x_89 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "version_etc_arn",
            "funcStartAddr": "0x405de0",
            "funcEndAddr": "0x4063ae",
            "decompiledFuncCode": "void __fastcall version_etc_arn(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        const char *const *authors,\n        size_t n_authors)\n{\n  char *v9; // rax\n  char *v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  char *v13; // rax\n  char *v14; // rax\n  char *v15; // rax\n  char *v16; // rax\n  char *v17; // rax\n  char *v18; // rax\n  char *v19; // rax\n  char *v20; // rax\n  char *v21; // rax\n  char *v22; // rax\n  char *v23; // rax\n  char *v24; // rax\n\n  if ( command_name )\n  {\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", command_name);\n  }\n  else\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      goto LABEL_7;\n    while ( 1 )\n    {\n      __fprintf_chk(stream, 1LL, \"%s %s\\n\", package);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\nLABEL_7:\n      __fprintf_chk(stream, 1LL, \"%s %s\\n\", package);\n    }\n  }\n  v9 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v9);\n  v10 = dcgettext(\n          0LL,\n          \"\\n\"\n          \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n          \"This is free software: you are free to change and redistribute it.\\n\"\n          \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n          \"\\n\",\n          5);\n  fputs_unlocked(v10, stream);\n  switch ( n_authors )\n  {\n    case 0uLL:\n      return;\n    case 1uLL:\n      v11 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v11, *authors);\n      break;\n    case 2uLL:\n      v12 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v12, *authors);\n      break;\n    case 3uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_29;\n      while ( 1 )\n      {\n        v17 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v17, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_29:\n        v18 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v18, *authors);\n      }\n      break;\n    case 4uLL:\n      v13 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v13, *authors);\n      break;\n    case 5uLL:\n      v14 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v14, *authors);\n      break;\n    case 6uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_32;\n      while ( 1 )\n      {\n        v19 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v19, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_32:\n        v20 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v20, *authors);\n      }\n      break;\n    case 7uLL:\n      v15 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v15, *authors);\n      break;\n    case 8uLL:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_35;\n      while ( 1 )\n      {\n        v21 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v21, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_35:\n        v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v22, *authors);\n      }\n      break;\n    case 9uLL:\n      v16 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\", 5);\n      __fprintf_chk(stream, 1LL, v16, *authors);\n      break;\n    default:\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n        goto LABEL_38;\n      while ( 1 )\n      {\n        v23 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v23, *authors);\n        if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n          break;\nLABEL_38:\n        v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\", 5);\n        __fprintf_chk(stream, 1LL, v24, *authors);\n      }\n      break;\n  }\n}\n"
        },
        {
            "funcName": "version_etc_ar",
            "funcStartAddr": "0x4063b0",
            "funcEndAddr": "0x406402",
            "decompiledFuncCode": "void __fastcall version_etc_ar(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        const char *const *authors)\n{\n  size_t v5; // r9\n\n  v5 = -1LL;\n  do\n  {\n    if ( (((_BYTE)x_20 * ((_BYTE)x_20 - 1)) & 1) != 0 && y_21 >= 10 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  while ( authors[++v5] != 0LL );\n  version_etc_arn(stream, command_name, package, version, authors, v5);\n}\n"
        },
        {
            "funcName": "version_etc_va",
            "funcStartAddr": "0x406410",
            "funcEndAddr": "0x4064d1",
            "decompiledFuncCode": "void __fastcall version_etc_va(\n        FILE *stream,\n        const char *command_name,\n        const char *package,\n        const char *version,\n        __va_list_tag *authors)\n{\n  __int64 v5; // rax\n  size_t v6; // r9\n  unsigned __int64 gp_offset; // r11\n  __int64 *overflow_arg_area; // r10\n  __int64 v9; // rax\n  _QWORD v10[2]; // [rsp-8h] [rbp-10h] BYREF\n\n  v10[0] = v5;\n  while ( (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 && y_23 >= 10 )\n    ;\n  if ( y_23 >= 10 && (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\nLABEL_13:\n      ;\n  }\n  v6 = 0LL;\n  while ( v6 <= 9 )\n  {\n    gp_offset = (int)authors->gp_offset;\n    if ( gp_offset > 0x28 )\n    {\n      overflow_arg_area = (__int64 *)authors->overflow_arg_area;\n      authors->overflow_arg_area = overflow_arg_area + 1;\n    }\n    else\n    {\n      overflow_arg_area = (__int64 *)((char *)authors->reg_save_area + gp_offset);\n      authors->gp_offset = gp_offset + 8;\n    }\n    v9 = *overflow_arg_area;\n    v10[v6 - 10] = *overflow_arg_area;\n    if ( !v9 )\n      break;\n    ++v6;\n    if ( y_23 >= 10 && (((_BYTE)x_22 * ((_BYTE)x_22 - 1)) & 1) != 0 )\n      goto LABEL_13;\n  }\n  version_etc_arn(stream, command_name, package, version, (const char *const *)&v10[-10], v6);\n}\n"
        },
        {
            "funcName": "version_etc",
            "funcStartAddr": "0x4064e0",
            "funcEndAddr": "0x406562",
            "decompiledFuncCode": "void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...)\n{\n  va_list va; // [rsp+0h] [rbp-D8h] BYREF\n\n  va_start(va, version);\n  version_etc_va(stream, command_name, package, version, va);\n}\n"
        },
        {
            "funcName": "emit_bug_reporting_address",
            "funcStartAddr": "0x406570",
            "funcEndAddr": "0x406698",
            "decompiledFuncCode": "void __cdecl emit_bug_reporting_address()\n{\n  char *v0; // rax\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n\n  if ( y_27 >= 10 && (((_BYTE)x_26 * ((_BYTE)x_26 - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v0 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n    __printf_chk(1LL, v0, \"bug-coreutils@gnu.org\");\n    v1 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n    __printf_chk(1LL, v1, \"GNU coreutils\", \"https://www.gnu.org/software/coreutils/\");\n    v2 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n    fputs_unlocked(v2, stdout);\n    if ( y_27 < 10 || (((_BYTE)x_26 * ((_BYTE)x_26 - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    v3 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n    __printf_chk(1LL, v3, \"bug-coreutils@gnu.org\");\n    v4 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n    __printf_chk(1LL, v4, \"GNU coreutils\", \"https://www.gnu.org/software/coreutils/\");\n    v5 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n    fputs_unlocked(v5, stdout);\n  }\n}\n"
        },
        {
            "funcName": "xnmalloc",
            "funcStartAddr": "0x4066a0",
            "funcEndAddr": "0x406733",
            "decompiledFuncCode": "void *__fastcall xnmalloc(size_t n, size_t s)\n{\n  size_t v2; // r14\n  bool v3; // bl\n  void *result; // rax\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n )\n    goto LABEL_10;\n  v2 = n * s;\n  v3 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = malloc(v2);\n  while ( !v3 );\n  if ( v2 && !result )\nLABEL_10:\n    xalloc_die();\n  return result;\n}\n"
        },
        {
            "funcName": "xmalloc",
            "funcStartAddr": "0x406740",
            "funcEndAddr": "0x406793",
            "decompiledFuncCode": "void *__fastcall xmalloc(size_t n)\n{\n  bool v1; // bl\n  void *result; // rax\n\n  v1 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = malloc(n);\n  while ( !v1 );\n  if ( n )\n  {\n    if ( !result )\n      xalloc_die();\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xnrealloc",
            "funcStartAddr": "0x4067a0",
            "funcEndAddr": "0x40681d",
            "decompiledFuncCode": "void *__fastcall xnrealloc(void *p, size_t n, size_t s)\n{\n  size_t v3; // rbx\n  void *result; // rax\n\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n )\n    xalloc_die();\n  v3 = n * s;\n  if ( y_4 >= 10 && (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) != 0 )\n    goto LABEL_8;\n  while ( 1 )\n  {\n    result = xrealloc(p, v3);\n    if ( y_4 < 10 || (((_BYTE)x_3 * ((_BYTE)x_3 - 1)) & 1) == 0 )\n      break;\nLABEL_8:\n    xrealloc(p, v3);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xrealloc",
            "funcStartAddr": "0x406820",
            "funcEndAddr": "0x4068a0",
            "decompiledFuncCode": "void *__fastcall xrealloc(void *p, size_t n)\n{\n  void *result; // rax\n\n  if ( !p || n )\n  {\n    result = realloc(p, n);\n    if ( n && !result )\n      xalloc_die();\n  }\n  else\n  {\n    if ( y_6 >= 10 && (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) != 0 )\n      goto LABEL_11;\n    while ( 1 )\n    {\n      free(p);\n      result = 0LL;\n      if ( y_6 < 10 || (((_BYTE)x_5 * ((_BYTE)x_5 - 1)) & 1) == 0 )\n        break;\nLABEL_11:\n      free(p);\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "x2nrealloc",
            "funcStartAddr": "0x4068a0",
            "funcEndAddr": "0x40696a",
            "decompiledFuncCode": "void *__fastcall x2nrealloc(void *p, size_t *pn, size_t s)\n{\n  size_t v3; // rcx\n\n  v3 = *pn;\n  if ( p )\n  {\n    if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    if ( 0x5555555555555554LL / s <= v3 )\n      xalloc_die();\n    v3 += (v3 >> 1) + 1;\n  }\n  else\n  {\n    if ( !v3 )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      v3 = 0x80 / s + (s > 0x80);\n    }\n    if ( 0x7FFFFFFFFFFFFFFFLL / s < v3 )\n      xalloc_die();\n  }\n  *pn = v3;\n  return xrealloc(p, v3 * s);\n}\n"
        },
        {
            "funcName": "xcharalloc",
            "funcStartAddr": "0x406970",
            "funcEndAddr": "0x4069c3",
            "decompiledFuncCode": "char *__fastcall xcharalloc(size_t n)\n{\n  bool v1; // bl\n  char *result; // rax\n\n  v1 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n    result = (char *)malloc(n);\n  while ( !v1 );\n  if ( n )\n  {\n    if ( !result )\n      xalloc_die();\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "x2realloc",
            "funcStartAddr": "0x4069d0",
            "funcEndAddr": "0x406b3c",
            "decompiledFuncCode": "void *__fastcall x2realloc(void *p, size_t *pn)\n{\n  __int64 v3; // rsi\n  void *result; // rax\n  __int64 v5; // rsi\n\n  if ( y_12 >= 10 && (((_BYTE)x_11 * ((_BYTE)x_11 - 1)) & 1) != 0 )\n    goto LABEL_14;\n  while ( 1 )\n  {\n    v3 = *pn;\n    if ( p )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( (unsigned __int64)v3 >= 0x5555555555555554LL )\n        xalloc_die();\n      v3 += ((unsigned __int64)v3 >> 1) + 1;\n    }\n    else if ( v3 )\n    {\n      if ( v3 < 0 )\n        xalloc_die();\n    }\n    else\n    {\n      v3 = 128LL;\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n    }\n    *pn = v3;\n    result = xrealloc(p, v3);\n    if ( y_12 < 10 || (((_BYTE)x_11 * ((_BYTE)x_11 - 1)) & 1) == 0 )\n      break;\nLABEL_14:\n    v5 = *pn;\n    if ( p )\n    {\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      if ( (unsigned __int64)v5 >= 0x5555555555555554LL )\n        xalloc_die();\n      v5 += ((unsigned __int64)v5 >> 1) + 1;\n    }\n    else if ( v5 )\n    {\n      if ( v5 < 0 )\n        xalloc_die();\n    }\n    else\n    {\n      v5 = 128LL;\n      if ( y_8 >= 10 && (((_BYTE)x_7 * ((_BYTE)x_7 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n    }\n    *pn = v5;\n    xrealloc(p, v5);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "xzalloc",
            "funcStartAddr": "0x406b40",
            "funcEndAddr": "0x406c09",
            "decompiledFuncCode": "void *__fastcall xzalloc(size_t s)\n{\n  int v1; // ecx\n  int v2; // ebp\n  char v3; // r12\n  int v4; // r13d\n  void *v5; // rax\n  void *v6; // rbx\n  int v8; // [rsp+0h] [rbp-34h]\n\n  v1 = y_14;\n  v2 = ((_BYTE)x_13 * ((_BYTE)x_13 - 1)) & 1;\n  v3 = x_1;\n  v4 = y_2;\n  if ( y_14 >= 10 && (((_BYTE)x_13 * ((_BYTE)x_13 - 1)) & 1) != 0 )\n    goto LABEL_9;\n  while ( 1 )\n  {\n    v8 = v1;\n    do\n    {\n      v5 = malloc(s);\n      v6 = v5;\n    }\n    while ( ((v3 * (v3 - 1)) & 1) != 0 && v4 >= 10 );\n    if ( s && !v5 )\n      xalloc_die();\n    memset(v5, 0, s);\n    v1 = v8;\n    if ( v8 < 10 || !v2 )\n      break;\nLABEL_9:\n    if ( v4 >= 10 && ((v3 * (v3 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "xcalloc",
            "funcStartAddr": "0x406c10",
            "funcEndAddr": "0x406c36",
            "decompiledFuncCode": "void *__fastcall xcalloc(size_t n, size_t s)\n{\n  void *result; // rax\n\n  if ( 0x7FFFFFFFFFFFFFFFLL / s < n || (result = rpl_calloc(n, s)) == 0LL )\n    xalloc_die();\n  return result;\n}\n"
        },
        {
            "funcName": "xmemdup",
            "funcStartAddr": "0x406c40",
            "funcEndAddr": "0x406cab",
            "decompiledFuncCode": "void *__fastcall xmemdup(const void *p, size_t s)\n{\n  bool v2; // bp\n  void *v3; // rax\n  void *v4; // rbx\n\n  v2 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n  {\n    v3 = malloc(s);\n    v4 = v3;\n  }\n  while ( !v2 );\n  if ( s && !v3 )\n    xalloc_die();\n  memcpy(v3, p, s);\n  return v4;\n}\n"
        },
        {
            "funcName": "xstrdup",
            "funcStartAddr": "0x406cb0",
            "funcEndAddr": "0x406d2b",
            "decompiledFuncCode": "char *__fastcall xstrdup(const char *string)\n{\n  size_t v1; // r15\n  bool v2; // bp\n  char *v3; // rax\n  char *v4; // rbx\n\n  v1 = strlen(string) + 1;\n  v2 = (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) == 0 || y_2 < 10;\n  do\n  {\n    v3 = (char *)malloc(v1);\n    v4 = v3;\n  }\n  while ( !v2 );\n  if ( v1 && !v3 )\n    xalloc_die();\n  memcpy(v3, string, v1);\n  return v4;\n}\n"
        },
        {
            "funcName": "xalloc_die",
            "funcStartAddr": "0x406d30",
            "funcEndAddr": "0x406d60",
            "decompiledFuncCode": "void __cdecl __noreturn xalloc_die()\n{\n  int v0; // ebx\n  char *v1; // rax\n\n  v0 = exit_failure;\n  v1 = dcgettext(0LL, \"memory exhausted\", 5);\n  error(v0, 0, \"%s\", v1);\n  abort();\n}\n"
        },
        {
            "funcName": "xnumtoumax",
            "funcStartAddr": "0x406d60",
            "funcEndAddr": "0x406f00",
            "decompiledFuncCode": "uintmax_t __fastcall xnumtoumax(\n        const char *n_str,\n        int base,\n        uintmax_t min,\n        uintmax_t max,\n        const char *suffixes,\n        const char *err,\n        int status)\n{\n  strtol_error_0 v10; // ebx\n  uintmax_t v11; // rbx\n  char v12; // r12\n  int v13; // ebp\n  int *v14; // rax\n  int *v15; // rax\n  int v16; // edx\n  int v17; // r12d\n  int v18; // ebx\n  const char *v19; // rax\n  const char *v20; // rax\n  uintmax_t val[6]; // [rsp+8h] [rbp-30h] BYREF\n\n  v10 = xstrtoumax(n_str, 0LL, base, val, suffixes);\n  if ( v10 == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW )\n  {\n    *__errno_location() = 0;\n    goto LABEL_19;\n  }\n  if ( v10 == LONGINT_OVERFLOW )\n  {\n    v12 = x;\n    v13 = y;\n    v14 = __errno_location();\n    if ( v13 >= 10 && ((v12 * (v12 - 1)) & 1) != 0 )\n      goto LABEL_18;\n    while ( 1 )\n    {\n      *v14 = 75;\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\nLABEL_18:\n      *v14 = 75;\n    }\n    goto LABEL_19;\n  }\n  if ( v10 )\n  {\nLABEL_19:\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    v17 = 1;\n    if ( status )\n      v17 = status;\n    v18 = *__errno_location();\n    if ( v18 == 22 )\n      v18 = 0;\n    while ( 1 )\n    {\n      v20 = quote(n_str);\n      error(v17, v18, \"%s: %s\", err, v20);\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\n      v19 = quote(n_str);\n      error(v17, v18, \"%s: %s\", err, v19);\n    }\n    return val[0];\n  }\n  v11 = val[0];\n  if ( val[0] < min )\n    goto LABEL_13;\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( val[0] > max )\n  {\nLABEL_13:\n    v15 = __errno_location();\n    v16 = 34;\n    if ( v11 > 0x3FFFFFFF )\n      v16 = 75;\n    *v15 = v16;\n    goto LABEL_19;\n  }\n  return val[0];\n}\n"
        },
        {
            "funcName": "xdectoumax",
            "funcStartAddr": "0x406f00",
            "funcEndAddr": "0x406f23",
            "decompiledFuncCode": "uintmax_t __fastcall xdectoumax(\n        const char *n_str,\n        uintmax_t min,\n        uintmax_t max,\n        const char *suffixes,\n        const char *err,\n        int err_exit)\n{\n  return xnumtoumax(n_str, 10, min, max, suffixes, err, err_exit);\n}\n"
        },
        {
            "funcName": "xstrtoumax",
            "funcStartAddr": "0x406f30",
            "funcEndAddr": "0x407c09",
            "decompiledFuncCode": "strtol_error_0 __fastcall xstrtoumax(\n        const char *s,\n        char **ptr,\n        int strtol_base,\n        uintmax_t *val,\n        const char *valid_suffixes)\n{\n  const char *v8; // rbp\n  char **v9; // rax\n  int *v10; // r14\n  bool v11; // bl\n  const unsigned __int16 **v12; // rax\n  const unsigned __int16 *v13; // rax\n  const char *i; // rcx\n  __int64 v15; // rdx\n  int v16; // r9d\n  char **j; // rsi\n  unsigned __int64 v18; // rbx\n  char v19; // r13\n  int v20; // r12d\n  char *v21; // r15\n  int v22; // ebp\n  char v23; // r14\n  __int64 v24; // r10\n  unsigned __int64 v25; // r13\n  unsigned __int64 v26; // rax\n  __int64 v27; // rcx\n  int v28; // r9d\n  int v29; // eax\n  int v30; // eax\n  unsigned __int64 v31; // rax\n  bool v32; // dl\n  unsigned __int64 v33; // rax\n  bool v34; // dl\n  unsigned __int64 v35; // rax\n  bool v36; // cl\n  unsigned __int64 v37; // rsi\n  unsigned __int64 v38; // rdi\n  bool v39; // cf\n  unsigned __int64 v40; // rdi\n  unsigned __int64 v41; // rax\n  bool v42; // dl\n  bool v43; // dl\n  unsigned __int64 v44; // rcx\n  unsigned __int64 v45; // rdx\n  unsigned __int64 v46; // rax\n  bool v47; // r10\n  bool v48; // r9\n  unsigned __int64 v49; // rcx\n  unsigned __int64 v50; // rdx\n  unsigned __int64 v51; // rcx\n  unsigned __int64 v52; // rdx\n  unsigned __int64 v53; // r14\n  unsigned __int64 v54; // rbp\n  unsigned __int64 v55; // rcx\n  unsigned __int64 v56; // rdx\n  unsigned __int64 v57; // rsi\n  unsigned __int64 v58; // rdi\n  unsigned __int64 v59; // rdi\n  unsigned __int64 v60; // rax\n  bool v61; // r10\n  unsigned __int64 v62; // rcx\n  unsigned __int64 v63; // rdx\n  unsigned __int64 v64; // rcx\n  unsigned __int64 v65; // rbp\n  unsigned __int64 v66; // rcx\n  unsigned __int64 v67; // rdx\n  unsigned __int64 v68; // rsi\n  unsigned __int64 v69; // rdi\n  unsigned __int64 v70; // rax\n  bool v71; // r10\n  bool v72; // r9\n  unsigned __int64 v73; // rcx\n  unsigned __int64 v74; // rdx\n  unsigned __int64 v75; // rcx\n  unsigned __int64 v76; // rdx\n  unsigned __int64 v77; // rcx\n  unsigned __int64 v78; // rdx\n  unsigned __int64 v79; // r8\n  unsigned __int64 v80; // r14\n  unsigned __int64 v81; // r12\n  unsigned __int64 v82; // rsi\n  unsigned __int64 v83; // rbp\n  unsigned __int64 v84; // rdx\n  unsigned __int64 v85; // rcx\n  unsigned __int64 v86; // rdi\n  unsigned __int64 v87; // rax\n  bool v88; // dl\n  unsigned __int64 v89; // rdx\n  __int64 v90; // rcx\n  unsigned __int8 v91; // si\n  char v92; // r8\n  char v93; // al\n  unsigned __int64 v94; // rsi\n  unsigned __int64 v95; // rdx\n  unsigned __int8 v96; // cl\n  __int64 v97; // r13\n  unsigned __int8 v98; // al\n  __int64 v99; // rcx\n  __int64 v100; // rsi\n  __int64 v101; // rcx\n  unsigned __int64 v102; // rsi\n  unsigned __int64 v103; // rbp\n  unsigned __int64 v104; // rdx\n  __int64 v105; // rcx\n  unsigned __int64 v106; // rsi\n  char v107; // r8\n  unsigned __int64 v108; // rdi\n  char v109; // r9\n  unsigned __int64 v110; // rsi\n  __int64 v111; // r14\n  char v112; // r10\n  unsigned __int64 v113; // rdi\n  char v114; // r11\n  unsigned __int64 v115; // rsi\n  char v116; // bp\n  unsigned __int64 v117; // rdi\n  char v118; // cl\n  char v119; // al\n  char v120; // al\n  __int64 v122; // rcx\n  int v123; // [rsp+4h] [rbp-54h]\n  char *v124; // [rsp+8h] [rbp-50h]\n  char *v125; // [rsp+8h] [rbp-50h]\n  uintmax_t *v126; // [rsp+10h] [rbp-48h]\n  char **endptr; // [rsp+18h] [rbp-40h]\n  char v128; // [rsp+20h] [rbp-38h] BYREF\n\n  v8 = s;\n  if ( (unsigned int)strtol_base >= 0x25 )\n    __assert_fail(\n      \"0 <= strtol_base && strtol_base <= 36\",\n      \"../lib/xstrtol.c\",\n      0x54u,\n      \"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\");\n  v9 = (char **)&v128;\n  if ( ptr )\n    v9 = ptr;\n  endptr = v9;\n  v10 = __errno_location();\n  *v10 = 0;\n  v11 = (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 || y < 10;\n  v12 = __ctype_b_loc();\n  if ( !v11 )\n  {\n    while ( 1 )\n      ;\n  }\n  v13 = *v12;\n  for ( i = s; ; ++i )\n  {\n    v15 = *(unsigned __int8 *)i;\n    if ( (v13[v15] & 0x2000) == 0 )\n      break;\n  }\n  v16 = 4;\n  if ( (_BYTE)v15 == 45 )\n    return v16;\n  v124 = (char *)valid_suffixes;\n  v126 = val;\n  for ( j = endptr; ; j = endptr )\n  {\n    v18 = __strtoul_internal(s, j, strtol_base, 0);\n    v19 = x;\n    v20 = y;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\n    __strtoul_internal(v8, endptr, strtol_base, 0);\n    s = v8;\n  }\n  v21 = *endptr;\n  if ( *endptr == v8 )\n  {\n    if ( v124 && *v8 && strchr(v124, *v8) )\n    {\n      v16 = 0;\n      v18 = 1LL;\n      goto LABEL_27;\n    }\n    if ( v20 >= 10 )\n    {\n      v16 = 4;\n      if ( ((v19 * (v19 - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      return v16;\n    }\n    return 4;\n  }\n  if ( !*v10 )\n  {\n    v16 = 0;\n    if ( !v124 )\n      goto LABEL_261;\n    goto LABEL_27;\n  }\n  if ( *v10 != 34 )\n  {\n    if ( y >= 10 )\n    {\n      v16 = 4;\n      if ( (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      return v16;\n    }\n    return 4;\n  }\n  v16 = 1;\n  if ( !v124 )\n    goto LABEL_261;\nLABEL_27:\n  v22 = *v21;\n  if ( !*v21 )\n    goto LABEL_261;\n  v23 = v19 * (v19 - 1);\n  if ( v20 >= 10 && (v23 & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v123 = v16;\n  if ( !strchr(v124, v22) )\n  {\n    do\n      *v126 = v18;\n    while ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 );\n    return v123 | 2;\n  }\n  v24 = 1LL;\n  v25 = 1024LL;\n  v26 = (unsigned int)(v22 - 69);\n  if ( (unsigned int)v26 > 0x2F )\n    goto LABEL_49;\n  v27 = 0x814400308945LL;\n  v28 = v123;\n  if ( !_bittest64(&v27, v26) )\n    goto LABEL_50;\n  if ( !strchr(v124, 48) )\n  {\n    v24 = 1LL;\n    v25 = 1024LL;\nLABEL_49:\n    v28 = v123;\n    goto LABEL_50;\n  }\n  v29 = v21[1];\n  if ( v29 == 66 || v29 == 68 )\n  {\n    v24 = 2LL;\n    v25 = 1000LL;\n    goto LABEL_49;\n  }\n  v28 = v123;\n  if ( v29 == 105 )\n    v24 = 2LL * (v21[2] == 66) + 1;\n  else\n    v24 = 1LL;\n  v25 = 1024LL;\nLABEL_50:\n  v30 = 0;\n  switch ( v22 )\n  {\n    case 'B':\n      v43 = v18 >> 54 != 0;\n      v44 = v18 >> 54 == 0 ? v18 << 10 : -1;\n      if ( (v23 & 1) != 0 && v20 >= 10 )\n      {\n        while ( 1 )\n        {\n          v45 = v44 << 10;\n          if ( v44 > 0x3FFFFFFFFFFFFFLL )\n            v45 = -1LL;\n          v44 = v45 << 10;\n          if ( v45 > 0x3FFFFFFFFFFFFFLL )\n            v44 = -1LL;\n        }\n      }\n      goto LABEL_194;\n    case 'E':\n      v125 = (char *)v24;\n      v46 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v47 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      v48 = (v23 & 1) == 0 || v20 < 10;\n      while ( 2 )\n      {\n        v53 = v18;\n        if ( v47 )\n          goto LABEL_95;\n        do\n        {\n          v18 = v25 * v53;\n          if ( v46 < v53 )\n            v18 = -1LL;\nLABEL_95:\n          v53 = v25 * v18;\n          if ( v46 < v18 )\n            v53 = -1LL;\n        }\n        while ( !v47 );\n        v54 = v25 * v53;\n        if ( v46 < v53 )\n          v54 = -1LL;\n        v55 = v25 * v54;\n        if ( v46 < v54 )\n          v55 = -1LL;\n        v56 = v25 * v55;\n        if ( v46 < v55 )\n          v56 = -1LL;\n        v57 = v25 * v56;\n        if ( v46 < v56 )\n          v57 = -1LL;\n        v58 = v25 * v57;\n        if ( v46 < v57 )\n          v58 = -1LL;\n        if ( !v48 )\n        {\n          v39 = v46 < v58;\n          v59 = v25 * v58;\n          if ( v39 )\n            v59 = -1LL;\n          v49 = v25 * v59;\n          if ( v46 < v59 )\n            v49 = -1LL;\n          v50 = v25 * v49;\n          if ( v46 < v49 )\n            v50 = -1LL;\n          v51 = v25 * v50;\n          if ( v46 < v50 )\n            v51 = -1LL;\n          v52 = v25 * v51;\n          if ( v46 < v51 )\n            v52 = -1LL;\n          v18 = v25 * v52;\n          if ( v46 < v52 )\n            v18 = -1LL;\n          continue;\n        }\n        break;\n      }\n      v91 = -(v46 < v57);\n      v92 = -(v46 < v56);\n      v93 = v46 < v55 ? -1 : v46 < v54 ? -1 : v46 < v53 ? -1u : (unsigned __int8)-(v46 < v18);\n      goto LABEL_200;\n    case 'G':\n    case 'g':\n      v31 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v32 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      if ( v32 )\n        goto LABEL_204;\n      while ( 1 )\n      {\n        v99 = v25 * v18;\n        if ( v31 < v18 )\n          v99 = -1LL;\n        v18 = v99;\nLABEL_204:\n        v94 = v25 * v18;\n        if ( v31 < v18 )\n          v94 = -1LL;\n        if ( v32 )\n          break;\n        v18 = v94;\n      }\n      v95 = v25 * v94;\n      if ( v31 < v94 )\n        v95 = -1LL;\n      v96 = -(v31 < v95);\n      v97 = v95 * v25;\n      if ( v31 < v95 )\n        v97 = -1LL;\n      v98 = v31 < v94 ? -1 : -(v31 < v18);\n      goto LABEL_234;\n    case 'K':\n    case 'k':\n      v33 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v34 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      if ( v34 )\n        goto LABEL_216;\n      while ( 1 )\n      {\n        v101 = v25 * v18;\n        if ( v33 < v18 )\n          v101 = -1LL;\n        v18 = v101;\nLABEL_216:\n        v100 = v25 * v18;\n        if ( v33 < v18 )\n          v100 = -1LL;\n        if ( v34 )\n          break;\n        v18 = v100;\n      }\n      v30 = v33 < v18;\n      v18 = v100;\n      goto LABEL_256;\n    case 'M':\n    case 'm':\n      v35 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v36 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      while ( 2 )\n      {\n        v37 = v18;\n        if ( v36 )\n          goto LABEL_60;\n        do\n        {\n          v18 = v25 * v37;\n          if ( v35 < v37 )\n            v18 = -1LL;\nLABEL_60:\n          v37 = v25 * v18;\n          if ( v35 < v18 )\n            v37 = -1LL;\n        }\n        while ( !v36 );\n        v38 = v25 * v37;\n        if ( v35 < v37 )\n          v38 = -1LL;\n        if ( (v23 & 1) != 0 && v20 >= 10 )\n        {\n          v39 = v35 < v38;\n          v40 = v25 * v38;\n          if ( v39 )\n            v40 = -1LL;\n          v18 = v25 * v40;\n          if ( v35 < v40 )\n            v18 = -1LL;\n          continue;\n        }\n        break;\n      }\n      v30 = ((unsigned __int8)-(v35 < v37) | (unsigned __int8)-(v35 < v18)) & 1;\n      v18 = v38;\n      goto LABEL_256;\n    case 'P':\n      v125 = (char *)v24;\n      v60 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v61 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      while ( 2 )\n      {\n        v65 = v18;\n        if ( v61 )\n          goto LABEL_126;\n        do\n        {\n          v18 = v25 * v65;\n          if ( v60 < v65 )\n            v18 = -1LL;\nLABEL_126:\n          v65 = v25 * v18;\n          if ( v60 < v18 )\n            v65 = -1LL;\n        }\n        while ( !v61 );\n        v66 = v25 * v65;\n        if ( v60 < v65 )\n          v66 = -1LL;\n        v67 = v25 * v66;\n        if ( v60 < v66 )\n          v67 = -1LL;\n        v68 = v25 * v67;\n        if ( v60 < v67 )\n          v68 = -1LL;\n        v58 = v25 * v68;\n        if ( v60 < v68 )\n          v58 = -1LL;\n        if ( (v23 & 1) != 0 && v20 >= 10 )\n        {\n          v39 = v60 < v58;\n          v69 = v25 * v58;\n          if ( v39 )\n            v69 = -1LL;\n          v62 = v25 * v69;\n          if ( v60 < v69 )\n            v62 = -1LL;\n          v63 = v25 * v62;\n          if ( v60 < v62 )\n            v63 = -1LL;\n          v64 = v25 * v63;\n          if ( v60 < v63 )\n            v64 = -1LL;\n          v18 = v25 * v64;\n          if ( v60 < v64 )\n            v18 = -1LL;\n          continue;\n        }\n        break;\n      }\n      v91 = -(v60 < v68);\n      v92 = -(v60 < v67);\n      v93 = v60 < v66 ? -1 : v60 < v65 ? -1 : (unsigned __int8)-(v60 < v18);\nLABEL_200:\n      v30 = (v91 | (unsigned __int8)(v92 | v93)) & 1;\n      goto LABEL_202;\n    case 'T':\n    case 't':\n      v41 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v42 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      if ( v42 )\n        goto LABEL_224;\n      while ( 1 )\n      {\n        v105 = v25 * v18;\n        if ( v41 < v18 )\n          v105 = -1LL;\n        v18 = v105;\nLABEL_224:\n        v102 = v25 * v18;\n        if ( v41 < v18 )\n          v102 = -1LL;\n        if ( v42 )\n          break;\n        v18 = v102;\n      }\n      v103 = v25 * v102;\n      if ( v41 < v102 )\n        v103 = -1LL;\n      v104 = v25 * v103;\n      if ( v41 < v103 )\n        v104 = -1LL;\n      v96 = -(v41 < v104);\n      v97 = v104 * v25;\n      if ( v41 < v104 )\n        v97 = -1LL;\n      v98 = v41 < v103 ? -1 : v41 < v102 ? -1 : (unsigned __int8)-(v41 < v18);\nLABEL_234:\n      v30 = (v96 | v98) & 1;\n      goto LABEL_255;\n    case 'Y':\n      v125 = (char *)v24;\n      v70 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v71 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      v72 = (v23 & 1) == 0 || v20 < 10;\n      break;\n    case 'Z':\n      v87 = 0xFFFFFFFFFFFFFFFFLL / v25;\n      v88 = (((_BYTE)x_4 * ((_BYTE)x_4 - 1)) & 1) == 0 || y_5 < 10;\n      if ( v88 )\n        goto LABEL_239;\n      while ( 1 )\n      {\n        v122 = v25 * v18;\n        if ( v87 < v18 )\n          v122 = -1LL;\n        v18 = v122;\nLABEL_239:\n        v106 = v25 * v18;\n        if ( v87 < v18 )\n          v106 = -1LL;\n        if ( v88 )\n          break;\n        v18 = v106;\n      }\n      v107 = -(v87 < v106);\n      v108 = v25 * v106;\n      if ( v87 < v106 )\n        v108 = -1LL;\n      v109 = -(v87 < v108);\n      v110 = v25 * v108;\n      if ( v87 < v108 )\n        v110 = -1LL;\n      v111 = v24;\n      v112 = -(v87 < v110);\n      v113 = v25 * v110;\n      if ( v87 < v110 )\n        v113 = -1LL;\n      v114 = -(v87 < v113);\n      v115 = v25 * v113;\n      if ( v87 < v113 )\n        v115 = -1LL;\n      v116 = -(v87 < v115);\n      v117 = v25 * v115;\n      if ( v87 < v115 )\n        v117 = -1LL;\n      v118 = -(v87 < v117);\n      v97 = v117 * v25;\n      if ( v87 < v117 )\n        v97 = -1LL;\n      v119 = v109 | (v87 < v18 ? -1 : v107);\n      v28 = v123;\n      v120 = v112 | v119;\n      v24 = v111;\n      v30 = v118 & 1 | v116 & 1 | v114 & 1 | v120 & 1;\nLABEL_255:\n      v18 = v97;\n      goto LABEL_256;\n    case 'b':\n      v43 = v18 >> 55 != 0;\n      v44 = v18 >> 55 == 0 ? v18 << 9 : -1;\n      if ( (v23 & 1) != 0 && v20 >= 10 )\n      {\n        while ( 1 )\n        {\n          v89 = v44 << 9;\n          if ( v44 > 0x7FFFFFFFFFFFFFLL )\n            v89 = -1LL;\n          v44 = v89 << 9;\n          if ( v89 > 0x7FFFFFFFFFFFFFLL )\n            v44 = -1LL;\n        }\n      }\nLABEL_194:\n      v30 = v43;\n      v18 = v44;\n      goto LABEL_256;\n    case 'c':\n      goto LABEL_256;\n    case 'w':\n      v90 = -1LL;\n      if ( (v18 & 0x8000000000000000LL) == 0LL )\n        v90 = 2 * v18;\n      v30 = v18 >> 63;\n      v18 = v90;\n      goto LABEL_256;\n    default:\n      *v126 = v18;\n      return v28 | 2;\n  }\n  while ( 1 )\n  {\n    v79 = v18;\n    if ( !v71 )\n      goto LABEL_180;\n    while ( 1 )\n    {\n      v79 = v25 * v18;\n      if ( v70 < v18 )\n        v79 = -1LL;\n      if ( v71 )\n        break;\nLABEL_180:\n      v18 = v25 * v79;\n      if ( v70 < v79 )\n        v18 = -1LL;\n    }\n    v80 = v25 * v79;\n    if ( v70 < v79 )\n      v80 = -1LL;\n    v81 = v25 * v80;\n    if ( v70 < v80 )\n      v81 = -1LL;\n    v82 = v25 * v81;\n    if ( v70 < v81 )\n      v82 = -1LL;\n    v83 = v25 * v82;\n    if ( v70 < v82 )\n      v83 = -1LL;\n    v84 = v25 * v83;\n    if ( v70 < v83 )\n      v84 = -1LL;\n    v85 = v25 * v84;\n    if ( v70 < v84 )\n      v85 = -1LL;\n    v58 = v25 * v85;\n    if ( v70 < v85 )\n      v58 = -1LL;\n    if ( v72 )\n      break;\n    v39 = v70 < v58;\n    v86 = v25 * v58;\n    if ( v39 )\n      v86 = -1LL;\n    v73 = v25 * v86;\n    if ( v70 < v86 )\n      v73 = -1LL;\n    v74 = v25 * v73;\n    if ( v70 < v73 )\n      v74 = -1LL;\n    v75 = v25 * v74;\n    if ( v70 < v74 )\n      v75 = -1LL;\n    v76 = v25 * v75;\n    if ( v70 < v75 )\n      v76 = -1LL;\n    v77 = v25 * v76;\n    if ( v70 < v76 )\n      v77 = -1LL;\n    v78 = v25 * v77;\n    if ( v70 < v77 )\n      v78 = -1LL;\n    v18 = v25 * v78;\n    if ( v70 < v78 )\n      v18 = -1LL;\n  }\n  v30 = (v70 < v85) | (v70 < v84) | (v70 < v83) | ((unsigned __int8)-(v70 < v82) | (unsigned __int8)(v70 < v81 ? -1 : v70 < v80 ? -1u : v70 < v79 ? -1u : (unsigned __int8)-(v70 < v18))) & 1;\nLABEL_202:\n  v18 = v58;\n  v28 = v123;\n  v24 = (__int64)v125;\nLABEL_256:\n  v16 = v30 | v28;\n  *endptr = &v21[v24];\n  if ( v21[v24] )\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    v16 |= 2u;\n  }\nLABEL_261:\n  *v126 = v18;\n  return v16;\n}\n"
        },
        {
            "funcName": "rpl_calloc",
            "funcStartAddr": "0x407c10",
            "funcEndAddr": "0x407cb4",
            "decompiledFuncCode": "void *__fastcall rpl_calloc(size_t n, size_t s)\n{\n  size_t v2; // r14\n  size_t v3; // r15\n  bool v4; // bl\n  void *result; // rax\n\n  v2 = 1LL;\n  if ( n )\n  {\n    v3 = 1LL;\n    if ( s )\n    {\n      if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      {\n        while ( 1 )\n          ;\n      }\n      v2 = s;\n      v3 = n;\n      if ( n * s / s != n )\n      {\n        *__errno_location() = 12;\n        return 0LL;\n      }\n    }\n  }\n  else\n  {\n    v3 = 1LL;\n  }\n  v4 = (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 || y < 10;\n  do\n    result = calloc(v3, v2);\n  while ( !v4 );\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_mbrtowc",
            "funcStartAddr": "0x407cc0",
            "funcEndAddr": "0x407d48",
            "decompiledFuncCode": "size_t __fastcall rpl_mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  wchar_t *v5; // rbx\n  size_t v6; // rax\n  size_t v7; // r12\n  __int64 v9; // [rsp+0h] [rbp-20h] BYREF\n\n  do\n    v5 = (wchar_t *)(&v9 - 2);\n  while ( (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 && y >= 10 );\n  if ( pwc )\n    v5 = pwc;\n  v6 = mbrtowc(v5, s, n, ps);\n  v7 = v6;\n  if ( n && v6 >= 0xFFFFFFFFFFFFFFFELL && !hard_locale(0) )\n  {\n    *v5 = *(unsigned __int8 *)s;\n    return 1LL;\n  }\n  return v7;\n}\n"
        },
        {
            "funcName": "close_stream",
            "funcStartAddr": "0x407d50",
            "funcEndAddr": "0x407e1d",
            "decompiledFuncCode": "int __fastcall close_stream(FILE *stream)\n{\n  size_t v1; // r14\n  int flags; // r12d\n  int v3; // eax\n  char v4; // r15\n  int v5; // ebp\n  int v6; // ebx\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v1 = __fpending(stream);\n    flags = stream->_flags;\n    v3 = rpl_fclose(stream);\n    v4 = x;\n    v5 = y;\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    __fpending(stream);\n    rpl_fclose(stream);\n  }\n  if ( (flags & 0x20) != 0 )\n  {\n    if ( !v3 )\n    {\n      *__errno_location() = 0;\n      v4 = x;\n      v5 = y;\n    }\n  }\n  else\n  {\n    v6 = 0;\n    if ( !v3 || !v1 && *__errno_location() == 9 )\n      return v6;\n  }\n  v6 = -1;\n  if ( v5 >= 10 && ((v4 * (v4 - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return v6;\n}\n"
        },
        {
            "funcName": "hard_locale",
            "funcStartAddr": "0x407e20",
            "funcEndAddr": "0x407e8b",
            "decompiledFuncCode": "bool __fastcall hard_locale(int category)\n{\n  char *v1; // rax\n  const char *v2; // rbx\n  bool v3; // bp\n\n  v1 = setlocale(category, 0LL);\n  v2 = v1;\n  v3 = 1;\n  if ( v1 && (!strcmp(v1, \"C\") || !strcmp(v2, \"POSIX\")) )\n  {\n    v3 = 0;\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  return v3;\n}\n"
        },
        {
            "funcName": "locale_charset",
            "funcStartAddr": "0x407e90",
            "funcEndAddr": "0x407eb5",
            "decompiledFuncCode": "const char *__cdecl locale_charset()\n{\n  char *v0; // rax\n  const char *v1; // rcx\n  const char *result; // rax\n\n  v0 = nl_langinfo(14);\n  v1 = \"\\n\"\n       \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n       \"This is free software: you are free to change and redistribute it.\\n\"\n       \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n       \"\\n\"\n     + 203;\n  if ( v0 )\n    v1 = v0;\n  result = \"ASCII\";\n  if ( *v1 )\n    return v1;\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fclose",
            "funcStartAddr": "0x407ec0",
            "funcEndAddr": "0x407fcb",
            "decompiledFuncCode": "int __fastcall rpl_fclose(FILE *fp)\n{\n  int v1; // eax\n  int v2; // eax\n  int result; // eax\n  int *v4; // r14\n  int v5; // ebp\n\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_5;\n  while ( 1 )\n  {\n    v1 = fileno(fp);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_5:\n    fileno(fp);\n  }\n  if ( v1 < 0 )\n    return fclose(fp);\n  if ( __freading(fp) )\n  {\n    v2 = fileno(fp);\n    if ( lseek(v2, 0LL, 1) == -1 )\n      return fclose(fp);\n  }\n  if ( !rpl_fflush(fp) )\n    return fclose(fp);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  v4 = __errno_location();\n  v5 = *v4;\n  result = fclose(fp);\n  if ( v5 )\n  {\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n      goto LABEL_19;\n    while ( 1 )\n    {\n      *v4 = v5;\n      result = -1;\n      if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n        break;\nLABEL_19:\n      *v4 = v5;\n    }\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fflush",
            "funcStartAddr": "0x407fd0",
            "funcEndAddr": "0x4080d4",
            "decompiledFuncCode": "int __fastcall rpl_fflush(FILE *stream)\n{\n  int v1; // eax\n  int result; // eax\n\n  if ( !stream )\n    return fflush(stream);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    goto LABEL_6;\n  while ( 1 )\n  {\n    v1 = __freading(stream);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\nLABEL_6:\n    __freading(stream);\n  }\n  if ( !v1 )\n    return fflush(stream);\n  while ( 1 )\n  {\n    if ( (stream->_flags & 0x100) != 0 )\n      rpl_fseeko(stream, 0LL, 1);\n    if ( y_2 >= 10 && (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    result = fflush(stream);\n    if ( y < 10 || (((_BYTE)x * ((_BYTE)x - 1)) & 1) == 0 )\n      break;\n    if ( (stream->_flags & 0x100) != 0 )\n      rpl_fseeko(stream, 0LL, 1);\n    if ( y_2 >= 10 && (((_BYTE)x_1 * ((_BYTE)x_1 - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n    fflush(stream);\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "rpl_fseeko",
            "funcStartAddr": "0x4080e0",
            "funcEndAddr": "0x408192",
            "decompiledFuncCode": "int __fastcall rpl_fseeko(FILE *fp, off_t offset, int whence)\n{\n  int result; // eax\n  int v5; // eax\n  __off_t v6; // rax\n\n  if ( fp->_IO_read_end != fp->_IO_read_ptr )\n    return fseeko(fp, offset, whence);\n  if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  if ( fp->_IO_write_ptr != fp->_IO_write_base || fp->_IO_save_base )\n    return fseeko(fp, offset, whence);\n  v5 = fileno(fp);\n  v6 = lseek(v5, offset, whence);\n  if ( v6 == -1 )\n  {\n    result = -1;\n    if ( y >= 10 && (((_BYTE)x * ((_BYTE)x - 1)) & 1) != 0 )\n    {\n      while ( 1 )\n        ;\n    }\n  }\n  else\n  {\n    LOBYTE(fp->_flags) &= ~0x10u;\n    fp->_offset = v6;\n    return 0;\n  }\n  return result;\n}\n"
        },
        {
            "funcName": "atexit",
            "funcStartAddr": "0x408220",
            "funcEndAddr": "0x408232",
            "decompiledFuncCode": "int __fastcall atexit(void (__fastcall *a1)(void *))\n{\n  return __cxa_atexit(a1, 0LL, _dso_handle);\n}\n"
        }
    ],
    "funcCount": 73
}