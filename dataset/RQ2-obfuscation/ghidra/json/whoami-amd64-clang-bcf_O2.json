{
    "funcCount": 71,
    "funcInfo": [
        {
            "funcStartAddr": "0x402300",
            "funcEndAddr": "0x402305",
            "decompiledFuncCode": "\nvoid _dl_relocate_static_pie(void)\n\n{\n  return;\n}\n\n",
            "funcName": "_dl_relocate_static_pie"
        },
        {
            "funcStartAddr": "0x4023c0",
            "funcEndAddr": "0x4025b3",
            "decompiledFuncCode": "\nvoid usage(int status)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  if (status == 0) {\n    while( true ) {\n      uVar2 = dcgettext(0,\"Usage: %s [OPTION]...\\n\",5);\n      __printf_chk(1,uVar2,program_name);\n      pcVar3 = (char *)dcgettext(0,\n                                 \"Print the user name associated with the current effective user ID.\\nSame as id -un.\\n\\n\"\n                                 ,5);\n      fputs_unlocked(pcVar3,stdout);\n      pcVar3 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n      fputs_unlocked(pcVar3,stdout);\n      pcVar3 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n      fputs_unlocked(pcVar3,stdout);\n      emit_ancillary_info(pcVar3);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\n      uVar2 = dcgettext(0,\"Usage: %s [OPTION]...\\n\",5);\n      __printf_chk(1,uVar2,program_name);\n      pcVar3 = (char *)dcgettext(0,\n                                 \"Print the user name associated with the current effective user ID.\\nSame as id -un.\\n\\n\"\n                                 ,5);\n      fputs_unlocked(pcVar3,stdout);\n      pcVar3 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n      fputs_unlocked(pcVar3,stdout);\n      pcVar3 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n      fputs_unlocked(pcVar3,stdout);\n      emit_ancillary_info(pcVar3);\n    }\n  }\n  else {\n    while( true ) {\n      uVar2 = stderr;\n      uVar1 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n      __fprintf_chk(uVar2,1,uVar1,program_name);\n      uVar2 = stderr;\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\n      uVar1 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n      __fprintf_chk(uVar2,1,uVar1,program_name);\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(status);\n}\n\n",
            "funcName": "usage"
        },
        {
            "funcStartAddr": "0x4025d0",
            "funcEndAddr": "0x40273a",
            "decompiledFuncCode": "\nvoid emit_ancillary_info(char *program)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  if ((9 < y_29) && (((x_28 + -1) * x_28 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  pcVar4 = \"whoami\";\n  if (emit_ancillary_info::infomap[6].node != (char *)0x0) {\n    pcVar4 = emit_ancillary_info::infomap[6].node;\n  }\n  while( true ) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if ((y_29 < 10) || (((x_28 + -1) * x_28 & 1U) == 0)) break;\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    setlocale(5,(char *)0x0);\n  }\n  if ((pcVar3 != (char *)0x0) && (iVar1 = strncmp(pcVar3,\"en_\",3), iVar1 != 0)) {\n    pcVar3 = (char *)dcgettext(0,\n                               \"Report any translation bugs to <https://translationproject.org/team/>\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,stdout);\n  }\n  uVar2 = dcgettext(0,\"Full documentation <%s%s>\\n\",5);\n  __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",\"whoami\");\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  pcVar3 = \"\";\n  if (pcVar4 == \"whoami\") {\n    pcVar3 = \" invocation\";\n  }\n  __printf_chk(1,uVar2,pcVar4,pcVar3);\n  return;\n}\n\n",
            "funcName": "emit_ancillary_info"
        },
        {
            "funcStartAddr": "0x402750",
            "funcEndAddr": "0x40290b",
            "decompiledFuncCode": "\nint main(int argc,char **argv)\n\n{\n  int iVar1;\n  __uid_t __uid;\n  int *piVar2;\n  char *pcVar3;\n  passwd *ppVar4;\n  undefined8 uVar5;\n  \n  set_program_name(*argv);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/home/yujeong/binary_gen/coreutils-8.31/tmp/_install/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  parse_gnu_standard_options_only\n            (argc,argv,\"whoami\",\"GNU coreutils\",Version,true,usage,\"Richard Mlynarik\",0);\n  if (optind != argc) {\n    uVar5 = dcgettext(0,\"extra operand %s\",5);\n    pcVar3 = quote(argv[optind]);\n    error(0,0,uVar5,pcVar3);\n                    /* WARNING: Subroutine does not return */\n    usage(1);\n  }\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  __uid = geteuid();\n  if ((__uid != 0xffffffff) || (*piVar2 == 0)) {\n    if ((9 < y_31) && (((x_30 + -1) * x_30 & 1U) != 0)) goto LAB_00402882;\n    while ((ppVar4 = getpwuid(__uid), 9 < y_31 && (((x_30 + -1) * x_30 & 1U) != 0))) {\nLAB_00402882:\n      getpwuid(__uid);\n    }\n    if (ppVar4 != (passwd *)0x0) {\n      puts(ppVar4->pw_name);\n      return 0;\n    }\n  }\n  if ((9 < y_31) && (((x_30 + -1) * x_30 & 1U) != 0)) goto LAB_004028de;\n  do {\n    iVar1 = *piVar2;\n    uVar5 = dcgettext(0,\"cannot find name for user ID %lu\",5);\n    error(1,iVar1,uVar5,__uid);\nLAB_004028de:\n    iVar1 = *piVar2;\n    uVar5 = dcgettext(0,\"cannot find name for user ID %lu\",5);\n    error(1,iVar1,uVar5,__uid);\n  } while( true );\n}\n\n",
            "funcName": "main"
        },
        {
            "funcStartAddr": "0x402910",
            "funcEndAddr": "0x402948",
            "decompiledFuncCode": "\nvoid close_stdout_set_file_name(char *file)\n\n{\n  do {\n    file_name = file;\n    if (y < 10) {\n      return;\n    }\n  } while (((x + -1) * x & 1U) != 0);\n  return;\n}\n\n",
            "funcName": "close_stdout_set_file_name"
        },
        {
            "funcStartAddr": "0x402950",
            "funcEndAddr": "0x402988",
            "decompiledFuncCode": "\nvoid close_stdout_set_ignore_EPIPE(_Bool ignore)\n\n{\n  do {\n    ignore_EPIPE = ignore;\n    if (y_4 < 10) {\n      return;\n    }\n  } while (((x_3 + -1) * x_3 & 1U) != 0);\n  return;\n}\n\n",
            "funcName": "close_stdout_set_ignore_EPIPE"
        },
        {
            "funcStartAddr": "0x402990",
            "funcEndAddr": "0x402b00",
            "decompiledFuncCode": "\nvoid close_stdout(void)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  \n  if ((9 < y_6) && (((x_5 + -1) * x_5 & 1U) != 0)) goto LAB_004029d3;\n  while ((iVar2 = close_stream(stdout), _Var1 = ignore_EPIPE, 9 < y_6 &&\n         (((x_5 + -1) * x_5 & 1U) != 0))) {\nLAB_004029d3:\n    close_stream(stdout);\n  }\n  if ((iVar2 != 0) && ((piVar3 = __errno_location(), _Var1 == false || (*piVar3 != 0x20)))) {\n    uVar4 = dcgettext(0,\"write error\",5);\n    iVar2 = *piVar3;\n    if (file_name != (char *)0x0) {\n      pcVar5 = quotearg_colon(file_name);\n      error(0,iVar2,\"%s: %s\",pcVar5,uVar4);\n                    /* WARNING: Subroutine does not return */\n      _exit(exit_failure);\n    }\n    if ((9 < y_6) && (((x_5 + -1) * x_5 & 1U) != 0)) goto LAB_00402aeb;\n    while ((error(0,iVar2,\"%s\",uVar4), 9 < y_6 && (((x_5 + -1) * x_5 & 1U) != 0))) {\nLAB_00402aeb:\n      error(0,iVar2,\"%s\",uVar4);\n    }\n                    /* WARNING: Subroutine does not return */\n    _exit(exit_failure);\n  }\n  while ((iVar2 = close_stream(stderr), 9 < y_6 && (((x_5 + -1) * x_5 & 1U) != 0))) {\n    close_stream(stderr);\n  }\n  if (iVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n    _exit(exit_failure);\n  }\n  return;\n}\n\n",
            "funcName": "close_stdout"
        },
        {
            "funcStartAddr": "0x402b10",
            "funcEndAddr": "0x402c84",
            "decompiledFuncCode": "\nvoid parse_long_options(int argc,char **argv,char *command_name,char *package,char *version,\n                       _func_void_int *usage_func,...)\n\n{\n  char in_AL;\n  int iVar1;\n  __va_list_tag *p_Var2;\n  uint uVar3;\n  __va_list_tag *authors;\n  undefined4 uVar4;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  undefined8 uStack_120;\n  uint local_118 [2];\n  long local_110 [3];\n  undefined local_f8 [48];\n  undefined4 local_c8;\n  undefined4 local_b8;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  char *local_40;\n  char *local_38;\n  \n  authors = (__va_list_tag *)local_f8;\n  if (in_AL != '\\0') {\n    local_c8 = in_XMM0_Da;\n    local_b8 = in_XMM1_Da;\n    local_a8 = in_XMM2_Da;\n    local_98 = in_XMM3_Da;\n    local_88 = in_XMM4_Da;\n    local_78 = in_XMM5_Da;\n    local_68 = in_XMM6_Da;\n    local_58 = in_XMM7_Da;\n  }\n  uVar3 = (x + -1) * x & 1;\n  p_Var2 = (__va_list_tag *)local_f8;\n  uVar4 = opterr;\n  if ((9 < y) && (p_Var2 = (__va_list_tag *)local_f8, uVar3 != 0)) goto LAB_00402b9f;\n  while( true ) {\n    authors = (__va_list_tag *)((long)p_Var2 + -0x20);\n    opterr = 0;\n    if ((y < 10) || (uVar3 == 0)) break;\nLAB_00402b9f:\n    p_Var2 = authors;\n    uVar4 = 0;\n  }\n  local_40 = package;\n  local_38 = command_name;\n  if (argc == 2) {\n    while( true ) {\n      *(undefined8 *)((long)p_Var2 + -0x28) = 0x402c04;\n      iVar1 = getopt_long(2,argv,&DAT_00408358,long_options,0);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\n      *(undefined8 *)((long)p_Var2 + -0x28) = 0x402bea;\n      getopt_long(2,argv,&DAT_00408358,long_options,0);\n    }\n    if (iVar1 == 0x68) {\n      *(undefined8 *)((long)p_Var2 + -0x28) = 0x402c70;\n      (*usage_func)(0);\n    }\n    else if (iVar1 == 0x76) {\n      *(undefined **)((long)p_Var2 + -0x10) = local_f8;\n      *(undefined **)((long)p_Var2 + -0x18) = &stack0x00000008;\n      *(undefined4 *)((long)p_Var2 + -0x1c) = 0x30;\n      authors->gp_offset = 0x30;\n      *(undefined8 *)((long)p_Var2 + -0x28) = 0x402c64;\n      version_etc_va(stdout,local_38,local_40,version,authors);\n                    /* WARNING: Subroutine does not return */\n      *(undefined8 *)((long)p_Var2 + -0x28) = 0x402c6b;\n      exit(0);\n    }\n  }\n  opterr = uVar4;\n  optind = 0;\n  return;\n}\n\n",
            "funcName": "parse_long_options"
        },
        {
            "funcStartAddr": "0x402c90",
            "funcEndAddr": "0x402e21",
            "decompiledFuncCode": "\nvoid parse_gnu_standard_options_only\n               (int argc,char **argv,char *command_name,char *package,char *version,_Bool scan_all,\n               _func_void_int *usage_func,...)\n\n{\n  undefined4 uVar1;\n  char in_AL;\n  int iVar2;\n  __va_list_tag *p_Var3;\n  char *pcVar4;\n  __va_list_tag *authors;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  undefined8 uStack_120;\n  uint local_118 [2];\n  long local_110 [3];\n  undefined local_f8 [48];\n  undefined4 local_c8;\n  undefined4 local_b8;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  char *local_48;\n  char *local_40;\n  char *local_38;\n  \n  if (in_AL != '\\0') {\n    local_c8 = in_XMM0_Da;\n    local_b8 = in_XMM1_Da;\n    local_a8 = in_XMM2_Da;\n    local_98 = in_XMM3_Da;\n    local_88 = in_XMM4_Da;\n    local_78 = in_XMM5_Da;\n    local_68 = in_XMM6_Da;\n    local_58 = in_XMM7_Da;\n  }\n  pcVar4 = \"+\";\n  if (scan_all) {\n    pcVar4 = \"\";\n  }\n  p_Var3 = (__va_list_tag *)local_f8;\n  local_48 = version;\n  local_40 = package;\n  local_38 = command_name;\n  if ((9 < y_5) &&\n     (p_Var3 = (__va_list_tag *)local_f8, authors = (__va_list_tag *)local_f8,\n     ((x_4 + -1) * x_4 & 1U) != 0)) goto LAB_00402d5b;\n  while( true ) {\n    uVar1 = opterr;\n    authors = (__va_list_tag *)((long)p_Var3 + -0x20);\n    opterr = 1;\n    *(undefined8 *)((long)p_Var3 + -0x28) = 0x402d41;\n    iVar2 = getopt_long(argc,argv,pcVar4,long_options,0);\n    if ((y_5 < 10) || (((x_4 + -1) * x_4 & 1U) == 0)) break;\nLAB_00402d5b:\n    p_Var3 = authors;\n    opterr = 1;\n    p_Var3[-1].reg_save_area = (void *)0x402d7a;\n    getopt_long(argc,argv,pcVar4,long_options,0);\n  }\n  if (iVar2 != -1) {\n    if (iVar2 == 0x68) {\n      *(undefined8 *)((long)p_Var3 + -0x28) = 0x402e10;\n      (*usage_func)(0);\n    }\n    else {\n      if (iVar2 == 0x76) {\n        *(undefined **)((long)p_Var3 + -0x10) = local_f8;\n        *(undefined **)((long)p_Var3 + -0x18) = &stack0x00000010;\n        *(undefined4 *)((long)p_Var3 + -0x1c) = 0x30;\n        authors->gp_offset = 0x30;\n        *(undefined8 *)((long)p_Var3 + -0x28) = 0x402dd4;\n        version_etc_va(stdout,local_38,local_40,local_48,authors);\n                    /* WARNING: Subroutine does not return */\n        *(undefined8 *)((long)p_Var3 + -0x28) = 0x402ddb;\n        exit(0);\n      }\n      while( true ) {\n        *(undefined8 *)((long)p_Var3 + -0x28) = 0x402df0;\n        (*usage_func)(exit_failure);\n        if ((y_5 < 10) || (((x_4 + -1) * x_4 & 1U) == 0)) break;\n        *(undefined8 *)((long)p_Var3 + -0x28) = 0x402de8;\n        (*usage_func)(exit_failure);\n      }\n    }\n  }\n  opterr = uVar1;\n  return;\n}\n\n",
            "funcName": "parse_gnu_standard_options_only"
        },
        {
            "funcStartAddr": "0x402e30",
            "funcEndAddr": "0x402ef3",
            "decompiledFuncCode": "\nvoid set_program_name(char *argv0)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s1;\n  \n  if (argv0 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",0x37,1,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr(argv0,0x2f);\n  __s1 = pcVar2 + 1;\n  if (pcVar2 == (char *)0x0) {\n    __s1 = argv0;\n  }\n  if (6 < (long)__s1 - (long)argv0) {\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    iVar1 = strncmp(__s1 + -7,\"/.libs/\",7);\n    if ((iVar1 == 0) && (iVar1 = strncmp(__s1,\"lt-\",3), argv0 = __s1, iVar1 == 0)) {\n      argv0 = __s1 + 3;\n      program_invocation_short_name = argv0;\n    }\n  }\n  program_name = argv0;\n  program_invocation_name = argv0;\n  return;\n}\n\n",
            "funcName": "set_program_name"
        },
        {
            "funcStartAddr": "0x402f00",
            "funcEndAddr": "0x402f33",
            "decompiledFuncCode": "\nquoting_options * clone_quoting_options(quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  quoting_options *pqVar3;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  pqVar3 = (quoting_options *)xmemdup(o,0x38);\n  *piVar2 = iVar1;\n  return pqVar3;\n}\n\n",
            "funcName": "clone_quoting_options"
        },
        {
            "funcStartAddr": "0x402f40",
            "funcEndAddr": "0x402f4f",
            "decompiledFuncCode": "\nquoting_style get_quoting_style(quoting_options *o)\n\n{\n  quoting_options *pqVar1;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  return pqVar1->style;\n}\n\n",
            "funcName": "get_quoting_style"
        },
        {
            "funcStartAddr": "0x402f50",
            "funcEndAddr": "0x402fa3",
            "decompiledFuncCode": "\nvoid set_quoting_style(quoting_options *o,quoting_style s)\n\n{\n  quoting_options *pqVar1;\n  \n  if ((9 < y_22) && (((x_21 + -1) * x_21 & 1U) != 0)) goto LAB_00402f92;\n  while( true ) {\n    pqVar1 = &default_quoting_options;\n    if (o != (quoting_options *)0x0) {\n      pqVar1 = o;\n    }\n    pqVar1->style = s;\n    if ((y_22 < 10) || (((x_21 + -1) * x_21 & 1U) == 0)) break;\nLAB_00402f92:\n    pqVar1 = &default_quoting_options;\n    if (o != (quoting_options *)0x0) {\n      pqVar1 = o;\n    }\n    pqVar1->style = s;\n  }\n  return;\n}\n\n",
            "funcName": "set_quoting_style"
        },
        {
            "funcStartAddr": "0x402fb0",
            "funcEndAddr": "0x402fe6",
            "decompiledFuncCode": "\nwchar_t set_char_quoting(quoting_options *o,char c,wchar_t i)\n\n{\n  quoting_options *pqVar1;\n  uint uVar2;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  uVar2 = pqVar1->quote_these_too[(byte)c >> 5] >> (c & 0x1fU);\n  pqVar1->quote_these_too[(byte)c >> 5] =\n       ((uVar2 ^ i) & 1U) << (c & 0x1fU) ^ pqVar1->quote_these_too[(byte)c >> 5];\n  return uVar2 & 1;\n}\n\n",
            "funcName": "set_char_quoting"
        },
        {
            "funcStartAddr": "0x402ff0",
            "funcEndAddr": "0x403003",
            "decompiledFuncCode": "\nwchar_t set_quoting_flags(quoting_options *o,wchar_t i)\n\n{\n  wchar_t wVar1;\n  quoting_options *pqVar2;\n  \n  pqVar2 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar2 = o;\n  }\n  wVar1 = pqVar2->flags;\n  pqVar2->flags = i;\n  return wVar1;\n}\n\n",
            "funcName": "set_quoting_flags"
        },
        {
            "funcStartAddr": "0x403010",
            "funcEndAddr": "0x40303b",
            "decompiledFuncCode": "\nvoid set_custom_quoting(quoting_options *o,char *left_quote,char *right_quote)\n\n{\n  quoting_options *pqVar1;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  pqVar1->style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    pqVar1->left_quote = left_quote;\n    pqVar1->right_quote = right_quote;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "set_custom_quoting"
        },
        {
            "funcStartAddr": "0x403040",
            "funcEndAddr": "0x4030b2",
            "decompiledFuncCode": "\nsize_t quotearg_buffer(char *buffer,size_t buffersize,char *arg,size_t argsize,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  quoting_options *pqVar4;\n  wchar_t e;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  sVar3 = quotearg_buffer_restyled\n                    (buffer,buffersize,arg,argsize,pqVar4->style,pqVar4->flags,\n                     pqVar4->quote_these_too,pqVar4->left_quote,pqVar4->right_quote);\n  *piVar2 = iVar1;\n  return sVar3;\n}\n\n",
            "funcName": "quotearg_buffer"
        },
        {
            "funcStartAddr": "0x4030c0",
            "funcEndAddr": "0x40473d",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nsize_t quotearg_buffer_restyled\n                 (char *buffer,size_t buffersize,char *arg,size_t argsize,\n                 quoting_style quoting_style,wchar_t flags,uint *quote_these_too,char *left_quote,\n                 char *right_quote)\n\n{\n  char cVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  bool bVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  ushort **ppuVar11;\n  size_t sVar12;\n  byte bVar13;\n  quoting_style qVar14;\n  ulong uVar15;\n  ulong uVar16;\n  byte bVar17;\n  ulong uVar18;\n  byte bVar19;\n  byte bVar20;\n  ulong uVar21;\n  ulong uVar22;\n  byte bVar23;\n  ulong uVar24;\n  byte bVar25;\n  int iVar26;\n  bool bVar27;\n  size_t local_d8;\n  char *local_d0;\n  int local_b0;\n  ulong local_a0;\n  char *local_90;\n  ulong local_88;\n  wchar_t local_5c;\n  char *local_58;\n  ulong local_50;\n  mbstate_t local_48;\n  size_t local_40;\n  ulong local_38;\n  \n  local_90 = right_quote;\n  local_40 = __ctype_get_mb_cur_max();\n  uVar10 = (ulong)((byte)((uint)flags >> 1) & 1);\n  bVar19 = 1;\n  local_a0 = 0;\n  local_d0 = (char *)0x0;\n  local_d8 = 0;\n  bVar7 = false;\n  bVar5 = false;\n  bVar4 = false;\n  local_88 = argsize;\n  do {\n    bVar25 = (byte)uVar10;\n    if (custom_quoting_style < quoting_style) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    uVar18 = 0;\n    uVar21 = 0;\n    qVar14 = literal_quoting_style;\n    switch(quoting_style) {\n    case literal_quoting_style:\n      break;\n    case shell_always_quoting_style:\n      bVar2 = bVar7;\n      goto joined_r0x004031d2;\n    case shell_escape_quoting_style:\n      bVar7 = true;\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n    case shell_quoting_style:\n      uVar10 = 1;\n    case shell_escape_always_quoting_style:\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      bVar2 = true;\n      if ((uVar10 & 1) != 0) {\n        bVar2 = bVar7;\n      }\njoined_r0x004031d2:\n      bVar7 = bVar2;\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      qVar14 = shell_always_quoting_style;\n      bVar25 = (byte)uVar10;\n      if ((uVar10 & 1) == 0) {\n        if ((buffersize != 0) && (*buffer = '\\'', 9 < y_32)) {\n          do {\n            if (((x_31 + -1) * x_31 & 1U) == 0) break;\n            *buffer = '\\'';\n          } while (9 < y_32);\n          uVar18 = 1;\n          local_d0 = \"\\'\";\n          local_d8 = 1;\n          uVar21 = uVar10 & 0xff;\n          qVar14 = shell_always_quoting_style;\n          break;\n        }\n        uVar18 = 1;\n        local_d0 = \"\\'\";\n      }\n      else {\n        uVar18 = 0;\n        local_d0 = \"\\'\";\n      }\nLAB_00403368:\n      local_d8 = 1;\n      uVar21 = (ulong)bVar25;\n      break;\n    case c_quoting_style:\n      bVar7 = true;\n      qVar14 = c_quoting_style;\n      if ((uVar10 & 1) == 0) {\n        if (buffersize != 0) {\n          *buffer = '\\\"';\n        }\n        uVar18 = 1;\n      }\n      else {\n        uVar18 = 0;\n      }\n      local_d0 = \"\\\"\";\n      goto LAB_00403368;\n    case c_maybe_quoting_style:\n      bVar7 = true;\n      uVar18 = 0;\n      local_d0 = \"\\\"\";\n      local_d8 = 1;\n      uVar21 = 1;\n      qVar14 = c_quoting_style;\n      break;\n    case escape_quoting_style:\n      uVar18 = 0;\n      bVar7 = true;\n      uVar21 = 0;\n      qVar14 = escape_quoting_style;\n      if (9 < y_32) {\n        uVar21 = 0;\n        qVar14 = escape_quoting_style;\n        if (((x_31 + -1) * x_31 & 1U) != 0) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n      }\n      break;\n    default:\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_004033ca;\n      while( true ) {\n        left_quote = gettext_quote(\"`\",quoting_style);\n        uVar21 = (ulong)quoting_style;\n        local_90 = gettext_quote(\"\\'\",quoting_style);\n        if ((y_32 < 10) || (((x_31 + -1) * x_31 & 1U) == 0)) break;\nLAB_004033ca:\n        gettext_quote(\"`\",quoting_style);\n        gettext_quote(\"\\'\",quoting_style);\n      }\n    case custom_quoting_style:\n      if ((uVar10 & 1) == 0) {\n        if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\nLAB_00404560:\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n        uVar18 = 0;\n        while (left_quote[uVar18] != '\\0') {\n          if (uVar18 < buffersize) {\n            buffer[uVar18] = left_quote[uVar18];\n          }\n          uVar18 = uVar18 + 1;\n          if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_00404560;\n        }\n      }\n      else {\n        uVar18 = 0;\n      }\n      local_d8 = strlen(local_90);\n      bVar7 = true;\n      local_d0 = local_90;\n      uVar21 = uVar21 & 0xffffffffffffff00 | uVar10 & 0xff;\n      qVar14 = quoting_style;\n    }\n    quoting_style = qVar14;\n    if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    bVar2 = quoting_style != shell_always_quoting_style;\n    bVar13 = bVar2 & bVar7;\n    bVar25 = (byte)uVar21;\n    uVar10 = local_88;\n    local_88 = 0;\n    iVar9 = y_32;\n    local_38 = uVar21;\n    iVar26 = x_31;\nLAB_00403776:\n    if (uVar10 != 0xffffffffffffffff) {\n      if (local_88 == uVar10) goto LAB_00404473;\nLAB_0040379b:\n      uVar22 = local_88;\n      if ((local_d8 != 0 & bVar13) != 0) {\n        if ((local_d8 < 2) || (uVar10 != 0xffffffffffffffff)) {\n          if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          if (local_88 + local_d8 <= uVar10) goto LAB_00403870;\n          goto LAB_0040380b;\n        }\n        uVar10 = strlen(arg);\n        if (uVar10 < local_88 + local_d8) goto LAB_0040380b;\nLAB_00403870:\n        if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n        iVar8 = memcmp(arg + local_88,local_d0,local_d8);\n        bVar27 = iVar8 == 0;\n        if ((!bVar27) || (local_b0 = 0x10, (uVar21 & 1) == 0)) goto joined_r0x00403919;\n        goto joined_r0x00404065;\n      }\nLAB_0040380b:\n      bVar27 = false;\njoined_r0x00403919:\n      if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      uVar24 = (ulong)(byte)arg[local_88];\n      bVar20 = 1;\n      bVar23 = 0x62;\n      bVar17 = 0;\n      bVar6 = 0x74;\n      switch(uVar24) {\n      case 0:\n        if (bVar7 != false) {\n          local_b0 = 0x10;\n          if ((uVar21 & 1) != 0) goto joined_r0x00404065;\n          uVar22 = uVar18;\n          if ((quoting_style == shell_always_quoting_style) && (!bVar5)) {\n            if (uVar18 < buffersize) {\n              buffer[uVar18] = '\\'';\n              iVar9 = y_32;\n              iVar26 = x_31;\n            }\n            if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n              do {\n                    /* WARNING: Do nothing block with infinite loop */\n              } while( true );\n            }\n            if (uVar18 + 1 < buffersize) {\n              do {\n                buffer[uVar18 + 1] = '$';\n                if (y_32 < 10) break;\n              } while (((x_31 + -1) * x_31 & 1U) != 0);\n            }\n            if (uVar18 + 2 < buffersize) {\n              buffer[uVar18 + 2] = '\\'';\n            }\n            uVar22 = uVar18 + 3;\n            bVar5 = true;\n          }\n          if (uVar22 < buffersize) {\n            buffer[uVar22] = '\\\\';\n          }\n          uVar18 = uVar22 + 1;\n          bVar3 = true;\n          uVar24 = 0x30;\n          if (quoting_style == shell_always_quoting_style) goto LAB_00403f13;\n          if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          if ((uVar10 <= local_88 + 1) || (9 < (byte)(arg[local_88 + 1] - 0x30U)))\n          goto LAB_00403f13;\n          if (uVar18 < buffersize) {\n            buffer[uVar18] = '0';\n          }\n          if (uVar22 + 2 < buffersize) {\n            buffer[uVar22 + 2] = '0';\n          }\n          uVar18 = uVar22 + 3;\n          bVar17 = 0;\n          goto joined_r0x0040384b;\n        }\n        local_b0 = 0xf;\n        if ((flags & 1U) == 0) {\n          uVar24 = 0;\n          goto LAB_00403f11;\n        }\n        goto joined_r0x00404065;\n      default:\n        local_50 = buffersize;\n        if (local_40 != 1) {\n          local_48 = (mbstate_t)0x0;\n          if (uVar10 == 0xffffffffffffffff) {\n            uVar10 = strlen(arg);\n          }\n          local_58 = arg + local_88;\n          bVar17 = 1;\n          uVar15 = 0;\n          do {\n            uVar16 = uVar15 + local_88;\n            sVar12 = rpl_mbrtowc(&local_5c,arg + uVar16,uVar10 - uVar16,&local_48);\n            if (sVar12 == 0) goto LAB_004040d2;\n            if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n              do {\n                    /* WARNING: Do nothing block with infinite loop */\n              } while( true );\n            }\n            if (sVar12 == 0xffffffffffffffff) {\nLAB_004040ca:\n              bVar17 = 0;\n              goto LAB_004040d2;\n            }\n            if (sVar12 == 0xfffffffffffffffe) {\n              if (uVar10 <= uVar16) goto LAB_004040ca;\n              goto LAB_004040a4;\n            }\n            if ((1 < sVar12 & quoting_style == shell_always_quoting_style & bVar25 & 1) == 1) {\n              uVar16 = 1;\n              do {\n                if (((int)local_58[uVar16 + uVar15] - 0x5bU < 0x22) &&\n                   ((0x20000002bU >> ((ulong)((int)local_58[uVar16 + uVar15] - 0x5bU) & 0x3f) & 1)\n                    != 0)) {\n                  local_b0 = 0x10;\n                  goto LAB_004040da;\n                }\n                uVar16 = uVar16 + 1;\n              } while (uVar16 < sVar12);\n            }\n            iVar9 = iswprint(local_5c);\n            local_b0 = 0;\n            bVar6 = 0;\n            if (iVar9 != 0) {\n              bVar6 = bVar17;\n            }\n            bVar17 = bVar6;\n            uVar15 = uVar15 + sVar12;\n            iVar9 = mbsinit((mbstate_t *)&local_48);\n          } while (iVar9 == 0);\n          goto LAB_004040da;\n        }\n        ppuVar11 = __ctype_b_loc();\n        bVar17 = (byte)((*ppuVar11)[uVar24] >> 0xe) & 1;\n        uVar15 = 1;\n        goto LAB_00404139;\n      case 7:\n        bVar23 = 0x61;\n        break;\n      case 8:\n        break;\n      case 9:\n        goto switchD_0040383e_caseD_9;\n      case 10:\n        bVar6 = 0x6e;\n        goto switchD_0040383e_caseD_9;\n      case 0xb:\n        bVar23 = 0x76;\n        break;\n      case 0xc:\n        bVar23 = 0x66;\n        break;\n      case 0xd:\n        bVar6 = 0x72;\nswitchD_0040383e_caseD_9:\n        bVar23 = bVar6;\n        if ((uVar21 & 1) == 0 || bVar2) break;\njoined_r0x00404065:\n        local_b0 = 0x10;\n        goto joined_r0x00404065;\n      case 0x20:\nswitchD_0040383e_caseD_20:\n        bVar17 = 1;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        if ((quoting_style == shell_always_quoting_style) && ((uVar21 & 1) != 0))\n        goto joined_r0x00404065;\njoined_r0x00403c85:\n        bVar3 = false;\n        goto joined_r0x0040384b;\n      case 0x23:\n      case 0x7e:\n        if (local_88 == 0) goto switchD_0040383e_caseD_20;\n        goto LAB_00403f11;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto switchD_0040383e_caseD_25;\n      case 0x27:\n        uVar24 = 0x27;\n        if (quoting_style != shell_always_quoting_style) {\nLAB_00403c7b:\n          bVar4 = true;\n          bVar17 = 1;\n          goto joined_r0x00403c85;\n        }\n        if ((uVar21 & 1) == 0) {\n          uVar22 = buffersize;\n          if (local_a0 == 0 && buffersize != 0) {\n            uVar22 = 0;\n            local_a0 = buffersize;\n          }\n          if (uVar18 < uVar22) {\n            buffer[uVar18] = '\\'';\n          }\n          if (uVar18 + 1 < uVar22) {\n            buffer[uVar18 + 1] = '\\\\';\n          }\n          if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          if (uVar18 + 2 < uVar22) {\n            do {\n              buffer[uVar18 + 2] = '\\'';\n              if (y_32 < 10) break;\n            } while (((x_31 + -1) * x_31 & 1U) != 0);\n          }\n          if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          uVar18 = uVar18 + 3;\n          bVar5 = false;\n          buffersize = uVar22;\n          goto LAB_00403c7b;\n        }\n        bVar4 = true;\n        goto joined_r0x00404065;\n      case 0x3f:\n        uVar24 = 0x3f;\n        if (quoting_style == c_quoting_style) {\n          if ((((flags & 4U) != 0) && (uVar15 = local_88 + 2, uVar15 < uVar10)) &&\n             (arg[local_88 + 1] == '?')) {\n            bVar17 = arg[uVar15];\n            bVar3 = false;\n            if (((uint)(int)(char)bVar17 < 0x3f) &&\n               (bVar3 = false,\n               (0x7000a38200000000U >> ((ulong)(uint)(int)(char)bVar17 & 0x3f) & 1) != 0)) {\n              if ((uVar21 & 1) != 0) goto joined_r0x00404065;\n              if (uVar18 < buffersize) {\n                do {\n                  buffer[uVar18] = '?';\n                  iVar26 = x_31;\n                  iVar9 = y_32;\n                  if (y_32 < 10) break;\n                } while (((x_31 + -1) * x_31 & 1U) != 0);\n              }\n              if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n                do {\n                    /* WARNING: Do nothing block with infinite loop */\n                } while( true );\n              }\n              if (uVar18 + 1 < buffersize) {\n                buffer[uVar18 + 1] = '\\\"';\n              }\n              uVar22 = uVar18 + 2;\n              if (uVar22 < buffersize) {\n                if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_004035bf;\n                while ((buffer[uVar22] = '\\\"', 9 < y_32 && (((x_31 + -1) * x_31 & 1U) != 0))) {\nLAB_004035bf:\n                  buffer[uVar22] = '\\\"';\n                }\n              }\n              uVar22 = uVar18 + 3;\n              if (uVar22 < buffersize) {\n                if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_00403606;\n                while ((buffer[uVar22] = '?', 9 < y_32 && (((x_31 + -1) * x_31 & 1U) != 0))) {\nLAB_00403606:\n                  buffer[uVar22] = '?';\n                }\n              }\n              uVar18 = uVar18 + 4;\n              bVar3 = false;\n              uVar24 = (ulong)bVar17;\n              local_88 = uVar15;\n            }\n            goto LAB_00403f13;\n          }\n        }\n        else if ((quoting_style == shell_always_quoting_style) && ((uVar21 & 1) != 0))\n        goto joined_r0x00404065;\nLAB_00403f11:\n        bVar3 = false;\nLAB_00403f13:\n        bVar17 = 0;\n        goto joined_r0x0040384b;\n      case 0x5c:\n        if (quoting_style == shell_always_quoting_style) {\n          if ((uVar21 & 1) != 0) goto joined_r0x00404065;\n        }\n        else {\n          bVar6 = 0x5c;\n          if ((bVar7 & bVar25 & local_d8 != 0) == 0) goto switchD_0040383e_caseD_9;\n        }\n        bVar3 = false;\n        bVar23 = 0x5c;\n        bVar17 = 0;\n        goto LAB_004043ea;\n      case 0x7b:\n      case 0x7d:\n        bVar3 = false;\n        if (uVar10 == 0xffffffffffffffff) {\n          if ((local_88 == 0) && (arg[1] == '\\0')) goto switchD_0040383e_caseD_20;\n          uVar10 = 0xffffffffffffffff;\n          bVar3 = false;\n        }\n        else if ((local_88 == 0) && (uVar10 == 1)) goto switchD_0040383e_caseD_20;\n        goto LAB_00403f13;\n      }\n      bVar20 = 0;\n      bVar17 = 0;\n      if (bVar7 == false) {\nswitchD_0040383e_caseD_25:\n        bVar3 = false;\n        bVar17 = bVar20;\n        goto joined_r0x0040384b;\n      }\n      goto LAB_00403f82;\n    }\n    if (arg[local_88] != '\\0') goto LAB_0040379b;\n    local_88 = 0xffffffffffffffff;\nLAB_00404473:\n    if (((uVar21 & 1) != 0) && (quoting_style == shell_always_quoting_style && uVar18 == 0)) {\nLAB_004046ef:\n      qVar14 = shell_escape_always_quoting_style;\n      if (bVar7 == false) {\n        qVar14 = quoting_style;\n      }\n      if (quoting_style != shell_always_quoting_style) {\n        qVar14 = quoting_style;\n      }\n      if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) goto LAB_004048ab;\n      while( true ) {\n        sVar12 = quotearg_buffer_restyled\n                           (buffer,buffersize,arg,local_88,qVar14,flags & 0xfffffffdU,(uint *)0x0,\n                            left_quote,local_90);\n        if (y_32 < 10) {\n          return sVar12;\n        }\n        if (((x_31 + -1) * x_31 & 1U) == 0) break;\nLAB_004048ab:\n        quotearg_buffer_restyled\n                  (buffer,buffersize,arg,local_88,qVar14,flags & 0xfffffffdU,(uint *)0x0,left_quote,\n                   local_90);\n      }\n      return sVar12;\n    }\n    if ((!bVar4) || (quoting_style != shell_always_quoting_style || (uVar21 & 1) != 0)) {\nLAB_00404741:\n      if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      if ((local_d0 != (char *)0x0) && ((uVar21 & 1) == 0)) {\n        cVar1 = *local_d0;\n        while (cVar1 != '\\0') {\n          local_d0 = local_d0 + 1;\n          if (uVar18 < buffersize) {\n            buffer[uVar18] = cVar1;\n            iVar9 = y_32;\n            iVar26 = x_31;\n          }\n          if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          uVar18 = uVar18 + 1;\n          cVar1 = *local_d0;\n        }\n      }\n      if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      if (uVar18 < buffersize) {\n        do {\n          buffer[uVar18] = '\\0';\n          if (y_32 < 10) {\n            return uVar18;\n          }\n        } while (((x_31 + -1) * x_31 & 1U) != 0);\n      }\n      return uVar18;\n    }\n    if (bVar19 != 0) {\n      sVar12 = quotearg_buffer_restyled\n                         (buffer,local_a0,arg,local_88,c_quoting_style,flags,quote_these_too,\n                          left_quote,local_90);\n      return sVar12;\n    }\n    if ((local_a0 == 0) || (buffersize != 0)) goto LAB_00404741;\n    uVar10 = local_38 & 0xffffffff;\n    buffersize = local_a0;\n    if ((9 < iVar9) && (uVar10 = local_38 & 0xffffffff, ((iVar26 + -1) * iVar26 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n  } while( true );\n  while (uVar16 = local_88 + 1 + uVar15, uVar15 = uVar15 + 1, uVar16 < uVar10) {\nLAB_004040a4:\n    if (local_58[uVar15] == '\\0') break;\n  }\n  bVar17 = 0;\nLAB_004040d2:\n  local_b0 = 0;\nLAB_004040da:\n  if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  iVar9 = y_32;\n  iVar26 = x_31;\n  buffersize = local_50;\n  if (local_b0 != 0) goto joined_r0x00404065;\nLAB_00404139:\n  if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  buffersize = local_50;\n  if ((1 < uVar15) || ((bVar17 | !bVar7) == 0)) {\n    uVar15 = uVar15 + local_88;\n    bVar3 = false;\n    do {\n      bVar23 = (byte)uVar24;\n      if (bVar7 == false) {\nLAB_00404296:\n        if (bVar27) {\n          if (uVar18 < local_50) {\n            buffer[uVar18] = '\\\\';\n          }\n          uVar18 = uVar18 + 1;\n          bVar27 = false;\n        }\n      }\n      else {\n        if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n        if (bVar17 != 0) goto LAB_00404296;\n        if ((uVar21 & 1) != 0) {\n          local_b0 = 0x10;\n          uVar22 = local_88;\n          goto joined_r0x00404065;\n        }\n        if ((quoting_style == shell_always_quoting_style) && (!bVar5)) {\n          if (uVar18 < local_50) {\n            do {\n              buffer[uVar18] = '\\'';\n              iVar9 = y_32;\n              iVar26 = x_31;\n              if (y_32 < 10) break;\n            } while (((x_31 + -1) * x_31 & 1U) != 0);\n          }\n          if (uVar18 + 1 < local_50) {\n            buffer[uVar18 + 1] = '$';\n            iVar9 = y_32;\n            iVar26 = x_31;\n          }\n          if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          if (uVar18 + 2 < local_50) {\n            do {\n              buffer[uVar18 + 2] = '\\'';\n              iVar9 = y_32;\n              iVar26 = x_31;\n              if (y_32 < 10) break;\n            } while (((x_31 + -1) * x_31 & 1U) != 0);\n          }\n          if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          uVar18 = uVar18 + 3;\n          bVar5 = true;\n        }\n        if (uVar18 < local_50) {\n          buffer[uVar18] = '\\\\';\n          iVar9 = y_32;\n          iVar26 = x_31;\n        }\n        if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n        if (uVar18 + 1 < local_50) {\n          do {\n            buffer[uVar18 + 1] = (byte)(uVar24 >> 6) | 0x30;\n            if (y_32 < 10) break;\n          } while (((x_31 + -1) * x_31 & 1U) != 0);\n        }\n        if (uVar18 + 2 < local_50) {\n          buffer[uVar18 + 2] = (byte)(uVar24 >> 3) & 7 | 0x30;\n        }\n        uVar18 = uVar18 + 3;\n        bVar23 = bVar23 & 7 | 0x30;\n        bVar3 = true;\n      }\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      uVar22 = local_88 + 1;\n      iVar26 = x_31;\n      iVar9 = y_32;\n      if (uVar15 <= uVar22) goto LAB_004043ea;\n      if ((bVar5) && (!bVar3)) {\n        if (uVar18 < local_50) {\n          buffer[uVar18] = '\\'';\n        }\n        if (uVar18 + 1 < local_50) {\n          buffer[uVar18 + 1] = '\\'';\n        }\n        uVar18 = uVar18 + 2;\n        bVar5 = false;\n      }\n      if (uVar18 < local_50) {\n        buffer[uVar18] = bVar23;\n      }\n      if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      uVar24 = (ulong)(byte)arg[uVar22];\n      uVar18 = uVar18 + 1;\n      local_88 = uVar22;\n      iVar9 = y_32;\n      iVar26 = x_31;\n    } while( true );\n  }\n  bVar3 = false;\njoined_r0x0040384b:\n  bVar23 = (byte)uVar24;\n  if (bVar13 == 0) {\n    if ((quote_these_too != (uint *)0x0 & bVar25 & 1) != 0) goto LAB_00403f27;\nLAB_00403f50:\n    if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    iVar26 = x_31;\n    iVar9 = y_32;\n    if (bVar27) goto LAB_00403f82;\nLAB_004043ea:\n    if ((bVar5) && (!bVar3)) {\n      if (uVar18 < buffersize) {\n        buffer[uVar18] = '\\'';\n        iVar9 = y_32;\n        iVar26 = x_31;\n      }\n      if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      if (uVar18 + 1 < buffersize) {\n        do {\n          buffer[uVar18 + 1] = '\\'';\n          if (y_32 < 10) break;\n        } while (((x_31 + -1) * x_31 & 1U) != 0);\n      }\n      uVar18 = uVar18 + 2;\n      bVar5 = false;\n    }\n  }\n  else {\n    if (quote_these_too == (uint *)0x0) goto LAB_00403f50;\nLAB_00403f27:\n    if ((quote_these_too[uVar24 >> 5] >> ((uint)uVar24 & 0x1f) & 1) == 0) goto LAB_00403f50;\nLAB_00403f82:\n    local_b0 = 0x10;\n    uVar22 = local_88;\n    iVar9 = y_32;\n    iVar26 = x_31;\n    if ((uVar21 & 1) != 0) goto joined_r0x00404065;\n    if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    if ((quoting_style == shell_always_quoting_style) && (!bVar5)) {\n      if (uVar18 < buffersize) {\n        do {\n          buffer[uVar18] = '\\'';\n          if (y_32 < 10) break;\n        } while (((x_31 + -1) * x_31 & 1U) != 0);\n      }\n      uVar22 = uVar18 + 1;\n      if (uVar22 < buffersize) {\n        if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_0040366f;\n        while ((buffer[uVar22] = '$', 9 < y_32 && (((x_31 + -1) * x_31 & 1U) != 0))) {\nLAB_0040366f:\n          buffer[uVar22] = '$';\n        }\n      }\n      uVar22 = uVar18 + 2;\n      if (uVar22 < buffersize) {\n        if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_004036b3;\n        while ((buffer[uVar22] = '\\'', 9 < y_32 && (((x_31 + -1) * x_31 & 1U) != 0))) {\nLAB_004036b3:\n          buffer[uVar22] = '\\'';\n        }\n      }\n      uVar18 = uVar18 + 3;\n      bVar5 = true;\n    }\n    if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    if (uVar18 < buffersize) {\n      buffer[uVar18] = '\\\\';\n    }\n    uVar18 = uVar18 + 1;\n  }\n  if (uVar18 < buffersize) {\n    if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) goto LAB_00403733;\n    while ((buffer[uVar18] = bVar23, 9 < y_32 && (((x_31 + -1) * x_31 & 1U) != 0))) {\nLAB_00403733:\n      buffer[uVar18] = bVar23;\n    }\n  }\n  uVar18 = uVar18 + 1;\n  bVar19 = -bVar17 & bVar19;\n  local_b0 = 0;\n  uVar22 = local_88;\n  iVar9 = y_32;\n  iVar26 = x_31;\n  if ((9 < y_32) && (((x_31 + -1) * x_31 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\njoined_r0x00404065:\n  local_88 = uVar10;\n  if ((9 < iVar9) && (((iVar26 + -1) * iVar26 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  if ((local_b0 != 0) && (local_b0 != 0xf)) {\n    if (local_b0 != 0x10) {\n      return uVar18;\n    }\n    goto LAB_004046ef;\n  }\n  uVar10 = local_88;\n  local_88 = uVar22 + 1;\n  goto LAB_00403776;\n}\n\n",
            "funcName": "quotearg_buffer_restyled"
        },
        {
            "funcStartAddr": "0x404900",
            "funcEndAddr": "0x4049c1",
            "decompiledFuncCode": "\nchar * quotearg_alloc(char *arg,size_t argsize,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  char *buffer;\n  wchar_t flags;\n  quoting_options *pqVar4;\n  wchar_t e;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  flags = pqVar4->flags | 1;\n  sVar3 = quotearg_buffer_restyled\n                    ((char *)0x0,0,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n                     pqVar4->left_quote,pqVar4->right_quote);\n  buffer = (char *)xmalloc(sVar3 + 1);\n  quotearg_buffer_restyled\n            (buffer,sVar3 + 1,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n             pqVar4->left_quote,pqVar4->right_quote);\n  *piVar2 = iVar1;\n  return buffer;\n}\n\n",
            "funcName": "quotearg_alloc"
        },
        {
            "funcStartAddr": "0x4049d0",
            "funcEndAddr": "0x404abc",
            "decompiledFuncCode": "\nchar * quotearg_alloc_mem(char *arg,size_t argsize,size_t *size,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  char *buffer;\n  wchar_t flags;\n  quoting_options *pqVar4;\n  wchar_t e;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  flags = (uint)(size == (size_t *)0x0) | pqVar4->flags;\n  sVar3 = quotearg_buffer_restyled\n                    ((char *)0x0,0,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n                     pqVar4->left_quote,pqVar4->right_quote);\n  buffer = (char *)xmalloc(sVar3 + 1);\n  quotearg_buffer_restyled\n            (buffer,sVar3 + 1,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n             pqVar4->left_quote,pqVar4->right_quote);\n  *piVar2 = iVar1;\n  if (size != (size_t *)0x0) {\n    *size = sVar3;\n  }\n  return buffer;\n}\n\n",
            "funcName": "quotearg_alloc_mem"
        },
        {
            "funcStartAddr": "0x404ac0",
            "funcEndAddr": "0x404c10",
            "decompiledFuncCode": "\nvoid quotearg_free(void)\n\n{\n  slotvec *__ptr;\n  char **ppcVar1;\n  long lVar2;\n  \n  __ptr = slotvec;\n  if (L'\\x01' < nslots) {\n    ppcVar1 = &slotvec[1].val;\n    lVar2 = 1;\n    do {\n      if ((9 < y_38) && (((x_37 + -1) * x_37 & 1U) != 0)) goto LAB_00404b24;\n      while ((free(*ppcVar1), 9 < y_38 && (((x_37 + -1) * x_37 & 1U) != 0))) {\nLAB_00404b24:\n        free(*ppcVar1);\n      }\n      lVar2 = lVar2 + 1;\n      ppcVar1 = ppcVar1 + 2;\n    } while (lVar2 < nslots);\n  }\n  if (__ptr->val != slot0) {\n    free(__ptr->val);\n    slotvec0.size = 0x100;\n    slotvec0.val = slot0;\n  }\n  if (__ptr != &slotvec0) {\n    if ((9 < y_38) && (((x_37 + -1) * x_37 & 1U) != 0)) goto LAB_00404bc1;\n    while( true ) {\n      free(__ptr);\n      slotvec = &slotvec0;\n      if ((y_38 < 10) || (((x_37 + -1) * x_37 & 1U) == 0)) break;\nLAB_00404bc1:\n      free(__ptr);\n      slotvec = &slotvec0;\n    }\n  }\n  do {\n    nslots = L'\\x01';\n    if (y_38 < 10) {\n      nslots = L'\\x01';\n      return;\n    }\n  } while (((x_37 + -1) * x_37 & 1U) != 0);\n  return;\n}\n\n",
            "funcName": "quotearg_free"
        },
        {
            "funcStartAddr": "0x404c20",
            "funcEndAddr": "0x404c2e",
            "decompiledFuncCode": "\nchar * quotearg_n(wchar_t n,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n"
        },
        {
            "funcStartAddr": "0x404c30",
            "funcEndAddr": "0x404e62",
            "decompiledFuncCode": "\nchar * quotearg_n_options(wchar_t n,char *arg,size_t argsize,quoting_options *options)\n\n{\n  int iVar1;\n  size_t buffersize;\n  slotvec *psVar2;\n  int *piVar3;\n  slotvec *psVar4;\n  size_t sVar5;\n  char *buffer;\n  wchar_t flags;\n  \n  if ((9 < y_42) && (((x_41 + -1) * x_41 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  piVar3 = __errno_location();\n  psVar2 = slotvec;\n  if (n < L'\\0') {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  iVar1 = *piVar3;\n  psVar4 = slotvec;\n  if (nslots <= n) {\n    if (n == L'\\x7fffffff') {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    psVar4 = (slotvec *)0x0;\n    if (slotvec != &slotvec0) {\n      psVar4 = slotvec;\n    }\n    psVar4 = (slotvec *)xrealloc(psVar4,(long)n * 0x10 + 0x10);\n    slotvec = psVar4;\n    if (psVar2 == &slotvec0) {\n      *psVar4 = slotvec0;\n    }\n    memset(psVar4 + nslots,0,((long)(n + L'\\x01') - (long)nslots) * 0x10);\n    nslots = n + L'\\x01';\n  }\n  buffersize = psVar4[n].size;\n  buffer = psVar4[n].val;\n  flags = options->flags | 1;\n  sVar5 = quotearg_buffer_restyled\n                    (buffer,buffersize,arg,argsize,options->style,flags,options->quote_these_too,\n                     options->left_quote,options->right_quote);\n  if (buffersize <= sVar5) {\n    sVar5 = sVar5 + 1;\n    if ((9 < y_42) && (((x_41 + -1) * x_41 & 1U) != 0)) goto LAB_00404de5;\n    while ((psVar4[n].size = sVar5, 9 < y_42 && (((x_41 + -1) * x_41 & 1U) != 0))) {\nLAB_00404de5:\n      psVar4[n].size = sVar5;\n    }\n    if (buffer != slot0) {\n      free(buffer);\n    }\n    buffer = (char *)xmalloc(sVar5);\n    psVar4[n].val = buffer;\n    quotearg_buffer_restyled\n              (buffer,sVar5,arg,argsize,options->style,flags,options->quote_these_too,\n               options->left_quote,options->right_quote);\n  }\n  *piVar3 = iVar1;\n  return buffer;\n}\n\n",
            "funcName": "quotearg_n_options"
        },
        {
            "funcStartAddr": "0x404e70",
            "funcEndAddr": "0x404e7a",
            "decompiledFuncCode": "\nchar * quotearg_n_mem(wchar_t n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,argsize,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n_mem"
        },
        {
            "funcStartAddr": "0x404e80",
            "funcEndAddr": "0x404e99",
            "decompiledFuncCode": "\nchar * quotearg(char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg"
        },
        {
            "funcStartAddr": "0x404ea0",
            "funcEndAddr": "0x404eb8",
            "decompiledFuncCode": "\nchar * quotearg_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_mem"
        },
        {
            "funcStartAddr": "0x404ec0",
            "funcEndAddr": "0x404fd5",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nchar * quotearg_n_style(wchar_t n,quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  quoting_options *options;\n  quoting_options *options_00;\n  undefined local_58 [16];\n  undefined local_48 [16];\n  undefined local_38 [16];\n  undefined4 local_28;\n  \n  options_00 = (quoting_options *)local_58;\n  options = (quoting_options *)local_58;\n  if ((9 < y_50) && (options = (quoting_options *)local_58, ((x_49 + -1) * x_49 & 1U) != 0))\n  goto LAB_00404f64;\n  while( true ) {\n    options_00 = (quoting_options *)((long)(options + 0xfffffffffffffffe) + 0x30);\n    local_38 = ZEXT816(0);\n    local_48 = ZEXT816(0);\n    local_58 = ZEXT816(0);\n    local_28 = 0;\n    if (s == custom_quoting_style) {\n                    /* WARNING: Subroutine does not return */\n      *(undefined8 *)((long)(options + 0xfffffffffffffffe) + 0x28) = 0x404fd0;\n      abort();\n    }\n    options_00->style = s;\n    *(undefined4 *)((long)(options + 0xffffffffffffffff) + 0x2c) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x1c) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x20) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x24) = 0;\n    *(undefined4 *)((long)(options + 0xffffffffffffffff) + 0x28) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0xc) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x10) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x14) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x18) = 0;\n    *(undefined4 *)((long)(options + 0xfffffffffffffffe) + 0x34) = 0;\n    options[0xffffffffffffffff].style = 0;\n    *(int *)((long)(options + 0xffffffffffffffff) + 4) = 0;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 8) = 0;\n    *(undefined8 *)((long)(options + 0xfffffffffffffffe) + 0x28) = 0x404f4a;\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,options_00);\n    if ((y_50 < 10) || (((x_49 + -1) * x_49 & 1U) == 0)) break;\nLAB_00404f64:\n    options = (quoting_options *)((long)(options_00 + 0xfffffffffffffffe) + 0x30);\n    local_38 = ZEXT816(0);\n    local_48 = ZEXT816(0);\n    local_58 = ZEXT816(0);\n    local_28 = 0;\n    if (s == custom_quoting_style) {\n                    /* WARNING: Subroutine does not return */\n      *(undefined8 *)((long)(options_00 + 0xfffffffffffffffe) + 0x28) = 0x404fd5;\n      abort();\n    }\n    options->style = s;\n    *(undefined4 *)((long)(options_00 + 0xffffffffffffffff) + 0x2c) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x1c) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x20) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x24) = 0;\n    *(undefined4 *)((long)(options_00 + 0xffffffffffffffff) + 0x28) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0xc) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x10) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x14) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x18) = 0;\n    *(undefined4 *)((long)(options_00 + 0xfffffffffffffffe) + 0x34) = 0;\n    options_00[0xffffffffffffffff].style = 0;\n    *(int *)((long)(options_00 + 0xffffffffffffffff) + 4) = 0;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 8) = 0;\n    *(undefined8 *)((long)(options_00 + 0xfffffffffffffffe) + 0x28) = 0x404fbb;\n    quotearg_n_options(n,arg,0xffffffffffffffff,options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n_style"
        },
        {
            "funcStartAddr": "0x404fe0",
            "funcEndAddr": "0x405048",
            "decompiledFuncCode": "\nchar * quotearg_n_style_mem(wchar_t n,quoting_style s,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(n,arg,argsize,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_style_mem"
        },
        {
            "funcStartAddr": "0x405050",
            "funcEndAddr": "0x405061",
            "decompiledFuncCode": "\nchar * quotearg_style(quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_style(L'\\0',s,arg);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_style"
        },
        {
            "funcStartAddr": "0x405070",
            "funcEndAddr": "0x4050d1",
            "decompiledFuncCode": "\nchar * quotearg_style_mem(quoting_style s,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(L'\\0',arg,argsize,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_style_mem"
        },
        {
            "funcStartAddr": "0x4050e0",
            "funcEndAddr": "0x405203",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nchar * quotearg_char_mem(char *arg,size_t argsize,char ch)\n\n{\n  char *pcVar1;\n  byte bVar2;\n  quoting_options *options;\n  quoting_options *options_00;\n  ulong uVar3;\n  \n  options_00 = (quoting_options *)&stack0xffffffffffffffd8;\n  bVar2 = ch & 0x1f;\n  uVar3 = (ulong)((byte)ch >> 5);\n  options = (quoting_options *)&stack0xffffffffffffffd8;\n  if ((9 < y_60) &&\n     (options = (quoting_options *)&stack0xffffffffffffffd8, ((x_59 + -1) * x_59 & 1U) != 0))\n  goto LAB_00405192;\n  while( true ) {\n    options_00 = (quoting_options *)((long)(options + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 8) = default_quoting_options.quote_these_too[2]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options + 0xfffffffffffffffe) + 0x30) = default_quoting_options.style;\n    *(int *)((long)(options + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 4) = default_quoting_options.quote_these_too[1]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + uVar3 * 4) =\n         (~(*(uint *)((long)(options + 0xffffffffffffffff) + uVar3 * 4) >> bVar2) & 1) << bVar2 ^\n         *(uint *)((long)(options + 0xffffffffffffffff) + uVar3 * 4);\n    *(undefined8 *)((long)(options + 0xfffffffffffffffe) + 0x28) = 0x405178;\n    pcVar1 = quotearg_n_options(L'\\0',arg,argsize,options_00);\n    if ((y_60 < 10) || (((x_59 + -1) * x_59 & 1U) == 0)) break;\nLAB_00405192:\n    options = (quoting_options *)((long)(options_00 + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options_00 + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote\n    ;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 8) =\n         default_quoting_options.quote_these_too[2];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options_00 + 0xfffffffffffffffe) + 0x30) =\n         default_quoting_options.style;\n    *(int *)((long)(options_00 + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options_00[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 4) =\n         default_quoting_options.quote_these_too[1];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar3 * 4) =\n         (~(*(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar3 * 4) >> bVar2) & 1) << bVar2 ^\n         *(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar3 * 4);\n    *(undefined8 *)((long)(options_00 + 0xfffffffffffffffe) + 0x28) = 0x4051f1;\n    quotearg_n_options(L'\\0',arg,argsize,options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_char_mem"
        },
        {
            "funcStartAddr": "0x405210",
            "funcEndAddr": "0x405220",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nchar * quotearg_char(char *arg,char ch)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  byte bVar3;\n  quoting_options *options;\n  quoting_options *options_00;\n  \n  options_00 = (quoting_options *)&stack0xffffffffffffffd8;\n  uVar1 = (ulong)((byte)ch >> 5);\n  bVar3 = ch & 0x1f;\n  options = (quoting_options *)&stack0xffffffffffffffd8;\n  if ((9 < y_60) &&\n     (options = (quoting_options *)&stack0xffffffffffffffd8, ((x_59 + -1) * x_59 & 1U) != 0))\n  goto LAB_00405192;\n  while( true ) {\n    options_00 = (quoting_options *)((long)(options + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 8) = default_quoting_options.quote_these_too[2]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options + 0xfffffffffffffffe) + 0x30) = default_quoting_options.style;\n    *(int *)((long)(options + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 4) = default_quoting_options.quote_these_too[1]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + uVar1 * 4) =\n         (~(*(uint *)((long)(options + 0xffffffffffffffff) + uVar1 * 4) >> bVar3) & 1) << bVar3 ^\n         *(uint *)((long)(options + 0xffffffffffffffff) + uVar1 * 4);\n    *(undefined8 *)((long)(options + 0xfffffffffffffffe) + 0x28) = 0x405178;\n    pcVar2 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,options_00);\n    if ((y_60 < 10) || (((x_59 + -1) * x_59 & 1U) == 0)) break;\nLAB_00405192:\n    options = (quoting_options *)((long)(options_00 + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options_00 + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote\n    ;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 8) =\n         default_quoting_options.quote_these_too[2];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options_00 + 0xfffffffffffffffe) + 0x30) =\n         default_quoting_options.style;\n    *(int *)((long)(options_00 + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options_00[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 4) =\n         default_quoting_options.quote_these_too[1];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar1 * 4) =\n         (~(*(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar1 * 4) >> bVar3) & 1) << bVar3 ^\n         *(uint *)((long)(options_00 + 0xffffffffffffffff) + uVar1 * 4);\n    *(undefined8 *)((long)(options_00 + 0xfffffffffffffffe) + 0x28) = 0x4051f1;\n    quotearg_n_options(L'\\0',arg,0xffffffffffffffff,options);\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "quotearg_char"
        },
        {
            "funcStartAddr": "0x405220",
            "funcEndAddr": "0x405231",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nchar * quotearg_colon(char *arg)\n\n{\n  char *pcVar1;\n  quoting_options *options;\n  quoting_options *options_00;\n  \n  options_00 = (quoting_options *)&stack0xffffffffffffffd8;\n  options = (quoting_options *)&stack0xffffffffffffffd8;\n  if ((9 < y_60) &&\n     (options = (quoting_options *)&stack0xffffffffffffffd8, ((x_59 + -1) * x_59 & 1U) != 0))\n  goto LAB_00405192;\n  while( true ) {\n    options_00 = (quoting_options *)((long)(options + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 8) = default_quoting_options.quote_these_too[2]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options + 0xfffffffffffffffe) + 0x30) = default_quoting_options.style;\n    *(int *)((long)(options + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options + 0xffffffffffffffff) + 4) = default_quoting_options.quote_these_too[1]\n    ;\n    *(uint *)((long)(options + 0xffffffffffffffff) + 4) =\n         (~((uint)*(int *)((long)(options + 0xffffffffffffffff) + 4) >> 0x1a) & 1) << 0x1a ^\n         *(int *)((long)(options + 0xffffffffffffffff) + 4);\n    *(undefined8 *)((long)(options + 0xfffffffffffffffe) + 0x28) = 0x405178;\n    pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,options_00);\n    if ((y_60 < 10) || (((x_59 + -1) * x_59 & 1U) == 0)) break;\nLAB_00405192:\n    options = (quoting_options *)((long)(options_00 + 0xfffffffffffffffe) + 0x30);\n    *(char **)((long)(options_00 + 0xffffffffffffffff) + 0x28) = default_quoting_options.right_quote\n    ;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x18) =\n         default_quoting_options.quote_these_too[6];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x1c) =\n         default_quoting_options.quote_these_too[7];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x20) =\n         (uint)default_quoting_options.left_quote;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x24) =\n         default_quoting_options.left_quote._4_4_;\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 8) =\n         default_quoting_options.quote_these_too[2];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0xc) =\n         default_quoting_options.quote_these_too[3];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x10) =\n         default_quoting_options.quote_these_too[4];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 0x14) =\n         default_quoting_options.quote_these_too[5];\n    *(quoting_style *)((long)(options_00 + 0xfffffffffffffffe) + 0x30) =\n         default_quoting_options.style;\n    *(int *)((long)(options_00 + 0xfffffffffffffffe) + 0x34) = default_quoting_options.flags;\n    options_00[0xffffffffffffffff].style = default_quoting_options.quote_these_too[0];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 4) =\n         default_quoting_options.quote_these_too[1];\n    *(uint *)((long)(options_00 + 0xffffffffffffffff) + 4) =\n         (~((uint)*(int *)((long)(options_00 + 0xffffffffffffffff) + 4) >> 0x1a) & 1) << 0x1a ^\n         *(int *)((long)(options_00 + 0xffffffffffffffff) + 4);\n    *(undefined8 *)((long)(options_00 + 0xfffffffffffffffe) + 0x28) = 0x4051f1;\n    quotearg_n_options(L'\\0',arg,0xffffffffffffffff,options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_colon"
        },
        {
            "funcStartAddr": "0x405240",
            "funcEndAddr": "0x4052a8",
            "decompiledFuncCode": "\nchar * quotearg_colon_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  if ((9 < y_66) && (((x_65 + -1) * x_65 & 1U) != 0)) goto LAB_0040528e;\n  while( true ) {\n    pcVar1 = quotearg_char_mem(arg,argsize,':');\n    if ((y_66 < 10) || (((x_65 + -1) * x_65 & 1U) == 0)) break;\nLAB_0040528e:\n    quotearg_char_mem(arg,argsize,':');\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_colon_mem"
        },
        {
            "funcStartAddr": "0x4052b0",
            "funcEndAddr": "0x405344",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * quotearg_n_style_colon(wchar_t n,quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  undefined local_78 [16];\n  undefined local_68 [16];\n  undefined local_58 [16];\n  undefined4 local_48;\n  undefined4 local_44;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  undefined4 uStack_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  undefined4 local_18;\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  local_58 = ZEXT816(0);\n  local_68 = ZEXT816(0);\n  local_78 = ZEXT816(0);\n  local_48 = 0;\n  if (s != custom_quoting_style) {\n    local_8 = 0;\n    local_18 = 0;\n    uStack_14 = 0;\n    uStack_10 = 0;\n    uStack_c = 0;\n    local_28 = 0;\n    uStack_24 = 0;\n    uStack_20 = 0;\n    uStack_1c = 0;\n    local_38 = 0;\n    uStack_34 = 0;\n    uStack_30 = 0;\n    uStack_2c = 0;\n    local_44 = 0;\n    local_58._0_12_ = ZEXT412(0) << 0x40;\n    local_48 = 0;\n    local_68._0_12_ = ZEXT412(0) << 0x40;\n    local_58._4_12_ = local_58._0_12_ >> 0x20 & (undefined  [12])0xffffffffffffffff;\n    local_58 = ZEXT1216(local_58._4_12_) << 0x20;\n    local_68._4_12_ = local_68._0_12_ >> 0x20 & (undefined  [12])0xffffffffffffffff;\n    local_68 = ZEXT1216(local_68._4_12_) << 0x20;\n    local_78 = ZEXT416(s) | (undefined  [16])0x400000000000000;\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,(quoting_options *)local_78);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_style_colon"
        },
        {
            "funcStartAddr": "0x405350",
            "funcEndAddr": "0x4053bd",
            "decompiledFuncCode": "\nchar * quotearg_n_custom(wchar_t n,char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    local_38.left_quote = left_quote;\n    local_38.right_quote = right_quote;\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_custom"
        },
        {
            "funcStartAddr": "0x4053c0",
            "funcEndAddr": "0x405429",
            "decompiledFuncCode": "\nchar * quotearg_n_custom_mem(wchar_t n,char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    local_38.left_quote = left_quote;\n    local_38.right_quote = right_quote;\n    pcVar1 = quotearg_n_options(n,arg,argsize,&local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_custom_mem"
        },
        {
            "funcStartAddr": "0x405430",
            "funcEndAddr": "0x40549f",
            "decompiledFuncCode": "\nchar * quotearg_custom(char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    local_38.left_quote = left_quote;\n    local_38.right_quote = right_quote;\n    pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_custom"
        },
        {
            "funcStartAddr": "0x4054a0",
            "funcEndAddr": "0x40550b",
            "decompiledFuncCode": "\nchar * quotearg_custom_mem(char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    local_38.left_quote = left_quote;\n    local_38.right_quote = right_quote;\n    pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_custom_mem"
        },
        {
            "funcStartAddr": "0x405510",
            "funcEndAddr": "0x40557b",
            "decompiledFuncCode": "\nchar * quote_n_mem(wchar_t n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  if ((9 < y_78) && (((x_77 + -1) * x_77 & 1U) != 0)) goto LAB_00405562;\n  while( true ) {\n    pcVar1 = quotearg_n_options(n,arg,argsize,&quote_quoting_options);\n    if ((y_78 < 10) || (((x_77 + -1) * x_77 & 1U) == 0)) break;\nLAB_00405562:\n    quotearg_n_options(n,arg,argsize,&quote_quoting_options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quote_n_mem"
        },
        {
            "funcStartAddr": "0x405580",
            "funcEndAddr": "0x4055ec",
            "decompiledFuncCode": "\nchar * quote_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  if ((9 < y_78) && (((x_77 + -1) * x_77 & 1U) != 0)) goto LAB_004055d0;\n  while( true ) {\n    pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&quote_quoting_options);\n    if ((y_78 < 10) || (((x_77 + -1) * x_77 & 1U) == 0)) break;\nLAB_004055d0:\n    quotearg_n_options(L'\\0',arg,argsize,&quote_quoting_options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quote_mem"
        },
        {
            "funcStartAddr": "0x4055f0",
            "funcEndAddr": "0x405661",
            "decompiledFuncCode": "\nchar * quote_n(wchar_t n,char *arg)\n\n{\n  char *pcVar1;\n  \n  if ((9 < y_78) && (((x_77 + -1) * x_77 & 1U) != 0)) goto LAB_00405642;\n  while( true ) {\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&quote_quoting_options);\n    if ((y_78 < 10) || (((x_77 + -1) * x_77 & 1U) == 0)) break;\nLAB_00405642:\n    quotearg_n_options(n,arg,0xffffffffffffffff,&quote_quoting_options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quote_n"
        },
        {
            "funcStartAddr": "0x405670",
            "funcEndAddr": "0x4056d8",
            "decompiledFuncCode": "\nchar * quote(char *arg)\n\n{\n  char *pcVar1;\n  \n  if ((9 < y_78) && (((x_77 + -1) * x_77 & 1U) != 0)) goto LAB_004056be;\n  while( true ) {\n    pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&quote_quoting_options);\n    if ((y_78 < 10) || (((x_77 + -1) * x_77 & 1U) == 0)) break;\nLAB_004056be:\n    quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&quote_quoting_options);\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "quote"
        },
        {
            "funcStartAddr": "0x4056e0",
            "funcEndAddr": "0x4057e6",
            "decompiledFuncCode": "\nchar * gettext_quote(char *msgid,quoting_style s)\n\n{\n  wchar_t wVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char unaff_BL;\n  char unaff_BPL;\n  char unaff_R14B;\n  bool bVar4;\n  \n  pcVar2 = (char *)dcgettext(0,msgid,5);\n  if (pcVar2 == msgid) {\n    pcVar2 = locale_charset();\n    wVar1 = strcaseeq0(pcVar2,(char *)0x55,'T','F','-','8','\\0','\\0',unaff_BL,unaff_R14B,unaff_BPL);\n    if (wVar1 == L'\\0') {\n      if ((9 < y_86) && (((x_85 + -1) * x_85 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      wVar1 = strcaseeq0(pcVar2,(char *)0x47,'B','1','8','0','3','0',unaff_BL,unaff_R14B,unaff_BPL);\n      if (wVar1 == L'\\0') {\n        bVar4 = s == clocale_quoting_style;\n        pcVar3 = \"\\\"\";\n        pcVar2 = \"\\'\";\n      }\n      else {\n        bVar4 = *msgid == '`';\n        pcVar3 = &DAT_00408954;\n        pcVar2 = &DAT_00408958;\n      }\n    }\n    else {\n      bVar4 = *msgid == '`';\n      pcVar3 = &DAT_0040894c;\n      pcVar2 = &DAT_00408950;\n    }\n    if (bVar4) {\n      pcVar2 = pcVar3;\n    }\n  }\n  if ((9 < y_86) && (((x_85 + -1) * x_85 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "gettext_quote"
        },
        {
            "funcStartAddr": "0x4057f0",
            "funcEndAddr": "0x405c89",
            "decompiledFuncCode": "\n/* WARNING: Type propagation algorithm not settling */\n\nwchar_t strcaseeq0(char *s1,char *s2,char s20,char s21,char s22,char s23,char s24,char s25,char s26,\n                  char s27,char s28)\n\n{\n  char cVar1;\n  bool bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  char cVar6;\n  uint uVar7;\n  bool bVar8;\n  bool bVar9;\n  undefined uVar10;\n  \n  if ((9 < y_88) && (((x_87 + -1) * x_87 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  cVar6 = (char)s2;\n  if ((int)cVar6 - 0x41U < 0x1a) {\n    if (((int)*s1 & 0xffffffdfU) != (int)cVar6) {\n      return L'\\0';\n    }\n  }\n  else if (*s1 != cVar6) {\n    return L'\\0';\n  }\n  if (cVar6 != '\\0') {\n    if ((int)s20 - 0x41U < 0x1a) {\n      if (((int)s1[1] & 0xffffffdfU) != (int)s20) {\n        return L'\\0';\n      }\n    }\n    else if (s1[1] != s20) {\n      return L'\\0';\n    }\n    if (s20 != '\\0') {\n      cVar6 = s1[2];\n      uVar3 = (uint)s22;\n      uVar7 = (uint)s23;\n      bVar8 = ((x_99 + -1) * x_99 & 1U) != 0;\n      uVar5 = (uint)s24;\n      bVar9 = ((x_91 + -1) * x_91 & 1U) != 0;\n      bVar2 = 9 < y_92;\n      uVar4 = (uint)s25;\n      do {\n        if ((int)s21 - 0x41U < 0x1a) {\n          if (((int)cVar6 & 0xffffffdfU) == (int)s21) {\n            if (bVar2 && bVar9) {\n              do {\n                    /* WARNING: Do nothing block with infinite loop */\n              } while( true );\n            }\n            if (s21 != '\\0') goto LAB_00405a25;\n            uVar10 = true;\n          }\n          else {\n            if (bVar2 && bVar9) {\n              do {\n                    /* WARNING: Do nothing block with infinite loop */\n              } while( true );\n            }\n            uVar10 = false;\n          }\n        }\n        else {\n          if (bVar2 && bVar9) {\n            do {\n                    /* WARNING: Do nothing block with infinite loop */\n            } while( true );\n          }\n          uVar10 = cVar6 == s21;\n          if (cVar6 == s21 && s21 != '\\0') {\nLAB_00405a25:\n            cVar1 = s1[3];\n            if (uVar3 - 0x41 < 0x1a) {\n              uVar10 = ((int)cVar1 & 0xffffffdfU) == uVar3;\n              if ((s22 != '\\0') && (((int)cVar1 & 0xffffffdfU) == uVar3)) {\nLAB_00405aa1:\n                cVar1 = s1[4];\n                if (uVar7 - 0x41 < 0x1a) {\n                  uVar10 = ((int)cVar1 & 0xffffffdfU) == uVar7;\n                  if ((s23 != '\\0') && (((int)cVar1 & 0xffffffdfU) == uVar7)) {\nLAB_00405ae6:\n                    cVar1 = s1[5];\n                    if (uVar5 - 0x41 < 0x1a) {\n                      if (9 < y_98 && ((x_97 + -1) * x_97 & 1U) != 0) {\n                        do {\n                    /* WARNING: Do nothing block with infinite loop */\n                        } while( true );\n                      }\n                      uVar10 = ((int)cVar1 & 0xffffffdfU) == uVar5;\n                      if ((s24 != '\\0') && (((int)cVar1 & 0xffffffdfU) == uVar5)) {\nLAB_00405b41:\n                        cVar1 = s1[6];\n                        if (uVar4 - 0x41 < 0x1a) {\n                          if (9 < y_100 && bVar8) {\n                            do {\n                    /* WARNING: Do nothing block with infinite loop */\n                            } while( true );\n                          }\n                          uVar10 = ((int)cVar1 & 0xffffffdfU) == uVar4;\n                          if ((s25 != '\\0') && (((int)cVar1 & 0xffffffdfU) == uVar4)) {\nLAB_00405bce:\n                            if (9 < y_102 && ((x_101 + -1) * x_101 & 1U) != 0) {\n                              do {\n                    /* WARNING: Do nothing block with infinite loop */\n                              } while( true );\n                            }\n                            if (9 < y_100 && bVar8) {\n                              do {\n                    /* WARNING: Do nothing block with infinite loop */\n                              } while( true );\n                            }\n                            uVar10 = s1[7] == '\\0';\n                          }\n                        }\n                        else {\n                          uVar10 = cVar1 == s25;\n                          if ((s25 != '\\0') && (cVar1 == s25)) goto LAB_00405bce;\n                        }\n                      }\n                    }\n                    else {\n                      uVar10 = cVar1 == s24;\n                      if ((s24 != '\\0') && (cVar1 == s24)) goto LAB_00405b41;\n                    }\n                  }\n                }\n                else {\n                  uVar10 = cVar1 == s23;\n                  if ((s23 != '\\0') && (cVar1 == s23)) goto LAB_00405ae6;\n                }\n              }\n            }\n            else {\n              if (9 < y_94 && ((x_93 + -1) * x_93 & 1U) != 0) {\n                do {\n                    /* WARNING: Do nothing block with infinite loop */\n                } while( true );\n              }\n              uVar10 = cVar1 == s22;\n              if ((s22 != '\\0') && (cVar1 == s22)) goto LAB_00405aa1;\n            }\n          }\n        }\n        if (y_90 < 10 || ((x_89 + -1) * x_89 & 1U) == 0) {\n          return (uint)(byte)uVar10;\n        }\n      } while( true );\n    }\n    if (9 < y_90) {\n      if (((x_89 + -1) * x_89 & 1U) == 0) {\n        return L'\\x01';\n      }\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n  }\n  return L'\\x01';\n}\n\n",
            "funcName": "strcaseeq0"
        },
        {
            "funcStartAddr": "0x405d00",
            "funcEndAddr": "0x4062ce",
            "decompiledFuncCode": "\nvoid version_etc_arn(FILE *stream,char *command_name,char *package,char *version,char **authors,\n                    size_t n_authors)\n\n{\n  undefined8 uVar1;\n  char *__s;\n  \n  if (command_name == (char *)0x0) {\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00405d8a;\n    while ((__fprintf_chk(stream,1,\"%s %s\\n\",package,version), 9 < y && (((x + -1) * x & 1U) != 0)))\n    {\nLAB_00405d8a:\n      __fprintf_chk(stream,1,\"%s %s\\n\",package,version);\n    }\n  }\n  else {\n    __fprintf_chk(stream,1,\"%s (%s) %s\\n\",command_name,package,version);\n  }\n  uVar1 = dcgettext(0,&DAT_004089c3,5);\n  __fprintf_chk(stream,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e3);\n  __s = (char *)dcgettext(0,\n                          \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                          ,5);\n  fputs_unlocked(__s,(FILE *)stream);\n  switch(n_authors) {\n  case 0:\n    break;\n  case 1:\n    uVar1 = dcgettext(0,\"Written by %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors);\n    return;\n  case 2:\n    uVar1 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1]);\n    return;\n  case 3:\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00406069;\n    while( true ) {\n      uVar1 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2]);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00406069:\n      uVar1 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2]);\n    }\n    break;\n  case 4:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3]);\n    break;\n  case 5:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4]);\n    break;\n  case 6:\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00406100;\n    while( true ) {\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5]);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00406100:\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5]);\n    }\n    break;\n  case 7:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6]);\n    break;\n  case 8:\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_004061b9;\n    while( true ) {\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                    authors[6],authors[7]);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_004061b9:\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                    authors[6],authors[7]);\n    }\n    break;\n  case 9:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6],authors[7],authors[8]);\n    break;\n  default:\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00406272;\n    while( true ) {\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                    authors[6],authors[7],authors[8]);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00406272:\n      uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\",5);\n      __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                    authors[6],authors[7],authors[8]);\n    }\n  }\n  return;\n}\n\n",
            "funcName": "version_etc_arn"
        },
        {
            "funcStartAddr": "0x4062d0",
            "funcEndAddr": "0x406317",
            "decompiledFuncCode": "\nvoid version_etc_ar(FILE *stream,char *command_name,char *package,char *version,char **authors)\n\n{\n  long lVar1;\n  size_t n_authors;\n  \n  n_authors = 0xffffffffffffffff;\n  do {\n    if (9 < y_21 && ((x_20 + -1) * x_20 & 1U) != 0) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    lVar1 = n_authors + 1;\n    n_authors = n_authors + 1;\n  } while (authors[lVar1] != (char *)0x0);\n  version_etc_arn(stream,command_name,package,version,authors,n_authors);\n  return;\n}\n\n",
            "funcName": "version_etc_ar"
        },
        {
            "funcStartAddr": "0x406330",
            "funcEndAddr": "0x4063f0",
            "decompiledFuncCode": "\nvoid version_etc_va(FILE *stream,char *command_name,char *package,char *version,\n                   __va_list_tag *authors)\n\n{\n  char *pcVar1;\n  char **authors_00;\n  char **ppcVar2;\n  uint uVar3;\n  size_t n_authors;\n  char **ppcVar4;\n  undefined auStack_18 [8];\n  \n  uVar3 = (x_22 + -1) * x_22;\n  authors_00 = (char **)auStack_18;\n  do {\n    ppcVar2 = authors_00;\n    authors_00 = ppcVar2 + -10;\n  } while (9 < y_23 && (uVar3 & 1) != 0);\n  if ((y_23 < 10) || ((uVar3 & 1) == 0)) {\n    n_authors = 0;\n    do {\n      if (9 < n_authors) {\nLAB_004063e2:\n        ppcVar2[-0xb] = (char *)0x4063ea;\n        version_etc_arn(stream,command_name,package,version,authors_00,n_authors);\n        return;\n      }\n      uVar3 = authors->gp_offset;\n      if ((ulong)(long)(int)uVar3 < 0x29) {\n        ppcVar4 = (char **)((long)(int)uVar3 + (long)authors->reg_save_area);\n        authors->gp_offset = uVar3 + 8;\n      }\n      else {\n        ppcVar4 = (char **)authors->overflow_arg_area;\n        authors->overflow_arg_area = ppcVar4 + 1;\n      }\n      pcVar1 = *ppcVar4;\n      authors_00[n_authors] = pcVar1;\n      if (pcVar1 == (char *)0x0) goto LAB_004063e2;\n      n_authors = n_authors + 1;\n    } while ((y_23 < 10) || (((x_22 + -1) * x_22 & 1U) == 0));\n  }\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "version_etc_va"
        },
        {
            "funcStartAddr": "0x406400",
            "funcEndAddr": "0x406482",
            "decompiledFuncCode": "\nvoid version_etc(FILE *stream,char *command_name,char *package,char *version,...)\n\n{\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list authors;\n  __va_list_tag local_d8;\n  undefined local_b8 [32];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  local_d8.reg_save_area = local_b8;\n  local_d8.overflow_arg_area = &authors[0].overflow_arg_area;\n  local_d8.fp_offset = 0x30;\n  local_d8.gp_offset = 0x20;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  version_etc_va(stream,command_name,package,version,&local_d8);\n  return;\n}\n\n",
            "funcName": "version_etc"
        },
        {
            "funcStartAddr": "0x406490",
            "funcEndAddr": "0x4065b8",
            "decompiledFuncCode": "\nvoid emit_bug_reporting_address(void)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  \n  if ((9 < y_27) && (((x_26 + -1) * x_26 & 1U) != 0)) goto LAB_0040653f;\n  while( true ) {\n    uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n    __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n    uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n    __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar2 = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\"\n                               ,5);\n    fputs_unlocked(pcVar2,stdout);\n    if ((y_27 < 10) || (((x_26 + -1) * x_26 & 1U) == 0)) break;\nLAB_0040653f:\n    uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n    __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n    uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n    __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar2 = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\"\n                               ,5);\n    fputs_unlocked(pcVar2,stdout);\n  }\n  return;\n}\n\n",
            "funcName": "emit_bug_reporting_address"
        },
        {
            "funcStartAddr": "0x4065c0",
            "funcEndAddr": "0x406653",
            "decompiledFuncCode": "\nvoid * xnmalloc(size_t n,size_t s)\n\n{\n  bool bVar1;\n  void *pvVar2;\n  uint uVar3;\n  \n  if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  if (n <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0)) {\n    uVar3 = (x_1 + -1) * x_1;\n    bVar1 = 9 < y_2;\n    do {\n      pvVar2 = malloc(s * n);\n    } while (bVar1 && (uVar3 & 1) != 0);\n    if ((s * n == 0) || (pvVar2 != (void *)0x0)) {\n      return pvVar2;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "xnmalloc"
        },
        {
            "funcStartAddr": "0x406660",
            "funcEndAddr": "0x4066b3",
            "decompiledFuncCode": "\nvoid * xmalloc(size_t n)\n\n{\n  bool bVar1;\n  void *pvVar2;\n  uint uVar3;\n  \n  uVar3 = (x_1 + -1) * x_1;\n  bVar1 = 9 < y_2;\n  do {\n    pvVar2 = malloc(n);\n  } while (bVar1 && (uVar3 & 1) != 0);\n  if ((n != 0) && (pvVar2 == (void *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar2;\n}\n\n",
            "funcName": "xmalloc"
        },
        {
            "funcStartAddr": "0x4066c0",
            "funcEndAddr": "0x40673d",
            "decompiledFuncCode": "\nvoid * xnrealloc(void *p,size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0) < n) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  if ((9 < y_4) && (((x_3 + -1) * x_3 & 1U) != 0)) goto LAB_00406728;\n  while ((pvVar1 = xrealloc(p,s * n), 9 < y_4 && (((x_3 + -1) * x_3 & 1U) != 0))) {\nLAB_00406728:\n    xrealloc(p,s * n);\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "xnrealloc"
        },
        {
            "funcStartAddr": "0x406740",
            "funcEndAddr": "0x4067c0",
            "decompiledFuncCode": "\nvoid * xrealloc(void *p,size_t n)\n\n{\n  void *pvVar1;\n  \n  if ((p == (void *)0x0) || (n != 0)) {\n    pvVar1 = realloc(p,n);\n    if ((n != 0) && (pvVar1 == (void *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  else {\n    if ((9 < y_6) && (((x_5 + -1) * x_5 & 1U) != 0)) goto LAB_004067ae;\n    while( true ) {\n      free(p);\n      pvVar1 = (void *)0x0;\n      if ((y_6 < 10) || (((x_5 + -1) * x_5 & 1U) == 0)) break;\nLAB_004067ae:\n      free(p);\n    }\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "xrealloc"
        },
        {
            "funcStartAddr": "0x4067c0",
            "funcEndAddr": "0x40688a",
            "decompiledFuncCode": "\nvoid * x2nrealloc(void *p,size_t *pn,size_t s)\n\n{\n  void *pvVar1;\n  ulong uVar2;\n  \n  uVar2 = *pn;\n  if (p == (void *)0x0) {\n    if (uVar2 == 0) {\n      if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      uVar2 = (ulong)(0x80 < s) + SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(s),0);\n    }\n    if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0) < uVar2) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  else {\n    if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554)) / ZEXT816(s),0) <= uVar2) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    uVar2 = uVar2 + 1 + (uVar2 >> 1);\n  }\n  *pn = uVar2;\n  pvVar1 = xrealloc(p,s * uVar2);\n  return pvVar1;\n}\n\n",
            "funcName": "x2nrealloc"
        },
        {
            "funcStartAddr": "0x406890",
            "funcEndAddr": "0x4068e3",
            "decompiledFuncCode": "\nchar * xcharalloc(size_t n)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  uint uVar3;\n  \n  uVar3 = (x_1 + -1) * x_1;\n  bVar1 = 9 < y_2;\n  do {\n    pcVar2 = (char *)malloc(n);\n  } while (bVar1 && (uVar3 & 1) != 0);\n  if ((n != 0) && (pcVar2 == (char *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pcVar2;\n}\n\n",
            "funcName": "xcharalloc"
        },
        {
            "funcStartAddr": "0x4068f0",
            "funcEndAddr": "0x406a5c",
            "decompiledFuncCode": "\nvoid * x2realloc(void *p,size_t *pn)\n\n{\n  void *pvVar1;\n  size_t sVar2;\n  \n  if ((9 < y_12) && (((x_11 + -1) * x_11 & 1U) != 0)) goto LAB_0040699b;\n  while( true ) {\n    sVar2 = *pn;\n    if (p == (void *)0x0) {\n      if (sVar2 == 0) {\n        sVar2 = 0x80;\n        if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n      }\n      else if ((long)sVar2 < 0) {\n                    /* WARNING: Subroutine does not return */\n        xalloc_die();\n      }\n    }\n    else {\n      if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      if (0x5555555555555553 < sVar2) {\n                    /* WARNING: Subroutine does not return */\n        xalloc_die();\n      }\n      sVar2 = sVar2 + 1 + (sVar2 >> 1);\n    }\n    *pn = sVar2;\n    pvVar1 = xrealloc(p,sVar2);\n    if ((y_12 < 10) || (((x_11 + -1) * x_11 & 1U) == 0)) break;\nLAB_0040699b:\n    sVar2 = *pn;\n    if (p == (void *)0x0) {\n      if (sVar2 == 0) {\n        sVar2 = 0x80;\n        if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n      }\n      else if ((long)sVar2 < 0) {\n                    /* WARNING: Subroutine does not return */\n        xalloc_die();\n      }\n    }\n    else {\n      if ((9 < y_8) && (((x_7 + -1) * x_7 & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      if (0x5555555555555553 < sVar2) {\n                    /* WARNING: Subroutine does not return */\n        xalloc_die();\n      }\n      sVar2 = sVar2 + 1 + (sVar2 >> 1);\n    }\n    *pn = sVar2;\n    xrealloc(p,sVar2);\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "x2realloc"
        },
        {
            "funcStartAddr": "0x406a60",
            "funcEndAddr": "0x406b29",
            "decompiledFuncCode": "\nvoid * xzalloc(size_t s)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  void *__s;\n  uint uVar4;\n  \n  iVar3 = y_2;\n  iVar2 = y_14;\n  iVar1 = x_1;\n  uVar4 = (x_13 + -1) * x_13 & 1;\n  if ((9 < y_14) && (uVar4 != 0)) goto LAB_00406af4;\n  do {\n    do {\n      __s = malloc(s);\n    } while (9 < iVar3 && ((iVar1 + -1) * iVar1 & 1U) != 0);\n    if ((s != 0) && (__s == (void *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    memset(__s,0,s);\n    if ((iVar2 < 10) || (uVar4 == 0)) {\n      return __s;\n    }\nLAB_00406af4:\n  } while ((iVar3 < 10) || (((iVar1 + -1) * iVar1 & 1U) == 0));\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "funcName": "xzalloc"
        },
        {
            "funcStartAddr": "0x406b30",
            "funcEndAddr": "0x406b56",
            "decompiledFuncCode": "\nvoid * xcalloc(size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (n <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0)) {\n    pvVar1 = rpl_calloc(n,s);\n    if (pvVar1 != (void *)0x0) {\n      return pvVar1;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "xcalloc"
        },
        {
            "funcStartAddr": "0x406b60",
            "funcEndAddr": "0x406bcb",
            "decompiledFuncCode": "\nvoid * xmemdup(void *p,size_t s)\n\n{\n  bool bVar1;\n  void *__dest;\n  uint uVar2;\n  \n  uVar2 = (x_1 + -1) * x_1;\n  bVar1 = 9 < y_2;\n  do {\n    __dest = malloc(s);\n  } while (bVar1 && (uVar2 & 1) != 0);\n  if ((s != 0) && (__dest == (void *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  memcpy(__dest,p,s);\n  return __dest;\n}\n\n",
            "funcName": "xmemdup"
        },
        {
            "funcStartAddr": "0x406bd0",
            "funcEndAddr": "0x406c4b",
            "decompiledFuncCode": "\nchar * xstrdup(char *string)\n\n{\n  bool bVar1;\n  size_t sVar2;\n  char *__dest;\n  uint uVar3;\n  \n  sVar2 = strlen(string);\n  sVar2 = sVar2 + 1;\n  uVar3 = (x_1 + -1) * x_1;\n  bVar1 = 9 < y_2;\n  do {\n    __dest = (char *)malloc(sVar2);\n  } while (bVar1 && (uVar3 & 1) != 0);\n  if ((sVar2 != 0) && (__dest == (char *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  memcpy(__dest,string,sVar2);\n  return __dest;\n}\n\n",
            "funcName": "xstrdup"
        },
        {
            "funcStartAddr": "0x406c50",
            "funcEndAddr": "0x406c80",
            "decompiledFuncCode": "\nvoid xalloc_die(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = exit_failure;\n  uVar2 = dcgettext(0,\"memory exhausted\",5);\n  error(iVar1,0,\"%s\",uVar2);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "xalloc_die"
        },
        {
            "funcStartAddr": "0x406c80",
            "funcEndAddr": "0x406d24",
            "decompiledFuncCode": "\nvoid * rpl_calloc(size_t n,size_t s)\n\n{\n  bool bVar1;\n  uint uVar2;\n  void *pvVar3;\n  int *piVar4;\n  size_t __size;\n  size_t __nmemb;\n  \n  __size = 1;\n  if (n == 0) {\n    __nmemb = 1;\n  }\n  else {\n    __nmemb = 1;\n    if (s != 0) {\n      if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      __size = s;\n      __nmemb = n;\n      if ((s * n) / s != n) {\n        piVar4 = __errno_location();\n        *piVar4 = 0xc;\n        return (void *)0x0;\n      }\n    }\n  }\n  uVar2 = (x + -1) * x;\n  bVar1 = 9 < y;\n  do {\n    pvVar3 = calloc(__nmemb,__size);\n  } while (bVar1 && (uVar2 & 1) != 0);\n  return pvVar3;\n}\n\n",
            "funcName": "rpl_calloc"
        },
        {
            "funcStartAddr": "0x406d30",
            "funcEndAddr": "0x406db8",
            "decompiledFuncCode": "\nsize_t rpl_mbrtowc(wchar_t *pwc,char *s,size_t n,mbstate_t *ps)\n\n{\n  _Bool _Var1;\n  size_t sVar2;\n  wchar_t *pwVar3;\n  wchar_t *pwVar4;\n  undefined8 auStack_40 [3];\n  \n  pwVar3 = (wchar_t *)&stack0xffffffffffffffd8;\n  do {\n    pwVar4 = pwVar3;\n    pwVar3 = pwVar4 + -4;\n  } while (9 < y && ((x + -1) * x & 1U) != 0);\n  if (pwc != (wchar_t *)0x0) {\n    pwVar3 = pwc;\n  }\n  *(undefined8 *)(pwVar4 + -6) = 0x406d83;\n  sVar2 = mbrtowc(pwVar3,s,n,(mbstate_t *)ps);\n  if ((n != 0) && (0xfffffffffffffffd < sVar2)) {\n    *(undefined8 *)(pwVar4 + -6) = 0x406d98;\n    _Var1 = hard_locale(0);\n    if (!_Var1) {\n      *pwVar3 = (uint)(byte)*s;\n      sVar2 = 1;\n    }\n  }\n  return sVar2;\n}\n\n",
            "funcName": "rpl_mbrtowc"
        },
        {
            "funcStartAddr": "0x406dc0",
            "funcEndAddr": "0x406e8d",
            "decompiledFuncCode": "\nint close_stream(FILE *stream)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  int *piVar4;\n  int iVar5;\n  int iVar6;\n  \n  if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00406e1a;\n  while( true ) {\n    lVar3 = __fpending(stream);\n    uVar1 = stream->_flags;\n    iVar2 = rpl_fclose(stream);\n    iVar5 = y;\n    iVar6 = x;\n    if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00406e1a:\n    __fpending(stream);\n    rpl_fclose(stream);\n  }\n  if ((uVar1 & 0x20) == 0) {\n    if (iVar2 == 0) {\n      return 0;\n    }\n    if ((lVar3 == 0) && (piVar4 = __errno_location(), *piVar4 == 9)) {\n      return 0;\n    }\n  }\n  else if (iVar2 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    iVar6 = x;\n    iVar5 = y;\n  }\n  if ((9 < iVar5) && (((iVar6 + -1) * iVar6 & 1U) != 0)) {\n    do {\n                    /* WARNING: Do nothing block with infinite loop */\n    } while( true );\n  }\n  return -1;\n}\n\n",
            "funcName": "close_stream"
        },
        {
            "funcStartAddr": "0x406e90",
            "funcEndAddr": "0x406efb",
            "decompiledFuncCode": "\n_Bool hard_locale(int category)\n\n{\n  int iVar1;\n  char *__s1;\n  _Bool _Var2;\n  \n  __s1 = setlocale(category,(char *)0x0);\n  _Var2 = true;\n  if ((__s1 != (char *)0x0) &&\n     ((iVar1 = strcmp(__s1,\"C\"), iVar1 == 0 || (iVar1 = strcmp(__s1,\"POSIX\"), iVar1 == 0)))) {\n    _Var2 = false;\n    if ((9 < y) && (_Var2 = false, ((x + -1) * x & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n  }\n  return _Var2;\n}\n\n",
            "funcName": "hard_locale"
        },
        {
            "funcStartAddr": "0x406f00",
            "funcEndAddr": "0x406f25",
            "decompiledFuncCode": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar1 = nl_langinfo(0xe);\n  pcVar2 = \"\";\n  if (pcVar1 != (char *)0x0) {\n    pcVar2 = pcVar1;\n  }\n  pcVar1 = \"ASCII\";\n  if (*pcVar2 != '\\0') {\n    pcVar1 = pcVar2;\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "locale_charset"
        },
        {
            "funcStartAddr": "0x406f30",
            "funcEndAddr": "0x40703b",
            "decompiledFuncCode": "\nint rpl_fclose(FILE *fp)\n\n{\n  int iVar1;\n  int iVar2;\n  __off_t _Var3;\n  int *piVar4;\n  \n  if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00406f73;\n  while( true ) {\n    iVar1 = fileno((FILE *)fp);\n    if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00406f73:\n    fileno((FILE *)fp);\n  }\n  if (-1 < iVar1) {\n    iVar1 = __freading(fp);\n    if (iVar1 != 0) {\n      iVar1 = fileno((FILE *)fp);\n      _Var3 = lseek(iVar1,0,1);\n      if (_Var3 == -1) goto LAB_00406fd2;\n    }\n    iVar1 = rpl_fflush(fp);\n    if (iVar1 != 0) {\n      if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n        do {\n                    /* WARNING: Do nothing block with infinite loop */\n        } while( true );\n      }\n      piVar4 = __errno_location();\n      iVar1 = *piVar4;\n      iVar2 = fclose((FILE *)fp);\n      if (iVar1 != 0) {\n        if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00407031;\n        while( true ) {\n          *piVar4 = iVar1;\n          iVar2 = -1;\n          if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00407031:\n          *piVar4 = iVar1;\n        }\n      }\n      return iVar2;\n    }\n  }\nLAB_00406fd2:\n  iVar1 = fclose((FILE *)fp);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fclose"
        },
        {
            "funcStartAddr": "0x407040",
            "funcEndAddr": "0x407132",
            "decompiledFuncCode": "\nint rpl_fflush(FILE *stream)\n\n{\n  int iVar1;\n  \n  if (stream != (FILE *)0x0) {\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) goto LAB_00407085;\n    while( true ) {\n      iVar1 = __freading(stream);\n      if ((y < 10) || (((x + -1) * x & 1U) == 0)) break;\nLAB_00407085:\n      __freading(stream);\n    }\n    if (iVar1 != 0) {\n      while( true ) {\n        if ((*(byte *)((long)&stream->_flags + 1) & 1) != 0) {\n          rpl_fseeko(stream,0,1);\n        }\n        if ((9 < y_2) && (((x_1 + -1) * x_1 & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n        iVar1 = fflush((FILE *)stream);\n        if ((y < 10) || (((x + -1) * x & 1U) == 0)) {\n          return iVar1;\n        }\n        if ((*(byte *)((long)&stream->_flags + 1) & 1) != 0) {\n          rpl_fseeko(stream,0,1);\n        }\n        if ((9 < y_2) && (((x_1 + -1) * x_1 & 1U) != 0)) break;\n        fflush((FILE *)stream);\n      }\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n  }\n  iVar1 = fflush((FILE *)stream);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fflush"
        },
        {
            "funcStartAddr": "0x407150",
            "funcEndAddr": "0x407202",
            "decompiledFuncCode": "\nint rpl_fseeko(FILE *fp,off_t offset,int whence)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (fp->_IO_read_end == fp->_IO_read_ptr) {\n    if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n      do {\n                    /* WARNING: Do nothing block with infinite loop */\n      } while( true );\n    }\n    if ((fp->_IO_write_ptr == fp->_IO_write_base) && (fp->_IO_save_base == (char *)0x0)) {\n      iVar1 = fileno((FILE *)fp);\n      _Var2 = lseek(iVar1,offset,whence);\n      if (_Var2 == -1) {\n        iVar1 = -1;\n        if ((9 < y) && (((x + -1) * x & 1U) != 0)) {\n          do {\n                    /* WARNING: Do nothing block with infinite loop */\n          } while( true );\n        }\n      }\n      else {\n        *(byte *)&fp->_flags = *(byte *)&fp->_flags & 0xef;\n        fp->_offset = _Var2;\n        iVar1 = 0;\n      }\n      return iVar1;\n    }\n  }\n  iVar1 = fseeko((FILE *)fp,offset,whence);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fseeko"
        },
        {
            "funcStartAddr": "0x407290",
            "funcEndAddr": "0x4072a2",
            "decompiledFuncCode": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n",
            "funcName": "atexit"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "whoami-amd64-clang-bcf_O2",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}