{
    "funcCount": 72,
    "funcInfo": [
        {
            "funcStartAddr": "0x402350",
            "funcEndAddr": "0x402355",
            "decompiledFuncCode": "\nvoid _dl_relocate_static_pie(void)\n\n{\n  return;\n}\n\n",
            "funcName": "_dl_relocate_static_pie"
        },
        {
            "funcStartAddr": "0x402410",
            "funcEndAddr": "0x4025cb",
            "decompiledFuncCode": "\nvoid usage(int status)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  uVar2 = stderr;\n  if (status == 0) {\n    uVar2 = dcgettext(0,\"Usage: %s [OPTION]...\\n\",5);\n    __printf_chk(1,uVar2,program_name);\n    pcVar3 = (char *)dcgettext(0,\n                               \"Print the number of processing units available to the current process,\\nwhich may be less than the number of online processors\\n\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,stdout);\n    pcVar3 = (char *)dcgettext(0,\n                               \"      --all      print the number of installed processors\\n      --ignore=N  if possible, exclude N processing units\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,stdout);\n    pcVar3 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar3,stdout);\n    pcVar3 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar3,stdout);\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\n        pcVar3 = (char *)dcgettext(0,\n                                   \"Report any translation bugs to <https://translationproject.org/team/>\\n\"\n                                   ,5);\n        fputs_unlocked(pcVar3,stdout);\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation <%s%s>\\n\",5);\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",\"nproc\");\n    uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n    __printf_chk(1,uVar2,\"nproc\",\" invocation\");\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  uVar4 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n  __fprintf_chk(uVar2,1,uVar4,program_name);\n                    /* WARNING: Subroutine does not return */\n  exit(status);\n}\n\n",
            "funcName": "usage"
        },
        {
            "funcStartAddr": "0x4025d0",
            "funcEndAddr": "0x40276e",
            "decompiledFuncCode": "\nint main(int argc,char **argv)\n\n{\n  nproc_query nVar1;\n  int iVar2;\n  char *err;\n  uintmax_t uVar3;\n  ulong uVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  long lVar7;\n  nproc_query query;\n  \n  set_program_name(*argv);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/home/yujeong/binary_gen/coreutils-8.31/tmp/_install/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  uVar3 = 0;\n  nVar1 = NPROC_CURRENT_OVERRIDABLE;\n  while( true ) {\n    query = nVar1;\n    iVar2 = getopt_long(argc,argv,\"\",longopts,0);\n    pcVar6 = optarg;\n    if (iVar2 < 0x80) break;\n    nVar1 = NPROC_ALL;\n    if (iVar2 != 0x80) {\n      if (iVar2 != 0x81) goto LAB_00402772;\n      err = (char *)dcgettext(0,\"invalid number\",5);\n      uVar3 = xdectoumax(pcVar6,0,0xffffffffffffffff,\"\",err,0);\n      nVar1 = query;\n    }\n  }\n  if (iVar2 == -1) {\n    if (optind != argc) {\n      uVar5 = dcgettext(0,\"extra operand %s\",5);\n      pcVar6 = quote(argv[optind]);\n      error(0,0,uVar5,pcVar6);\n                    /* WARNING: Subroutine does not return */\n      usage(1);\n    }\n    uVar4 = num_processors(query);\n    lVar7 = 1;\n    if (uVar3 < uVar4) {\n      lVar7 = uVar4 - uVar3;\n    }\n    __printf_chk(1,&DAT_00407222,lVar7);\n    return 0;\n  }\n  if (iVar2 == -0x83) {\n    version_etc(stdout,\"nproc\",\"GNU coreutils\",Version,\"Giuseppe Scrivano\",0);\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  if (iVar2 == -0x82) {\n                    /* WARNING: Subroutine does not return */\n    usage(0);\n  }\nLAB_00402772:\n                    /* WARNING: Subroutine does not return */\n  usage(1);\n}\n\n",
            "funcName": "main"
        },
        {
            "funcStartAddr": "0x402780",
            "funcEndAddr": "0x402788",
            "decompiledFuncCode": "\nvoid close_stdout_set_file_name(char *file)\n\n{\n  file_name = file;\n  return;\n}\n\n",
            "funcName": "close_stdout_set_file_name"
        },
        {
            "funcStartAddr": "0x402790",
            "funcEndAddr": "0x402798",
            "decompiledFuncCode": "\nvoid close_stdout_set_ignore_EPIPE(_Bool ignore)\n\n{\n  ignore_EPIPE = ignore;\n  return;\n}\n\n",
            "funcName": "close_stdout_set_ignore_EPIPE"
        },
        {
            "funcStartAddr": "0x4027a0",
            "funcEndAddr": "0x402855",
            "decompiledFuncCode": "\nvoid close_stdout(void)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  \n  iVar2 = close_stream(stdout);\n  _Var1 = ignore_EPIPE;\n  if (iVar2 != 0) {\n    piVar3 = __errno_location();\n    if ((_Var1 == false) || (*piVar3 != 0x20)) {\n      uVar4 = dcgettext(0,\"write error\",5);\n      iVar2 = *piVar3;\n      if (file_name == (char *)0x0) {\n        error(0,iVar2,\"%s\",uVar4);\n                    /* WARNING: Subroutine does not return */\n        _exit(exit_failure);\n      }\n      pcVar5 = quotearg_colon(file_name);\n      error(0,iVar2,\"%s: %s\",pcVar5,uVar4);\n                    /* WARNING: Subroutine does not return */\n      _exit(exit_failure);\n    }\n  }\n  iVar2 = close_stream(stderr);\n  if (iVar2 == 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n",
            "funcName": "close_stdout"
        },
        {
            "funcStartAddr": "0x402860",
            "funcEndAddr": "0x40295a",
            "decompiledFuncCode": "\nulong num_processors(nproc_query query)\n\n{\n  int iVar1;\n  char *pcVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  cpu_set_t local_90;\n  \n  uVar5 = 0xffffffffffffffff;\n  if (query == NPROC_CURRENT_OVERRIDABLE) {\n    pcVar2 = getenv(\"OMP_NUM_THREADS\");\n    uVar3 = parse_omp_threads(pcVar2);\n    pcVar2 = getenv(\"OMP_THREAD_LIMIT\");\n    uVar5 = parse_omp_threads(pcVar2);\n    uVar5 = -(ulong)(uVar5 == 0) | uVar5;\n    uVar4 = uVar5;\n    if (uVar3 < uVar5) {\n      uVar4 = uVar3;\n    }\n    if (uVar3 != 0) {\n      return uVar4;\n    }\n    query = NPROC_CURRENT;\n  }\n  if (query == NPROC_CURRENT) {\n    iVar1 = sched_getaffinity(0,0x80,&local_90);\n    if ((iVar1 == 0) && (iVar1 = __sched_cpucount(0x80,&local_90), iVar1 != 0)) {\n      uVar4 = (ulong)iVar1;\n      goto LAB_00402945;\n    }\n    uVar4 = sysconf(0x54);\njoined_r0x00402927:\n    if (0 < (long)uVar4) goto LAB_00402945;\n  }\n  else {\n    uVar4 = sysconf(0x53);\n    if (uVar4 != 1) goto joined_r0x00402927;\n    iVar1 = sched_getaffinity(0,0x80,&local_90);\n    if ((iVar1 == 0) && (iVar1 = __sched_cpucount(0x80,&local_90), iVar1 != 0)) {\n      uVar4 = (ulong)iVar1;\n      goto joined_r0x00402927;\n    }\n  }\n  uVar4 = 1;\nLAB_00402945:\n  if (uVar4 < uVar5) {\n    uVar5 = uVar4;\n  }\n  return uVar5;\n}\n\n",
            "funcName": "num_processors"
        },
        {
            "funcStartAddr": "0x402960",
            "funcEndAddr": "0x402a1c",
            "decompiledFuncCode": "\nulong parse_omp_threads(char *threads)\n\n{\n  char *pcVar1;\n  char cVar2;\n  ulong uVar3;\n  uint uVar4;\n  char *local_8;\n  \n  if (threads != (char *)0x0) {\n    cVar2 = *threads;\n    while (cVar2 != '\\0') {\n      if ((0x17 < (int)cVar2 - 9U) ||\n         (uVar4 = 0x80001f >> ((byte)((int)cVar2 - 9U) & 0x1f),\n         ((uVar4 ^ 0xfffffe) & uVar4 & 0xffffff) == 0)) goto LAB_004029b2;\n      pcVar1 = threads + 1;\n      threads = threads + 1;\n      cVar2 = *pcVar1;\n    }\n    cVar2 = '\\0';\nLAB_004029b2:\n    if ((int)cVar2 - 0x30U < 10) {\n      local_8 = (char *)0x0;\n      uVar3 = strtoul(threads,&local_8,10);\n      if (local_8 != (char *)0x0) {\n        cVar2 = *local_8;\n        while (((cVar2 != '\\0' && ((int)cVar2 - 9U < 0x18)) &&\n               ((~(0x80001fU >> ((byte)((int)cVar2 - 9U) & 0x1f)) | 0xfffffffe) != 0xffffffff))) {\n          cVar2 = local_8[1];\n          local_8 = local_8 + 1;\n        }\n        if (*local_8 == ',') {\n          return uVar3;\n        }\n        if (*local_8 == '\\0') {\n          return uVar3;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "funcName": "parse_omp_threads"
        },
        {
            "funcStartAddr": "0x402a30",
            "funcEndAddr": "0x402ad1",
            "decompiledFuncCode": "\nvoid set_program_name(char *argv0)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s1;\n  \n  if (argv0 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",0x37,1,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar2 = strrchr(argv0,0x2f);\n  __s1 = pcVar2 + 1;\n  if (pcVar2 == (char *)0x0) {\n    __s1 = argv0;\n  }\n  if (((6 < (long)__s1 - (long)argv0) && (iVar1 = strncmp(__s1 + -7,\"/.libs/\",7), iVar1 == 0)) &&\n     (iVar1 = strncmp(__s1,\"lt-\",3), argv0 = __s1, iVar1 == 0)) {\n    argv0 = __s1 + 3;\n    program_invocation_short_name = argv0;\n  }\n  program_name = argv0;\n  program_invocation_name = argv0;\n  return;\n}\n\n",
            "funcName": "set_program_name"
        },
        {
            "funcStartAddr": "0x402ae0",
            "funcEndAddr": "0x402b13",
            "decompiledFuncCode": "\nquoting_options * clone_quoting_options(quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  quoting_options *pqVar3;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  pqVar3 = (quoting_options *)xmemdup(o,0x38);\n  *piVar2 = iVar1;\n  return pqVar3;\n}\n\n",
            "funcName": "clone_quoting_options"
        },
        {
            "funcStartAddr": "0x402b20",
            "funcEndAddr": "0x402b2f",
            "decompiledFuncCode": "\nquoting_style get_quoting_style(quoting_options *o)\n\n{\n  quoting_options *pqVar1;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  return pqVar1->style;\n}\n\n",
            "funcName": "get_quoting_style"
        },
        {
            "funcStartAddr": "0x402b30",
            "funcEndAddr": "0x402b3f",
            "decompiledFuncCode": "\nvoid set_quoting_style(quoting_options *o,quoting_style s)\n\n{\n  quoting_options *pqVar1;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  pqVar1->style = s;\n  return;\n}\n\n",
            "funcName": "set_quoting_style"
        },
        {
            "funcStartAddr": "0x402b40",
            "funcEndAddr": "0x402bae",
            "decompiledFuncCode": "\nwchar_t set_char_quoting(quoting_options *o,char c,wchar_t i)\n\n{\n  uint uVar1;\n  wchar_t wVar2;\n  uint uVar3;\n  quoting_options *pqVar4;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  uVar1 = pqVar4->quote_these_too[(byte)c >> 5];\n  uVar3 = uVar1 >> (c & 0x1fU);\n  wVar2 = (uVar3 ^ 0xfffffffe) & uVar3;\n  uVar3 = ((~i | 0xfffffffeU) & wVar2 | ~wVar2 & i & 1U) << (c & 0x1fU);\n  pqVar4->quote_these_too[(byte)c >> 5] =\n       (uVar1 & 0x62131bca | ~uVar1 & 0x9dece435) ^ (uVar3 & 0x62131bca | ~uVar3 & 0x9dece435);\n  return wVar2;\n}\n\n",
            "funcName": "set_char_quoting"
        },
        {
            "funcStartAddr": "0x402bb0",
            "funcEndAddr": "0x402bc3",
            "decompiledFuncCode": "\nwchar_t set_quoting_flags(quoting_options *o,wchar_t i)\n\n{\n  wchar_t wVar1;\n  quoting_options *pqVar2;\n  \n  pqVar2 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar2 = o;\n  }\n  wVar1 = pqVar2->flags;\n  pqVar2->flags = i;\n  return wVar1;\n}\n\n",
            "funcName": "set_quoting_flags"
        },
        {
            "funcStartAddr": "0x402bd0",
            "funcEndAddr": "0x402c08",
            "decompiledFuncCode": "\nvoid set_custom_quoting(quoting_options *o,char *left_quote,char *right_quote)\n\n{\n  quoting_options *pqVar1;\n  \n  pqVar1 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar1 = o;\n  }\n  pqVar1->style = custom_quoting_style;\n  if (((right_quote != (char *)0x0) == (left_quote != (char *)0x0)) && (left_quote != (char *)0x0))\n  {\n    pqVar1->left_quote = left_quote;\n    pqVar1->right_quote = right_quote;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "set_custom_quoting"
        },
        {
            "funcStartAddr": "0x402c10",
            "funcEndAddr": "0x402c82",
            "decompiledFuncCode": "\nsize_t quotearg_buffer(char *buffer,size_t buffersize,char *arg,size_t argsize,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  quoting_options *pqVar4;\n  wchar_t e;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  sVar3 = quotearg_buffer_restyled\n                    (buffer,buffersize,arg,argsize,pqVar4->style,pqVar4->flags,\n                     pqVar4->quote_these_too,pqVar4->left_quote,pqVar4->right_quote);\n  *piVar2 = iVar1;\n  return sVar3;\n}\n\n",
            "funcName": "quotearg_buffer"
        },
        {
            "funcStartAddr": "0x402c90",
            "funcEndAddr": "0x403de4",
            "decompiledFuncCode": "\n/* WARNING: Removing unreachable block (ram,0x00402dcf) */\n/* WARNING: Type propagation algorithm not settling */\n\nsize_t quotearg_buffer_restyled\n                 (char *buffer,size_t buffersize,char *arg,size_t argsize,\n                 quoting_style quoting_style,wchar_t flags,uint *quote_these_too,char *left_quote,\n                 char *right_quote)\n\n{\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  quoting_style qVar4;\n  ulong uVar5;\n  undefined4 extraout_var;\n  ushort **ppuVar6;\n  size_t sVar7;\n  byte bVar8;\n  byte bVar9;\n  byte bVar10;\n  byte bVar11;\n  byte bVar12;\n  byte bVar13;\n  size_t __n;\n  ulong uVar14;\n  bool bVar15;\n  quoting_style quoting_style_00;\n  byte bVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  byte bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  bool bVar25;\n  bool bVar26;\n  bool bVar27;\n  ulong local_b0;\n  char *local_a8;\n  ulong local_a0;\n  ulong local_90;\n  char *local_80;\n  char *local_78;\n  mbstate_t local_68;\n  uint local_5c;\n  uint local_58;\n  wchar_t local_54;\n  char *local_50;\n  ulong local_48;\n  ulong local_40;\n  size_t local_38;\n  \n  local_78 = right_quote;\n  local_80 = left_quote;\n  local_38 = __ctype_get_mb_cur_max();\n  uVar5 = (ulong)((uint)flags >> 1) & 1;\n  local_58 = (flags ^ 0xfffffffeU) & flags;\n  local_5c = (flags ^ 0xfffffffbU) & flags;\n  bVar16 = 1;\n  local_90 = 0;\n  local_a8 = (char *)0x0;\n  __n = 0;\n  bVar9 = 0;\n  local_48 = 0;\n  local_b0 = argsize;\n  bVar10 = 0;\n  do {\n    if (custom_quoting_style < quoting_style) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    uVar19 = 0;\n    uVar14 = 0;\n    bVar12 = (byte)uVar5;\n    bVar20 = 1;\n    bVar8 = bVar10;\n    qVar4 = escape_quoting_style;\n    switch(quoting_style) {\n    case literal_quoting_style:\n      uVar19 = 0;\n      uVar14 = 0;\n      bVar20 = bVar10;\n      qVar4 = literal_quoting_style;\n      break;\n    case shell_always_quoting_style:\n      goto switchD_00402e67_caseD_2;\n    case shell_escape_quoting_style:\n      bVar10 = 1;\n    case shell_quoting_style:\n      uVar5 = 1;\nswitchD_00402e67_caseD_4:\n      bVar8 = 1;\n      if ((byte)(((byte)uVar5 ^ 0xfe) & (byte)uVar5) != 0) {\n        bVar8 = bVar10;\n      }\nswitchD_00402e67_caseD_2:\n      if ((byte)(((byte)uVar5 ^ 0xfe) & (byte)uVar5) == 0) {\n        if (buffersize != 0) {\n          *buffer = '\\'';\n        }\n        uVar19 = 1;\n      }\n      else {\n        uVar19 = 0;\n      }\n      local_a8 = \"\\'\";\n      __n = 1;\n      uVar14 = uVar5 & 0xff;\n      bVar20 = bVar8;\n      qVar4 = shell_always_quoting_style;\n      break;\n    case shell_escape_always_quoting_style:\n      goto switchD_00402e67_caseD_4;\n    case c_quoting_style:\n      if (((bVar12 ^ 0xfe) & bVar12) == 0) {\n        if (buffersize != 0) {\n          *buffer = '\\\"';\n        }\n        uVar19 = 1;\n      }\n      else {\n        uVar19 = 0;\n      }\n      local_a8 = \"\\\"\";\n      __n = 1;\n      uVar14 = uVar5 & 0xff;\n      bVar20 = 1;\n      qVar4 = c_quoting_style;\n      break;\n    case c_maybe_quoting_style:\n      uVar19 = 0;\n      local_a8 = \"\\\"\";\n      __n = 1;\n      uVar14 = 1;\n      bVar20 = 1;\n      qVar4 = c_quoting_style;\n      break;\n    case escape_quoting_style:\n      break;\n    default:\n      local_80 = gettext_quote(\"`\",quoting_style);\n      uVar14 = (ulong)quoting_style;\n      local_78 = gettext_quote(\"\\'\",quoting_style);\n    case custom_quoting_style:\n      if ((byte)(~bVar12 | 0xfe) == 0xff) {\n        cVar2 = *local_80;\n        uVar14 = 0x95fb53789b2dc18f;\n        if (cVar2 == '\\0') goto LAB_00402ead;\n        uVar18 = 0;\n        do {\n          if (uVar18 < buffersize) {\n            buffer[uVar18] = cVar2;\n          }\n          uVar19 = uVar18 + 1;\n          cVar2 = local_80[uVar18 + 1];\n          uVar18 = uVar19;\n        } while (cVar2 != '\\0');\n      }\n      else {\nLAB_00402ead:\n        uVar19 = 0;\n      }\n      __n = strlen(local_78);\n      local_a8 = local_78;\n      uVar14 = uVar14 & 0xffffffffffffff00 | uVar5 & 0xff;\n      bVar20 = 1;\n      qVar4 = quoting_style;\n    }\n    quoting_style = qVar4;\n    bVar21 = quoting_style == shell_always_quoting_style;\n    bVar22 = bVar20 == 0;\n    bVar23 = __n != 0;\n    bVar10 = (byte)uVar14;\n    bVar8 = (bVar10 ^ 0xfe) & bVar10;\n    bVar24 = bVar8 == 0;\n    bVar1 = !bVar24;\n    uVar5 = uVar14 & 0xffffff00;\n    bVar25 = (byte)(((~bVar10 | ~bVar20) ^ 1) & ~(~bVar10 | ~bVar20)) != 0;\n    uVar18 = 0;\n    local_40 = uVar14;\n    if (local_b0 == 0xffffffffffffffff) goto LAB_00403070;\nLAB_00403060:\n    local_a0 = buffersize;\n    if (uVar18 != local_b0) {\nLAB_0040307b:\n      if ((bool)(~(bVar23 != (!bVar21 && !bVar22)) & bVar23)) {\n        uVar5 = uVar5 & 0xffffffffffffff00;\n        if ((1 < __n == (local_b0 == 0xffffffffffffffff)) && (1 < __n)) {\n          uVar5 = strlen(arg);\n          local_b0 = uVar5;\n        }\n        if (local_b0 < uVar18 + __n) goto LAB_004030df;\n        iVar3 = memcmp(arg + uVar18,local_a8,__n);\n        bVar26 = iVar3 == 0;\n        uVar5 = CONCAT44(extraout_var,iVar3) & 0xffffffffffffff00;\n        if ((bVar26 || bVar8 != 0) && (!bVar26 == (bVar8 == 0))) goto LAB_00403d0b;\n      }\n      else {\nLAB_004030df:\n        bVar26 = false;\n      }\n      uVar14 = (ulong)(byte)arg[uVar18];\n      bVar13 = 0;\n      bVar12 = 0x61;\n      bVar11 = 0x6e;\n      bVar10 = 1;\n      switch(uVar14) {\n      case 0:\n        if (bVar20 == 0) {\n          if (local_58 == 0) {\n            uVar14 = 0;\n            goto LAB_00403909;\n          }\n          goto LAB_0040364a;\n        }\n        if (bVar8 == 0) {\n          uVar5 = uVar19;\n          if ((((byte)(~bVar9 | 0xfe) == 0xff) == (quoting_style == shell_always_quoting_style)) &&\n             (quoting_style == shell_always_quoting_style)) {\n            if (uVar19 < buffersize) {\n              buffer[uVar19] = '\\'';\n            }\n            if (uVar19 + 1 < buffersize) {\n              buffer[uVar19 + 1] = '$';\n            }\n            if (uVar19 + 2 < buffersize) {\n              buffer[uVar19 + 2] = '\\'';\n            }\n            bVar9 = 1;\n            uVar5 = uVar19 + 3;\n          }\n          if (uVar5 < buffersize) {\n            buffer[uVar5] = '\\\\';\n          }\n          uVar19 = uVar5 + 1;\n          bVar11 = 1;\n          uVar14 = 0x30;\n          if (((quoting_style != shell_always_quoting_style) && (uVar18 + 1 < local_b0)) &&\n             ((byte)(arg[uVar18 + 1] - 0x30U) < 10)) {\n            if (uVar19 < buffersize) {\n              buffer[uVar19] = '0';\n            }\n            if (uVar5 + 2 < buffersize) {\n              buffer[uVar5 + 2] = '0';\n            }\n            uVar19 = uVar5 + 3;\n          }\n          goto LAB_0040390b;\n        }\n        goto LAB_00403d0b;\n      default:\n        if (local_38 == 1) {\n          ppuVar6 = __ctype_b_loc();\n          bVar10 = (byte)((*ppuVar6)[uVar14] >> 0xe) & 1;\n          uVar5 = 1;\n        }\n        else {\n          local_68 = (mbstate_t)0x0;\n          if (local_b0 == 0xffffffffffffffff) {\n            local_b0 = strlen(arg);\n          }\n          local_50 = arg + uVar18;\n          bVar10 = 1;\n          uVar5 = 0;\n          do {\n            uVar17 = uVar5 + uVar18;\n            sVar7 = rpl_mbrtowc(&local_54,arg + uVar17,local_b0 - uVar17,&local_68);\n            if (sVar7 == 0) break;\n            if (sVar7 == 0xffffffffffffffff) {\n              bVar10 = 0;\n              break;\n            }\n            if (sVar7 == 0xfffffffffffffffe) goto joined_r0x00403c51;\n            if (1 < sVar7 && (bVar21 && !bVar24)) {\n              uVar17 = 1;\n              do {\n                if (((int)local_50[uVar17 + uVar5] - 0x5bU < 0x22) &&\n                   ((0x20000002bU >> ((ulong)((int)local_50[uVar17 + uVar5] - 0x5bU) & 0x3f) & 1) !=\n                    0)) goto LAB_00403d06;\n                uVar17 = uVar17 + 1;\n              } while (uVar17 < sVar7);\n            }\n            iVar3 = iswprint(local_54);\n            if (iVar3 == 0) {\n              bVar10 = 0;\n            }\n            uVar5 = sVar7 + uVar5;\n            iVar3 = mbsinit((mbstate_t *)&local_68);\n          } while (iVar3 == 0);\n        }\n        goto LAB_004033da;\n      case 7:\n        break;\n      case 8:\n        bVar12 = 0x62;\n        break;\n      case 9:\n        bVar11 = 0x74;\n      case 10:\n        goto switchD_004030fd_caseD_a;\n      case 0xb:\n        bVar12 = 0x76;\n        break;\n      case 0xc:\n        bVar12 = 0x66;\n        break;\n      case 0xd:\n        bVar11 = 0x72;\nswitchD_004030fd_caseD_a:\n        bVar12 = bVar11;\n        if ((bVar21 || bVar1) && bVar21 == bVar1) {\nLAB_00403d06:\n          quoting_style = shell_always_quoting_style;\n          goto LAB_00403d0b;\n        }\n        break;\n      case 0x20:\nswitchD_004030fd_caseD_20:\n        bVar13 = 1;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar10 = bVar13;\n        if ((bVar21 || bVar1) && bVar21 == bVar1) goto LAB_00403d06;\n        goto joined_r0x0040310a;\n      case 0x23:\n      case 0x7e:\n        if (uVar18 == 0) goto switchD_004030fd_caseD_20;\n        goto LAB_00403909;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        goto joined_r0x0040310a;\n      case 0x27:\n        uVar14 = 0x27;\n        local_48 = uVar5 & 0xffffffffffffff00 | 1;\n        if (quoting_style != shell_always_quoting_style) {\nLAB_0040333f:\n          bVar10 = 1;\n          goto joined_r0x0040310a;\n        }\n        if (bVar8 == 0) {\n          bVar15 = buffersize == 0;\n          bVar27 = local_90 != 0;\n          if (bVar27 == bVar15 && (!bVar27 || !bVar15)) {\n            local_90 = buffersize;\n          }\n          if (bVar27 == bVar15 && (!bVar27 || !bVar15)) {\n            buffersize = 0;\n          }\n          if (uVar19 < buffersize) {\n            buffer[uVar19] = '\\'';\n          }\n          if (uVar19 + 1 < buffersize) {\n            buffer[uVar19 + 1] = '\\\\';\n          }\n          if (uVar19 + 2 < buffersize) {\n            buffer[uVar19 + 2] = '\\'';\n          }\n          uVar19 = uVar19 + 3;\n          bVar9 = 0;\n          goto LAB_0040333f;\n        }\n        goto LAB_00403d06;\n      case 0x3f:\n        uVar14 = 0x3f;\n        if (quoting_style == c_quoting_style) {\n          if (((local_5c != 0) && (uVar5 = uVar18 + 2, uVar5 < local_b0)) &&\n             (arg[uVar18 + 1] == '?')) {\n            bVar10 = arg[uVar5];\n            bVar11 = 0;\n            if (((uint)(int)(char)bVar10 < 0x3f) &&\n               ((0x7000a38200000000U >> ((ulong)(uint)(int)(char)bVar10 & 0x3f) & 1) != 0)) {\n              if (bVar8 == 0) {\n                if (uVar19 < buffersize) {\n                  buffer[uVar19] = '?';\n                }\n                if (uVar19 + 1 < buffersize) {\n                  buffer[uVar19 + 1] = '\\\"';\n                }\n                if (uVar19 + 2 < buffersize) {\n                  buffer[uVar19 + 2] = '\\\"';\n                }\n                if (uVar19 + 3 < buffersize) {\n                  buffer[uVar19 + 3] = '?';\n                }\n                uVar19 = uVar19 + 4;\n                bVar11 = 0;\n                uVar14 = (ulong)bVar10;\n                uVar18 = uVar5;\n                goto LAB_0040390b;\n              }\n              quoting_style = c_quoting_style;\n              goto LAB_00403d0b;\n            }\n            goto LAB_0040390b;\n          }\n        }\n        else if ((quoting_style == shell_always_quoting_style) && (bVar8 != 0)) goto LAB_00403d06;\nLAB_00403909:\n        bVar11 = 0;\nLAB_0040390b:\n        bVar10 = 0;\n        goto joined_r0x0040310a;\n      case 0x5c:\n        if (quoting_style == shell_always_quoting_style) {\n          if (bVar8 != 0) goto LAB_00403d06;\n          bVar12 = 0x5c;\n          bVar11 = 0;\n          bVar10 = 0;\n        }\n        else {\n          bVar11 = 0x5c;\n          if (!(bool)(~(bVar23 != bVar25) & bVar25)) goto switchD_004030fd_caseD_a;\n          bVar11 = 0;\n          bVar12 = 0x5c;\n          bVar10 = 0;\n        }\n        goto LAB_004034ce;\n      case 0x7b:\n      case 0x7d:\n        if (local_b0 == 0xffffffffffffffff) {\n          bVar11 = 0;\n          if ((uVar18 == 0 || arg[1] == '\\0') && ((uVar18 != 0) == (arg[1] != '\\0')))\n          goto switchD_004030fd_caseD_20;\n          local_b0 = 0xffffffffffffffff;\n        }\n        else {\n          bVar11 = 0;\n          if ((uVar18 == 0 || local_b0 == 1) && ((uVar18 != 0) == (local_b0 != 1)))\n          goto switchD_004030fd_caseD_20;\n        }\n        goto LAB_0040390b;\n      }\n      bVar10 = 0;\n      bVar13 = 0;\n      if (bVar20 == 0) goto joined_r0x0040310a;\n      goto joined_r0x004035a5;\n    }\nLAB_00403cb6:\n    local_b0 = uVar18;\n    bVar10 = ~((uVar19 == 0) != (quoting_style == shell_always_quoting_style)) &\n             quoting_style == shell_always_quoting_style ^ 1;\n    if ((!(bool)(bVar8 == 0 & bVar10)) && (buffersize = local_a0, !(bool)(bVar8 == 0 ^ bVar10))) {\nLAB_00403d0b:\n      qVar4 = shell_escape_always_quoting_style;\n      if ((bVar20 == 0) != (quoting_style != shell_always_quoting_style)) {\n        qVar4 = quoting_style;\n      }\n      quoting_style_00 = qVar4;\n      if (bVar20 == 0) {\n        quoting_style_00 = quoting_style;\n      }\n      if (quoting_style == shell_always_quoting_style) {\n        quoting_style_00 = qVar4;\n      }\n      sVar7 = quotearg_buffer_restyled\n                        (buffer,buffersize,arg,local_b0,quoting_style_00,flags & 0xfffffffd,\n                         (uint *)0x0,local_80,local_78);\n      return sVar7;\n    }\n    bVar10 = ((byte)local_48 ^ 0xfe) & (byte)local_48;\n    if (((bVar10 == 0) != (bVar8 != 0 || quoting_style != shell_always_quoting_style)) ||\n       (bVar10 == 0 && (bVar8 != 0 || quoting_style != shell_always_quoting_style))) {\nLAB_00403d7a:\n      if (((local_a8 != (char *)0x0) == (bVar8 == 0)) && (local_a8 != (char *)0x0)) {\n        cVar2 = *local_a8;\n        while (cVar2 != '\\0') {\n          local_a8 = local_a8 + 1;\n          if (uVar19 < local_a0) {\n            buffer[uVar19] = cVar2;\n          }\n          uVar19 = uVar19 + 1;\n          cVar2 = *local_a8;\n        }\n      }\n      if (uVar19 < local_a0) {\n        buffer[uVar19] = '\\0';\n      }\n      return uVar19;\n    }\n    if (bVar16 != 0) {\n      sVar7 = quotearg_buffer_restyled\n                        (buffer,local_90,arg,local_b0,c_quoting_style,flags,quote_these_too,local_80\n                         ,local_78);\n      return sVar7;\n    }\n    if (local_a0 != 0 || local_90 == 0) goto LAB_00403d7a;\n    uVar5 = local_40 & 0xffffffff;\n    buffersize = local_90;\n    bVar10 = bVar20;\n  } while( true );\njoined_r0x00403c51:\n  while ((uVar17 < local_b0 && (local_50[uVar5] != '\\0'))) {\n    uVar5 = uVar5 + 1;\n    uVar17 = uVar5 + uVar18;\n  }\n  bVar10 = 0;\nLAB_004033da:\n  bVar27 = bVar10 != 0;\n  bVar15 = bVar27 != bVar22 || bVar27 && bVar22;\n  if ((uVar5 < 2 != bVar15) || (1 < uVar5)) {\n    uVar17 = uVar18 + 1;\n    bVar11 = 0;\n    if (bVar15) goto LAB_00403bcf;\nLAB_00403a80:\n    if (bVar8 == 0) {\n      if (((bVar9 == 0) == (quoting_style == shell_always_quoting_style)) &&\n         (quoting_style == shell_always_quoting_style)) {\n        if (uVar19 < buffersize) {\n          buffer[uVar19] = '\\'';\n        }\n        if (uVar19 + 1 < buffersize) {\n          buffer[uVar19 + 1] = '$';\n        }\n        if (uVar19 + 2 < buffersize) {\n          buffer[uVar19 + 2] = '\\'';\n        }\n        uVar19 = uVar19 + 3;\n        bVar9 = 1;\n      }\n      if (uVar19 < buffersize) {\n        buffer[uVar19] = '\\\\';\n      }\n      if (uVar19 + 1 < buffersize) {\n        buffer[uVar19 + 1] = ((byte)(uVar14 >> 6) | 0x60) ^ 0x50;\n      }\n      if (uVar19 + 2 < buffersize) {\n        buffer[uVar19 + 2] = (byte)(uVar14 >> 3) & 0x17 | 0x30;\n      }\n      uVar19 = uVar19 + 3;\n      bVar12 = ((byte)uVar14 ^ 0xf8) & (byte)uVar14;\n      bVar12 = bVar12 & 0x30 | (bVar12 & 0xb0 | ~bVar12 & 0x4f) ^ 0x7f;\n      bVar11 = 1;\n      uVar14 = (ulong)bVar12;\n      while (uVar17 < uVar5 + uVar18) {\n        while( true ) {\n          if ((((byte)(~bVar11 | 0xfe) == 0xff) == (bVar9 != 0)) && (bVar9 != 0)) {\n            if (uVar19 < buffersize) {\n              buffer[uVar19] = '\\'';\n            }\n            if (uVar19 + 1 < buffersize) {\n              buffer[uVar19 + 1] = '\\'';\n            }\n            uVar19 = uVar19 + 2;\n            bVar9 = 0;\n          }\n          if (uVar19 < buffersize) {\n            buffer[uVar19] = (char)uVar14;\n          }\n          uVar19 = uVar19 + 1;\n          uVar14 = (ulong)(byte)arg[uVar17];\n          uVar17 = uVar17 + 1;\n          if (bVar27 == bVar22 && (!bVar27 || !bVar22)) goto LAB_00403a80;\nLAB_00403bcf:\n          bVar12 = (byte)uVar14;\n          if ((byte)(~bVar26 | 0xfeU) == 0xff) break;\n          if (uVar19 < buffersize) {\n            buffer[uVar19] = '\\\\';\n          }\n          uVar19 = uVar19 + 1;\n          bVar26 = false;\n          if (uVar5 + uVar18 <= uVar17) goto LAB_00403c1b;\n        }\n      }\nLAB_00403c1b:\n      uVar18 = uVar17 - 1;\n      goto LAB_004034ce;\n    }\n    goto LAB_00403d0b;\n  }\njoined_r0x0040310a:\n  bVar11 = 0;\njoined_r0x0040310a:\n  bVar12 = (byte)uVar14;\n  bVar13 = bVar10;\n  if (!bVar21 && !bVar22) {\n    if (quote_these_too != (uint *)0x0) goto LAB_00403487;\nLAB_004034c2:\n    if (bVar26) goto joined_r0x004035a5;\nLAB_004034ce:\n    if ((byte)(~bVar11 | 0xfe) == 0xff && (byte)(~bVar9 | 0xfe) != 0xff) {\n      if (uVar19 < buffersize) {\n        buffer[uVar19] = '\\'';\n      }\n      if (uVar19 + 1 < buffersize) {\n        buffer[uVar19 + 1] = '\\'';\n      }\n      uVar19 = uVar19 + 2;\n      bVar9 = 0;\n    }\n    if (buffersize <= uVar19) goto LAB_00403633;\n  }\n  else {\n    if (quote_these_too == (uint *)0x0 || bVar24 == (quote_these_too != (uint *)0x0))\n    goto LAB_004034c2;\nLAB_00403487:\n    if (!bVar26 ==\n        ((~(1 << (bVar12 & 0x1f) ^ quote_these_too[uVar14 >> 5]) & quote_these_too[uVar14 >> 5]) ==\n        0)) goto LAB_004034c2;\njoined_r0x004035a5:\n    bVar10 = bVar13;\n    if (bVar8 != 0) goto LAB_00403d0b;\n    if (bVar9 == 0 && quoting_style == shell_always_quoting_style) {\n      if (uVar19 < buffersize) {\n        buffer[uVar19] = '\\'';\n      }\n      if (uVar19 + 1 < buffersize) {\n        buffer[uVar19 + 1] = '$';\n      }\n      if (uVar19 + 2 < buffersize) {\n        buffer[uVar19 + 2] = '\\'';\n      }\n      uVar19 = uVar19 + 3;\n      bVar9 = 1;\n    }\n    if (uVar19 < buffersize) {\n      buffer[uVar19] = '\\\\';\n    }\n    uVar19 = uVar19 + 1;\n    if (buffersize <= uVar19) goto LAB_00403633;\n  }\n  buffer[uVar19] = bVar12;\nLAB_00403633:\n  if (bVar10 != 0) {\n    bVar10 = bVar16;\n  }\n  uVar19 = uVar19 + 1;\n  bVar16 = bVar10;\nLAB_0040364a:\n  uVar5 = uVar18 + 1;\n  uVar18 = uVar5;\n  if (local_b0 != 0xffffffffffffffff) goto LAB_00403060;\nLAB_00403070:\n  if (arg[uVar18] == '\\0') {\n    uVar18 = 0xffffffffffffffff;\n    local_a0 = buffersize;\n    goto LAB_00403cb6;\n  }\n  goto LAB_0040307b;\n}\n\n",
            "funcName": "quotearg_buffer_restyled"
        },
        {
            "funcStartAddr": "0x403e50",
            "funcEndAddr": "0x403f24",
            "decompiledFuncCode": "\nchar * quotearg_alloc(char *arg,size_t argsize,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  char *buffer;\n  wchar_t flags;\n  quoting_options *pqVar4;\n  wchar_t e;\n  \n  pqVar4 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar4 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  flags = pqVar4->flags ^ 1U | pqVar4->flags & 1U;\n  sVar3 = quotearg_buffer_restyled\n                    ((char *)0x0,0,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n                     pqVar4->left_quote,pqVar4->right_quote);\n  buffer = (char *)xmalloc(sVar3 + 1);\n  quotearg_buffer_restyled\n            (buffer,sVar3 + 1,arg,argsize,pqVar4->style,flags,pqVar4->quote_these_too,\n             pqVar4->left_quote,pqVar4->right_quote);\n  *piVar2 = iVar1;\n  return buffer;\n}\n\n",
            "funcName": "quotearg_alloc"
        },
        {
            "funcStartAddr": "0x403f30",
            "funcEndAddr": "0x40404c",
            "decompiledFuncCode": "\nchar * quotearg_alloc_mem(char *arg,size_t argsize,size_t *size,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  char *buffer;\n  uint uVar4;\n  wchar_t flags;\n  quoting_options *pqVar5;\n  wchar_t e;\n  \n  pqVar5 = &default_quoting_options;\n  if (o != (quoting_options *)0x0) {\n    pqVar5 = o;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar4 = ~pqVar5->flags;\n  flags = ~(~(uint)(size == (size_t *)0x0) | uVar4) |\n          (size == (size_t *)0x0 | 0x5530148e) ^ (pqVar5->flags & 0xaacfeb71U | uVar4 & 0x5530148e);\n  sVar3 = quotearg_buffer_restyled\n                    ((char *)0x0,0,arg,argsize,pqVar5->style,flags,pqVar5->quote_these_too,\n                     pqVar5->left_quote,pqVar5->right_quote);\n  buffer = (char *)xmalloc(sVar3 + 1);\n  quotearg_buffer_restyled\n            (buffer,sVar3 + 1,arg,argsize,pqVar5->style,flags,pqVar5->quote_these_too,\n             pqVar5->left_quote,pqVar5->right_quote);\n  *piVar2 = iVar1;\n  if (size != (size_t *)0x0) {\n    *size = sVar3;\n  }\n  return buffer;\n}\n\n",
            "funcName": "quotearg_alloc_mem"
        },
        {
            "funcStartAddr": "0x404050",
            "funcEndAddr": "0x4040fd",
            "decompiledFuncCode": "\nvoid quotearg_free(void)\n\n{\n  slotvec *__ptr;\n  long lVar1;\n  char **ppcVar2;\n  \n  __ptr = slotvec;\n  if (L'\\x01' < nslots) {\n    ppcVar2 = &slotvec[1].val;\n    lVar1 = 1;\n    do {\n      free(*ppcVar2);\n      lVar1 = lVar1 + 1;\n      ppcVar2 = ppcVar2 + 2;\n    } while (lVar1 < nslots);\n  }\n  if (__ptr->val != slot0) {\n    free(__ptr->val);\n    slotvec0.size = 0x100;\n    slotvec0.val = slot0;\n  }\n  if (__ptr != &slotvec0) {\n    free(__ptr);\n    slotvec = &slotvec0;\n  }\n  nslots = L'\\x01';\n  return;\n}\n\n",
            "funcName": "quotearg_free"
        },
        {
            "funcStartAddr": "0x404100",
            "funcEndAddr": "0x40410e",
            "decompiledFuncCode": "\nchar * quotearg_n(wchar_t n,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n"
        },
        {
            "funcStartAddr": "0x404110",
            "funcEndAddr": "0x4042dd",
            "decompiledFuncCode": "\nchar * quotearg_n_options(wchar_t n,char *arg,size_t argsize,quoting_options *options)\n\n{\n  int iVar1;\n  size_t buffersize;\n  slotvec *psVar2;\n  int *piVar3;\n  slotvec *psVar4;\n  size_t sVar5;\n  char *buffer;\n  wchar_t wVar6;\n  \n  piVar3 = __errno_location();\n  psVar2 = slotvec;\n  if (n < L'\\0') {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  iVar1 = *piVar3;\n  psVar4 = slotvec;\n  if (nslots <= n) {\n    if (n == L'\\x7fffffff') {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    psVar4 = (slotvec *)0x0;\n    if (slotvec != &slotvec0) {\n      psVar4 = slotvec;\n    }\n    wVar6 = n + L'\\x01';\n    psVar4 = (slotvec *)xrealloc(psVar4,(long)wVar6 << 4);\n    slotvec = psVar4;\n    if (psVar2 == &slotvec0) {\n      *psVar4 = slotvec0;\n    }\n    memset(psVar4 + nslots,0,(long)(wVar6 - nslots) << 4);\n    nslots = wVar6;\n  }\n  buffersize = psVar4[n].size;\n  buffer = psVar4[n].val;\n  wVar6 = options->flags ^ 1U | options->flags & 1U;\n  sVar5 = quotearg_buffer_restyled\n                    (buffer,buffersize,arg,argsize,options->style,wVar6,options->quote_these_too,\n                     options->left_quote,options->right_quote);\n  if (buffersize <= sVar5) {\n    sVar5 = sVar5 + 1;\n    psVar4[n].size = sVar5;\n    if (buffer != slot0) {\n      free(buffer);\n    }\n    buffer = (char *)xmalloc(sVar5);\n    psVar4[n].val = buffer;\n    quotearg_buffer_restyled\n              (buffer,sVar5,arg,argsize,options->style,wVar6,options->quote_these_too,\n               options->left_quote,options->right_quote);\n  }\n  *piVar3 = iVar1;\n  return buffer;\n}\n\n",
            "funcName": "quotearg_n_options"
        },
        {
            "funcStartAddr": "0x4042e0",
            "funcEndAddr": "0x4042ea",
            "decompiledFuncCode": "\nchar * quotearg_n_mem(wchar_t n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,argsize,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n_mem"
        },
        {
            "funcStartAddr": "0x4042f0",
            "funcEndAddr": "0x404309",
            "decompiledFuncCode": "\nchar * quotearg(char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg"
        },
        {
            "funcStartAddr": "0x404310",
            "funcEndAddr": "0x404328",
            "decompiledFuncCode": "\nchar * quotearg_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&default_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_mem"
        },
        {
            "funcStartAddr": "0x404330",
            "funcEndAddr": "0x40439c",
            "decompiledFuncCode": "\nchar * quotearg_n_style(wchar_t n,quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_style"
        },
        {
            "funcStartAddr": "0x4043a0",
            "funcEndAddr": "0x404408",
            "decompiledFuncCode": "\nchar * quotearg_n_style_mem(wchar_t n,quoting_style s,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(n,arg,argsize,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_style_mem"
        },
        {
            "funcStartAddr": "0x404410",
            "funcEndAddr": "0x404478",
            "decompiledFuncCode": "\nchar * quotearg_style(quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_style"
        },
        {
            "funcStartAddr": "0x404480",
            "funcEndAddr": "0x4044e1",
            "decompiledFuncCode": "\nchar * quotearg_style_mem(quoting_style s,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 local_4;\n  \n  if (s != custom_quoting_style) {\n    local_4 = 0;\n    local_38._36_4_ = 0;\n    local_38._40_4_ = 0;\n    uStack_c = 0;\n    uStack_8 = 0;\n    local_38._20_4_ = 0;\n    local_38._24_4_ = 0;\n    local_38._28_4_ = 0;\n    local_38._32_4_ = 0;\n    local_38._4_4_ = 0;\n    local_38._8_4_ = 0;\n    local_38._12_4_ = 0;\n    local_38._16_4_ = 0;\n    local_38._0_4_ = s;\n    pcVar1 = quotearg_n_options(L'\\0',arg,argsize,(quoting_options *)local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_style_mem"
        },
        {
            "funcStartAddr": "0x4044f0",
            "funcEndAddr": "0x404581",
            "decompiledFuncCode": "\nchar * quotearg_char_mem(char *arg,size_t argsize,char ch)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  uint uVar3;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  char *local_8;\n  \n  local_8 = default_quoting_options.right_quote;\n  local_38._32_4_ = default_quoting_options.quote_these_too[6];\n  local_38._36_4_ = default_quoting_options.quote_these_too[7];\n  local_38._40_4_ = default_quoting_options.left_quote._0_4_;\n  uStack_c = default_quoting_options.left_quote._4_4_;\n  local_38._16_4_ = default_quoting_options.quote_these_too[2];\n  local_38._20_4_ = default_quoting_options.quote_these_too[3];\n  local_38._24_4_ = default_quoting_options.quote_these_too[4];\n  local_38._28_4_ = default_quoting_options.quote_these_too[5];\n  local_38._0_4_ = default_quoting_options.style;\n  local_38._4_4_ = default_quoting_options.flags;\n  local_38._8_4_ = default_quoting_options.quote_these_too[0];\n  local_38._12_4_ = default_quoting_options.quote_these_too[1];\n  uVar1 = *(uint *)(local_38 + (ulong)((byte)ch >> 5) * 4 + 8);\n  uVar3 = uVar1 >> (ch & 0x1fU);\n  uVar3 = (uVar3 ^ 0xfffffffe) & uVar3;\n  uVar3 = ((uVar3 & 0xe9464f16 | ~uVar3 & 0x16b9b0e9) ^ 0x16b9b0e8) << (ch & 0x1fU);\n  *(uint *)(local_38 + (ulong)((byte)ch >> 5) * 4 + 8) = ~uVar1 & uVar3 | ~uVar3 & uVar1;\n  pcVar2 = quotearg_n_options(0 << (ch & 0x1fU),arg,argsize,(quoting_options *)local_38);\n  return pcVar2;\n}\n\n",
            "funcName": "quotearg_char_mem"
        },
        {
            "funcStartAddr": "0x404590",
            "funcEndAddr": "0x404627",
            "decompiledFuncCode": "\nchar * quotearg_char(char *arg,char ch)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  uint uVar3;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  char *local_8;\n  \n  local_8 = default_quoting_options.right_quote;\n  local_38._32_4_ = default_quoting_options.quote_these_too[6];\n  local_38._36_4_ = default_quoting_options.quote_these_too[7];\n  local_38._40_4_ = default_quoting_options.left_quote._0_4_;\n  uStack_c = default_quoting_options.left_quote._4_4_;\n  local_38._16_4_ = default_quoting_options.quote_these_too[2];\n  local_38._20_4_ = default_quoting_options.quote_these_too[3];\n  local_38._24_4_ = default_quoting_options.quote_these_too[4];\n  local_38._28_4_ = default_quoting_options.quote_these_too[5];\n  local_38._0_4_ = default_quoting_options.style;\n  local_38._4_4_ = default_quoting_options.flags;\n  local_38._8_4_ = default_quoting_options.quote_these_too[0];\n  local_38._12_4_ = default_quoting_options.quote_these_too[1];\n  uVar1 = *(uint *)(local_38 + (ulong)((byte)ch >> 5) * 4 + 8);\n  uVar3 = (~(uVar1 >> (ch & 0x1fU)) & 1) << (ch & 0x1fU);\n  *(uint *)(local_38 + (ulong)((byte)ch >> 5) * 4 + 8) =\n       (uVar1 & 0xfe6d2c77 | ~uVar1 & 0x192d388) ^ (uVar3 & 0xfe6d2c77 | ~uVar3 & 0x192d388);\n  pcVar2 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,(quoting_options *)local_38);\n  return pcVar2;\n}\n\n",
            "funcName": "quotearg_char"
        },
        {
            "funcStartAddr": "0x404630",
            "funcEndAddr": "0x404697",
            "decompiledFuncCode": "\nchar * quotearg_colon(char *arg)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  char *local_8;\n  \n  local_8 = default_quoting_options.right_quote;\n  local_38._32_4_ = default_quoting_options.quote_these_too[6];\n  local_38._36_4_ = default_quoting_options.quote_these_too[7];\n  local_38._40_4_ = default_quoting_options.left_quote._0_4_;\n  uStack_c = default_quoting_options.left_quote._4_4_;\n  local_38._16_4_ = default_quoting_options.quote_these_too[2];\n  local_38._20_4_ = default_quoting_options.quote_these_too[3];\n  local_38._24_4_ = default_quoting_options.quote_these_too[4];\n  local_38._28_4_ = default_quoting_options.quote_these_too[5];\n  local_38._0_4_ = default_quoting_options.style;\n  local_38._4_4_ = default_quoting_options.flags;\n  local_38._8_4_ = default_quoting_options.quote_these_too[0];\n  local_38._12_4_ =\n       default_quoting_options.quote_these_too[1] ^ 0x4000000 |\n       default_quoting_options.quote_these_too[1] & 0x4000000;\n  pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,(quoting_options *)local_38);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_colon"
        },
        {
            "funcStartAddr": "0x4046a0",
            "funcEndAddr": "0x404706",
            "decompiledFuncCode": "\nchar * quotearg_colon_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  undefined local_38 [44];\n  undefined4 uStack_c;\n  char *local_8;\n  \n  local_8 = default_quoting_options.right_quote;\n  local_38._32_4_ = default_quoting_options.quote_these_too[6];\n  local_38._36_4_ = default_quoting_options.quote_these_too[7];\n  local_38._40_4_ = default_quoting_options.left_quote._0_4_;\n  uStack_c = default_quoting_options.left_quote._4_4_;\n  local_38._16_4_ = default_quoting_options.quote_these_too[2];\n  local_38._20_4_ = default_quoting_options.quote_these_too[3];\n  local_38._24_4_ = default_quoting_options.quote_these_too[4];\n  local_38._28_4_ = default_quoting_options.quote_these_too[5];\n  local_38._0_4_ = default_quoting_options.style;\n  local_38._4_4_ = default_quoting_options.flags;\n  local_38._8_4_ = default_quoting_options.quote_these_too[0];\n  local_38._12_4_ =\n       default_quoting_options.quote_these_too[1] ^ 0x4000000 |\n       default_quoting_options.quote_these_too[1] & 0x4000000;\n  pcVar1 = quotearg_n_options(L'\\0',arg,argsize,(quoting_options *)local_38);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_colon_mem"
        },
        {
            "funcStartAddr": "0x404710",
            "funcEndAddr": "0x4047b7",
            "decompiledFuncCode": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * quotearg_n_style_colon(wchar_t n,quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  undefined local_78 [16];\n  undefined local_68 [16];\n  undefined local_58 [16];\n  undefined4 local_48;\n  undefined4 local_44;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  undefined4 uStack_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  undefined4 local_18;\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  local_58 = ZEXT816(0);\n  local_68 = ZEXT816(0);\n  local_78 = ZEXT816(0);\n  local_48 = 0;\n  if (s != custom_quoting_style) {\n    local_8 = 0;\n    local_18 = 0;\n    uStack_14 = 0;\n    uStack_10 = 0;\n    uStack_c = 0;\n    local_28 = 0;\n    uStack_24 = 0;\n    uStack_20 = 0;\n    uStack_1c = 0;\n    local_38 = 0;\n    uStack_34 = 0;\n    uStack_30 = 0;\n    uStack_2c = 0;\n    local_44 = 0;\n    local_58._0_12_ = ZEXT412(0) << 0x40;\n    local_48 = 0;\n    local_68._0_12_ = ZEXT412(0) << 0x40;\n    local_58._4_12_ = local_58._0_12_ >> 0x20 & (undefined  [12])0xffffffffffffffff;\n    local_58 = ZEXT1216(local_58._4_12_) << 0x20;\n    local_68._4_12_ = local_68._0_12_ >> 0x20 & (undefined  [12])0xffffffffffffffff;\n    local_68 = ZEXT1216(local_68._4_12_) << 0x20;\n    local_78 = CONCAT412(0x4000000,ZEXT412(s));\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,(quoting_options *)local_78);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_style_colon"
        },
        {
            "funcStartAddr": "0x4047c0",
            "funcEndAddr": "0x40483a",
            "decompiledFuncCode": "\nchar * quotearg_n_custom(wchar_t n,char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if (((right_quote != (char *)0x0) == (left_quote != (char *)0x0)) && (left_quote != (char *)0x0))\n  {\n    local_38.left_quote = left_quote;\n    local_38.right_quote = right_quote;\n    pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&local_38);\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "quotearg_n_custom"
        },
        {
            "funcStartAddr": "0x404840",
            "funcEndAddr": "0x4048b9",
            "decompiledFuncCode": "\nchar * quotearg_n_custom_mem(wchar_t n,char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if (right_quote == (char *)0x0 || left_quote == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_38.left_quote = left_quote;\n  local_38.right_quote = right_quote;\n  pcVar1 = quotearg_n_options(n,arg,argsize,&local_38);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_n_custom_mem"
        },
        {
            "funcStartAddr": "0x4048c0",
            "funcEndAddr": "0x40493e",
            "decompiledFuncCode": "\nchar * quotearg_custom(char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if (right_quote == (char *)0x0 || left_quote == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_38.left_quote = left_quote;\n  local_38.right_quote = right_quote;\n  pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&local_38);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_custom"
        },
        {
            "funcStartAddr": "0x404940",
            "funcEndAddr": "0x4049bb",
            "decompiledFuncCode": "\nchar * quotearg_custom_mem(char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  quoting_options local_38;\n  \n  local_38.right_quote = default_quoting_options.right_quote;\n  local_38.quote_these_too[6] = default_quoting_options.quote_these_too[6];\n  local_38.quote_these_too[7] = default_quoting_options.quote_these_too[7];\n  local_38.left_quote =\n       (char *)CONCAT44(default_quoting_options.left_quote._4_4_,\n                        default_quoting_options.left_quote._0_4_);\n  local_38.quote_these_too[2] = default_quoting_options.quote_these_too[2];\n  local_38.quote_these_too[3] = default_quoting_options.quote_these_too[3];\n  local_38.quote_these_too[4] = default_quoting_options.quote_these_too[4];\n  local_38.quote_these_too[5] = default_quoting_options.quote_these_too[5];\n  local_38.flags = default_quoting_options.flags;\n  local_38.quote_these_too[0] = default_quoting_options.quote_these_too[0];\n  local_38.quote_these_too[1] = default_quoting_options.quote_these_too[1];\n  local_38.style = custom_quoting_style;\n  if (right_quote == (char *)0x0 || left_quote == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_38.left_quote = left_quote;\n  local_38.right_quote = right_quote;\n  pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&local_38);\n  return pcVar1;\n}\n\n",
            "funcName": "quotearg_custom_mem"
        },
        {
            "funcStartAddr": "0x4049c0",
            "funcEndAddr": "0x4049ca",
            "decompiledFuncCode": "\nchar * quote_n_mem(wchar_t n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,argsize,&quote_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quote_n_mem"
        },
        {
            "funcStartAddr": "0x4049d0",
            "funcEndAddr": "0x4049e8",
            "decompiledFuncCode": "\nchar * quote_mem(char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,argsize,&quote_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quote_mem"
        },
        {
            "funcStartAddr": "0x4049f0",
            "funcEndAddr": "0x404a01",
            "decompiledFuncCode": "\nchar * quote_n(wchar_t n,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&quote_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quote_n"
        },
        {
            "funcStartAddr": "0x404a10",
            "funcEndAddr": "0x404a29",
            "decompiledFuncCode": "\nchar * quote(char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(L'\\0',arg,0xffffffffffffffff,&quote_quoting_options);\n  return pcVar1;\n}\n\n",
            "funcName": "quote"
        },
        {
            "funcStartAddr": "0x404a30",
            "funcEndAddr": "0x404b01",
            "decompiledFuncCode": "\nchar * gettext_quote(char *msgid,quoting_style s)\n\n{\n  char *pcVar1;\n  byte *pbVar2;\n  byte bVar3;\n  char *pcVar4;\n  bool bVar5;\n  \n  pcVar1 = (char *)dcgettext(0,msgid,5);\n  if (pcVar1 != msgid) {\n    return pcVar1;\n  }\n  pbVar2 = (byte *)locale_charset();\n  bVar3 = (*pbVar2 ^ 0x20) & *pbVar2;\n  if (bVar3 == 0x47) {\n    if (((((byte)(~pbVar2[1] | 0x20) == 0xbd) && (pbVar2[2] == 0x31)) && (pbVar2[3] == 0x38)) &&\n       (((pbVar2[4] == 0x30 && (pbVar2[5] == 0x33)) && ((pbVar2[6] == 0x30 && (pbVar2[7] == 0))))))\n    {\n      bVar5 = *msgid == '`';\n      pcVar4 = &DAT_00407982;\n      pcVar1 = &DAT_00407986;\n      goto LAB_00404ae7;\n    }\n  }\n  else if (((bVar3 == 0x55) && (((pbVar2[1] ^ 0x20) & pbVar2[1]) == 0x54)) &&\n          (((byte)(~pbVar2[2] | 0x20) == 0xb9 &&\n           (((pbVar2[3] == 0x2d && (pbVar2[4] == 0x38)) && (pbVar2[5] == 0)))))) {\n    bVar5 = *msgid == '`';\n    pcVar4 = &DAT_0040797a;\n    pcVar1 = &DAT_0040797e;\n    goto LAB_00404ae7;\n  }\n  bVar5 = s == clocale_quoting_style;\n  pcVar4 = \"\\\"\";\n  pcVar1 = \"\\'\";\nLAB_00404ae7:\n  if (bVar5) {\n    pcVar1 = pcVar4;\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "gettext_quote"
        },
        {
            "funcStartAddr": "0x404b10",
            "funcEndAddr": "0x404e68",
            "decompiledFuncCode": "\nvoid version_etc_arn(FILE *stream,char *command_name,char *package,char *version,char **authors,\n                    size_t n_authors)\n\n{\n  undefined8 uVar1;\n  char *__s;\n  \n  if (command_name == (char *)0x0) {\n    __fprintf_chk(stream,1,\"%s %s\\n\",package,version);\n  }\n  else {\n    __fprintf_chk(stream,1,\"%s (%s) %s\\n\",command_name,package);\n  }\n  uVar1 = dcgettext(0,&DAT_004079f3,5);\n  __fprintf_chk(stream,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e3);\n  __s = (char *)dcgettext(0,\n                          \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                          ,5);\n  fputs_unlocked(__s,(FILE *)stream);\n  switch(n_authors) {\n  case 0:\n    break;\n  case 1:\n    uVar1 = dcgettext(0,\"Written by %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors);\n    return;\n  case 2:\n    uVar1 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1]);\n    return;\n  case 3:\n    uVar1 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2]);\n    return;\n  case 4:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3]);\n    break;\n  case 5:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4]);\n    break;\n  case 6:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5]);\n    break;\n  case 7:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6]);\n    break;\n  case 8:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6],authors[7]);\n    break;\n  case 9:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6],authors[7],authors[8]);\n    break;\n  default:\n    uVar1 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\",5);\n    __fprintf_chk(stream,1,uVar1,*authors,authors[1],authors[2],authors[3],authors[4],authors[5],\n                  authors[6],authors[7],authors[8]);\n  }\n  return;\n}\n\n",
            "funcName": "version_etc_arn"
        },
        {
            "funcStartAddr": "0x404e70",
            "funcEndAddr": "0x404e94",
            "decompiledFuncCode": "\nvoid version_etc_ar(FILE *stream,char *command_name,char *package,char *version,char **authors)\n\n{\n  long lVar1;\n  size_t n_authors;\n  \n  n_authors = 0xffffffffffffffff;\n  do {\n    lVar1 = n_authors + 1;\n    n_authors = n_authors + 1;\n  } while (authors[lVar1] != (char *)0x0);\n  version_etc_arn(stream,command_name,package,version,authors,n_authors);\n  return;\n}\n\n",
            "funcName": "version_etc_ar"
        },
        {
            "funcStartAddr": "0x404ea0",
            "funcEndAddr": "0x405098",
            "decompiledFuncCode": "\nvoid version_etc_va(FILE *stream,char *command_name,char *package,char *version,\n                   __va_list_tag *authors)\n\n{\n  char **ppcVar1;\n  long *plVar2;\n  size_t n_authors;\n  uint uVar3;\n  char *authtab [10];\n  char *local_58;\n  long local_50;\n  long local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  long local_20;\n  long local_18;\n  long local_10;\n  \n  uVar3 = authors->gp_offset;\n  if ((ulong)(long)(int)uVar3 < 0x29) {\n    ppcVar1 = (char **)((long)(int)uVar3 + (long)authors->reg_save_area);\n    uVar3 = uVar3 + 8;\n    authors->gp_offset = uVar3;\n  }\n  else {\n    ppcVar1 = (char **)authors->overflow_arg_area;\n    authors->overflow_arg_area = ppcVar1 + 1;\n  }\n  local_58 = *ppcVar1;\n  if (local_58 == (char *)0x0) {\n    n_authors = 0;\n  }\n  else {\n    if (uVar3 < 0x29) {\n      plVar2 = (long *)((long)(int)uVar3 + (long)authors->reg_save_area);\n      uVar3 = uVar3 + 8;\n      authors->gp_offset = uVar3;\n    }\n    else {\n      plVar2 = (long *)authors->overflow_arg_area;\n      authors->overflow_arg_area = plVar2 + 1;\n    }\n    local_50 = *plVar2;\n    if (local_50 == 0) {\n      n_authors = 1;\n    }\n    else {\n      if (uVar3 < 0x29) {\n        plVar2 = (long *)((long)(int)uVar3 + (long)authors->reg_save_area);\n        uVar3 = uVar3 + 8;\n        authors->gp_offset = uVar3;\n      }\n      else {\n        plVar2 = (long *)authors->overflow_arg_area;\n        authors->overflow_arg_area = plVar2 + 1;\n      }\n      local_48 = *plVar2;\n      if (local_48 == 0) {\n        n_authors = 2;\n      }\n      else {\n        if (uVar3 < 0x29) {\n          plVar2 = (long *)((long)(int)uVar3 + (long)authors->reg_save_area);\n          uVar3 = uVar3 + 8;\n          authors->gp_offset = uVar3;\n        }\n        else {\n          plVar2 = (long *)authors->overflow_arg_area;\n          authors->overflow_arg_area = plVar2 + 1;\n        }\n        local_40 = *plVar2;\n        if (local_40 == 0) {\n          n_authors = 3;\n        }\n        else {\n          if (uVar3 < 0x29) {\n            plVar2 = (long *)((long)(int)uVar3 + (long)authors->reg_save_area);\n            uVar3 = uVar3 + 8;\n            authors->gp_offset = uVar3;\n          }\n          else {\n            plVar2 = (long *)authors->overflow_arg_area;\n            authors->overflow_arg_area = plVar2 + 1;\n          }\n          local_38 = *plVar2;\n          if (local_38 == 0) {\n            n_authors = 4;\n          }\n          else {\n            if (uVar3 < 0x29) {\n              plVar2 = (long *)((long)(int)uVar3 + (long)authors->reg_save_area);\n              authors->gp_offset = uVar3 + 8;\n            }\n            else {\n              plVar2 = (long *)authors->overflow_arg_area;\n              authors->overflow_arg_area = plVar2 + 1;\n            }\n            local_30 = *plVar2;\n            if (local_30 == 0) {\n              n_authors = 5;\n            }\n            else {\n              plVar2 = (long *)authors->overflow_arg_area;\n              authors->overflow_arg_area = plVar2 + 1;\n              local_28 = *plVar2;\n              if (local_28 == 0) {\n                n_authors = 6;\n              }\n              else {\n                plVar2 = (long *)authors->overflow_arg_area;\n                authors->overflow_arg_area = plVar2 + 1;\n                local_20 = *plVar2;\n                if (local_20 == 0) {\n                  n_authors = 7;\n                }\n                else {\n                  plVar2 = (long *)authors->overflow_arg_area;\n                  authors->overflow_arg_area = plVar2 + 1;\n                  local_18 = *plVar2;\n                  if (local_18 == 0) {\n                    n_authors = 8;\n                  }\n                  else {\n                    plVar2 = (long *)authors->overflow_arg_area;\n                    authors->overflow_arg_area = plVar2 + 1;\n                    local_10 = *plVar2;\n                    n_authors = 10 - (ulong)(local_10 == 0);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  version_etc_arn(stream,command_name,package,version,&local_58,n_authors);\n  return;\n}\n\n",
            "funcName": "version_etc_va"
        },
        {
            "funcStartAddr": "0x4050a0",
            "funcEndAddr": "0x405122",
            "decompiledFuncCode": "\nvoid version_etc(FILE *stream,char *command_name,char *package,char *version,...)\n\n{\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list authors;\n  __va_list_tag local_d8;\n  undefined local_b8 [32];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  local_d8.reg_save_area = local_b8;\n  local_d8.overflow_arg_area = &authors[0].overflow_arg_area;\n  local_d8.fp_offset = 0x30;\n  local_d8.gp_offset = 0x20;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  version_etc_va(stream,command_name,package,version,&local_d8);\n  return;\n}\n\n",
            "funcName": "version_etc"
        },
        {
            "funcStartAddr": "0x405130",
            "funcEndAddr": "0x4051a4",
            "decompiledFuncCode": "\nvoid emit_bug_reporting_address(void)\n\n{\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,stdout);\n  return;\n}\n\n",
            "funcName": "emit_bug_reporting_address"
        },
        {
            "funcStartAddr": "0x4051b0",
            "funcEndAddr": "0x4051f4",
            "decompiledFuncCode": "\nvoid * xnmalloc(size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if ((n <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0)) &&\n     (pvVar1 = malloc(s * n), pvVar1 != (void *)0x0 || s * n == 0)) {\n    return pvVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "xnmalloc"
        },
        {
            "funcStartAddr": "0x405200",
            "funcEndAddr": "0x405225",
            "decompiledFuncCode": "\nvoid * xmalloc(size_t n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(n);\n  if (((n != 0) == (pvVar1 == (void *)0x0)) && (n != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "xmalloc"
        },
        {
            "funcStartAddr": "0x405230",
            "funcEndAddr": "0x405292",
            "decompiledFuncCode": "\nvoid * xnrealloc(void *p,size_t n,size_t s)\n\n{\n  void *pvVar1;\n  size_t __size;\n  \n  if (n <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0)) {\n    __size = s * n;\n    if (((p != (void *)0x0) == (__size == 0)) && (p != (void *)0x0)) {\n      free(p);\n      return (void *)0x0;\n    }\n    pvVar1 = realloc(p,__size);\n    if (pvVar1 != (void *)0x0 || __size == 0) {\n      return pvVar1;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "xnrealloc"
        },
        {
            "funcStartAddr": "0x4052a0",
            "funcEndAddr": "0x4052f6",
            "decompiledFuncCode": "\nvoid * xrealloc(void *p,size_t n)\n\n{\n  void *pvVar1;\n  \n  if (n == 0 && p != (void *)0x0) {\n    free(p);\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    pvVar1 = realloc(p,n);\n    if (pvVar1 == (void *)0x0 && n != 0) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "xrealloc"
        },
        {
            "funcStartAddr": "0x405300",
            "funcEndAddr": "0x4053e5",
            "decompiledFuncCode": "\nvoid * x2nrealloc(void *p,size_t *pn,size_t s)\n\n{\n  void *pvVar1;\n  ulong uVar2;\n  size_t __size;\n  \n  uVar2 = *pn;\n  if (p == (void *)0x0) {\n    if (uVar2 == 0) {\n      uVar2 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(s),0) + (ulong)(0x80 < s);\n    }\n    if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0) < uVar2) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  else {\n    if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554)) / ZEXT816(s),0) <= uVar2)\n    goto LAB_004053db;\n    uVar2 = uVar2 + (uVar2 >> 1) + 1;\n  }\n  *pn = uVar2;\n  __size = s * uVar2;\n  if (__size == 0 && p != (void *)0x0) {\n    free(p);\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    pvVar1 = realloc(p,__size);\n    if (pvVar1 == (void *)0x0 && __size != 0) {\nLAB_004053db:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  return pvVar1;\n}\n\n",
            "funcName": "x2nrealloc"
        },
        {
            "funcStartAddr": "0x4053f0",
            "funcEndAddr": "0x405415",
            "decompiledFuncCode": "\nchar * xcharalloc(size_t n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)malloc(n);\n  if (((n != 0) == (pcVar1 == (char *)0x0)) && (n != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "xcharalloc"
        },
        {
            "funcStartAddr": "0x405420",
            "funcEndAddr": "0x405497",
            "decompiledFuncCode": "\nvoid * x2realloc(void *p,size_t *pn)\n\n{\n  ulong uVar1;\n  void *pvVar2;\n  size_t __size;\n  \n  uVar1 = *pn;\n  if (p == (void *)0x0) {\n    __size = 0x80;\n    if (uVar1 != 0) {\n      __size = uVar1;\n    }\n    if ((long)__size < 0) goto LAB_0040548d;\n    *pn = __size;\n  }\n  else {\n    if (0x5555555555555553 < uVar1) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    __size = uVar1 + 1 + (uVar1 >> 1);\n    *pn = __size;\n    if (__size == 0) {\n      free(p);\n      return (void *)0x0;\n    }\n  }\n  pvVar2 = realloc(p,__size);\n  if (((__size != 0) != (pvVar2 == (void *)0x0)) || (__size == 0)) {\n    return pvVar2;\n  }\nLAB_0040548d:\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "x2realloc"
        },
        {
            "funcStartAddr": "0x4054a0",
            "funcEndAddr": "0x4054e1",
            "decompiledFuncCode": "\nvoid * xzalloc(size_t s)\n\n{\n  void *__s;\n  \n  __s = malloc(s);\n  if (((s != 0) == (__s == (void *)0x0)) && (s != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  memset(__s,0,s);\n  return __s;\n}\n\n",
            "funcName": "xzalloc"
        },
        {
            "funcStartAddr": "0x4054f0",
            "funcEndAddr": "0x405516",
            "decompiledFuncCode": "\nvoid * xcalloc(size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (n <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x7fffffffffffffff)) / ZEXT816(s),0)) {\n    pvVar1 = rpl_calloc(n,s);\n    if (pvVar1 != (void *)0x0) {\n      return pvVar1;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
            "funcName": "xcalloc"
        },
        {
            "funcStartAddr": "0x405520",
            "funcEndAddr": "0x405567",
            "decompiledFuncCode": "\nvoid * xmemdup(void *p,size_t s)\n\n{\n  void *__dest;\n  \n  __dest = malloc(s);\n  if (((s != 0) == (__dest == (void *)0x0)) && (s != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  memcpy(__dest,p,s);\n  return __dest;\n}\n\n",
            "funcName": "xmemdup"
        },
        {
            "funcStartAddr": "0x405570",
            "funcEndAddr": "0x4055d5",
            "decompiledFuncCode": "\nchar * xstrdup(char *string)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  sVar1 = strlen(string);\n  sVar1 = sVar1 + 1;\n  __dest = (char *)malloc(sVar1);\n  if (((__dest == (char *)0x0) == (sVar1 != 0)) && (sVar1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  memcpy(__dest,string,sVar1);\n  return __dest;\n}\n\n",
            "funcName": "xstrdup"
        },
        {
            "funcStartAddr": "0x4055e0",
            "funcEndAddr": "0x405610",
            "decompiledFuncCode": "\nvoid xalloc_die(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = exit_failure;\n  uVar2 = dcgettext(0,\"memory exhausted\",5);\n  error(iVar1,0,\"%s\",uVar2);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "funcName": "xalloc_die"
        },
        {
            "funcStartAddr": "0x405610",
            "funcEndAddr": "0x4056e7",
            "decompiledFuncCode": "\nuintmax_t xnumtoumax(char *n_str,int base,uintmax_t min,uintmax_t max,char *suffixes,char *err,\n                    int err_exit)\n\n{\n  ulong uVar1;\n  strtol_error sVar2;\n  ulong in_RAX;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  int iVar6;\n  ulong local_38;\n  \n  local_38 = in_RAX;\n  sVar2 = xstrtoumax(n_str,(char **)0x0,base,&local_38,suffixes);\n  uVar1 = local_38;\n  if (sVar2 == LONGINT_OK) {\n    if ((min <= local_38 == local_38 <= max) && (min <= local_38 || local_38 <= max)) {\n      return local_38;\n    }\n    piVar3 = __errno_location();\n    iVar5 = 0x22;\n    if (0x3fffffff < uVar1) {\n      iVar5 = 0x4b;\n    }\n    *piVar3 = iVar5;\n  }\n  else if (sVar2 == LONGINT_OVERFLOW) {\n    piVar3 = __errno_location();\n    *piVar3 = 0x4b;\n  }\n  else if (sVar2 == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW) {\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n  }\n  else {\n    piVar3 = __errno_location();\n  }\n  iVar5 = 1;\n  if (err_exit != 0) {\n    iVar5 = err_exit;\n  }\n  iVar6 = *piVar3;\n  if (iVar6 == 0x16) {\n    iVar6 = 0;\n  }\n  pcVar4 = quote(n_str);\n  error(iVar5,iVar6,\"%s: %s\",err,pcVar4);\n  return local_38;\n}\n\n",
            "funcName": "xnumtoumax"
        },
        {
            "funcStartAddr": "0x4056f0",
            "funcEndAddr": "0x405713",
            "decompiledFuncCode": "\nuintmax_t xdectoumax(char *n_str,uintmax_t min,uintmax_t max,char *suffixes,char *err,int err_exit)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = xnumtoumax(n_str,10,min,max,suffixes,err,err_exit);\n  return uVar1;\n}\n\n",
            "funcName": "xdectoumax"
        },
        {
            "funcStartAddr": "0x405720",
            "funcEndAddr": "0x405e34",
            "decompiledFuncCode": "\nstrtol_error xstrtoumax(char *s,char **ptr,int strtol_base,uintmax_t *val,char *valid_suffixes)\n\n{\n  char cVar1;\n  char *pcVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  strtol_error sVar6;\n  int *piVar7;\n  ushort **ppuVar8;\n  uintmax_t uVar9;\n  char *pcVar10;\n  ulong uVar11;\n  byte bVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  byte *pbVar17;\n  byte bVar18;\n  strtol_error sVar19;\n  ulong uVar20;\n  char **ppcVar21;\n  ulong uVar22;\n  ulong uVar23;\n  ulong uVar24;\n  long lVar25;\n  uintmax_t uVar26;\n  int __c;\n  bool bVar27;\n  bool bVar28;\n  bool bVar29;\n  bool bVar30;\n  bool bVar31;\n  char *local_38;\n  \n  if (0x24 < (uint)strtol_base) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"../lib/xstrtol.c\",0x54,\n                  \"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\");\n  }\n  piVar7 = __errno_location();\n  *piVar7 = 0;\n  ppuVar8 = __ctype_b_loc();\n  pbVar17 = (byte *)s;\n  do {\n    bVar12 = *pbVar17;\n    pbVar17 = pbVar17 + 1;\n  } while ((((*ppuVar8)[bVar12] ^ 0xdfff) & (*ppuVar8)[bVar12]) != 0);\n  ppcVar21 = &local_38;\n  if (ptr != (char **)0x0) {\n    ppcVar21 = ptr;\n  }\n  if (bVar12 == 0x2d) {\n    return LONGINT_INVALID;\n  }\n  sVar19 = LONGINT_OK;\n  uVar9 = __strtoul_internal(s,ppcVar21,strtol_base,0);\n  pcVar2 = *ppcVar21;\n  if (pcVar2 == s) {\n    if (valid_suffixes == (char *)0x0) {\n      return LONGINT_INVALID;\n    }\n    if (*s == '\\0') {\n      return LONGINT_INVALID;\n    }\n    pcVar10 = strchr(valid_suffixes,(int)*s);\n    if (pcVar10 == (char *)0x0) {\n      return LONGINT_INVALID;\n    }\n    sVar19 = LONGINT_OK;\n    uVar26 = 1;\n  }\n  else {\n    if (*piVar7 != 0) {\n      if (*piVar7 != 0x22) {\n        return LONGINT_INVALID;\n      }\n      sVar19 = LONGINT_OVERFLOW;\n    }\n    uVar26 = uVar9;\n    if (valid_suffixes == (char *)0x0) goto LAB_00405dbe;\n  }\n  __c = (int)*pcVar2;\n  uVar9 = uVar26;\n  if (*pcVar2 == '\\0') goto LAB_00405dbe;\n  pcVar10 = strchr(valid_suffixes,__c);\n  if (pcVar10 == (char *)0x0) {\n    *val = uVar26;\n    return sVar19 | LONGINT_INVALID_SUFFIX_CHAR;\n  }\n  lVar25 = 1;\n  uVar22 = 0x400;\n  if ((__c - 0x45U < 0x30) && ((0x814400308945U >> ((ulong)(__c - 0x45U) & 0x3f) & 1) != 0)) {\n    pcVar10 = strchr(valid_suffixes,0x30);\n    if (pcVar10 == (char *)0x0) {\nLAB_004058b3:\n      lVar25 = 1;\n      uVar22 = 0x400;\n    }\n    else {\n      cVar1 = pcVar2[1];\n      if ((cVar1 == 'B') || (cVar1 == 'D')) {\n        lVar25 = 2;\n        uVar22 = 1000;\n      }\n      else {\n        if (cVar1 != 'i') goto LAB_004058b3;\n        lVar25 = (ulong)(pcVar2[2] == 'B') * 2 + 1;\n        uVar22 = 0x400;\n      }\n    }\n  }\n  sVar6 = LONGINT_OK;\n  switch(__c) {\n  case 0x42:\n    uVar22 = uVar26 >> 0x36;\n    uVar11 = uVar26 << 10;\n    goto LAB_00405deb;\n  default:\n    *val = uVar26;\n    return ~sVar19 & 0x422869bf ^ 0x422869bd;\n  case 0x45:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    if (uVar11 < uVar26) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    if (uVar11 < uVar23) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar24 = uVar20 * uVar22;\n    bVar27 = uVar20 <= uVar11;\n    if (!bVar27) {\n      uVar24 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar24 * uVar22;\n    bVar28 = uVar24 <= uVar11;\n    if (!bVar28) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar24 = uVar20 * uVar22;\n    bVar14 = uVar11 < uVar20;\n    if (bVar14) {\n      uVar24 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar24;\n    if (uVar11 < uVar24) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    bVar12 = ~(uVar11 < uVar23 && uVar11 < uVar26 || uVar11 < uVar23 != uVar11 < uVar26);\n    bVar12 = ((bVar12 | bVar27) ^ 1 | bVar27 ^ bVar12) ^ 1;\n    bVar12 = (bVar12 | bVar28) ^ 1 | bVar28 ^ bVar12;\n    bVar12 = bVar12 ^ bVar14 | bVar14 & bVar12;\n    bVar12 = ~(~bVar12 | uVar24 <= uVar11) | -(uVar11 < uVar24) ^ bVar12;\n    goto LAB_00405d8d;\n  case 0x47:\n  case 0x67:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    if (uVar11 < uVar26) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    if (uVar11 < uVar23) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar20;\n    if (uVar11 < uVar20) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    bVar12 = -(uVar11 < uVar23) & -(uVar11 < uVar26) | -(uVar11 < uVar23) ^ -(uVar11 < uVar26);\n    sVar6 = (strtol_error)((bVar12 & -(uVar11 < uVar20) | -(uVar11 < uVar20) ^ bVar12) & 1);\n    break;\n  case 0x4b:\n  case 0x6b:\n    uVar9 = uVar22 * uVar26;\n    bVar27 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0) < uVar26\n    ;\n    if (bVar27) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    sVar6 = -(uint)bVar27;\n    goto LAB_00405d90;\n  case 0x4d:\n  case 0x6d:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    bVar27 = uVar26 <= uVar11;\n    if (!bVar27) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar23;\n    bVar28 = uVar23 <= uVar11;\n    if (!bVar28) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    sVar6 = (strtol_error)(!bVar28 && !bVar27 || bVar28 != bVar27);\n    break;\n  case 0x50:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    if (uVar11 < uVar26) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    if (uVar11 < uVar23) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    bVar12 = ~(uVar11 < uVar23 && uVar11 < uVar26 || uVar11 < uVar23 != uVar11 < uVar26);\n    uVar23 = uVar20 * uVar22;\n    bVar4 = uVar20 <= uVar11;\n    if (!bVar4) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    bVar18 = bVar4 ^ bVar12;\n    goto LAB_00405d4f;\n  case 0x54:\n  case 0x74:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    if (uVar11 < uVar26) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    if (uVar11 < uVar23) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar24 = uVar20 * uVar22;\n    if (uVar11 < uVar20) {\n      uVar24 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar24;\n    if (uVar11 < uVar24) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    bVar27 = uVar11 < uVar23 && uVar11 < uVar26 || uVar11 < uVar23 != uVar11 < uVar26;\n    bVar27 = bVar27 && uVar11 < uVar20 || uVar11 < uVar20 != bVar27;\n    sVar6 = (strtol_error)(byte)(~(~bVar27 | uVar24 <= uVar11) | bVar27 ^ -(uVar11 < uVar24));\n    goto LAB_00405d90;\n  case 0x59:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    bVar27 = uVar26 <= uVar11;\n    if (!bVar27) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    bVar28 = uVar23 <= uVar11;\n    if (!bVar28) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar23 = uVar20 * uVar22;\n    bVar14 = uVar20 <= uVar11;\n    if (!bVar14) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    bVar29 = uVar11 < uVar23;\n    if (bVar29) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar23 = uVar20 * uVar22;\n    bVar15 = uVar20 <= uVar11;\n    if (!bVar15) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    bVar30 = uVar11 < uVar23;\n    if (bVar30) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar23 = uVar20 * uVar22;\n    bVar16 = uVar11 < uVar20;\n    if (bVar16) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar23;\n    if (uVar11 < uVar23) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    bVar4 = bVar14 != ((bVar28 || bVar27) && bVar28 == bVar27);\n    bVar31 = bVar28 != bVar27;\n    bVar13 = ((!bVar28 && !bVar27 || bVar31) && !bVar14 || bVar4) == bVar29;\n    bVar28 = bVar28;\n    bVar3 = bVar27;\n    bVar31 = !bVar31;\n    bVar27 = bVar14;\n    bVar4 = !bVar4;\n    bVar5 = bVar15 != (bVar13 && (!bVar29 || ((bVar28 || bVar3) && bVar31 || bVar27) && bVar4));\n    bVar13 = !bVar13;\n    bVar14 = bVar29;\n    bVar28 = !bVar28;\n    bVar3 = !bVar3;\n    bVar31 = !bVar31;\n    bVar27 = !bVar27;\n    bVar4 = !bVar4;\n    bVar15 = !bVar15;\n    bVar29 = bVar30 != ((bVar13 || bVar14 && ((bVar28 && bVar3 || bVar31) && bVar27 || bVar4)) &&\n                        bVar15 || bVar5);\n    bVar27 = (((bVar13 || bVar14 && ((bVar28 && bVar3 || bVar31) && bVar27 || bVar4)) && bVar15 ||\n              bVar5) && bVar30 || bVar29) && bVar16 ||\n             bVar16 != (((bVar13 || bVar14 && ((bVar28 && bVar3 || bVar31) && bVar27 || bVar4)) &&\n                         bVar15 || bVar5) && bVar30 || bVar29);\n    bVar12 = ~(~bVar27 | uVar23 <= uVar11) | -(uVar11 < uVar23) ^ bVar27;\n    goto LAB_00405d8d;\n  case 0x5a:\n    uVar11 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / ZEXT816(uVar22),0);\n    uVar23 = uVar26 * uVar22;\n    bVar27 = uVar26 <= uVar11;\n    if (!bVar27) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    uVar20 = uVar23 * uVar22;\n    bVar28 = uVar23 <= uVar11;\n    if (!bVar28) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    bVar14 = !bVar28 && !bVar27 || bVar28 != bVar27;\n    uVar23 = uVar20 * uVar22;\n    bVar29 = uVar11 < uVar20;\n    if (bVar29) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    bVar15 = bVar14 != bVar29;\n    bVar14 = bVar15 || bVar29 && bVar14;\n    uVar20 = uVar23 * uVar22;\n    bVar30 = uVar11 < uVar23;\n    if (bVar30) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    bVar16 = bVar14 != bVar30;\n    uVar23 = uVar20 * uVar22;\n    bVar31 = uVar11 < uVar20;\n    if (bVar31) {\n      uVar23 = 0xffffffffffffffff;\n    }\n    bVar4 = !bVar31;\n    bVar18 = bVar31 != (bVar16 || bVar30 && bVar14);\n    bVar12 = !bVar16 && (!bVar30 || !bVar15 && (!bVar29 || (bVar28 || bVar27) && bVar28 == bVar27));\nLAB_00405d4f:\n    bVar18 = (bVar12 | bVar4) ^ 1 | bVar18;\n    uVar20 = uVar23 * uVar22;\n    bVar27 = uVar11 < uVar23;\n    if (bVar27) {\n      uVar20 = 0xffffffffffffffff;\n    }\n    uVar9 = uVar22 * uVar20;\n    bVar28 = uVar20 <= uVar11;\n    if (!bVar28) {\n      uVar9 = 0xffffffffffffffff;\n    }\n    bVar12 = (bVar18 ^ bVar27 | bVar27 & bVar18) ^ 1;\n    bVar12 = ~(bVar12 | bVar28) | bVar28 ^ bVar12;\nLAB_00405d8d:\n    sVar6 = (strtol_error)bVar12;\nLAB_00405d90:\n    sVar6 = sVar6 & LONGINT_OVERFLOW;\n    break;\n  case 0x62:\n    uVar22 = uVar26 >> 0x37;\n    uVar11 = uVar26 << 9;\nLAB_00405deb:\n    sVar6 = (strtol_error)(uVar22 != 0);\n    uVar9 = uVar11 | ~-(ulong)(uVar22 == 0);\n    break;\n  case 99:\n    break;\n  case 0x77:\n    uVar9 = 0xffffffffffffffff;\n    if (-1 < (long)uVar26) {\n      uVar9 = uVar26 * 2;\n    }\n    sVar6 = (strtol_error)(uVar26 >> 0x3f);\n  }\n  sVar6 = sVar6 ^ sVar19 | sVar6 & sVar19;\n  *ppcVar21 = pcVar2 + lVar25;\n  sVar19 = sVar6 + LONGINT_INVALID_SUFFIX_CHAR;\n  if (pcVar2[lVar25] == '\\0') {\n    sVar19 = sVar6;\n  }\nLAB_00405dbe:\n  *val = uVar9;\n  return sVar19;\n}\n\n",
            "funcName": "xstrtoumax"
        },
        {
            "funcStartAddr": "0x405e40",
            "funcEndAddr": "0x405e99",
            "decompiledFuncCode": "\nvoid * rpl_calloc(size_t n,size_t s)\n\n{\n  size_t __size;\n  int *piVar1;\n  void *pvVar2;\n  size_t __nmemb;\n  \n  __size = 1;\n  if ((n | s) == 0) {\n    __nmemb = 1;\n  }\n  else {\n    __nmemb = 1;\n    if (((n == 0) == (s == 0)) && (__size = s, __nmemb = n, (s * n) / s != n)) {\n      piVar1 = __errno_location();\n      *piVar1 = 0xc;\n      return (void *)0x0;\n    }\n  }\n  pvVar2 = calloc(__nmemb,__size);\n  return pvVar2;\n}\n\n",
            "funcName": "rpl_calloc"
        },
        {
            "funcStartAddr": "0x405ea0",
            "funcEndAddr": "0x405f07",
            "decompiledFuncCode": "\nsize_t rpl_mbrtowc(wchar_t *pwc,char *s,size_t n,mbstate_t *ps)\n\n{\n  _Bool _Var1;\n  size_t sVar2;\n  wchar_t *__pwc;\n  wchar_t local_24;\n  \n  __pwc = &local_24;\n  if (pwc != (wchar_t *)0x0) {\n    __pwc = pwc;\n  }\n  sVar2 = mbrtowc(__pwc,s,n,(mbstate_t *)ps);\n  if ((0xfffffffffffffffd < sVar2 && n != 0) && (_Var1 = hard_locale(0), !_Var1)) {\n    *__pwc = (uint)(byte)*s;\n    sVar2 = 1;\n  }\n  return sVar2;\n}\n\n",
            "funcName": "rpl_mbrtowc"
        },
        {
            "funcStartAddr": "0x405f10",
            "funcEndAddr": "0x405f79",
            "decompiledFuncCode": "\nint close_stream(FILE *stream)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  int *piVar4;\n  int iVar5;\n  \n  lVar3 = __fpending();\n  uVar1 = stream->_flags;\n  iVar2 = rpl_fclose(stream);\n  if ((~uVar1 | 0xffffffdf) == 0xffffffff) {\n    iVar5 = -(uint)(iVar2 != 0);\n    if ((iVar2 != 0 || lVar3 == 0) && ((lVar3 != 0) == (iVar2 == 0))) {\n      piVar4 = __errno_location();\n      iVar5 = -1;\n      if (*piVar4 == 9) {\n        iVar5 = 0;\n      }\n    }\n  }\n  else {\n    iVar5 = -1;\n    if (iVar2 == 0) {\n      piVar4 = __errno_location();\n      *piVar4 = 0;\n    }\n  }\n  return iVar5;\n}\n\n",
            "funcName": "close_stream"
        },
        {
            "funcStartAddr": "0x405f80",
            "funcEndAddr": "0x405fc2",
            "decompiledFuncCode": "\n_Bool hard_locale(int category)\n\n{\n  int iVar1;\n  char *__s1;\n  _Bool _Var2;\n  \n  __s1 = setlocale(category,(char *)0x0);\n  _Var2 = true;\n  if (__s1 != (char *)0x0) {\n    iVar1 = strcmp(__s1,\"C\");\n    if ((iVar1 != 0) && (iVar1 = strcmp(__s1,\"POSIX\"), iVar1 != 0)) {\n      return true;\n    }\n    _Var2 = false;\n  }\n  return _Var2;\n}\n\n",
            "funcName": "hard_locale"
        },
        {
            "funcStartAddr": "0x405fd0",
            "funcEndAddr": "0x405ff5",
            "decompiledFuncCode": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar1 = nl_langinfo(0xe);\n  pcVar2 = \"\";\n  if (pcVar1 != (char *)0x0) {\n    pcVar2 = pcVar1;\n  }\n  pcVar1 = \"ASCII\";\n  if (*pcVar2 != '\\0') {\n    pcVar1 = pcVar2;\n  }\n  return pcVar1;\n}\n\n",
            "funcName": "locale_charset"
        },
        {
            "funcStartAddr": "0x406000",
            "funcEndAddr": "0x406074",
            "decompiledFuncCode": "\nint rpl_fclose(FILE *fp)\n\n{\n  int iVar1;\n  int iVar2;\n  __off_t _Var3;\n  int *piVar4;\n  \n  iVar1 = fileno((FILE *)fp);\n  if (-1 < iVar1) {\n    iVar1 = __freading(fp);\n    if (iVar1 != 0) {\n      iVar1 = fileno((FILE *)fp);\n      _Var3 = lseek(iVar1,0,1);\n      if (_Var3 == -1) goto LAB_00406068;\n    }\n    iVar1 = rpl_fflush(fp);\n    if (iVar1 != 0) {\n      piVar4 = __errno_location();\n      iVar1 = *piVar4;\n      iVar2 = fclose((FILE *)fp);\n      if (iVar1 != 0) {\n        *piVar4 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00406068:\n  iVar1 = fclose((FILE *)fp);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fclose"
        },
        {
            "funcStartAddr": "0x406080",
            "funcEndAddr": "0x4060bb",
            "decompiledFuncCode": "\nint rpl_fflush(FILE *stream)\n\n{\n  int iVar1;\n  \n  if (stream != (FILE *)0x0) {\n    iVar1 = __freading(stream);\n    if ((iVar1 != 0) && (((stream->_flags ^ 0xfffffeffU) & stream->_flags) != 0)) {\n      rpl_fseeko(stream,0,1);\n    }\n  }\n  iVar1 = fflush((FILE *)stream);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fflush"
        },
        {
            "funcStartAddr": "0x4060c0",
            "funcEndAddr": "0x40612d",
            "decompiledFuncCode": "\nint rpl_fseeko(FILE *fp,off_t offset,int whence)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((fp->_IO_read_end == fp->_IO_read_ptr) && (fp->_IO_write_ptr == fp->_IO_write_base)) &&\n     (fp->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno((FILE *)fp);\n    _Var2 = lseek(iVar1,offset,whence);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      *(byte *)&fp->_flags = *(byte *)&fp->_flags & 0xef;\n      fp->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko((FILE *)fp,offset,whence);\n  return iVar1;\n}\n\n",
            "funcName": "rpl_fseeko"
        },
        {
            "funcStartAddr": "0x4061b0",
            "funcEndAddr": "0x4061c2",
            "decompiledFuncCode": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n",
            "funcName": "atexit"
        }
    ],
    "decompilerName": "Ghidra",
    "binaryName": "nproc-amd64-clang-sub_O2",
    "isStripped": "True",
    "compilerName": "gcc",
    "optLevel": "-O"
}