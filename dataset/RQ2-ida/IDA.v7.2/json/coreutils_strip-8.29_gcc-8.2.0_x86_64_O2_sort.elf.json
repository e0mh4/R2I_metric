{
    "funcInfo": [
        {
            "decompiledFuncCode": "__int64 __usercall main@<rax>(char **a1@<rsi>, char **a2@<rdx>, unsigned int a3@<edi>, __int64 a4@<r12>)\n{\n  unsigned __int64 v4; // rbp\n  __int64 v5; // rbx\n  char *v6; // rax\n  char v7; // al\n  char v8; // r14\n  struct lconv *v9; // rax\n  char *v10; // rcx\n  char *v11; // rdx\n  const unsigned __int16 **v12; // r13\n  const __int32_t **v13; // rax\n  __int64 v14; // rdx\n  char v15; // si\n  __int64 v16; // rdi\n  int v17; // esi\n  const __int32_t *v18; // rcx\n  unsigned __int16 v19; // cx\n  unsigned __int16 v20; // dx\n  __int64 i; // r14\n  char *v22; // rax\n  char *v23; // rbx\n  size_t v24; // rax\n  size_t v25; // r15\n  __int64 v26; // rax\n  unsigned __int64 v27; // rdx\n  const unsigned __int16 *v28; // r11\n  unsigned __int8 *v29; // rdi\n  __int64 v30; // r8\n  _BYTE *v31; // rcx\n  __int64 v32; // rsi\n  _BYTE *v33; // r9\n  int v34; // er14\n  __int64 v35; // r13\n  int v36; // er14\n  __int64 v37; // r13\n  __m128i v38; // xmm1\n  char *v39; // rsi\n  _BOOL8 v40; // rdx\n  double v41; // xmm0_8\n  __int64 v42; // rdi\n  unsigned __int64 v43; // r15\n  __int64 v44; // r14\n  __int64 *v45; // r13\n  __int64 v46; // rax\n  _BYTE *v47; // rdx\n  int v48; // edx\n  __int64 v49; // rax\n  int v50; // eax\n  __int64 v51; // rcx\n  __int64 v52; // rsi\n  char v53; // dl\n  char v54; // al\n  int v55; // eax\n  __int64 v56; // rcx\n  int v57; // eax\n  char *v58; // rax\n  void **v59; // rdi\n  __int64 v60; // rcx\n  __int64 *v61; // rsi\n  __int64 v62; // rbx\n  unsigned __int64 v63; // rax\n  char v64; // al\n  unsigned __int64 v65; // r15\n  unsigned __int64 v66; // r13\n  __int64 v67; // rax\n  __int64 v68; // r14\n  __int64 v69; // rax\n  __int64 v70; // r13\n  const char *v71; // rax\n  const char *v72; // rax\n  __int64 v73; // r15\n  char *v74; // rax\n  char v75; // al\n  char *v76; // rax\n  int v77; // esi\n  __int64 v78; // rdx\n  char *v79; // rax\n  unsigned int v80; // eax\n  char *v81; // rax\n  const char *v82; // rdi\n  char *v83; // rdx\n  int v84; // eax\n  int v85; // eax\n  unsigned int v86; // er11\n  __int64 v87; // rbp\n  char *v88; // rax\n  char *v89; // rax\n  char *v90; // rdx\n  int v91; // eax\n  char *v92; // rdx\n  int v93; // eax\n  __int64 v94; // rcx\n  __int128 *v95; // rdi\n  _BYTE *v96; // rax\n  __int64 v97; // rdx\n  __int64 v98; // rcx\n  _BYTE *v99; // rax\n  __int64 v100; // rax\n  __int64 v101; // rdx\n  __int64 *v102; // rcx\n  const char *v103; // rdi\n  char *v104; // rdx\n  int v105; // eax\n  char *v106; // rdx\n  char *v107; // rdi\n  unsigned int v108; // eax\n  unsigned __int64 v109; // rax\n  char v110; // al\n  char v111; // r12\n  char *v112; // rax\n  char *v113; // rax\n  unsigned __int64 v114; // rax\n  FILE *v115; // r14\n  unsigned __int8 v116; // bl\n  __int64 v117; // rax\n  size_t v118; // r12\n  char *v119; // r15\n  char *v120; // rbp\n  char *v121; // rdi\n  size_t v122; // rdx\n  char *v123; // rax\n  void *v124; // rax\n  int v125; // eax\n  char v126; // bl\n  __int64 result; // rax\n  char *v128; // rax\n  __int64 v129; // rbp\n  char *v130; // rax\n  char *v131; // rax\n  _BYTE *v132; // rax\n  __int64 v133; // rcx\n  __int128 *v134; // rdi\n  _BYTE *v135; // rax\n  __int64 v136; // rcx\n  pthread_mutex_t *v137; // rax\n  _BYTE *v138; // rax\n  __int64 v139; // rcx\n  __int64 v140; // rdx\n  __int64 v141; // rax\n  const char *v142; // rsi\n  void *v143; // rbx\n  char *v144; // rax\n  const char **v145; // rbp\n  bool v146; // cf\n  bool v147; // zf\n  __int64 v148; // rbx\n  const char *v149; // rdx\n  __int64 v150; // rcx\n  char *v151; // rdi\n  __int64 v152; // rsi\n  int v153; // eax\n  __int64 v154; // rax\n  char *v155; // r15\n  unsigned __int64 v156; // r14\n  __int64 v157; // rax\n  __int64 v158; // r13\n  char v159; // r12\n  char *v160; // rbx\n  __int64 v161; // rbp\n  rlim_t v162; // rax\n  char *v163; // rax\n  char *v164; // rax\n  char *v165; // rax\n  __int64 v166; // rdx\n  unsigned __int64 v167; // rax\n  __int64 v168; // rsi\n  unsigned __int64 v169; // rcx\n  bool v170; // al\n  rlim_t v171; // r14\n  rlim_t v172; // r14\n  double v173; // xmm0_8\n  double v174; // xmm2_8\n  double v175; // xmm0_8\n  double v176; // xmm0_8\n  unsigned __int64 v177; // rax\n  int v178; // eax\n  __int64 v179; // rbp\n  char *v180; // rax\n  char *v181; // rax\n  __int64 v182; // rax\n  __int64 j; // rdx\n  _QWORD *v184; // rbx\n  _QWORD *v185; // rbp\n  _QWORD *v186; // rdx\n  __int64 v187; // rax\n  __int64 v188; // rax\n  __int64 v189; // rdx\n  __int64 *v190; // rcx\n  _BYTE *v191; // rax\n  __int64 v192; // rdx\n  __int64 v193; // rcx\n  __int64 v194; // rdx\n  char *v195; // rax\n  unsigned __int64 v196; // rax\n  __int64 v197; // rdx\n  double v198; // xmm1_8\n  __int64 v199; // rbx\n  char *v200; // rax\n  char *v201; // rax\n  char *v202; // rax\n  const char *v203; // rsi\n  const char *v204; // rbx\n  char *v205; // rax\n  char *v206; // rax\n  __int64 v207; // rbx\n  char *v208; // rax\n  char *v209; // rax\n  char *v210; // rax\n  char *v211; // rax\n  char *v212; // rax\n  __int64 v213; // rbp\n  char *v214; // rbx\n  char *v215; // rax\n  __int64 v216; // rbp\n  char *v217; // rax\n  char *v218; // rax\n  __int64 v219; // rbx\n  char *v220; // rax\n  FILE *v221; // rbx\n  char *v222; // rsi\n  rlim_t v223; // rbx\n  bool v224; // cf\n  bool v225; // zf\n  char *v226; // r8\n  _BYTE *v227; // rdx\n  __int64 v228; // rcx\n  char *v229; // rdi\n  _BYTE *v230; // rsi\n  __int64 v231; // rbx\n  char *v232; // rax\n  __int64 v233; // rbx\n  char *v234; // rax\n  __int64 v235; // rbx\n  char *v236; // rax\n  __int64 v237; // rbx\n  char *v238; // rax\n  FILE *stream; // [rsp+0h] [rbp-388h]\n  char *src; // [rsp+8h] [rbp-380h]\n  char *v241; // [rsp+10h] [rbp-378h]\n  char *v242; // [rsp+10h] [rbp-378h]\n  double v243; // [rsp+10h] [rbp-378h]\n  char *s1; // [rsp+18h] [rbp-370h]\n  char *s1b; // [rsp+18h] [rbp-370h]\n  char *s1a; // [rsp+18h] [rbp-370h]\n  char *file; // [rsp+20h] [rbp-368h]\n  char *v248; // [rsp+28h] [rbp-360h]\n  __int64 v249; // [rsp+30h] [rbp-358h]\n  __int64 v250; // [rsp+38h] [rbp-350h]\n  __int64 *v251; // [rsp+40h] [rbp-348h]\n  pthread_mutex_t *mutex; // [rsp+48h] [rbp-340h]\n  rlim_t v253; // [rsp+50h] [rbp-338h]\n  unsigned int v254; // [rsp+50h] [rbp-338h]\n  __int64 v255; // [rsp+58h] [rbp-330h]\n  char **v256; // [rsp+60h] [rbp-328h]\n  char *v257; // [rsp+68h] [rbp-320h]\n  char v258; // [rsp+70h] [rbp-318h]\n  struct rlimit v259; // [rsp+90h] [rbp-2F8h]\n  void *dest; // [rsp+C0h] [rbp-2C8h]\n  __int64 v261; // [rsp+C8h] [rbp-2C0h]\n  unsigned __int64 v262; // [rsp+D0h] [rbp-2B8h]\n  char *v263; // [rsp+D8h] [rbp-2B0h]\n  __int64 v264; // [rsp+E0h] [rbp-2A8h]\n  char v265; // [rsp+F0h] [rbp-298h]\n  __int128 v266; // [rsp+100h] [rbp-288h]\n  __int64 v267; // [rsp+110h] [rbp-278h]\n  __int64 v268; // [rsp+118h] [rbp-270h]\n  char v269; // [rsp+139h] [rbp-24Fh]\n  __int64 v270; // [rsp+150h] [rbp-238h]\n  __int128 v271; // [rsp+158h] [rbp-230h]\n  __int128 v272; // [rsp+168h] [rbp-220h]\n  __int128 v273; // [rsp+178h] [rbp-210h]\n  __int128 v274; // [rsp+188h] [rbp-200h]\n  void *ptr; // [rsp+1A0h] [rbp-1E8h]\n  char v276; // [rsp+1A8h] [rbp-1E0h]\n  __int64 v277; // [rsp+1B0h] [rbp-1D8h]\n  __int64 v278; // [rsp+1B8h] [rbp-1D0h]\n  __int64 v279; // [rsp+1C0h] [rbp-1C8h]\n  __int64 v280; // [rsp+1C8h] [rbp-1C0h]\n  pthread_cond_t cond; // [rsp+1D0h] [rbp-1B8h]\n  struct rlimit rlimits; // [rsp+230h] [rbp-158h]\n  __m128i v283; // [rsp+248h] [rbp-140h]\n  __m128i v284; // [rsp+258h] [rbp-130h]\n  __m128i v285; // [rsp+268h] [rbp-120h]\n  __m128i v286; // [rsp+278h] [rbp-110h]\n  __m128i v287; // [rsp+288h] [rbp-100h]\n  __m128i v288; // [rsp+298h] [rbp-F0h]\n  __m128i v289; // [rsp+2A8h] [rbp-E0h]\n  int v290; // [rsp+2B8h] [rbp-D0h]\n\n  v4 = (unsigned __int64)a1;\n  v5 = a3;\n  v6 = getenv(\"POSIXLY_CORRECT\");\n  v250 = (__int64)v6;\n  LOBYTE(a4) = v6 != 0LL;\n  LOBYTE(src) = (unsigned int)sub_40DBE0() - 200112 > 0x2B8;\n  sub_40DC60(*a1);\n  v248 = setlocale(6, \"\");\n  bindtextdomain(\n    \"coreutils\",\n    \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale\");\n  textdomain(\"coreutils\");\n  status = 2;\n  byte_61CBA1 = sub_40BD10(3LL);\n  v7 = sub_40BD10(2LL);\n  v8 = v7;\n  byte_61CBA0 = v7;\n  v9 = localeconv();\n  v10 = v9->decimal_point;\n  dword_61CBA8 = *(unsigned __int8 *)v9->decimal_point;\n  if ( !(_BYTE)dword_61CBA8 || v10[1] )\n    dword_61CBA8 = 46;\n  v11 = v9->thousands_sep;\n  dword_61CBA4 = (unsigned __int8)*v11;\n  if ( !(_BYTE)dword_61CBA4 || v11[1] )\n    dword_61CBA4 = -1;\n  byte_61C758 = 0;\n  v12 = __ctype_b_loc();\n  v13 = __ctype_toupper_loc();\n  v14 = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      v15 = 1;\n      v19 = (*v12)[v14];\n      if ( v19 & 1 )\n        break;\n      if ( v14 != 10 )\n      {\n        v15 = 0;\n        break;\n      }\n      v20 = (*v12)[10];\n      byte_61CA8A = 1;\n      byte_61C88A = 0;\n      byte_61C98A = ((v20 >> 14) ^ 1) & 1;\n      byte_61C78A = (*v13)[10];\n      v14 = 11LL;\n    }\n    byte_61CA80[v14] = v15;\n    v16 = v14;\n    byte_61C980[v14] = ((v19 >> 14) ^ 1) & 1;\n    v17 = 0;\n    if ( !(v19 & 8) )\n    {\n      LOBYTE(v17) = v14 == 10;\n      v17 = (v17 | v19 & 1) ^ 1;\n    }\n    v18 = *v13;\n    byte_61C880[v14++] = v17;\n    *(_BYTE *)(v14 + 6408063) = v18[v16];\n  }\n  while ( v14 != 256 );\n  if ( v8 )\n  {\n    LODWORD(stream) = v5;\n    for ( i = 1LL; i != 13; ++i )\n    {\n      v22 = nl_langinfo((int)i + 131085);\n      v23 = v22;\n      v24 = strlen(v22);\n      v25 = v24;\n      v26 = sub_411210(v24 + 1);\n      v27 = 4 * i;\n      qword_61C430[v27 / 2] = v26;\n      dword_61C438[v27] = i;\n      if ( v25 )\n      {\n        v28 = *v12;\n        v29 = (unsigned __int8 *)v23;\n        v30 = 0LL;\n        v31 = (_BYTE *)v26;\n        do\n        {\n          v32 = *v29;\n          v33 = v31;\n          if ( !(v28[v32] & 1) )\n          {\n            ++v30;\n            *v31 = byte_61C780[v32];\n            v31 = (_BYTE *)(v26 + v30);\n            v33 = (_BYTE *)(v26 + v30);\n          }\n          ++v29;\n        }\n        while ( &v23[v25] != (char *)v29 );\n      }\n      else\n      {\n        v33 = (_BYTE *)v26;\n      }\n      *v33 = 0;\n    }\n    v5 = (unsigned int)stream;\n    qsort(&off_61C440, 0xCuLL, 0x10uLL, compar);\n  }\n  v34 = 14;\n  v35 = 0LL;\n  sigemptyset(&set);\n  while ( 1 )\n  {\n    sigaction(v34, 0LL, (struct sigaction *)&rlimits);\n    if ( rlimits.rlim_cur != 1 )\n      sigaddset(&set, v34);\n    if ( ++v35 == 11 )\n      break;\n    v34 = dword_414980[v35];\n  }\n  rlimits.rlim_cur = (rlim_t)sub_405D80;\n  v36 = 14;\n  v290 = 0;\n  v37 = 0LL;\n  *(struct rlimit *)((char *)&rlimits + 8) = (struct rlimit)_mm_load_si128((const __m128i *)&set);\n  v38 = _mm_load_si128((const __m128i *)&set.__val[12]);\n  v283 = _mm_load_si128((const __m128i *)&set.__val[2]);\n  v284 = _mm_load_si128((const __m128i *)&set.__val[4]);\n  v285 = _mm_load_si128((const __m128i *)&set.__val[6]);\n  v286 = _mm_load_si128((const __m128i *)&set.__val[8]);\n  v287 = _mm_load_si128((const __m128i *)&set.__val[10]);\n  v288 = v38;\n  v289 = _mm_load_si128((const __m128i *)&set.__val[14]);\n  while ( 2 )\n  {\n    if ( !sigismember(&set, v36) )\n    {\n      if ( ++v37 == 11 )\n        break;\n      goto LABEL_31;\n    }\n    ++v37;\n    sigaction(v36, (const struct sigaction *)&rlimits, 0LL);\n    if ( v37 != 11 )\n    {\nLABEL_31:\n      v36 = dword_414980[v37];\n      continue;\n    }\n    break;\n  }\n  v39 = 0LL;\n  signal(17, 0LL);\n  sub_413F20(sub_407890);\n  v41 = 0.0;\n  *(_QWORD *)&v271 = 0LL;\n  v270 = -1LL;\n  *((_QWORD *)&v271 + 1) = -1LL;\n  v272 = 0LL;\n  v42 = 8LL * (int)v5;\n  v273 = 0LL;\n  v274 = 0LL;\n  if ( (int)v5 & 0x1000000000000000LL || (unsigned __int64)(int)v5 >> 61 != 0 )\n    goto LABEL_451;\n  v43 = 0LL;\n  LOBYTE(v249) = 0;\n  LODWORD(v44) = 0;\n  v45 = (__int64 *)sub_411210(v42);\n  LOBYTE(stream) = 0;\n  file = 0LL;\n  v241 = 0LL;\n  v253 = 0LL;\n  s1 = 0LL;\n  v251 = &v267;\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      while ( 2 )\n      {\n        LODWORD(v259.rlim_cur) = -1;\n        if ( (_DWORD)v44 == -1 )\n        {\nLABEL_46:\n          v46 = dword_61C57C;\nLABEL_43:\n          if ( (int)v5 > (int)v46 )\n          {\n            v48 = v46 + 1;\n            v49 = *(_QWORD *)(v4 + 8 * v46);\n            dword_61C57C = v48;\n            v45[v43++] = v49;\n            continue;\n          }\n          goto LABEL_434;\n        }\n        break;\n      }\n      if ( !v43 || !(_BYTE)a4 )\n      {\nLABEL_50:\n        v50 = sub_412F30((unsigned int)v5, v4, \"-bcCdfghik:mMno:rRsS:t:T:uVy:z\", off_414B40, &v259);\n        LODWORD(v44) = v50;\n        if ( v50 == -1 )\n          goto LABEL_46;\n        switch ( v50 + 131 )\n        {\n          case 0:\n            sub_4110D0((char)stdout);\n            exit(0);\n            return result;\n          case 1:\n            sub_40A0D0(0);\n            return result;\n          case 132:\n            v106 = nptr;\n            if ( *nptr != 43 )\n              goto LABEL_172;\n            if ( dword_61C57C == (_DWORD)v5 )\n            {\n              LODWORD(mutex) = 0;\n            }\n            else\n            {\n              v132 = *(_BYTE **)(v4 + 8LL * dword_61C57C);\n              LODWORD(mutex) = 0;\n              if ( *v132 == 45 )\n                LODWORD(mutex) = (unsigned int)((char)v132[1] - 48) <= 9;\n            }\n            LOBYTE(src) = (unsigned __int8)mutex & (v250 == 0) | (unsigned __int8)src;\n            if ( !(_BYTE)src )\n              goto LABEL_172;\n            v133 = 18LL;\n            v134 = &v266;\n            while ( v133 )\n            {\n              *(_DWORD *)v134 = 0;\n              v134 = (__int128 *)((char *)v134 + 4);\n              --v133;\n            }\n            v267 = -1LL;\n            v135 = (_BYTE *)sub_407C00(v106 + 1, &v266, 0LL);\n            v136 = -1LL;\n            if ( !v135 )\n            {\n              v106 = nptr;\n              if ( v266 == 0 )\n                *(_QWORD *)&v266 = -1LL;\n              goto LABEL_172;\n            }\n            if ( *v135 == 46 )\n            {\n              v135 = (_BYTE *)sub_407C00(v135 + 1, (char *)&v266 + 8, 0LL);\n              if ( v266 != 0 )\n              {\nLABEL_243:\n                if ( !v135 )\n                  goto LABEL_397;\n                goto LABEL_244;\n              }\n            }\n            else if ( v266 != 0 )\n            {\nLABEL_244:\n              if ( !*(_BYTE *)sub_405C00(v135, &v266, 0LL, v136) )\n              {\n                if ( (_DWORD)mutex )\n                {\n                  v137 = *(pthread_mutex_t **)(v4 + 8LL * dword_61C57C++);\n                  mutex = v137;\n                  v138 = (_BYTE *)sub_407C00((char *)&v137->__lock + 1, v251, \"invalid number after '-'\");\n                  if ( !v138 )\n                    __assert_fail(\"s\", \"src/sort.c\", 0x110Du, \"main\");\n                  if ( *v138 == 46 )\nLABEL_411:\n                    v138 = (_BYTE *)sub_407C00(v138 + 1, &v268, \"invalid number after '.'\");\n                  if ( !v268 && v267 )\n                    --v267;\n                  if ( *(_BYTE *)sub_405C00(v138, &v266, 1LL, v139) )\n                  {\n                    sub_405D30(mutex, \"stray character in field spec\");\nLABEL_429:\n                    sub_407DD0(src);\n                  }\n                }\n                v269 = 1;\n                v100 = sub_411410(&v266, 0x48uLL);\n                v140 = qword_61C750;\n                v102 = &qword_61C750;\n                while ( v140 )\n                {\n                  v102 = (__int64 *)(v140 + 64);\n                  v140 = *(_QWORD *)(v140 + 64);\n                }\nLABEL_223:\n                *v102 = v100;\n                *(_QWORD *)(v100 + 64) = 0LL;\n                continue;\n              }\nLABEL_397:\n              v106 = nptr;\nLABEL_172:\n              v45[v43++] = (__int64)v106;\n              continue;\n            }\n            *(_QWORD *)&v266 = -1LL;\n            goto LABEL_243;\n          case 198:\n          case 230:\n            goto LABEL_56;\n          case 208:\n          case 213:\n          case 217:\n          case 229:\n          case 231:\n          case 233:\n          case 234:\n          case 235:\n          case 236:\n          case 241:\n          case 245:\n            goto LABEL_53;\n          case 214:\n            v107 = nptr;\n            mutex = (pthread_mutex_t *)nptr;\n            LODWORD(v255) = v259.rlim_cur;\n            v108 = sub_411B40(nptr);\n            if ( !v108 )\n            {\n              if ( (unsigned int)(*(char *)(rlimits.rlim_cur - 1) - 48) <= 9 )\n              {\n                if ( (unsigned __int64)ptr > 0x3FFFFFFFFFFFFFLL )\n                  goto LABEL_381;\n                ptr = (void *)((_QWORD)ptr << 10);\n              }\n              goto LABEL_177;\n            }\n            if ( v108 != 2\n              || (unsigned int)(*(char *)(rlimits.rlim_cur - 1) - 48) > 9\n              || *(_BYTE *)(rlimits.rlim_cur + 1) )\n            {\n              goto LABEL_229;\n            }\n            if ( *(_BYTE *)rlimits.rlim_cur != 37 )\n            {\n              if ( *(_BYTE *)rlimits.rlim_cur != 98 )\n                goto LABEL_229;\n              goto LABEL_177;\n            }\n            sub_40D840(v107, &rlimits);\n            if ( (__int64)ptr < 0 )\n              v198 = (double)(int)((unsigned __int8)ptr & 1 | ((unsigned __int64)ptr >> 1))\n                   + (double)(int)((unsigned __int8)ptr & 1 | ((unsigned __int64)ptr >> 1));\n            else\n              v198 = (double)(int)ptr;\n            v41 = v41 * v198 / 100.0;\n            if ( v41 >= 1.844674407370955e19 )\n            {\nLABEL_381:\n              v108 = 1;\nLABEL_229:\n              sub_411AB0(v108, (unsigned int)v255, 83LL, off_414B40, mutex);\n            }\n            v38.m128i_i64[0] = 4890909195324358656LL;\n            if ( v41 < 9.223372036854776e18 )\n            {\n              ptr = (void *)(unsigned int)(int)v41;\n              goto LABEL_177;\n            }\n            goto LABEL_408;\n          case 215:\n            sub_40A010(nptr);\n            continue;\n          case 238:\n            v94 = 18LL;\n            v95 = &v266;\n            while ( v94 )\n            {\n              *(_DWORD *)v95 = 0;\n              v95 = (__int128 *)((char *)v95 + 4);\n              --v94;\n            }\n            v267 = -1LL;\n            v96 = (_BYTE *)sub_407C00(nptr, &v266, \"invalid number at field start\");\n            v97 = v266;\n            v98 = v266 - 1;\n            *(_QWORD *)&v266 = v266 - 1;\n            if ( !v97 )\n              goto LABEL_425;\n            if ( *v96 == 46 )\n            {\n              v96 = (_BYTE *)sub_407C00(v96 + 1, (char *)&v266 + 8, \"invalid number after '.'\");\n              v194 = *((_QWORD *)&v266 + 1);\n              v98 = --*((_QWORD *)&v266 + 1);\n              if ( !v194 )\n              {\n                sub_405D30(nptr, \"character offset is zero\");\n                goto LABEL_377;\n              }\n            }\n            if ( v266 == 0 )\n              *(_QWORD *)&v266 = -1LL;\n            v99 = (_BYTE *)sub_405C00(v96, &v266, 0LL, v98);\n            if ( *v99 == 44 )\n            {\n              v191 = (_BYTE *)sub_407C00(v99 + 1, v251, \"invalid number after ','\");\n              v192 = v267;\n              v193 = --v267;\n              if ( !v192 )\n                goto LABEL_425;\n              if ( *v191 == 46 )\n                v191 = (_BYTE *)sub_407C00(v191 + 1, &v268, \"invalid number after '.'\");\n              v99 = (_BYTE *)sub_405C00(v191, &v266, 1LL, v193);\n            }\n            else\n            {\n              v267 = -1LL;\n              v268 = 0LL;\n            }\n            if ( *v99 )\n            {\n              sub_405D30(nptr, \"stray character in field spec\");\n              start();\n            }\n            v100 = sub_411410(&v266, 0x48uLL);\n            v101 = qword_61C750;\n            v102 = &qword_61C750;\n            while ( v101 )\n            {\n              v102 = (__int64 *)(v101 + 64);\n              v101 = *(_QWORD *)(v101 + 64);\n            }\n            goto LABEL_223;\n          case 240:\n            LOBYTE(v249) = 1;\n            continue;\n          case 242:\n            v103 = file;\n            v104 = nptr;\n            if ( file )\n            {\n              file = nptr;\n              v105 = strcmp(v103, nptr);\n              v104 = file;\n              if ( v105 )\n                goto LABEL_421;\n            }\n            file = v104;\n            continue;\n          case 246:\n            byte_61C75A = 1;\n            continue;\n          case 247:\n            v93 = *nptr;\n            if ( !*nptr )\n            {\n              v202 = dcgettext(0LL, \"empty tab\", 5);\n              error(2, 0, v202);\n              goto LABEL_411;\n            }\n            if ( nptr[1] )\n            {\n              mutex = (pthread_mutex_t *)nptr;\n              if ( strcmp(nptr, \"\\\\0\") )\n              {\n                v207 = sub_40F880(mutex);\n                v208 = dcgettext(0LL, \"multi-character tab %s\", 5);\n                error(2, 0, v208, v207);\nLABEL_418:\n                v209 = dcgettext(0LL, \"incompatible tabs\", 5);\n                error(2, 0, v209);\nLABEL_419:\n                v210 = dcgettext(0LL, \"multiple random sources specified\", 5);\n                error(2, 0, v210);\nLABEL_420:\n                v211 = dcgettext(0LL, \"multiple compress programs specified\", 5);\n                error(2, 0, v211);\nLABEL_421:\n                v212 = dcgettext(0LL, \"multiple output files specified\", 5);\n                error(2, 0, v212);\nLABEL_422:\n                if ( !(_BYTE)stream )\n                  LOBYTE(stream) = 111;\n                byte_61C408 = (char)stream;\n                sub_405D00(&byte_61C408);\nLABEL_425:\n                sub_405D30(nptr, \"field number is zero\");\nLABEL_426:\n                sub_405D00(\"cC\");\nLABEL_427:\n                sub_407DD0(file);\n              }\n              v93 = 0;\n            }\n            if ( dword_61C424 != 128 && dword_61C424 != v93 )\n              goto LABEL_418;\n            dword_61C424 = v93;\n            continue;\n          case 248:\n            byte_61C759 = 1;\n            continue;\n          case 252:\n            v92 = nptr;\n            if ( *(char **)(v4 + 8LL * dword_61C57C - 8) == nptr )\n            {\n              while ( (unsigned int)(*v92 - 48) <= 9 )\n                ++v92;\n              dword_61C57C -= *v92 != 0;\n            }\n            continue;\n          case 253:\n            byte_61C500 = 0;\n            continue;\n          case 259:\n            LODWORD(v44) = 99;\n            if ( nptr )\n              LODWORD(v44) = byte_414B18[sub_40A910(\"--check\", nptr, off_414B20, byte_414B18, 1LL, off_61C510)];\nLABEL_56:\n            if ( (_BYTE)stream && (char)stream != (_DWORD)v44 )\n              goto LABEL_426;\n            LOBYTE(stream) = v44;\n            continue;\n          case 260:\n            v90 = nptr;\n            if ( ::s1 )\n            {\n              mutex = (pthread_mutex_t *)nptr;\n              v91 = strcmp(::s1, nptr);\n              v90 = (char *)mutex;\n              if ( v91 )\n                goto LABEL_420;\n            }\n            ::s1 = v90;\n            continue;\n          case 261:\n            byte_61C740 = 1;\n            continue;\n          case 262:\n            goto LABEL_133;\n          case 263:\n            v255 = (__int64)nptr;\n            LODWORD(v256) = v259.rlim_cur;\n            LODWORD(mutex) = sub_411B40(nptr);\n            v85 = getrlimit(RLIMIT_NOFILE, &rlimits);\n            v86 = 17;\n            if ( !v85 )\n              v86 = LODWORD(rlimits.rlim_cur) - 3;\n            if ( (_DWORD)mutex )\n            {\n              if ( (_DWORD)mutex != 1 )\n                sub_411AB0((unsigned int)mutex, (unsigned int)v256, 4294967172LL, off_414B40, v255);\n            }\n            else\n            {\n              dword_61C420 = (int)dest;\n              if ( dest == (void *)(unsigned int)dest )\n              {\n                if ( (unsigned int)dest <= 1 )\n                {\n                  v213 = sub_40F880(v255);\n                  v214 = off_414B40[4 * (int)v256];\n                  v215 = dcgettext(0LL, \"invalid --%s argument %s\", 5);\n                  error(0, 0, v215, v214, v213);\n                  v216 = sub_40F880(\"2\");\n                  v217 = dcgettext(0LL, \"minimum --%s argument is %s\", 5);\n                  error(2, 0, v217, v214, v216);\n                  goto LABEL_431;\n                }\n                if ( (unsigned int)dest <= v86 )\n                  continue;\n              }\n            }\n            LODWORD(stream) = v86;\n            v87 = sub_40F880(v255);\n            v5 = (__int64)off_414B40[4 * (int)v256];\n            v88 = dcgettext(0LL, \"--%s argument %s too large\", 5);\n            error(0, 0, v88, v5, v87);\n            v4 = sub_40D330((unsigned int)stream, &ptr);\n            v89 = dcgettext(0LL, \"maximum --%s argument with current rlimit is %s\", 5);\n            error(2, 0, v89, v5, v4);\nLABEL_133:\n            v241 = nptr;\n            continue;\n          case 264:\n            goto LABEL_123;\n          case 265:\n            LODWORD(v44) = aGhmnrv[sub_40A910(\"--sort\", nptr, off_414AE0, \"ghMnRV\", 1LL, off_61C510)];\nLABEL_53:\n            LOWORD(rlimits.rlim_cur) = (unsigned __int8)v44;\n            sub_405C00(&rlimits, &v270, 2LL, v51);\n            continue;\n          case 266:\n            mutex = (pthread_mutex_t *)nptr;\n            v254 = v259.rlim_cur;\n            v80 = sub_411680(nptr);\n            if ( v80 == 1 )\n            {\n              v253 = -1LL;\n            }\n            else\n            {\n              if ( v80 )\n                sub_411AB0(v80, v254, 4294967175LL, off_414B40, mutex);\n              v253 = rlimits.rlim_cur;\n              if ( !rlimits.rlim_cur )\n              {\n                v81 = dcgettext(0LL, \"number in parallel must be nonzero\", 5);\n                error(2, 0, v81);\nLABEL_123:\n                v82 = s1;\n                v83 = nptr;\n                if ( s1 )\n                {\n                  s1b = nptr;\n                  v84 = strcmp(v82, nptr);\n                  v83 = s1b;\n                  if ( v84 )\n                    goto LABEL_419;\n                }\n                s1 = v83;\n              }\n            }\n            continue;\n          default:\n            goto LABEL_406;\n        }\n      }\n      break;\n    }\n    v46 = dword_61C57C;\n    if ( (_BYTE)src != 1 || (_BYTE)stream )\n      goto LABEL_43;\n    if ( dword_61C57C != (_DWORD)v5 )\n    {\n      v47 = *(_BYTE **)(v4 + 8LL * dword_61C57C);\n      if ( *v47 != 45 || v47[1] != 111 || !v47[2] && dword_61C57C + 1 == (_DWORD)v5 )\n        goto LABEL_43;\n      goto LABEL_50;\n    }\n    if ( v241 )\n      goto LABEL_405;\n    LOBYTE(stream) = 0;\nLABEL_61:\n    if ( qword_61C750 )\n    {\n      v52 = qword_61C750;\n      LODWORD(v5) = 0;\n      do\n      {\n        while ( (unsigned __int8)sub_405AF0(v52) && !*(_BYTE *)(v52 + 55) )\n        {\n          v53 = HIBYTE(v273);\n          *(_QWORD *)(v52 + 32) = *((_QWORD *)&v272 + 1);\n          *(_QWORD *)(v52 + 40) = v273;\n          *(_WORD *)(v52 + 48) = WORD4(v273);\n          *(_BYTE *)(v52 + 54) = BYTE14(v273);\n          *(_BYTE *)(v52 + 50) = BYTE10(v273);\n          *(_WORD *)(v52 + 52) = WORD6(v273);\n          v54 = v274;\n          *(_BYTE *)(v52 + 55) = v53;\n          *(_BYTE *)(v52 + 56) = v54;\n          v55 = BYTE11(v273);\n          *(_BYTE *)(v52 + 51) = BYTE11(v273);\n          v52 = *(_QWORD *)(v52 + 64);\n          v5 = v55 | (unsigned int)v5;\n          if ( !v52 )\n            goto LABEL_67;\n        }\n        v57 = *(unsigned __int8 *)(v52 + 51);\n        v52 = *(_QWORD *)(v52 + 64);\n        v5 = v57 | (unsigned int)v5;\n      }\n      while ( v52 );\nLABEL_67:\n      a4 = 0LL;\nLABEL_68:\n      if ( (unsigned __int8)((*(_QWORD *)(v56 + 32) != 0LL) | *(_BYTE *)(v56 + 56) | *(_BYTE *)(v56 + 51))\n         + *(unsigned __int8 *)(v56 + 54)\n         + *(unsigned __int8 *)(v56 + 53)\n         + *(unsigned __int8 *)(v56 + 52)\n         + *(unsigned __int8 *)(v56 + 50) > 1 )\n      {\nLABEL_407:\n        *(_BYTE *)(v56 + 55) = 0;\n        *(_WORD *)(v56 + 48) = 0;\n        sub_405B50(v56, &ptr);\n        v41 = sub_405D00(&ptr);\nLABEL_408:\n        v41 = v41 - *(double *)v38.m128i_i8;\n        ptr = (void *)(unsigned int)(int)v41;\n        ptr = (void *)((unsigned __int64)ptr ^ 0x8000000000000000LL);\nLABEL_177:\n        if ( (unsigned __int64)ptr >= qword_61C778 )\n        {\n          v109 = 34LL * (unsigned int)dword_61C420;\n          if ( v109 < (unsigned __int64)ptr )\n            v109 = (unsigned __int64)ptr;\n          qword_61C778 = v109;\n        }\n        continue;\n      }\n      while ( 1 )\n      {\n        v56 = *(_QWORD *)(v56 + 64);\n        if ( !v56 )\n          break;\n        if ( *(unsigned __int8 *)(v56 + 53)\n           + *(unsigned __int8 *)(v56 + 52)\n           + *(unsigned __int8 *)(v56 + 50)\n           + *(unsigned __int8 *)(v56 + 54)\n           + (unsigned __int8)((*(_QWORD *)(v56 + 32) != 0LL) | *(_BYTE *)(v56 + 51) | *(_BYTE *)(v56 + 56)) > 1 )\n          goto LABEL_407;\n      }\nLABEL_72:\n      if ( byte_61C740 )\n      {\nLABEL_73:\n        if ( (_BYTE)stream || file )\n          goto LABEL_422;\n        if ( !v248 || !setlocale(3, \"\") )\n        {\n          v131 = dcgettext(0LL, \"failed to set locale\", 5);\n          error(0, 0, \"%s\", v131);\n        }\n        if ( byte_61CBA1 )\n        {\n          v128 = setlocale(3, 0LL);\n          v129 = sub_40F880(v128);\n          v130 = dcgettext(0LL, \"using %s sorting rules\", 5);\n          error(0, 0, v130, v129);\n        }\n        else\n        {\n          v58 = dcgettext(0LL, \"using simple byte comparison\", 5);\n          error(0, 0, \"%s\", v58);\n        }\n        v44 = qword_61C750;\n        v59 = &ptr;\n        v60 = 18LL;\n        v61 = &v270;\n        src = (char *)&ptr;\n        v4 = 1LL;\n        while ( v60 )\n        {\n          *(_DWORD *)v59 = *(_DWORD *)v61;\n          v61 = (__int64 *)((char *)v61 + 4);\n          v59 = (void **)((char *)v59 + 4);\n          --v60;\n        }\n        if ( v44 )\n        {\n          LOBYTE(mutex) = v5;\n          v62 = v44;\n          v248 = (char *)&v259.rlim_cur + 1;\n          v250 = v43;\n          v251 = v45;\n          while ( 1 )\n          {\n            v65 = *(_QWORD *)v62;\n            v66 = *(_QWORD *)(v62 + 16);\n            if ( *(_BYTE *)(v62 + 57) )\n            {\n              if ( v65 == -1LL )\n                v65 = 0LL;\n              v67 = sub_40D370(v65, &v258);\n              LOBYTE(v259.rlim_cur) = 43;\n              v68 = __stpcpy_chk((char *)&v259.rlim_cur + 1, v67, 45LL);\n              v69 = sub_40D370(v65 + 1, &v258);\n              LODWORD(dest) = 2124589;\n              v241 = (char *)__stpcpy_chk((char *)&dest + 3, v69, 44LL);\n              if ( *(_QWORD *)(v62 + 16) != -1LL )\n              {\n                v70 = v66 + 1;\n                v71 = (const char *)sub_40D370(v70, &v258);\n                *(_WORD *)v68 = 11552;\n                strcpy((char *)(v68 + 2), v71);\n                v72 = (const char *)sub_40D370(v70 + (*(_QWORD *)(v62 + 24) == -1LL), &v258);\n                *v241 = 44;\n                strcpy(v241 + 1, v72);\n              }\n              v44 = sub_40F860(1LL, &dest);\n              v73 = sub_40F860(0LL, &v259);\n              v74 = dcgettext(0LL, \"obsolescent key %s used; consider %s instead\", 5);\n              error(0, 0, v74, v73, v44);\n              v65 = *(_QWORD *)v62;\n              v66 = *(_QWORD *)(v62 + 16);\n            }\n            v75 = a4;\n            if ( v65 != -1LL && v66 < v65 )\n            {\n              v76 = dcgettext(0LL, \"key %lu has zero width and will be ignored\", 5);\n              error(0, 0, v76, v4);\n              v66 = *(_QWORD *)(v62 + 16);\n              v75 = 1;\n            }\n            v77 = 1;\n            v78 = *(_QWORD *)(v62 + 48) & 0xFFFF00FF0000LL;\n            if ( !v78 )\n              v77 = *(unsigned __int8 *)(v62 + 54);\n            if ( v66 || !*(_QWORD *)(v62 + 24) )\n            {\n              if ( !v75 )\n              {\n                if ( dword_61C424 == 128\n                  && (!*(_BYTE *)(v62 + 48) && (!v77 || *(_QWORD *)(v62 + 8))\n                   || !*(_BYTE *)(v62 + 49) && *(_QWORD *)(v62 + 24)) )\n                {\n                  v79 = dcgettext(0LL, \"leading blanks are significant in key %lu; consider also specifying 'b'\", 5);\n                  error(0, 0, v79, v4);\n                  v78 = *(_QWORD *)(v62 + 48) & 0xFFFF00FF0000LL;\n                }\nLABEL_86:\n                if ( v78 )\n                {\n                  v63 = *(_QWORD *)v62 + 1LL;\n                  if ( *(_QWORD *)v62 == -1LL )\n                    v63 = 1LL;\n                  if ( *(_QWORD *)(v62 + 16) == -1LL || *(_QWORD *)(v62 + 16) + 1LL > v63 )\n                  {\n                    v144 = dcgettext(0LL, \"key %lu is numeric and spans multiple fields\", 5);\n                    error(0, 0, v144, v4);\n                  }\n                }\n                goto LABEL_91;\n              }\n            }\n            else if ( !v75 )\n            {\n              goto LABEL_86;\n            }\n            if ( !(_BYTE)a4 )\n              goto LABEL_86;\nLABEL_91:\n            if ( v279 && v279 == *(_QWORD *)(v62 + 32) )\n              v279 = 0LL;\n            if ( v280 && v280 == *(_QWORD *)(v62 + 40) )\n              v280 = 0LL;\n            ++v4;\n            cond.__size[0] &= *(_BYTE *)(v62 + 48) ^ 1;\n            cond.__size[1] &= *(_BYTE *)(v62 + 49) ^ 1;\n            cond.__size[6] &= *(_BYTE *)(v62 + 54) ^ 1;\n            cond.__size[2] &= *(_BYTE *)(v62 + 50) ^ 1;\n            cond.__size[4] &= *(_BYTE *)(v62 + 52) ^ 1;\n            cond.__size[5] &= *(_BYTE *)(v62 + 53) ^ 1;\n            cond.__size[3] &= *(_BYTE *)(v62 + 51) ^ 1;\n            cond.__size[8] &= *(_BYTE *)(v62 + 56) ^ 1;\n            v64 = *(_BYTE *)(v62 + 55);\n            v62 = *(_QWORD *)(v62 + 64);\n            cond.__size[7] &= v64 ^ 1;\n            if ( !v62 )\n            {\n              v43 = v250;\n              v45 = v251;\n              LOBYTE(v5) = (_BYTE)mutex;\n              break;\n            }\n          }\n        }\n        v110 = sub_405AF0(&ptr);\n        v111 = cond.__size[7];\n        if ( v110 )\n        {\n          if ( cond.__size[7] )\n          {\n            if ( byte_61C75A )\n            {\n              if ( qword_61C750 )\n              {\n                v4 = (unsigned __int64)&dest;\n                sub_405B50(&ptr, &dest);\n                v195 = dcngettext(\n                         0LL,\n                         \"option '-%s' is ignored\",\n                         \"options '-%s' are ignored\",\n                         strlen((const char *)&dest),\n                         5);\n                error(0, 0, v195, &dest);\n                cond.__size[7] = 1;\n                goto LABEL_187;\n              }\n            }\n            else\n            {\n              if ( byte_61C759 && qword_61C750 )\n              {\n                v4 = (unsigned __int64)&dest;\n                sub_405B50(&ptr, &dest);\n                v164 = dcngettext(\n                         0LL,\n                         \"option '-%s' is ignored\",\n                         \"options '-%s' are ignored\",\n                         strlen((const char *)&dest),\n                         5);\n                error(0, 0, v164, &dest);\n                cond.__size[7] = v111;\n                goto LABEL_187;\n              }\nLABEL_188:\n              if ( !byte_61C759 && qword_61C750 )\n              {\n                v113 = dcgettext(0LL, \"option '-r' only applies to last-resort comparison\", 5);\n                error(0, 0, v113);\n              }\n            }\n          }\n        }\n        else\n        {\n          if ( !byte_61C75A && !byte_61C759 )\n            cond.__size[7] = 0;\n          v4 = (unsigned __int64)&dest;\n          sub_405B50(&ptr, &dest);\n          v112 = dcngettext(0LL, \"option '-%s' is ignored\", \"options '-%s' are ignored\", strlen((const char *)&dest), 5);\n          error(0, 0, v112, &dest);\n          cond.__size[7] = v111;\n          if ( v111 )\n          {\nLABEL_187:\n            if ( !byte_61C75A )\n              goto LABEL_188;\n          }\n        }\n      }\n      byte_61C75B = HIBYTE(v273);\n      if ( (_BYTE)v5 )\n      {\n        v141 = sub_40F900(s1, 16LL);\n        v142 = \"open failed\";\n        v143 = (void *)v141;\n        if ( !v141 )\n          goto LABEL_416;\n        src = (char *)&ptr;\n        sub_40FC10(v141, &ptr, 16LL);\n        if ( (unsigned int)sub_40FD70(v143) )\n        {\n          v142 = \"close failed\";\nLABEL_416:\n          v206 = dcgettext(0LL, v142, 5);\n          sub_405DD0(v206, s1);\n        }\n        sub_40AA90(&xmmword_61C600);\n        sub_40B360(&ptr, 0x10uLL);\n      }\n    }\n    else\n    {\n      if ( !(unsigned __int8)sub_405AF0(&v270) )\n      {\n        v188 = sub_411410(&v270, 0x48uLL);\n        v189 = qword_61C750;\n        v190 = &qword_61C750;\n        while ( v189 )\n        {\n          v190 = (__int64 *)(v189 + 64);\n          v189 = *(_QWORD *)(v189 + 64);\n        }\n        *v190 = v188;\n        v56 = qword_61C750;\n        a4 = 1LL;\n        *(_QWORD *)(v188 + 64) = 0LL;\n        v5 = BYTE11(v273);\n        if ( v56 )\n          goto LABEL_68;\n        goto LABEL_72;\n      }\n      if ( byte_61C740 )\n      {\n        LOBYTE(a4) = 0;\n        LOBYTE(v5) = 0;\n        goto LABEL_73;\n      }\n      byte_61C75B = HIBYTE(v273);\n    }\n    break;\n  }\n  if ( !qword_61C768 )\n  {\n    v163 = getenv(\"TMPDIR\");\n    if ( !v163 )\n      v163 = \"/tmp\";\n    sub_40A010(v163);\n  }\n  if ( !v43 )\n  {\n    v43 = 1LL;\n    free(v45);\n    v45 = (__int64 *)sub_411210(8LL);\n    *v45 = (__int64)\"-\";\n  }\n  if ( qword_61C778 )\n  {\n    v114 = 34LL * (unsigned int)dword_61C420;\n    if ( v114 < qword_61C778 )\n      v114 = qword_61C778;\n    qword_61C778 = v114;\n  }\n  if ( (_BYTE)stream )\n  {\n    if ( v43 <= 1 )\n    {\n      if ( file )\n      {\n        byte_61C400 = (char)stream;\n        sub_405D00(&byte_61C400);\n      }\n      else\n      {\n        v45 = (__int64 *)*v45;\n        v115 = (FILE *)sub_407CD0((char *)v45, \"r\");\n        if ( v115 )\n        {\n          s1a = (char *)qword_61C750;\n          v116 = byte_61C759 ^ 1;\n          v117 = qword_61C428;\n          if ( qword_61C778 >= (unsigned __int64)qword_61C428 )\n            v117 = qword_61C778;\n          v118 = 0LL;\n          sub_405E30(&ptr, 32LL, v117);\n          dest = 0LL;\n          v242 = 0LL;\n          while ( 1 )\n          {\n            if ( !(unsigned __int8)sub_4074D0(&ptr, v115, v45) )\n            {\n              v126 = 1;\n              goto LABEL_221;\n            }\n            v119 = (char *)ptr + v278 - 32;\n            v120 = (char *)ptr + v278 + -32 * v277;\n            if ( v118 )\n            {\n              v125 = sub_4082A0(&dest, (char *)ptr + v278 - 32);\n              if ( v116 <= v125 )\n                break;\n            }\n            while ( 1 )\n            {\n              v121 = v119;\n              if ( v120 >= v119 )\n                break;\n              v119 -= 32;\n              if ( v116 <= (int)sub_4082A0(v121, v119) )\n                goto LABEL_219;\n            }\n            v122 = *((_QWORD *)v119 + 1);\n            v242 += v277;\n            if ( v118 < v122 )\n            {\n              while ( 1 )\n              {\n                v118 *= 2LL;\n                if ( !v118 )\n                  break;\n                if ( v122 <= v118 )\n                  goto LABEL_217;\n              }\n              v118 = *((_QWORD *)v119 + 1);\nLABEL_217:\n              free(dest);\n              v124 = (void *)sub_411210(v118);\n              v122 = *((_QWORD *)v119 + 1);\n              dest = v124;\n            }\n            memcpy(dest, *(const void **)v119, v122);\n            v261 = *((_QWORD *)v119 + 1);\n            if ( s1a )\n            {\n              v123 = (char *)dest + *((_QWORD *)v119 + 3) - *(_QWORD *)v119;\n              v262 = (unsigned __int64)dest + *((_QWORD *)v119 + 2) - *(_QWORD *)v119;\n              v263 = v123;\n            }\n          }\nLABEL_219:\n          v126 = 0;\n          if ( (_BYTE)stream == 99 )\n          {\n            sub_40D370(&v242[((_BYTE *)ptr + v278 - v119) >> 5], &v259);\n            v179 = qword_61CBC8;\n            v180 = dcgettext(0LL, \"%s: %s:%s: disorder: \", 5);\n            __fprintf_chk(stderr, 1LL, v180, v179);\n            v181 = dcgettext(0LL, \"standard error\", 5);\n            sub_407E70(v119, stderr, v181);\n          }\nLABEL_221:\n          sub_407DF0(v115);\n          free(ptr);\n          free(dest);\n          return (unsigned __int8)v126 ^ 1u;\n        }\n      }\n      sub_407DD0(v45);\n    }\n    v219 = sub_40F630(4LL, v45[1]);\n    v220 = dcgettext(0LL, \"extra operand %s not allowed with -%c\", 5);\n    error(2, 0, v220, v219, (unsigned int)(char)stream);\nLABEL_434:\n    if ( v241 )\n    {\n      if ( v43 )\n      {\nLABEL_405:\n        v199 = sub_40F630(4LL, *v45);\n        v200 = dcgettext(0LL, \"extra operand %s\", 5);\n        error(0, 0, v200, v199);\n        v201 = dcgettext(0LL, \"file operands cannot be combined with --files0-from\", 5);\n        __fprintf_chk(stderr, 1LL, \"%s\\n\", v201);\nLABEL_406:\n        sub_40A0D0(2);\n      }\n      v221 = (FILE *)sub_407CD0(v241, \"r\");\n      if ( !v221 )\nLABEL_448:\n        sub_407DD0(v241);\n      sub_4103A0(&rlimits);\n      v222 = v241;\n      if ( (unsigned __int8)sub_410440(v221) )\n      {\n        sub_407DF0(v221);\n        v223 = rlimits.rlim_cur;\n        if ( rlimits.rlim_cur )\n        {\n          free(v45);\n          v45 = (__int64 *)rlimits.rlim_max;\n          v226 = \"-\";\n          while ( 1 )\n          {\n            v227 = *(_BYTE **)(rlimits.rlim_max + 8 * v43);\n            v228 = 2LL;\n            v229 = \"-\";\n            v230 = *(_BYTE **)(rlimits.rlim_max + 8 * v43);\n            do\n            {\n              if ( !v228 )\n                break;\n              v224 = *v230 < (unsigned __int8)*v229;\n              v225 = *v230++ == *v229++;\n              --v228;\n            }\n            while ( v225 );\n            if ( (!v224 && !v225) == v224 )\n              break;\n            ++v43;\n            if ( !*v227 )\n              goto LABEL_447;\n            v224 = v223 < v43;\n            v225 = v223 == v43;\n            if ( v223 == v43 )\n              goto LABEL_61;\n          }\n          v231 = sub_40F630(4LL, *(_QWORD *)(rlimits.rlim_max + 8 * v43));\n          v232 = dcgettext(0LL, \"when reading file names from stdin, no file name of %s allowed\", 5);\n          error(2, 0, v232, v231);\nLABEL_447:\n          v233 = sub_40F700(0LL, 3LL, v241, v228, v226);\n          v234 = dcgettext(0LL, \"%s:%lu: invalid zero-length file name\", 5);\n          error(2, 0, v234, v233, v43);\n          goto LABEL_448;\n        }\n        v235 = sub_40F630(4LL, v241);\n        v236 = dcgettext(0LL, \"no input from %s\", 5);\n        v222 = 0LL;\n        error(2, 0, v236, v235);\n      }\n      v237 = sub_40F630(4LL, v222);\n      v238 = dcgettext(0LL, \"cannot read file names from %s\", 5);\n      v39 = 0LL;\n      v42 = 2LL;\n      error(2, 0, v238, v237);\nLABEL_451:\n      sub_411460(v42, v39, v40);\n    }\n    goto LABEL_61;\n  }\n  v145 = (const char **)v45;\n  v146 = 0;\n  v147 = 1;\n  v148 = 0LL;\n  v257 = \"-\";\n  while ( 2 )\n  {\n    v149 = *v145;\n    v150 = 2LL;\n    v151 = \"-\";\n    v152 = (__int64)*v145;\n    do\n    {\n      if ( !v150 )\n        break;\n      v146 = *(_BYTE *)v152 < (unsigned __int8)*v151;\n      v147 = *(_BYTE *)v152++ == *v151++;\n      --v150;\n    }\n    while ( v147 );\n    if ( (!v146 && !v147) != v146 )\n    {\n      v152 = 4LL;\n      if ( euidaccess(*v145, 4) )\n      {\n        v204 = *v145;\n        v203 = \"cannot read\";\nLABEL_414:\n        v205 = dcgettext(0LL, v203, 5);\n        sub_405DD0(v205, v204);\n      }\n    }\n    ++v145;\n    v146 = v43 < v148 + 1;\n    v147 = v43 == v148 + 1;\n    if ( v43 != v148 + 1 )\n    {\n      ++v148;\n      continue;\n    }\n    break;\n  }\n  if ( !file )\n    goto LABEL_273;\n  v152 = 524353LL;\n  v153 = open(file, 524353, 438LL);\n  if ( v153 < 0 )\n  {\nLABEL_431:\n    v218 = dcgettext(0LL, \"open failed\", 5);\n    sub_405DD0(v218, file);\n  }\n  if ( v153 != 1 )\n  {\n    v152 = 1LL;\n    sub_408E10(v153);\n  }\nLABEL_273:\n  if ( (_BYTE)v249 )\n  {\n    v182 = sub_4113E0(v148 + 1, 16LL, v149, v150);\n    for ( j = 0LL; ; ++j )\n    {\n      *(_QWORD *)(v182 + 16 * j) = v45[j];\n      if ( j == v148 )\n        break;\n    }\n    sub_409330(v182, 0LL, v148 + 1, file);\n    goto LABEL_311;\n  }\n  if ( !v253 )\n  {\n    v196 = sub_40D6F0(2LL, v152, v149, v150);\n    v197 = 8LL;\n    if ( v196 <= 8 )\n      v197 = v196;\n    v253 = v197;\n  }\n  v256 = (char **)v45;\n  v154 = 0xFFFFFFFFFFFFFFLL;\n  v263 = 0LL;\n  v249 = v148 + 1;\n  if ( v253 <= 0xFFFFFFFFFFFFFFLL )\n    v154 = v253;\n  v155 = 0LL;\n  v248 = (char *)v154;\n  v250 = v154 << 8;\n  v251 = (__int64 *)(2 * v154);\n  mutex = (pthread_mutex_t *)&v276;\n  while ( 2 )\n  {\n    src = *v256;\n    stream = (FILE *)sub_407CD0(*v256, \"r\");\n    if ( !stream )\n      goto LABEL_429;\n    v255 = 48LL;\n    if ( v253 > 1 )\n    {\n      v166 = 1LL;\n      v167 = 1LL;\n      do\n      {\n        v167 *= 2LL;\n        ++v166;\n      }\n      while ( (unsigned __int64)v248 > v167 );\n      v255 = 32 * v166;\n    }\n    if ( v263 )\n      goto LABEL_281;\n    v45 = (__int64 *)v249;\n    s1 = v155;\n    v43 = 0LL;\n    v4 = v255 + 1;\n    v5 = v255 + 2;\n    while ( 2 )\n    {\n      if ( v43 )\n      {\n        if ( !memcmp(v256[v43], v257, 2uLL) )\n          v170 = __fxstat(1, 0, (struct stat *)&ptr) != 0;\n        else\n          v170 = __xstat(1, v256[v43], (struct stat *)&ptr) != 0;\n      }\n      else\n      {\n        v178 = fileno(stream);\n        v170 = __fxstat(1, v178, (struct stat *)&ptr) != 0;\n      }\n      if ( v170 )\n      {\n        v203 = \"stat failed\";\n        v204 = v256[v43];\n        goto LABEL_414;\n      }\n      if ( (v278 & 0xF000) == 0x8000 )\n      {\n        a4 = cond.__align;\n        if ( !qword_61C5E0 )\n        {\n          qword_61C5E0 = qword_61C778;\n          if ( !qword_61C778 )\n            goto LABEL_331;\n        }\n      }\n      else\n      {\n        v168 = qword_61C778;\n        if ( qword_61C778 )\n          goto LABEL_363;\n        a4 = 0x20000LL;\n        if ( !qword_61C5E0 )\n        {\nLABEL_331:\n          v171 = -1LL;\n          if ( !getrlimit(RLIMIT_DATA, &v259) )\n            v171 = v259.rlim_cur;\n          if ( !getrlimit(RLIMIT_AS, &v259) && v171 > v259.rlim_cur )\n            v171 = v259.rlim_cur;\n          v172 = v171 >> 1;\n          if ( !getrlimit(__RLIMIT_RSS, &v259) && v172 > 15 * (v259.rlim_cur >> 4) )\n            v172 = 15 * (v259.rlim_cur >> 4);\n          v243 = sub_40D900();\n          v173 = sub_40D840(5LL, &v259);\n          v174 = 0.125 * v173;\n          v175 = v173 * 0.75;\n          v38.m128i_i64[0] = fmax(v243, v174);\n          if ( (double)(int)v172 > v175 )\n          {\n            if ( v175 < 9.223372036854776e18 )\n              v172 = (unsigned int)(int)v175;\n            else\n              v172 = (unsigned int)(int)(v175 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n          }\n          if ( (v172 & 0x8000000000000000LL) != 0LL )\n            v176 = (double)(int)(v172 & 1 | (v172 >> 1)) + (double)(int)(v172 & 1 | (v172 >> 1));\n          else\n            v176 = (double)(int)v172;\n          if ( v176 > *(double *)v38.m128i_i8 )\n          {\n            if ( *(double *)v38.m128i_i8 < 9.223372036854776e18 )\nLABEL_377:\n              v172 = (unsigned int)(int)*(double *)v38.m128i_i8;\n            else\n              v172 = (unsigned int)(int)(*(double *)v38.m128i_i8 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n          }\n          v177 = 34LL * (unsigned int)dword_61C420;\n          if ( v177 < v172 )\n            v177 = v172;\n          qword_61C5E0 = v177;\n        }\n      }\n      v168 = qword_61C5E0;\n      v169 = a4 * v4 + 1;\n      if ( a4 != v169 / v4 || v169 >= qword_61C5E0 - v5 )\n      {\nLABEL_363:\n        v155 = s1;\n        v5 = v168;\n        goto LABEL_364;\n      }\n      ++v43;\n      v5 += v169;\n      if ( v43 < (unsigned __int64)v45 )\n        continue;\n      break;\n    }\n    v155 = s1;\nLABEL_364:\n    sub_405E30(&dest, v255, v5);\nLABEL_281:\n    v265 = 0;\n    --v249;\nLABEL_284:\n    if ( !(unsigned __int8)sub_4074D0(&dest, stream, src) )\n    {\n      v39 = src;\n      sub_407DF0(stream);\n      if ( v249 )\n        goto LABEL_307;\n      v42 = (__int64)dest;\n      free(dest);\n      v184 = ::ptr;\n      v40 = ((unsigned __int64)v155 * (unsigned __int128)0x10uLL) >> 64 != 0;\n      if ( !((unsigned __int64)v155 & 0x800000000000000LL)\n        && ((unsigned __int64)v155 * (unsigned __int128)0x10uLL) >> 64 == 0 )\n      {\n        v185 = (_QWORD *)sub_411210(16LL * (_QWORD)v155);\n        v186 = v185;\n        while ( v184 )\n        {\n          v187 = (__int64)v184 + 13;\n          v186[1] = v184;\n          v184 = (_QWORD *)*v184;\n          v186 += 2;\n          *(v186 - 2) = v187;\n        }\n        sub_409330(v185, v155, v155, file);\n        free(v185);\n        goto LABEL_309;\n      }\n      goto LABEL_451;\n    }\n    v159 = v265;\n    if ( !v265 )\n      goto LABEL_288;\n    if ( v249 )\n    {\n      if ( v255 + 1 >= (unsigned __int64)&v263[-v261 - v262 * v255] )\n      {\nLABEL_288:\n        *(_QWORD *)&xmmword_61CB80 = 0LL;\n        v160 = &v263[(_QWORD)dest];\n        goto LABEL_289;\n      }\n      v264 = v261;\n      sub_407DF0(stream);\nLABEL_307:\n      ++v256;\n      continue;\n    }\n    break;\n  }\n  v160 = &v263[(_QWORD)dest];\n  *(_QWORD *)&xmmword_61CB80 = 0LL;\n  if ( v264 | (unsigned __int64)v155 )\n  {\nLABEL_289:\n    ++v155;\n    v159 = 0;\n    v161 = sub_4090C0(&v259, 0LL) + 13;\n  }\n  else\n  {\n    sub_407DF0(stream);\n    v162 = sub_407CD0(file, \"w\");\n    if ( !v162 )\n      goto LABEL_427;\n    v259.rlim_cur = v162;\n    v161 = (__int64)file;\n    v155 = 0LL;\n  }\n  if ( v262 > 1 )\n  {\n    ptr = (void *)sub_40CFD0(sub_407850, v251);\n    pthread_mutex_init(mutex, 0LL);\n    pthread_cond_init(&cond, 0LL);\n    v156 = v262;\n    v157 = sub_411210(v250);\n    *(_QWORD *)(v157 + 48) = v156;\n    v158 = v157;\n    *(_QWORD *)(v157 + 40) = v156;\n    *(_QWORD *)(v157 + 24) = 0LL;\n    *(_QWORD *)(v157 + 16) = 0LL;\n    *(_QWORD *)(v157 + 8) = 0LL;\n    *(_QWORD *)v157 = 0LL;\n    *(_QWORD *)(v157 + 32) = 0LL;\n    *(_QWORD *)(v157 + 56) = 0LL;\n    *(_DWORD *)(v157 + 80) = 0;\n    *(_BYTE *)(v157 + 84) = 0;\n    pthread_mutex_init((pthread_mutex_t *)(v157 + 88), 0LL);\n    sub_4061F0(v158, v158 + 128, v160, v248, v156, 0LL);\n    sub_409880((__int64)v160);\n  }\n  else\n  {\n    sub_4085D0(v160 - 32, v259.rlim_cur, v161);\n  }\n  sub_407DF0((FILE *)v259.rlim_cur);\n  if ( !v159 )\n    goto LABEL_284;\n  free(dest);\nLABEL_309:\n  while ( dword_61C69C > 0 )\n    sub_405FB0(-1);\nLABEL_311:\n  if ( byte_61C758 && (unsigned int)sub_411F80(stdin) == -1 )\n  {\n    v165 = dcgettext(0LL, \"close failed\", 5);\n    sub_405DD0(v165, \"-\");\n  }\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x402f50L", 
            "funcEndAddr": "0x405830L", 
            "funcName": "main"
        }, 
        {
            "decompiledFuncCode": "// positive sp value has been detected, the output may be wrong!\nvoid __usercall __noreturn start(__int64 a1@<rax>, void (*a2)(void)@<rdx>)\n{\n  int v2; // esi\n  int v3; // [rsp-8h] [rbp-8h]\n  __int64 _0; // [rsp+0h] [rbp+0h]\n\n  v2 = v3;\n  *(_QWORD *)&v3 = a1;\n  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v2, (char **)&_0, init, fini, a2, &v3);\n  __halt();\n}\n", 
            "funcStartAddr": "0x405830L", 
            "funcEndAddr": "0x40585bL", 
            "funcName": "start"
        }, 
        {
            "decompiledFuncCode": "void *sub_40585B()\n{\n  void *result; // rax\n\n  result = &unk_61C588;\n  if ( &unk_61C588 != &unk_61C588 )\n    result = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x40585bL", 
            "funcEndAddr": "0x40587aL", 
            "funcName": "sub_40585B"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_40587A()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40587aL", 
            "funcEndAddr": "0x4058b1L", 
            "funcName": "sub_40587A"
        }, 
        {
            "decompiledFuncCode": "void *sub_4058B1()\n{\n  void *result; // rax\n\n  if ( !byte_61C5C8 )\n  {\n    while ( qword_61C5D0 < (unsigned __int64)(&qword_61BE38 - qword_61BE30 - 1) )\n      ((void (*)(void))qword_61BE30[++qword_61C5D0])();\n    result = sub_40585B();\n    byte_61C5C8 = 1;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4058b1L", 
            "funcEndAddr": "0x405908L", 
            "funcName": "sub_4058B1"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_405908()\n{\n  return sub_40587A();\n}\n", 
            "funcStartAddr": "0x405908L", 
            "funcEndAddr": "0x40590dL", 
            "funcName": "sub_405908"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_405910(__int64 a1, unsigned __int64 a2)\n{\n  return *(int *)(a1 + 8) % a2;\n}\n", 
            "funcStartAddr": "0x405910L", 
            "funcEndAddr": "0x40591dL", 
            "funcName": "sub_405910"
        }, 
        {
            "decompiledFuncCode": "bool __fastcall sub_405920(__int64 a1, __int64 a2)\n{\n  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);\n}\n", 
            "funcStartAddr": "0x405920L", 
            "funcEndAddr": "0x40592aL", 
            "funcName": "sub_405920"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405930(unsigned __int8 **a1)\n{\n  unsigned __int8 *v1; // rcx\n  char v2; // r10\n  __int64 result; // rax\n  unsigned int v4; // edx\n  __int64 v5; // rsi\n  unsigned int v6; // er8\n  unsigned __int8 *v7; // rcx\n  unsigned int v8; // edx\n\n  v1 = *a1;\n  v2 = 0;\n  result = 0LL;\n  v4 = **a1;\n  while ( 1 )\n  {\n    v5 = (__int64)(v1 + 1);\n    if ( (unsigned int)(unsigned __int8)v4 - 48 > 9 )\n      break;\n    if ( (unsigned __int8)result < (unsigned __int8)v4 )\n      result = v4;\n    v2 = 0;\n    v4 = (char)v1[1];\n    if ( v4 == dword_61CBA4 )\n    {\n      v4 = v1[2];\n      v5 = (__int64)(v1 + 2);\n      v2 = 1;\n    }\n    v1 = (unsigned __int8 *)v5;\n  }\n  if ( v2 )\n  {\n    *a1 = v1 - 1;\n  }\n  else\n  {\n    if ( (unsigned __int8)v4 != dword_61CBA8 )\n    {\nLABEL_10:\n      *a1 = v1;\n      return result;\n    }\n    v6 = v1[1];\n    v7 = v1 + 2;\n    v8 = v6;\n    if ( v6 - 48 > 9 )\n    {\n      v1 = (unsigned __int8 *)v5;\n      goto LABEL_10;\n    }\n    while ( 1 )\n    {\n      if ( (unsigned __int8)result < (unsigned __int8)v8 )\n        result = v8;\n      v8 = *v7;\n      if ( v8 - 48 > 9 )\n        break;\n      ++v7;\n    }\n    *a1 = v7;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x405930L", 
            "funcEndAddr": "0x4059e8L", 
            "funcName": "sub_405930"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4059F0(char *a1)\n{\n  char v1; // bl\n  unsigned __int8 v2; // al\n  unsigned int v3; // edx\n  char *v5; // [rsp+8h] [rbp-10h]\n\n  v1 = *a1;\n  v5 = &a1[*a1 == 45];\n  v2 = sub_405930((unsigned __int8 **)&v5);\n  v3 = 0;\n  if ( v2 > 0x30u )\n  {\n    v3 = byte_4149C0[(unsigned __int8)*v5];\n    if ( v1 == 45 )\n      v3 = -byte_4149C0[(unsigned __int8)*v5];\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x4059f0L", 
            "funcEndAddr": "0x405a39L", 
            "funcName": "sub_4059F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405A40(unsigned __int8 *a1, _QWORD *a2)\n{\n  unsigned __int64 v2; // r11\n  unsigned __int64 v3; // r10\n  unsigned __int64 v4; // r9\n  char *v5; // rax\n  unsigned __int8 v6; // dl\n  __int64 v7; // rcx\n  unsigned __int8 *v8; // rdx\n  __int64 v9; // r8\n  unsigned __int8 v10; // cl\n\n  while ( byte_61CA80[*a1] )\n    ++a1;\n  v2 = 12LL;\n  v3 = 0LL;\n  while ( 1 )\n  {\n    v4 = (v3 + v2) >> 1;\n    v5 = (&off_61C440)[2 * v4];\n    v6 = *v5;\n    if ( !*v5 )\n    {\n      v8 = a1;\n      goto LABEL_12;\n    }\n    v7 = *a1;\n    if ( (unsigned __int8)byte_61C780[v7] >= v6 )\n      break;\nLABEL_15:\n    v2 = (v3 + v2) >> 1;\nLABEL_16:\n    if ( v3 >= v2 )\n      return 0LL;\n  }\n  if ( (unsigned __int8)byte_61C780[v7] > v6 )\n  {\nLABEL_18:\n    v3 = v4 + 1;\n    goto LABEL_16;\n  }\n  v8 = a1;\n  while ( 1 )\n  {\n    v10 = *++v5;\n    ++v8;\n    if ( !*v5 )\n      break;\n    v9 = *v8;\n    if ( (unsigned __int8)byte_61C780[v9] < v10 )\n      goto LABEL_15;\n    if ( (unsigned __int8)byte_61C780[v9] > v10 )\n      goto LABEL_18;\n  }\nLABEL_12:\n  if ( a2 )\n    *a2 = v8;\n  return (unsigned int)dword_61C448[4 * v4];\n}\n", 
            "funcStartAddr": "0x405a40L", 
            "funcEndAddr": "0x405ae3L", 
            "funcName": "sub_405A40"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405AF0(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( !*(_QWORD *)(a1 + 32) && !*(_QWORD *)(a1 + 40) )\n  {\n    result = *(unsigned __int8 *)(a1 + 48);\n    if ( (_BYTE)result )\n      return 0LL;\n    if ( !*(_BYTE *)(a1 + 49) && !(*(_QWORD *)(a1 + 48) & 0xFFFF00FF0000LL) )\n    {\n      result = *(unsigned __int8 *)(a1 + 54);\n      if ( !(_BYTE)result )\n      {\n        if ( !*(_BYTE *)(a1 + 56) )\n          result = *(unsigned __int8 *)(a1 + 51) ^ 1u;\n        return result;\n      }\n      return 0LL;\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x405af0L", 
            "funcEndAddr": "0x405b43L", 
            "funcName": "sub_405AF0"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_405B50(__int64 a1, _BYTE *a2)\n{\n  _BYTE *result; // rax\n\n  if ( *(_WORD *)(a1 + 48) )\n    *a2++ = 98;\n  if ( *(char **)(a1 + 32) == byte_61C880 )\n    *a2++ = 100;\n  result = a2;\n  if ( *(_QWORD *)(a1 + 40) )\n  {\n    *a2 = 102;\n    result = a2 + 1;\n  }\n  if ( *(_BYTE *)(a1 + 52) )\n    *result++ = 103;\n  if ( *(_BYTE *)(a1 + 53) )\n    *result++ = 104;\n  if ( *(char **)(a1 + 32) == byte_61C980 )\n    *result++ = 105;\n  if ( *(_BYTE *)(a1 + 54) )\n    *result++ = 77;\n  if ( *(_BYTE *)(a1 + 50) )\n    *result++ = 110;\n  if ( *(_BYTE *)(a1 + 51) )\n    *result++ = 82;\n  if ( *(_BYTE *)(a1 + 55) )\n    *result++ = 114;\n  if ( *(_BYTE *)(a1 + 56) )\n    *result++ = 86;\n  *result = 0;\n  return result;\n}\n", 
            "funcStartAddr": "0x405b50L", 
            "funcEndAddr": "0x405bf7L", 
            "funcName": "sub_405B50"
        }, 
        {
            "decompiledFuncCode": "char *__fastcall sub_405C00(char *a1, __int64 a2, int a3)\n{\n  char v3; // cl\n  int v4; // eax\n  unsigned int v5; // edx\n  unsigned int v6; // eax\n\n  v3 = *a1;\n  if ( *a1 )\n  {\n    v4 = a3;\n    v5 = a3 - 1;\n    v6 = v4 & 0xFFFFFFFD;\n    while ( 2 )\n    {\n      switch ( v3 )\n      {\n        case 77:\n          *(_BYTE *)(a2 + 54) = 1;\n          goto LABEL_5;\n        case 82:\n          *(_BYTE *)(a2 + 51) = 1;\n          goto LABEL_5;\n        case 86:\n          *(_BYTE *)(a2 + 56) = 1;\n          goto LABEL_5;\n        case 98:\n          if ( !v6 )\n            *(_BYTE *)(a2 + 48) = 1;\n          if ( v5 <= 1 )\n            *(_BYTE *)(a2 + 49) = 1;\n          goto LABEL_5;\n        case 100:\n          *(_QWORD *)(a2 + 32) = byte_61C880;\n          goto LABEL_5;\n        case 102:\n          *(_QWORD *)(a2 + 40) = byte_61C780;\n          goto LABEL_5;\n        case 103:\n          *(_BYTE *)(a2 + 52) = 1;\n          goto LABEL_5;\n        case 104:\n          *(_BYTE *)(a2 + 53) = 1;\n          goto LABEL_5;\n        case 105:\n          if ( !*(_QWORD *)(a2 + 32) )\n            *(_QWORD *)(a2 + 32) = byte_61C980;\n          goto LABEL_5;\n        case 110:\n          *(_BYTE *)(a2 + 50) = 1;\n          goto LABEL_5;\n        case 114:\n          *(_BYTE *)(a2 + 55) = 1;\nLABEL_5:\n          v3 = *++a1;\n          if ( !*a1 )\n            return a1;\n          continue;\n        default:\n          return a1;\n      }\n    }\n  }\n  return a1;\n}\n", 
            "funcStartAddr": "0x405c00L", 
            "funcEndAddr": "0x405ce9L", 
            "funcName": "sub_405C00"
        }, 
        {
            "decompiledFuncCode": "int __fastcall compar(const void *a1, const void *a2)\n{\n  return strcmp(*(const char **)a1, *(const char **)a2);\n}\n", 
            "funcStartAddr": "0x405cf0L", 
            "funcEndAddr": "0x405cfbL", 
            "funcName": "compar"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405D00(__int64 a1)\n{\n  char *v1; // rax\n\n  v1 = dcgettext(0LL, \"options '-%s' are incompatible\", 5);\n  error(2, 0, v1, a1);\n  return sub_405D30(2LL, 0LL);\n}\n", 
            "funcStartAddr": "0x405d00L", 
            "funcEndAddr": "0x405d30L", 
            "funcName": "sub_405D00"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405D30(__int64 a1, const char *a2)\n{\n  __int64 v2; // rbp\n  char *v3; // rbx\n  char *v4; // rax\n\n  v2 = sub_40F880(a1);\n  v3 = dcgettext(0LL, a2, 5);\n  v4 = dcgettext(0LL, \"%s: invalid field specification %s\", 5);\n  error(2, 0, v4, v3, v2);\n  return sub_405D80(2);\n}\n", 
            "funcStartAddr": "0x405d30L", 
            "funcEndAddr": "0x405d80L", 
            "funcName": "sub_405D30"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_405D80(int sig)\n{\n  const char *v1; // rbx\n\n  v1 = (const char *)ptr;\n  if ( ptr )\n  {\n    do\n    {\n      unlink(v1 + 13);\n      v1 = *(const char **)v1;\n    }\n    while ( v1 );\n  }\n  ptr = 0LL;\n  signal(sig, 0LL);\n  return raise(sig);\n}\n", 
            "funcStartAddr": "0x405d80L", 
            "funcEndAddr": "0x405dcaL", 
            "funcName": "sub_405D80"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_405DD0(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  char *v5; // rdx\n  __int64 v6; // rbp\n  int *v7; // rax\n\n  v5 = a2;\n  if ( !a2 )\n    goto LABEL_3;\n  while ( 1 )\n  {\n    v6 = sub_40F700(0LL, 3LL, v5, a4, a5);\n    v7 = __errno_location();\n    error(2, *v7, \"%s: %s\", a1, v6);\nLABEL_3:\n    v5 = dcgettext(0LL, \"standard output\", 5);\n  }\n}\n", 
            "funcStartAddr": "0x405dd0L", 
            "funcEndAddr": "0x405e24L", 
            "funcName": "sub_405DD0"
        }, 
        {
            "decompiledFuncCode": "void *__fastcall sub_405E30(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  __int64 v3; // rbp\n  unsigned __int64 v4; // rbx\n  size_t v5; // rbx\n  size_t v6; // rdi\n  void *result; // rax\n  __int64 v8; // rdx\n\n  v3 = a1;\n  v4 = a3;\n  while ( 1 )\n  {\n    v5 = (v4 & 0xFFFFFFFFFFFFFFE0LL) + 32;\n    v6 = v5;\n    result = malloc(v5);\n    *(_QWORD *)v3 = result;\n    if ( result )\n      break;\n    v4 = v5 >> 1;\n    if ( a2 + 1 >= v4 )\n      sub_411460(v6, a2, v8);\n  }\n  *(_QWORD *)(v3 + 40) = a2;\n  *(_QWORD *)(v3 + 24) = v5;\n  *(_QWORD *)(v3 + 16) = 0LL;\n  *(_QWORD *)(v3 + 32) = 0LL;\n  *(_QWORD *)(v3 + 8) = 0LL;\n  *(_BYTE *)(v3 + 48) = 0;\n  return result;\n}\n", 
            "funcStartAddr": "0x405e30L", 
            "funcEndAddr": "0x405ea5L", 
            "funcName": "sub_405E30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405EB0(char *a1, unsigned __int64 a2)\n{\n  char *v2; // rbx\n  __int64 result; // rax\n\n  v2 = a1;\n  result = (int)sub_40D3C0(a1);\n  if ( a2 > (unsigned __int64)a1 )\n  {\n    do\n      result += *(++v2 - 1) == 9;\n    while ( (char *)a2 != v2 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x405eb0L", 
            "funcEndAddr": "0x405eecL", 
            "funcName": "sub_405EB0"
        }, 
        {
            "decompiledFuncCode": "size_t __fastcall sub_405EF0(char *dest, char *src, size_t n)\n{\n  size_t v3; // r13\n  int *v4; // rax\n  int *v5; // rbx\n  size_t result; // rax\n  char *v7; // rax\n  char *v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n\n  v3 = n;\n  v4 = __errno_location();\n  *v4 = 0;\n  v5 = v4;\n  result = strxfrm(dest, src, v3);\n  if ( *v5 )\n  {\n    v7 = dcgettext(0LL, \"string transformation failed\", 5);\n    error(0, *v5, v7);\n    v8 = dcgettext(0LL, \"set LC_ALL='C' to work around the problem\", 5);\n    error(0, 0, v8);\n    v9 = sub_40F550(0LL, 8LL, src);\n    v10 = dcgettext(0LL, \"the untransformed string was %s\", 5);\n    error(2, 0, v10, v9);\n    result = sub_405FB0(2);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x405ef0L", 
            "funcEndAddr": "0x405fb0L", 
            "funcName": "sub_405EF0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_405FB0(__pid_t pid)\n{\n  int v1; // edx\n  __pid_t v2; // ebx\n  bool v3; // zf\n  __pid_t v4; // edi\n  __pid_t v5; // eax\n  unsigned int v6; // ebp\n  __int64 v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n  __int64 v11; // rbp\n  char *v12; // rbx\n  int *v13; // rax\n  int stat_loc; // [rsp+Ch] [rbp-2Ch]\n  char v15; // [rsp+10h] [rbp-28h]\n  __pid_t v16; // [rsp+18h] [rbp-20h]\n\n  v1 = 0;\n  v2 = pid;\n  v3 = pid == 0;\n  v4 = -1;\n  if ( !v3 )\n    v4 = v2;\n  LOBYTE(v1) = v3;\n  v5 = waitpid(v4, &stat_loc, v1);\n  if ( v5 >= 0 )\n  {\n    v6 = v5;\n    if ( !v5 )\n      return v6;\n    if ( v2 <= 0 )\n    {\n      v16 = v5;\n      v8 = sub_40CDE0(qword_61C6A0, &v15);\n      if ( !v8 )\n        return v6;\n      *(_BYTE *)(v8 + 12) = 2;\n    }\n    if ( !(stat_loc & 0x7F | BYTE1(stat_loc)) )\n    {\n      --dword_61C69C;\n      return v6;\n    }\n    v9 = sub_40F630(4LL, s1);\n    v10 = dcgettext(0LL, \"%s [-d] terminated abnormally\", 5);\n    error(2, 0, v10, v9);\n  }\n  v11 = sub_40F630(4LL, s1);\n  v12 = dcgettext(0LL, \"waiting for %s [-d]\", 5);\n  v13 = __errno_location();\n  error(2, *v13, v12, v11);\n  return sub_4060A0(2);\n}\n", 
            "funcStartAddr": "0x405fb0L", 
            "funcEndAddr": "0x4060a0L", 
            "funcName": "sub_405FB0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4060A0(__pid_t pid)\n{\n  __int64 result; // rax\n  __int64 v2; // [rsp+0h] [rbp-18h]\n  __pid_t v3; // [rsp+8h] [rbp-10h]\n\n  v3 = pid;\n  result = sub_40CDE0(qword_61C6A0, &v2);\n  if ( result )\n  {\n    *(_BYTE *)(result + 12) = 2;\n    result = sub_405FB0(pid);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4060a0L", 
            "funcEndAddr": "0x4060d0L", 
            "funcName": "sub_4060A0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_4060D0(unsigned int a1, const void *a2)\n{\n  const void *v2; // rbx\n  char v3; // [rsp+4h] [rbp-14h]\n\n  write(2, a2, strlen((const char *)a2));\n  if ( a1 )\n  {\n    v2 = (const void *)sub_40D2B0(a1, &v3);\n    write(2, \": errno \", 8uLL);\n    write(2, v2, strlen((const char *)v2));\n  }\n  write(2, \"\\n\", 1uLL);\n  _exit(2);\n}\n", 
            "funcStartAddr": "0x4060d0L", 
            "funcEndAddr": "0x406185L", 
            "funcName": "sub_4060D0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406190(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rdi\n  __int64 v3; // rsi\n  __int64 result; // rax\n  __int64 v5; // rdx\n\n  v1 = a1;\n  v2 = qword_61C6A0;\n  if ( !qword_61C6A0 && (v3 = 0LL, v2 = sub_40C600(47LL, 0LL, sub_405910, sub_405920, 0LL), (qword_61C6A0 = v2) == 0)\n    || (*(_BYTE *)(v1 + 12) = 1, v3 = v1, (result = sub_40CDA0(v2, v1)) == 0) )\n  {\n    sub_411460(v2, v3, v5);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406190L", 
            "funcEndAddr": "0x4061e5L", 
            "funcName": "sub_406190"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4061F0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, char a6)\n{\n  unsigned __int64 v6; // r13\n  __int64 v7; // r12\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // r14\n  __int64 v12; // rcx\n  int v13; // eax\n  __int64 result; // rax\n  __int64 v15; // rax\n\n  while ( 1 )\n  {\n    v6 = a4;\n    v7 = a5;\n    v8 = a3 - 32 * a5;\n    if ( a6 )\n    {\n      v9 = *(_QWORD *)(a1 + 40) >> 1;\n      v10 = *(_QWORD *)(a1 + 40) - v9;\n      v11 = v8 - 32 * v9;\n      v12 = a1 + 16;\n    }\n    else\n    {\n      v9 = *(_QWORD *)(a1 + 48) >> 1;\n      v10 = *(_QWORD *)(a1 + 48) - v9;\n      v11 = v8 - 32 * v9;\n      v12 = a1 + 24;\n    }\n    *(_QWORD *)(a2 + 48) = v10;\n    v13 = *(_DWORD *)(a1 + 80);\n    *(_QWORD *)(a2 + 56) = a1;\n    *(_QWORD *)(a2 + 16) = v8;\n    *(_QWORD *)a2 = v8;\n    *(_QWORD *)(a2 + 24) = v11;\n    *(_QWORD *)(a2 + 8) = v11;\n    *(_QWORD *)(a2 + 32) = v12;\n    *(_QWORD *)(a2 + 40) = v9;\n    *(_DWORD *)(a2 + 80) = v13 + 1;\n    *(_BYTE *)(a2 + 84) = 0;\n    pthread_mutex_init((pthread_mutex_t *)(a2 + 88), 0LL);\n    if ( v6 <= 1 )\n      break;\n    *(_QWORD *)(a2 + 64) = a2 + 128;\n    v15 = sub_4061F0(a2, a2 + 128, v8, v6 >> 1, v7, 1LL);\n    a5 = v7;\n    a4 = v6 - (v6 >> 1);\n    a3 = v11;\n    *(_QWORD *)(a2 + 72) = v15;\n    a1 = a2;\n    a6 = 0;\n    a2 = v15;\n  }\n  *(_QWORD *)(a2 + 64) = 0LL;\n  result = a2 + 128;\n  *(_QWORD *)(a2 + 72) = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x4061f0L", 
            "funcEndAddr": "0x40631dL", 
            "funcName": "sub_4061F0"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_406320(__int64 a1, __int64 a2)\n{\n  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));\n  sub_40D070(*(_QWORD *)a1, a2);\n  *(_BYTE *)(a2 + 84) = 1;\n  pthread_cond_signal((pthread_cond_t *)(a1 + 48));\n  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));\n}\n", 
            "funcStartAddr": "0x406320L", 
            "funcEndAddr": "0x40635cL", 
            "funcName": "sub_406320"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_406360(char *a1, __int64 a2, __int64 *a3)\n{\n  unsigned __int64 result; // rax\n  __int64 v4; // rcx\n  __int64 v5; // r9\n  __int64 v6; // r8\n  unsigned __int8 *v7; // rdi\n  unsigned __int8 *v8; // rdi\n  __int64 v9; // rsi\n  char v10; // cl\n  unsigned __int8 *v11; // rdi\n\n  result = (unsigned __int64)&a1[a2 - 1];\n  v4 = *a3;\n  v5 = a3[1];\n  if ( dword_61C424 == 128 )\n  {\n    if ( result <= (unsigned __int64)a1 )\n      goto LABEL_6;\n    v9 = v4 - 1;\n    if ( v4 )\n    {\n      do\n      {\n        v10 = byte_61CA80[(unsigned __int8)*a1];\n        while ( !v10 )\n        {\n          if ( result <= (unsigned __int64)a1 )\n            goto LABEL_6;\n          do\n          {\n            if ( (char *)result == ++a1 )\n            {\n              a1 = (char *)result;\n              goto LABEL_6;\n            }\n            v10 = byte_61CA80[(unsigned __int8)*a1];\n          }\n          while ( !v10 );\n          if ( --v9 == -1 )\n            goto LABEL_12;\n        }\n        ++a1;\n      }\n      while ( result > (unsigned __int64)a1 );\n      v11 = (unsigned __int8 *)&a1[v5];\n      if ( result > (unsigned __int64)v11 )\n        result = (unsigned __int64)v11;\n      return result;\n    }\n  }\n  else\n  {\n    if ( result <= (unsigned __int64)a1 )\n      goto LABEL_6;\n    v6 = v4 - 1;\n    if ( v4 )\n    {\n      do\n      {\n        while ( dword_61C424 != *a1 )\n        {\n          if ( result <= (unsigned __int64)++a1 )\n            goto LABEL_6;\n        }\n        if ( result <= (unsigned __int64)a1 )\n          goto LABEL_6;\n        if ( result <= (unsigned __int64)++a1 )\n          goto LABEL_6;\n      }\n      while ( --v6 != -1 );\n    }\n  }\nLABEL_12:\n  if ( !*((_BYTE *)a3 + 48) )\n  {\nLABEL_6:\n    v7 = (unsigned __int8 *)&a1[v5];\n    if ( result > (unsigned __int64)v7 )\n      result = (unsigned __int64)v7;\n    return result;\n  }\n  while ( byte_61CA80[(unsigned __int8)*a1] )\n  {\n    if ( result <= (unsigned __int64)++a1 )\n      goto LABEL_6;\n  }\n  v8 = (unsigned __int8 *)&a1[v5];\n  if ( result > (unsigned __int64)v8 )\n    result = (unsigned __int64)v8;\n  return result;\n}\n", 
            "funcStartAddr": "0x406360L", 
            "funcEndAddr": "0x40646fL", 
            "funcName": "sub_406360"
        }, 
        {
            "decompiledFuncCode": "char *__fastcall sub_406470(char *a1, __int64 a2, __int64 a3)\n{\n  unsigned __int64 v3; // r9\n  unsigned __int64 v4; // rcx\n  char *result; // rax\n  __int64 v6; // rsi\n  __int64 v7; // r8\n  __int64 v8; // rdi\n  char v9; // si\n\n  v3 = *(_QWORD *)(a3 + 24);\n  v4 = (unsigned __int64)&a1[a2 - 1];\n  result = a1;\n  v6 = (v3 < 1) + *(_QWORD *)(a3 + 16);\n  if ( dword_61C424 == 128 )\n  {\n    if ( v4 > (unsigned __int64)a1 )\n    {\n      v8 = v6 - 1;\n      if ( v6 )\n      {\n        do\n        {\n          v9 = byte_61CA80[(unsigned __int8)*result];\n          while ( !v9 )\n          {\n            if ( v4 > (unsigned __int64)result )\n            {\n              do\n              {\n                if ( (char *)v4 == ++result )\n                {\n                  result = (char *)v4;\n                  goto LABEL_6;\n                }\n                v9 = byte_61CA80[(unsigned __int8)*result];\n              }\n              while ( !v9 );\n              if ( --v8 != -1 )\n                continue;\n            }\n            goto LABEL_6;\n          }\n          ++result;\n        }\n        while ( v4 > (unsigned __int64)result );\n      }\n    }\n  }\n  else if ( v4 > (unsigned __int64)a1 )\n  {\n    v7 = v6 - 1;\n    if ( v6 )\n    {\n      do\n      {\n        while ( dword_61C424 != *result )\n        {\n          if ( v4 <= (unsigned __int64)++result )\n            goto LABEL_6;\n        }\n        if ( v4 <= (unsigned __int64)result )\n          break;\n        if ( !(v7 | v3) )\n          return result;\n        if ( v4 <= (unsigned __int64)++result )\n          break;\n        --v7;\n      }\n      while ( v7 != -1 );\n    }\n  }\nLABEL_6:\n  if ( v3 )\n  {\n    if ( *(_BYTE *)(a3 + 49) && v4 > (unsigned __int64)result )\n    {\n      while ( byte_61CA80[(unsigned __int8)*result] )\n      {\n        if ( (char *)v4 == ++result )\n        {\n          result = (char *)(v3 + v4);\n          if ( v4 <= v3 + v4 )\n            result = (char *)v4;\n          return result;\n        }\n      }\n    }\n    result += v3;\n    if ( v4 <= (unsigned __int64)result )\n      result = (char *)v4;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406470L", 
            "funcEndAddr": "0x4065adL", 
            "funcName": "sub_406470"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4065B0(__int64 a1, char **a2)\n{\n  char *v2; // r15\n  char *v3; // rbx\n  char *v4; // r10\n  __int64 v5; // r12\n  char *v6; // r14\n  char *v7; // rax\n  __int64 v8; // r13\n  __int64 v9; // rbp\n  size_t v10; // r11\n  size_t v11; // r10\n  char v12; // cl\n  unsigned __int8 v13; // cl\n  unsigned int v14; // eax\n  __int64 v15; // rbp\n  __int64 v16; // r11\n  __int64 v17; // r11\n  char *i; // rdi\n  char *j; // rsi\n  unsigned int v21; // eax\n  unsigned __int64 v22; // rdi\n  char *v23; // rcx\n  char *v24; // rsi\n  char *v25; // rdi\n  char *v26; // r8\n  unsigned __int8 v27; // al\n  unsigned __int8 *v28; // rdi\n  unsigned __int8 v29; // al\n  char *v30; // rax\n  long double v31; // fst7\n  long double v32; // fst6\n  char *k; // rbx\n  char *l; // rbp\n  int v35; // er13\n  int v36; // eax\n  unsigned int v37; // eax\n  char *v38; // rcx\n  char *v39; // r8\n  int v40; // edx\n  bool v41; // cf\n  int v42; // ebx\n  int v43; // eax\n  __int64 v44; // rax\n  char *v45; // rbp\n  char *v46; // r13\n  size_t v47; // r15\n  size_t v48; // r12\n  size_t v49; // rbx\n  size_t v50; // rdx\n  unsigned __int64 v51; // rax\n  char *v52; // rax\n  size_t v53; // rax\n  size_t v54; // rdx\n  char *v55; // rdi\n  unsigned __int64 v56; // r14\n  char *v57; // rax\n  char *v58; // r11\n  size_t v59; // r10\n  int v60; // eax\n  char *v61; // r11\n  size_t v62; // r10\n  unsigned int v63; // eax\n  int v64; // eax\n  size_t v65; // rdx\n  int v66; // eax\n  __int64 v67; // r14\n  size_t v68; // rdx\n  unsigned int v69; // [rsp+0h] [rbp-2188h]\n  long double v70; // [rsp+0h] [rbp-2188h]\n  size_t v71; // [rsp+0h] [rbp-2188h]\n  __int64 v72; // [rsp+18h] [rbp-2170h]\n  char v73; // [rsp+26h] [rbp-2162h]\n  unsigned __int8 v74; // [rsp+27h] [rbp-2161h]\n  char *srcd; // [rsp+28h] [rbp-2160h]\n  char *srce; // [rsp+28h] [rbp-2160h]\n  char *srcf; // [rsp+28h] [rbp-2160h]\n  char *src; // [rsp+28h] [rbp-2160h]\n  char *srcg; // [rsp+28h] [rbp-2160h]\n  char *srch; // [rsp+28h] [rbp-2160h]\n  char *srca; // [rsp+28h] [rbp-2160h]\n  char *srcb; // [rsp+28h] [rbp-2160h]\n  char *srci; // [rsp+28h] [rbp-2160h]\n  char *srcj; // [rsp+28h] [rbp-2160h]\n  char *srcc; // [rsp+28h] [rbp-2160h]\n  size_t v86; // [rsp+30h] [rbp-2158h]\n  size_t v87; // [rsp+30h] [rbp-2158h]\n  size_t v88; // [rsp+30h] [rbp-2158h]\n  size_t v89; // [rsp+30h] [rbp-2158h]\n  size_t v90; // [rsp+30h] [rbp-2158h]\n  char *v91; // [rsp+30h] [rbp-2158h]\n  char *v92; // [rsp+30h] [rbp-2158h]\n  size_t v93; // [rsp+30h] [rbp-2158h]\n  size_t v94; // [rsp+30h] [rbp-2158h]\n  char *v95; // [rsp+30h] [rbp-2158h]\n  size_t v96; // [rsp+30h] [rbp-2158h]\n  __int64 v97; // [rsp+38h] [rbp-2150h]\n  char **v98; // [rsp+40h] [rbp-2148h]\n  unsigned __int8 *v99; // [rsp+48h] [rbp-2140h]\n  size_t v100; // [rsp+48h] [rbp-2140h]\n  size_t v101; // [rsp+48h] [rbp-2140h]\n  char *v102; // [rsp+50h] [rbp-2138h]\n  char *s2; // [rsp+58h] [rbp-2130h]\n  void *ptr; // [rsp+60h] [rbp-2128h]\n  size_t size; // [rsp+68h] [rbp-2120h]\n  char *v106; // [rsp+78h] [rbp-2110h]\n  __int64 v107; // [rsp+80h] [rbp-2108h]\n  char *v108; // [rsp+88h] [rbp-2100h]\n  size_t v109; // [rsp+90h] [rbp-20F8h]\n  size_t v110; // [rsp+98h] [rbp-20F0h]\n  char *endptr; // [rsp+A8h] [rbp-20E0h]\n  char *v112; // [rsp+B0h] [rbp-20D8h]\n  char v113; // [rsp+C0h] [rbp-20C8h]\n  __m128i v114; // [rsp+D0h] [rbp-20B8h]\n  __m128i v115; // [rsp+E0h] [rbp-20A8h]\n  __m128i v116; // [rsp+F0h] [rbp-2098h]\n  __m128i v117; // [rsp+100h] [rbp-2088h]\n  __m128i v118; // [rsp+110h] [rbp-2078h]\n  __m128i v119; // [rsp+120h] [rbp-2068h]\n  __m128i v120; // [rsp+130h] [rbp-2058h]\n  __m128i v121; // [rsp+140h] [rbp-2048h]\n  __m128i v122; // [rsp+150h] [rbp-2038h]\n  __int64 v123; // [rsp+160h] [rbp-2028h]\n  int v124; // [rsp+168h] [rbp-2020h]\n  __m128i v125; // [rsp+16Ch] [rbp-201Ch]\n  __m128i v126; // [rsp+17Ch] [rbp-200Ch]\n  __m128i v127; // [rsp+18Ch] [rbp-1FFCh]\n  __m128i v128; // [rsp+19Ch] [rbp-1FECh]\n  __m128i v129; // [rsp+1ACh] [rbp-1FDCh]\n  __m128i v130; // [rsp+1BCh] [rbp-1FCCh]\n  __m128i v131; // [rsp+1CCh] [rbp-1FBCh]\n  __m128i v132; // [rsp+1DCh] [rbp-1FACh]\n  __m128i v133; // [rsp+1ECh] [rbp-1F9Ch]\n  __int64 v134; // [rsp+1FCh] [rbp-1F8Ch]\n  int v135; // [rsp+204h] [rbp-1F84h]\n  char v136[4000]; // [rsp+210h] [rbp-1F78h]\n  _TBYTE s1; // [rsp+11B0h] [rbp-FD8h]\n\n  v2 = a2[2];\n  v97 = a1;\n  v3 = *(char **)(a1 + 24);\n  v4 = a2[3];\n  v98 = a2;\n  v5 = qword_61C750;\n  v6 = *(char **)(a1 + 16);\n  while ( 1 )\n  {\nLABEL_2:\n    v7 = v4;\n    v8 = *(_QWORD *)(v5 + 40);\n    v9 = *(_QWORD *)(v5 + 32);\n    if ( v6 >= v3 )\n      v3 = v6;\n    if ( v2 >= v4 )\n      v7 = v2;\n    v10 = v3 - v6;\n    v11 = v7 - v2;\n    if ( byte_61CBA1 || *(_QWORD *)(v5 + 48) & 0xFFFFFFFFFF0000LL || *(_BYTE *)(v5 + 56) )\n      break;\n    if ( !v9 )\n    {\n      if ( !v10 )\n      {\n        v69 = -(v7 != v2);\n        goto LABEL_19;\n      }\n      if ( v11 )\n      {\n        if ( v8 )\n        {\n          while ( v6 < v3 && v2 < v7 )\n          {\n            v40 = *(unsigned __int8 *)(v8 + (unsigned __int8)*(++v6 - 1))\n                - *(unsigned __int8 *)(v8 + (unsigned __int8)*(++v2 - 1));\n            if ( v40 )\n            {\nLABEL_172:\n              v69 = v40;\n              v67 = v5;\n              goto LABEL_173;\n            }\n          }\n        }\n        else\n        {\n          v68 = v7 - v2;\n          if ( v10 <= v11 )\n            v68 = v3 - v6;\n          srcc = (char *)(v7 - v2);\n          v69 = memcmp(v6, v2, v68);\n          if ( v69 )\n            goto LABEL_35;\n          v10 = v3 - v6;\n          v11 = (size_t)srcc;\n        }\n        if ( v10 >= v11 )\n        {\n          v69 = v10 != v11;\n          goto LABEL_19;\n        }\n        v67 = v5;\n        v69 = -1;\n      }\n      else\n      {\n        v67 = v5;\n        v69 = 1;\n      }\nLABEL_173:\n      if ( !*(_BYTE *)(v67 + 55) )\n        return v69;\n      goto LABEL_174;\n    }\n    v38 = v6;\n    v39 = v6;\n    if ( v8 )\n    {\n      while ( 1 )\n      {\n        if ( v38 >= v3 || !*(_BYTE *)(v9 + (unsigned __int8)*v38) )\n        {\n          if ( v2 >= v7 )\n            goto LABEL_101;\n          while ( *(_BYTE *)(v9 + (unsigned __int8)*v2) )\n          {\n            if ( v7 == ++v2 )\n            {\n              v2 = v7;\n              goto LABEL_101;\n            }\n          }\n          if ( v3 <= v38 || v7 <= v2 )\n          {\nLABEL_101:\n            v41 = v38 < v3;\n            goto LABEL_102;\n          }\n          v40 = *(unsigned __int8 *)(v8 + (unsigned __int8)*v38) - *(unsigned __int8 *)(v8 + (unsigned __int8)*v2);\n          if ( v40 )\n            goto LABEL_172;\n          ++v2;\n        }\n        ++v38;\n      }\n    }\n    while ( 1 )\n    {\n      if ( v39 < v3 && *(_BYTE *)(v9 + (unsigned __int8)*v39) )\n        goto LABEL_92;\n      if ( v2 >= v7 )\n        break;\n      while ( *(_BYTE *)(v9 + (unsigned __int8)*v2) )\n      {\n        if ( v7 == ++v2 )\n        {\n          v2 = v7;\n          goto LABEL_154;\n        }\n      }\n      if ( v3 <= v39 || v7 <= v2 )\n        break;\n      v40 = (unsigned __int8)*v39 - (unsigned __int8)*v2;\n      if ( v40 )\n        goto LABEL_172;\n      ++v2;\nLABEL_92:\n      ++v39;\n    }\nLABEL_154:\n    v41 = v39 < v3;\nLABEL_102:\n    v69 = v41 - (v7 > v2);\nLABEL_19:\n    if ( v69 )\n      goto LABEL_35;\nLABEL_20:\n    v5 = *(_QWORD *)(v5 + 64);\n    if ( !v5 )\n      return v69;\n    v6 = *(char **)v97;\n    v15 = *(_QWORD *)(v97 + 8);\n    v2 = *v98;\n    if ( *(_QWORD *)(v5 + 16) == -1LL )\n    {\n      v3 = &v6[v15 - 1];\n      v4 = &v98[1][(_QWORD)v2 - 1];\n      if ( *(_QWORD *)v5 == -1LL )\n        goto LABEL_25;\nLABEL_23:\n      v6 = (char *)sub_406360(v6, v15, (__int64 *)v5);\n      v2 = (char *)sub_406360(v2, v17, (__int64 *)v5);\n    }\n    else\n    {\n      v3 = sub_406470(*(char **)v97, *(_QWORD *)(v97 + 8), v5);\n      v4 = sub_406470(v2, v16, v5);\n      if ( *(_QWORD *)v5 != -1LL )\n        goto LABEL_23;\nLABEL_25:\n      if ( *(_BYTE *)(v5 + 48) )\n      {\n        if ( v3 > v6 )\n        {\n          while ( byte_61CA80[(unsigned __int8)*v6] )\n          {\n            if ( v3 == ++v6 )\n            {\n              v6 = v3;\n              break;\n            }\n          }\n        }\n        if ( v4 > v2 )\n        {\n          while ( byte_61CA80[(unsigned __int8)*v2] )\n          {\n            if ( v4 == ++v2 )\n            {\n              v2 = v4;\n              goto LABEL_2;\n            }\n          }\n        }\n      }\n    }\n  }\n  v72 = v9 | v8;\n  if ( !(v9 | v8) )\n  {\n    v12 = *v3;\n    *v3 = 0;\n    v73 = v12;\n    v13 = *v7;\n    *v7 = 0;\n    v74 = v13;\n    goto LABEL_10;\n  }\n  v22 = v10 + v11 + 2;\n  if ( v22 <= 0xFA0 )\n  {\n    v23 = v136;\n    ptr = 0LL;\n    v24 = &v136[v10 + 1];\n    if ( v10 )\n      goto LABEL_44;\nLABEL_105:\n    *v23 = 0;\n    if ( !v11 )\n      goto LABEL_106;\nLABEL_52:\n    v28 = (unsigned __int8 *)&v2[v11];\n    v11 = 0LL;\n    while ( 2 )\n    {\n      v29 = *v2;\n      if ( !v9 )\n      {\nLABEL_58:\n        v29 = *(_BYTE *)(v8 + v29);\n        goto LABEL_55;\n      }\n      if ( !*(_BYTE *)(v9 + v29) )\n      {\n        if ( v8 )\n          goto LABEL_58;\nLABEL_55:\n        v24[v11++] = v29;\n      }\n      if ( v28 == (unsigned __int8 *)++v2 )\n      {\n        v30 = &v24[v11];\n        goto LABEL_60;\n      }\n      continue;\n    }\n  }\n  srch = (char *)(v7 - v2);\n  v44 = sub_411210(v22);\n  v10 = v3 - v6;\n  v11 = (size_t)srch;\n  v23 = (char *)v44;\n  ptr = (void *)v44;\n  v24 = (char *)(v44 + v3 - v6 + 1);\n  if ( v3 == v6 )\n    goto LABEL_105;\nLABEL_44:\n  v25 = &v6[v10];\n  v26 = v6;\n  v10 = 0LL;\n  while ( 2 )\n  {\n    v27 = *v26;\n    if ( !v9 )\n    {\nLABEL_50:\n      v27 = *(_BYTE *)(v8 + v27);\n      goto LABEL_47;\n    }\n    if ( !*(_BYTE *)(v9 + v27) )\n    {\n      if ( v8 )\n        goto LABEL_50;\nLABEL_47:\n      v23[v10++] = v27;\n    }\n    if ( v25 != ++v26 )\n      continue;\n    break;\n  }\n  v23[v10] = 0;\n  if ( v11 )\n    goto LABEL_52;\nLABEL_106:\n  v30 = v24;\nLABEL_60:\n  *v30 = 0;\n  v2 = v24;\n  v6 = v23;\nLABEL_10:\n  if ( *(_BYTE *)(v5 + 50) )\n  {\n    for ( i = v6; byte_61CA80[(unsigned __int8)*i]; ++i )\n      ;\n    for ( j = v2; byte_61CA80[(unsigned __int8)*j]; ++j )\n      ;\n    v87 = v11;\n    srce = (char *)v10;\n    v21 = sub_4106A0(i, j, (unsigned int)dword_61CBA8, (unsigned int)dword_61CBA4);\n    v10 = (size_t)srce;\n    v11 = v87;\n    v69 = v21;\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 52) )\n  {\n    v88 = v11;\n    srcf = (char *)v10;\n    v70 = strtold(v6, &endptr);\n    v31 = strtold(v2, &v112);\n    v10 = (size_t)srcf;\n    v11 = v88;\n    if ( v6 == endptr )\n    {\n      v69 = -(v112 != v2);\n      goto LABEL_17;\n    }\n    if ( v2 == v112 )\n    {\n      v69 = 1;\n      goto LABEL_17;\n    }\n    if ( v31 <= v70 )\n    {\n      v32 = v70;\n      v69 = 1;\n      if ( v32 > v31 )\n        goto LABEL_17;\n      if ( v32 == v31 )\n      {\n        v69 = 0;\n        goto LABEL_17;\n      }\n    }\n    v69 = -1;\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 53) )\n  {\n    for ( k = v6; byte_61CA80[(unsigned __int8)*k]; ++k )\n      ;\n    for ( l = v2; byte_61CA80[(unsigned __int8)*l]; ++l )\n      ;\n    v89 = v11;\n    src = (char *)v10;\n    v35 = sub_4059F0(k);\n    v36 = sub_4059F0(l);\n    v11 = v89;\n    v10 = (size_t)src;\n    v69 = v35 - v36;\n    if ( v35 == v36 )\n    {\n      v37 = sub_4106A0(k, l, (unsigned int)dword_61CBA8, (unsigned int)dword_61CBA4);\n      v11 = v89;\n      v10 = (size_t)src;\n      v69 = v37;\n    }\n    goto LABEL_17;\n  }\n  if ( *(_BYTE *)(v5 + 54) )\n  {\n    v90 = v11;\n    srcg = (char *)v10;\n    v42 = sub_405A40((unsigned __int8 *)v6, 0LL);\n    v43 = sub_405A40((unsigned __int8 *)v2, 0LL);\n    v10 = (size_t)srcg;\n    v11 = v90;\n    v69 = v42 - v43;\n    goto LABEL_17;\n  }\n  if ( !*(_BYTE *)(v5 + 51) )\n  {\n    if ( *(_BYTE *)(v5 + 56) )\n    {\n      v86 = v11;\n      srcd = (char *)v10;\n      v14 = sub_40B900(v6, v2);\n      v10 = (size_t)srcd;\n      v11 = v86;\n      v69 = v14;\n    }\n    else if ( v10 )\n    {\n      v69 = 1;\n      if ( v11 )\n      {\n        v93 = v11;\n        srci = (char *)v10;\n        v63 = sub_4115C0(v6, v10 + 1, v2, v11 + 1);\n        v11 = v93;\n        v10 = (size_t)srci;\n        v69 = v63;\n      }\n    }\n    else\n    {\n      v69 = -(v11 != 0);\n    }\n    goto LABEL_17;\n  }\n  v125 = _mm_load_si128((const __m128i *)&xmmword_61C600);\n  v126 = _mm_load_si128((const __m128i *)&xmmword_61C610);\n  v127 = _mm_load_si128((const __m128i *)&xmmword_61C620);\n  v128 = _mm_load_si128((const __m128i *)&xmmword_61C630);\n  v129 = _mm_load_si128((const __m128i *)&xmmword_61C640);\n  v130 = _mm_load_si128((const __m128i *)&xmmword_61C650);\n  v131 = _mm_load_si128((const __m128i *)&xmmword_61C660);\n  v132 = _mm_load_si128((const __m128i *)&xmmword_61C670);\n  v133 = _mm_load_si128((const __m128i *)&xmmword_61C680);\n  v134 = qword_61C690;\n  v135 = dword_61C698;\n  v114 = v125;\n  v115 = v126;\n  v116 = v127;\n  v117 = v128;\n  v118 = v129;\n  v119 = v130;\n  v120 = v131;\n  v121 = v132;\n  v122 = v133;\n  v123 = qword_61C690;\n  v124 = dword_61C698;\n  if ( !byte_61CBA1 )\n  {\n    v71 = v11;\n    v94 = v10;\n    sub_40B360(v6, v10);\n    sub_40B250(&v114, &v112);\n    srcb = (char *)v71;\n    sub_40B360(v2, v71);\n    sub_40B250(&v125, &v113);\n    v64 = memcmp(&v112, &v113, 0x10uLL);\n    v62 = v71;\n    v61 = (char *)v94;\n    v69 = v64;\n    if ( !v64 )\n    {\n      v49 = v94;\n      v46 = v6;\n      s2 = v2;\n      v102 = 0LL;\n      goto LABEL_162;\n    }\n    v102 = 0LL;\n    goto LABEL_167;\n  }\n  v69 = 0;\n  v45 = v6;\n  v46 = (char *)&s1;\n  v91 = &v6[v10];\n  v99 = (unsigned __int8 *)&v2[v11];\n  v106 = v6;\n  v102 = 0LL;\n  v107 = v5;\n  v109 = v10;\n  v110 = v11;\n  size = 3 * (v10 + v11) + 2;\n  srca = v2;\n  v108 = v2;\n  v47 = 4000LL;\nLABEL_111:\n  if ( size > v47 )\n  {\n    while ( 1 )\n    {\n      v46 = (char *)&s1;\n      v51 = (3 * v47) >> 1;\n      if ( size >= v51 )\n        v51 = size;\n      v47 = v51;\n      free(v102);\n      v52 = (char *)malloc(v47);\n      v102 = v52;\n      if ( !v52 )\n        v47 = 4000LL;\n      if ( v52 )\n        v46 = v52;\n      if ( v91 <= v45 )\n        goto LABEL_113;\nLABEL_131:\n      v53 = sub_405EF0(v46, v45, v47);\n      v49 = v53 + 1;\n      if ( v99 > (unsigned __int8 *)srca )\n        break;\n      v56 = v53 + 1;\n      v48 = 0LL;\n      if ( v47 < v49 )\n        goto LABEL_135;\nLABEL_176:\n      if ( v47 < v56 )\n        goto LABEL_135;\nLABEL_115:\n      s2 = &v46[v49];\n      if ( v91 <= v45 )\n      {\n        if ( v99 <= (unsigned __int8 *)srca )\n          goto LABEL_150;\n        goto LABEL_148;\n      }\n      v45 += strlen(v45) + 1;\n      if ( v99 > (unsigned __int8 *)srca )\n        goto LABEL_148;\nLABEL_117:\n      if ( v91 <= v45 && v99 <= (unsigned __int8 *)srca )\n      {\nLABEL_150:\n        srcb = (char *)v48;\n        v6 = v106;\n        v2 = v108;\n        v58 = (char *)v109;\n        v59 = v110;\n        v5 = v107;\n        goto LABEL_142;\n      }\n      sub_40B360(v46, v49);\n      sub_40B360(s2, v48);\n      if ( v69 )\n        goto LABEL_111;\n      v50 = v48;\n      if ( v49 <= v48 )\n        v50 = v49;\n      v69 = memcmp(v46, s2, v50);\n      if ( v69 )\n        goto LABEL_111;\n      v69 = (v49 > v48) - (v49 < v48);\n      if ( size <= v47 )\n        goto LABEL_112;\n    }\n    if ( v47 >= v49 )\n    {\n      v55 = &v46[v49];\n      v54 = v47 - v49;\n    }\n    else\n    {\n      v54 = 0LL;\n      v55 = 0LL;\n    }\n  }\n  else\n  {\nLABEL_112:\n    if ( v91 > v45 )\n      goto LABEL_131;\nLABEL_113:\n    if ( v99 <= (unsigned __int8 *)srca )\n    {\n      v48 = 0LL;\n      v49 = 0LL;\n      goto LABEL_115;\n    }\n    v55 = v46;\n    v54 = v47;\n    v49 = 0LL;\n  }\n  v48 = sub_405EF0(v55, srca, v54) + 1;\n  v56 = v48 + v49;\n  if ( v47 >= v49 )\n    goto LABEL_176;\nLABEL_135:\n  if ( v56 <= 0x5555555555555554LL )\n    v56 = (3 * v56) >> 1;\n  free(v102);\n  v57 = (char *)sub_411210(v56);\n  v46 = v57;\n  if ( v91 > v45 )\n    strxfrm(v57, v45, v49);\n  s2 = &v46[v49];\n  if ( v99 > (unsigned __int8 *)srca )\n  {\n    strxfrm(&v46[v49], srca, v48);\n    if ( v91 > v45 )\n      v45 += strlen(v45) + 1;\n    v102 = v46;\n    v47 = v56;\nLABEL_148:\n    srca += strlen(srca) + 1;\n    goto LABEL_117;\n  }\n  if ( v91 > v45 )\n  {\n    v47 = v56;\n    v102 = v46;\n    v45 += strlen(v45) + 1;\n    goto LABEL_117;\n  }\n  v102 = v46;\n  v6 = v106;\n  srcb = (char *)v48;\n  v2 = v108;\n  v58 = (char *)v109;\n  v59 = v110;\n  v5 = v107;\nLABEL_142:\n  v100 = v59;\n  v92 = v58;\n  sub_40B360(v46, v49);\n  sub_40B250(&v114, &v112);\n  sub_40B360(s2, (size_t)srcb);\n  sub_40B250(&v125, &v113);\n  v60 = memcmp(&v112, &v113, 0x10uLL);\n  v61 = v92;\n  v62 = v100;\n  if ( v60 )\n  {\nLABEL_166:\n    v69 = v60;\n  }\n  else if ( !v69 )\n  {\nLABEL_162:\n    v101 = v62;\n    v95 = v61;\n    v65 = (size_t)srcb;\n    if ( v49 <= (unsigned __int64)srcb )\n      v65 = v49;\n    v66 = memcmp(v46, s2, v65);\n    v61 = v95;\n    v62 = v101;\n    v69 = v66;\n    if ( !v66 )\n    {\n      v60 = (v49 > (unsigned __int64)srcb) - (v49 < (unsigned __int64)srcb);\n      goto LABEL_166;\n    }\n  }\nLABEL_167:\n  v96 = v62;\n  srcj = v61;\n  free(v102);\n  v10 = (size_t)srcj;\n  v11 = v96;\nLABEL_17:\n  if ( !v72 )\n  {\n    v6[v10] = v73;\n    v2[v11] = v74;\n    goto LABEL_19;\n  }\n  free(ptr);\n  if ( !v69 )\n    goto LABEL_20;\nLABEL_35:\n  if ( *(_BYTE *)(v5 + 55) )\nLABEL_174:\n    v69 = -v69;\n  return v69;\n}\n", 
            "funcStartAddr": "0x4065b0L", 
            "funcEndAddr": "0x4074c8L", 
            "funcName": "sub_4065B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4074D0(char **a1, FILE *a2, char *a3)\n{\n  char *v3; // r9\n  __int64 v4; // rbx\n  __int64 v5; // rbp\n  __int64 v6; // r15\n  size_t v7; // rdx\n  char *v8; // rax\n  unsigned __int64 v9; // rbp\n  __int64 v10; // r12\n  __int64 v11; // rsi\n  char *v12; // r12\n  char **v13; // r13\n  unsigned __int64 v14; // r12\n  char *v15; // r15\n  char **v16; // r14\n  char *v17; // r13\n  size_t v18; // rax\n  unsigned __int64 v19; // r11\n  char *v20; // rax\n  __int64 v21; // r10\n  __int64 v22; // r15\n  char *v23; // rax\n  unsigned __int64 v24; // r11\n  bool v25; // zf\n  char *v26; // rax\n  char **v27; // r13\n  char *v28; // r14\n  char *v29; // r15\n  char *v30; // rdi\n  unsigned __int64 v31; // rdx\n  __int64 v32; // rax\n  unsigned __int64 v33; // rax\n  __int64 v34; // rax\n  char *v35; // rax\n  __int64 v36; // rax\n  __int64 result; // rax\n  char *v38; // rax\n  __int64 v39; // rdx\n  __int64 v40; // rcx\n  __int64 v41; // r8\n  char *v42; // [rsp+0h] [rbp-78h]\n  char *v43; // [rsp+8h] [rbp-70h]\n  unsigned __int64 v44; // [rsp+10h] [rbp-68h]\n  FILE *stream; // [rsp+20h] [rbp-58h]\n  __int64 *v46; // [rsp+28h] [rbp-50h]\n  char v47; // [rsp+37h] [rbp-41h]\n  char *v48; // [rsp+38h] [rbp-40h]\n\n  if ( *((_BYTE *)a1 + 48) )\n    return 0LL;\n  v3 = a1[1];\n  v4 = qword_61C750;\n  v5 = qword_61C428;\n  v6 = (__int64)*a1;\n  stream = a2;\n  v48 = a3;\n  v7 = (size_t)a1[4];\n  v46 = (__int64 *)a1;\n  v47 = byte_61C500;\n  v42 = a1[5];\n  if ( v3 == (char *)v7 )\n  {\n    v8 = a1[2];\n  }\n  else\n  {\n    memmove((void *)v6, &v3[v6 - v7], v7);\n    v3 = a1[4];\n    v6 = (__int64)*a1;\n    a1[2] = 0LL;\n    a1[1] = v3;\n    v8 = 0LL;\n  }\n  v9 = v5 - 34;\n  v44 = (unsigned __int64)(v42 + 1);\n  v10 = (__int64)a1[3];\n  v11 = (unsigned int)v47;\n  while ( 1 )\n  {\n    v12 = (char *)(v6 + v10);\n    v13 = (char **)&v12[-32 * (_QWORD)v8];\n    v14 = &v12[-((_QWORD)v8 * (_QWORD)v42)] - &v3[v6];\n    if ( v8 )\n    {\n      v15 = &v3[v6];\n      v16 = v13;\n      v17 = &v13[1][(_QWORD)*v13];\n    }\n    else\n    {\n      v35 = (char *)v6;\n      v15 = &v3[v6];\n      v16 = v13;\n      v17 = v35;\n    }\n    while ( v14 > v44 )\n    {\n      v18 = fread_unlocked(v15, 1uLL, (v14 - 1) / v44, stream);\n      v19 = (v14 - 1) / v44;\n      v14 -= v18;\n      v43 = &v15[v18];\n      if ( v19 == v18 )\n        goto LABEL_49;\n      if ( stream->_flags & 0x20 )\n      {\n        v38 = dcgettext(0LL, \"read failed\", 5);\n        sub_405DD0((__int64)v38, v48, v39, v40, v41);\n      }\n      if ( !(stream->_flags & 0x10) )\n        goto LABEL_49;\n      *((_BYTE *)v46 + 48) = 1;\n      v20 = &v15[v18];\n      if ( (char *)*v46 == v43 )\n        return 0LL;\n      if ( v17 != v43 && *(v43 - 1) != v47 )\n      {\n        *v43 = v47;\n        v21 = (__int64)v15;\n        ++v43;\n        v22 = (__int64)(v20 + 1);\n      }\n      else\n      {\nLABEL_49:\n        v21 = (__int64)v15;\n        v22 = (__int64)v43;\n      }\n      while ( 1 )\n      {\n        v11 = (unsigned int)v47;\n        v23 = (char *)sub_413030(v21, v11, v22 - v21);\n        if ( !v23 )\n          break;\n        v21 = (__int64)(v23 + 1);\n        v16 -= 4;\n        *v23 = 0;\n        *v16 = v17;\n        v24 = v23 + 1 - v17;\n        v16[1] = (char *)v24;\n        if ( v9 < v24 )\n          v9 = v23 + 1 - v17;\n        v14 -= (unsigned __int64)v42;\n        if ( v4 )\n        {\n          if ( *(_QWORD *)(v4 + 16) != -1LL )\n            v23 = sub_406470(v17, v23 + 1 - v17, v4);\n          v25 = *(_QWORD *)v4 == -1LL;\n          v16[3] = v23;\n          if ( v25 )\n          {\n            if ( *(_BYTE *)(v4 + 48) )\n            {\n              while ( byte_61CA80[(unsigned __int8)*v17] )\n                ++v17;\n            }\n            v16[2] = v17;\n          }\n          else\n          {\n            v16[2] = (char *)sub_406360(v17, v24, (__int64 *)v4);\n          }\n        }\n        v17 = (char *)v21;\n      }\n      v15 = v43;\n      if ( *((_BYTE *)v46 + 48) )\n        break;\n    }\n    v26 = v17;\n    v27 = v16;\n    v28 = v15;\n    v29 = v26;\n    v30 = (char *)*v46;\n    v31 = v46[3];\n    v46[1] = (__int64)&v28[-*v46];\n    v32 = (&v30[v31] - (char *)v27) >> 5;\n    v46[2] = v32;\n    if ( v32 )\n      break;\n    v33 = v31 >> 5;\n    if ( v30 )\n    {\n      v11 = 6148914691236517183LL;\n      if ( v31 > 0x555555555555553FLL )\n        goto LABEL_46;\n      v10 = 32 * (v33 + (v31 >> 6) + 1);\n    }\n    else if ( v31 <= 0x1F )\n    {\n      v10 = 128LL;\n    }\n    else\n    {\n      v36 = 32 * v33;\n      if ( v36 < 0 )\nLABEL_46:\n        sub_411460(v30, v11, v31);\n      v10 = v36;\n    }\n    v11 = v10;\n    v34 = sub_411270(v30, v10);\n    v6 = v34;\n    *v46 = v34;\n    v3 = (char *)v46[1];\n    v46[3] = v10;\n    v8 = (char *)v46[2];\n  }\n  result = 1LL;\n  qword_61C428 = v9 + 34;\n  v46[4] = v28 - v29;\n  return result;\n}\n", 
            "funcStartAddr": "0x4074d0L", 
            "funcEndAddr": "0x407847L", 
            "funcName": "sub_4074D0"
        }, 
        {
            "decompiledFuncCode": "_BOOL8 __fastcall sub_407850(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  _BOOL8 result; // rax\n\n  v2 = *(_DWORD *)(a2 + 80);\n  if ( *(_DWORD *)(a1 + 80) == v2 )\n    result = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 48) < *(_QWORD *)(a2 + 40) + *(_QWORD *)(a2 + 48);\n  else\n    result = *(_DWORD *)(a1 + 80) < v2;\n  return result;\n}\n", 
            "funcStartAddr": "0x407850L", 
            "funcEndAddr": "0x40787dL", 
            "funcName": "sub_407850"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_407880(__int64 a1)\n{\n  return pthread_sigmask(2, (const __sigset_t *)(a1 + 8), 0LL);\n}\n", 
            "funcStartAddr": "0x407880L", 
            "funcEndAddr": "0x407890L", 
            "funcName": "sub_407880"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_407890()\n{\n  int v0; // eax\n  const char *v1; // rbx\n  char v2; // al\n  char v4; // [rsp+0h] [rbp-98h]\n  __sigset_t oldmask; // [rsp+8h] [rbp-90h]\n\n  if ( !ptr )\n    return sub_40A9F0();\n  v0 = pthread_sigmask(0, &set, &oldmask);\n  v1 = (const char *)ptr;\n  v2 = v0 == 0;\n  v4 = v2;\n  if ( ptr )\n  {\n    do\n    {\n      unlink(v1 + 13);\n      v1 = *(const char **)v1;\n    }\n    while ( v1 );\n    v2 = v4;\n  }\n  ptr = 0LL;\n  if ( !v2 )\n    return sub_40A9F0();\n  sub_407880((__int64)&v4);\n  return sub_40A9F0();\n}\n", 
            "funcStartAddr": "0x407890L", 
            "funcEndAddr": "0x40791eL", 
            "funcName": "sub_407890"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_407920(char *name)\n{\n  __int64 *v1; // r13\n  char *v2; // rbx\n  char *i; // rax\n  __int64 v4; // r12\n  int v5; // er14\n  int *v6; // rax\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  bool v9; // zf\n  int v10; // er15\n  __int64 v11; // rbp\n  char *v12; // rax\n  bool v13; // [rsp+0h] [rbp-C8h]\n  __sigset_t oldmask; // [rsp+8h] [rbp-C0h]\n\n  v1 = (__int64 *)&ptr;\n  v2 = (char *)ptr;\n  if ( name != (char *)ptr + 13 )\n  {\n    for ( i = *(char **)ptr; i + 13 != name; i = *(char **)i )\n      v2 = i;\n    v1 = (__int64 *)v2;\n    v2 = i;\n  }\n  if ( v2[12] == 1 )\n    sub_4060A0(*((_DWORD *)v2 + 2));\n  v4 = *(_QWORD *)v2;\n  v13 = pthread_sigmask(0, &set, &oldmask) == 0;\n  v5 = unlink(name);\n  v6 = __errno_location();\n  v9 = !v13;\n  v10 = *v6;\n  *v1 = v4;\n  if ( v9 )\n  {\n    if ( !v5 )\n      goto LABEL_9;\nLABEL_12:\n    v11 = sub_40F700(0LL, 3LL, name, v7, v8);\n    v12 = dcgettext(0LL, \"warning: cannot remove: %s\", 5);\n    error(0, v10, v12, v11);\n    if ( v4 )\n      goto LABEL_10;\nLABEL_13:\n    off_61C418 = v1;\n    goto LABEL_10;\n  }\n  sub_407880((__int64)&v13);\n  if ( v5 )\n    goto LABEL_12;\nLABEL_9:\n  if ( !v4 )\n    goto LABEL_13;\nLABEL_10:\n  free(v2);\n}\n", 
            "funcStartAddr": "0x407920L", 
            "funcEndAddr": "0x407a2dL", 
            "funcName": "sub_407920"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_407A30(int *a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  int *v3; // rbp\n  int v4; // eax\n  void *v5; // r12\n  __pid_t v6; // eax\n  int v7; // er15\n  unsigned int v8; // er13\n  double v10; // [rsp+8h] [rbp-E0h]\n  __pid_t v11; // [rsp+14h] [rbp-D4h]\n  bool v12; // [rsp+20h] [rbp-C8h]\n  __sigset_t oldmask; // [rsp+28h] [rbp-C0h]\n\n  if ( (int)sub_40DA00(a1) < 0 )\n    return (unsigned int)-1;\n  if ( dword_61C420 + 1 < (unsigned int)dword_61C69C )\n  {\n    sub_405FB0(-1);\n    while ( dword_61C69C > 0 && (unsigned int)sub_405FB0(0) )\n      ;\n  }\n  v2 = a2 - 1;\n  v3 = __errno_location();\n  v10 = 0.25;\n  while ( 1 )\n  {\n    v4 = pthread_sigmask(0, &set, &oldmask);\n    v5 = ptr;\n    ptr = 0LL;\n    v12 = v4 == 0;\n    v6 = fork();\n    v7 = *v3;\n    v8 = v6;\n    if ( v6 )\n    {\n      ptr = v5;\n      if ( !v12 )\n        goto LABEL_5;\n    }\n    else if ( !v12 )\n    {\n      goto LABEL_19;\n    }\n    v11 = v6;\n    sub_407880((__int64)&v12);\n    v6 = v11;\nLABEL_5:\n    *v3 = v7;\n    if ( v6 >= 0 )\n      break;\n    if ( v7 != 11 )\n      goto LABEL_18;\n    sub_411620(v10);\n    v10 = v10 + v10;\n    while ( dword_61C69C > 0 && (unsigned int)sub_405FB0(0) )\n      ;\n    if ( --v2 == -1 )\n    {\n      v7 = *v3;\nLABEL_18:\n      close(*a1);\n      close(a1[1]);\n      *v3 = v7;\n      return v8;\n    }\n  }\n  if ( v6 )\n  {\n    ++dword_61C69C;\n    return v8;\n  }\nLABEL_19:\n  v8 = 0;\n  close(0);\n  close(1);\n  return v8;\n}\n", 
            "funcStartAddr": "0x407a30L", 
            "funcEndAddr": "0x407bf4L", 
            "funcName": "sub_407A30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_407C00(char *a1, _QWORD *a2, const char *a3)\n{\n  const char *v3; // r12\n  __int64 v5; // rbp\n  char *v6; // rbx\n  char *v7; // rax\n  __int64 v8; // [rsp+0h] [rbp-28h]\n  __int64 v9; // [rsp+8h] [rbp-20h]\n\n  v3 = a3;\n  switch ( (unsigned int)sub_411B40(a1) )\n  {\n    case 0u:\n    case 2u:\n      *a2 = v9;\n      return v8;\n    case 1u:\n    case 3u:\n      *a2 = -1LL;\n      return v8;\n    case 4u:\n      if ( !v3 )\n        return 0LL;\n      v5 = sub_40F880(a1);\n      v6 = dcgettext(0LL, v3, 5);\n      v7 = dcgettext(0LL, \"%s: invalid count at start of %s\", 5);\n      error(2, 0, v7, v6, v5);\n      return sub_407CD0((char *)2, 0LL);\n    default:\n      return v8;\n  }\n}\n", 
            "funcStartAddr": "0x407c00L", 
            "funcEndAddr": "0x407cd0L", 
            "funcName": "sub_407C00"
        }, 
        {
            "decompiledFuncCode": "_IO_FILE *__fastcall sub_407CD0(char *file, char *modes)\n{\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  FILE *v5; // rbx\n  int v6; // eax\n  __int64 v7; // rbp\n  char *v8; // rbx\n  int *v9; // rax\n\n  if ( *modes != 114 )\n  {\n    if ( *modes == 119 )\n    {\n      if ( !file || !ftruncate(1, 0LL) )\n        return stdout;\n      v7 = sub_40F700(0LL, 3LL, file, v2, v3);\n      v8 = dcgettext(0LL, \"%s: error truncating\", 5);\n      v9 = __errno_location();\n      error(2, *v9, v8, v7);\n    }\n    __assert_fail(\"!\\\"unexpected mode passed to stream_open\\\"\", \"src/sort.c\", 0x3CCu, \"stream_open\");\n  }\n  if ( !strcmp(file, \"-\") )\n  {\n    byte_61C758 = 1;\n    v5 = stdin;\n  }\n  else\n  {\n    v5 = 0LL;\n    v6 = open(file, 0x80000);\n    if ( v6 >= 0 )\n      v5 = fdopen(v6, modes);\n  }\n  sub_40B800(v5, 2LL);\n  return v5;\n}\n", 
            "funcStartAddr": "0x407cd0L", 
            "funcEndAddr": "0x407dccL", 
            "funcName": "sub_407CD0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_407DD0(char *a1)\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n\n  v1 = dcgettext(0LL, \"open failed\", 5);\n  sub_405DD0((__int64)v1, a1, v2, v3, v4);\n}\n", 
            "funcStartAddr": "0x407dd0L", 
            "funcEndAddr": "0x407df0L", 
            "funcName": "sub_407DD0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_407DF0(FILE *stream, char *a2)\n{\n  char *v2; // rbp\n  int v3; // eax\n  const char *v4; // rsi\n  char *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n\n  v2 = a2;\n  v3 = fileno(stream);\n  if ( v3 )\n  {\n    if ( v3 != 1 )\n    {\n      if ( !(unsigned int)sub_411F80(stream) )\n        return;\n      v4 = \"close failed\";\nLABEL_10:\n      v5 = dcgettext(0LL, v4, 5);\n      sub_405DD0((__int64)v5, v2, v6, v7, v8);\n    }\n    if ( fflush_unlocked(stream) )\n    {\n      v4 = \"fflush failed\";\n      goto LABEL_10;\n    }\n  }\n  else if ( stream->_flags & 0x10 )\n  {\n    clearerr_unlocked(stream);\n  }\n}\n", 
            "funcStartAddr": "0x407df0L", 
            "funcEndAddr": "0x407e6cL", 
            "funcName": "sub_407DF0"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_407E70(__int64 a1, FILE *a2, char *a3)\n{\n  char *v3; // r14\n  _IO_FILE *v4; // rbp\n  char *v5; // rbx\n  __int64 v6; // r15\n  char *v7; // r12\n  size_t v8; // rdx\n  char *v9; // rdi\n  char *v10; // rax\n  unsigned __int8 v11; // si\n  char *v12; // rdx\n  char *v13; // rax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  char v17; // al\n  __int64 v18; // r12\n  char *v19; // r14\n  __int64 v20; // r10\n  unsigned __int8 *v21; // rbp\n  __int64 v22; // r11\n  char v23; // r15\n  unsigned __int8 *v24; // rax\n  unsigned __int8 *v25; // rax\n  __int64 v26; // r15\n  __int64 v27; // rbx\n  char *v28; // rax\n  char *v29; // rax\n  char *v30; // rax\n  char *v31; // rax\n  __int64 v32; // rdx\n  __int64 v33; // rcx\n  __int64 v34; // r8\n  char *v36; // [rsp+0h] [rbp-48h]\n  unsigned __int8 *v37; // [rsp+8h] [rbp-40h]\n\n  v3 = a3;\n  v4 = a2;\n  v5 = *(char **)a1;\n  v6 = *(_QWORD *)(a1 + 8);\n  v7 = (char *)(*(_QWORD *)a1 + v6);\n  if ( !a3 && byte_61C740 )\n  {\n    if ( v5 >= v7 )\n      goto LABEL_18;\n    while ( 1 )\n    {\n      v17 = *(++v5 - 1);\n      if ( v17 == 9 )\n      {\n        v11 = 62;\n        v17 = 62;\n        v12 = v4->_IO_write_ptr;\n        if ( v4->_IO_write_end <= v12 )\n          goto LABEL_15;\n      }\n      else\n      {\n        v11 = *(v5 - 1);\n        if ( v7 == v5 )\n        {\n          v11 = 10;\n          v17 = 10;\n        }\n        v12 = v4->_IO_write_ptr;\n        if ( v4->_IO_write_end <= v12 )\n        {\nLABEL_15:\n          if ( __overflow(v4, v11) == -1 )\n          {\n            v13 = dcgettext(0LL, \"write failed\", 5);\n            sub_405DD0((__int64)v13, 0LL, v14, v15, v16);\n          }\n          goto LABEL_12;\n        }\n      }\n      v4->_IO_write_ptr = v12 + 1;\n      *v12 = v17;\nLABEL_12:\n      if ( v7 == v5 )\n      {\n        v5 = *(char **)a1;\n        v6 = *(_QWORD *)(a1 + 8);\nLABEL_18:\n        v18 = qword_61C750;\n        v19 = &v5[v6 - 1];\n        if ( !qword_61C750 )\n        {\n          v21 = (unsigned __int8 *)v5;\n          goto LABEL_39;\n        }\n        while ( 2 )\n        {\n          v20 = *(_QWORD *)v18;\n          if ( *(_QWORD *)v18 == -1LL )\n          {\n            v21 = (unsigned __int8 *)v5;\n            if ( *(_QWORD *)(v18 + 16) != -1LL )\nLABEL_21:\n              v19 = sub_406470(v5, v6, v18);\n            if ( *(_BYTE *)(v18 + 48) && v20 == -1 )\n            {\nLABEL_26:\n              v23 = *v19;\n              for ( *v19 = 0; byte_61CA80[*v21]; ++v21 )\n                ;\n              v36 = (char *)v21;\n              if ( v21 > (unsigned __int8 *)v19 )\n                goto LABEL_55;\n              if ( *(_BYTE *)(v18 + 54) )\n              {\n                sub_405A40(v21, &v36);\n              }\n              else if ( *(_BYTE *)(v18 + 52) )\n              {\n                strtold((const char *)v21, &v36);\n              }\n              else\n              {\n                if ( *(_QWORD *)(v18 + 48) & 0xFF0000FF0000LL )\n                {\n                  v24 = v21;\n                  if ( v21 < (unsigned __int8 *)v19 )\n                    v24 = &v21[*v21 == 45];\n                  v37 = v24;\n                  if ( (unsigned __int8)sub_405930(&v37) > 0x2Fu )\n                  {\n                    v25 = v37;\n                    if ( *(_BYTE *)(v18 + 53) )\n                      v25 = &v37[-((unsigned __int8)byte_4149C0[*v37] < 1u) + 1];\n                    v36 = (char *)v25;\n                  }\n                  goto LABEL_38;\n                }\nLABEL_55:\n                v36 = v19;\n              }\nLABEL_38:\n              *v19 = v23;\n              v19 = v36;\n              goto LABEL_39;\n            }\n          }\n          else\n          {\n            v21 = (unsigned __int8 *)sub_406360(v5, v6, (__int64 *)v18);\n            if ( v22 != -1 )\n              goto LABEL_21;\n          }\n          if ( *(_BYTE *)(v18 + 54) || *(_QWORD *)(v18 + 48) & 0xFFFF00FF0000LL )\n            goto LABEL_26;\n          while ( 1 )\n          {\nLABEL_39:\n            v26 = sub_405EB0(v5, (unsigned __int64)v21);\n            v27 = sub_405EB0((char *)v21, (unsigned __int64)v19);\n            while ( --v26 != -1 )\n            {\n              v28 = stdout->_IO_write_ptr;\n              if ( v28 >= stdout->_IO_write_end )\n              {\n                __overflow(stdout, 32);\n              }\n              else\n              {\n                stdout->_IO_write_ptr = v28 + 1;\n                *v28 = 32;\n              }\n            }\n            if ( v27 )\n            {\n              do\n              {\n                v29 = stdout->_IO_write_ptr;\n                if ( v29 >= stdout->_IO_write_end )\n                {\n                  __overflow(stdout, 95);\n                }\n                else\n                {\n                  stdout->_IO_write_ptr = v29 + 1;\n                  *v29 = 95;\n                }\n                --v27;\n              }\n              while ( v27 );\n              v10 = stdout->_IO_write_ptr;\n              if ( v10 >= stdout->_IO_write_end )\n              {\n                LODWORD(v10) = __overflow(stdout, 10);\n              }\n              else\n              {\n                stdout->_IO_write_ptr = v10 + 1;\n                *v10 = 10;\n              }\n            }\n            else\n            {\n              v30 = dcgettext(0LL, \"^ no match for key\\n\", 5);\n              LODWORD(v10) = __printf_chk(1LL, v30);\n            }\n            if ( !v18 )\n              return (int)v10;\n            v18 = *(_QWORD *)(v18 + 64);\n            if ( v18 )\n              break;\n            if ( byte_61C759 || byte_61C75A )\n              return (int)v10;\n            v21 = *(unsigned __int8 **)a1;\n            v5 = *(char **)a1;\n            v19 = (char *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 8) - 1LL);\n          }\n          v5 = *(char **)a1;\n          v6 = *(_QWORD *)(a1 + 8);\n          v19 = (char *)(*(_QWORD *)a1 + v6 - 1);\n          continue;\n        }\n      }\n    }\n  }\n  v8 = *(_QWORD *)(a1 + 8);\n  v9 = *(char **)a1;\n  *(v7 - 1) = byte_61C500;\n  v10 = (char *)fwrite_unlocked(v9, 1uLL, v8, a2);\n  if ( (char *)v6 != v10 )\n  {\n    v31 = dcgettext(0LL, \"write failed\", 5);\n    sub_405DD0((__int64)v31, v3, v32, v33, v34);\n  }\n  *(v7 - 1) = 0;\n  return (int)v10;\n}\n", 
            "funcStartAddr": "0x407e70L", 
            "funcEndAddr": "0x408297L", 
            "funcName": "sub_407E70"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_4082A0(const void **a1, _QWORD *a2)\n{\n  _QWORD *v2; // rbp\n  const void **v3; // rbx\n  int result; // eax\n  char *v5; // r12\n  char *v6; // r14\n  unsigned __int64 v7; // r13\n  unsigned __int64 v8; // r15\n  char *v9; // rsi\n  const void *v10; // rdi\n  size_t v11; // rdx\n\n  v2 = a2;\n  v3 = a1;\n  if ( !qword_61C750 || (result = sub_4065B0((__int64)a1, (char **)a2)) == 0 && !byte_61C759 && !byte_61C75A )\n  {\n    v5 = (char *)a1[1];\n    v6 = (char *)a2[1];\n    v7 = (unsigned __int64)(v6 - 1);\n    v8 = (unsigned __int64)a1[1] - 1;\n    if ( a1[1] == (const void *)1 )\n    {\n      result = -(v6 != (char *)1);\n    }\n    else\n    {\n      result = 1;\n      if ( v6 != (char *)1 )\n      {\n        v9 = (char *)*a2;\n        v10 = *a1;\n        if ( byte_61CBA1 )\n        {\n          result = sub_4115C0(v10, v3[1], *v2, v2[1]);\n        }\n        else\n        {\n          v11 = (size_t)(v6 - 1);\n          if ( v8 <= v7 )\n            v11 = v8;\n          result = memcmp(v10, v9, v11);\n          if ( !result )\n          {\n            result = -1;\n            if ( v8 >= v7 )\n              result = v5 != v6;\n          }\n        }\n      }\n    }\n    if ( byte_61C75B )\n      result = -result;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4082a0L", 
            "funcEndAddr": "0x408370L", 
            "funcName": "sub_4082A0"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_408370(__m128i *a1, unsigned __int64 a2, __m128i *a3, char a4)\n{\n  const __m128i *v4; // rbp\n  __m128i *v5; // rbx\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // r15\n  __m128i v8; // xmm1\n  __int64 v9; // r13\n  __m128i *v10; // rax\n  const void **v11; // rdx\n  _QWORD *i; // r14\n  __int64 v13; // rax\n  __m128i v14; // xmm1\n  __m128i v15; // xmm0\n  __m128i v16; // xmm2\n  __m128i v17; // xmm3\n  _BOOL4 v18; // eax\n  int v19; // edx\n  const __m128i *v20; // rdx\n  __m128i v21; // xmm1\n  __m128i v22; // xmm0\n  __m128i v23; // xmm1\n  const void **v25; // [rsp+8h] [rbp-40h]\n  char v26; // [rsp+8h] [rbp-40h]\n\n  v4 = a1;\n  v5 = a3;\n  if ( a2 == 2 )\n  {\n    v26 = a4;\n    LODWORD(v13) = sub_4082A0((const void **)&a1[-2], (__m128i *)a1[-4].m128i_i64);\n    if ( v26 )\n    {\n      v18 = (int)v13 > 0;\n      v19 = v18;\n      v13 = 32LL * (v18 - 2);\n      v20 = &a1[2 * ~v19];\n      v21 = _mm_loadu_si128(v20 + 1);\n      v5[-2] = _mm_loadu_si128(v20);\n      v22 = _mm_loadu_si128((__m128i *)((char *)a1 + v13));\n      v5[-1] = v21;\n      v23 = _mm_loadu_si128((__m128i *)((char *)a1 + v13 + 16));\n      v5[-4] = v22;\n      v5[-3] = v23;\n    }\n    else if ( (int)v13 > 0 )\n    {\n      v14 = _mm_loadu_si128(a1 - 2);\n      v15 = _mm_loadu_si128(a1 - 1);\n      v16 = _mm_loadu_si128(a1 - 4);\n      v17 = _mm_loadu_si128(a1 - 3);\n      v5[-2] = v14;\n      v5[-1] = v15;\n      a1[-2] = v16;\n      a1[-1] = v17;\n      a1[-4] = v14;\n      a1[-3] = v15;\n    }\n  }\n  else\n  {\n    v6 = a2 >> 1;\n    v7 = a2 - (a2 >> 1);\n    if ( a4 )\n    {\n      v9 = (__int64)a3[-2 * (a2 >> 1)].m128i_i64;\n      sub_408370(&a1[-2 * (a2 >> 1)], a2 - (a2 >> 1), v9, 1LL);\n      if ( a2 > 3 )\n        sub_408370(a1, v6, v5, 0LL);\n    }\n    else\n    {\n      sub_408370(&a1[-2 * (a2 >> 1)], a2 - (a2 >> 1), a3, 0LL);\n      if ( a2 > 3 )\n      {\n        sub_408370(a1, v6, v5, 1LL);\n        v9 = (__int64)a1[-2 * (a2 >> 1)].m128i_i64;\n        v10 = v5;\n      }\n      else\n      {\n        v8 = _mm_loadu_si128(a1 - 1);\n        v9 = (__int64)a1[-2 * (a2 >> 1)].m128i_i64;\n        v10 = v5;\n        v5[-2] = _mm_loadu_si128(a1 - 2);\n        v5[-1] = v8;\n      }\n      v5 = a1;\n      v4 = v10;\n    }\n    v11 = (const void **)&v4[-2];\n    for ( i = (_QWORD *)(v9 - 32); ; i -= 4 )\n    {\n      while ( 1 )\n      {\n        v25 = v11;\n        v5 -= 2;\n        LODWORD(v13) = sub_4082A0(v11, i);\n        v11 = v25;\n        if ( (int)v13 > 0 )\n          break;\n        *v5 = _mm_loadu_si128(v4 - 2);\n        v5[1] = _mm_loadu_si128(v4 - 1);\n        if ( !--v6 )\n          return v13;\n        v4 = (const __m128i *)v25;\n        v11 = v25 - 4;\n      }\n      *v5 = _mm_loadu_si128((const __m128i *)(v9 - 32));\n      v5[1] = _mm_loadu_si128((const __m128i *)(v9 - 16));\n      if ( !--v7 )\n        break;\n      v9 = (__int64)i;\n    }\n    v13 = -32LL;\n    do\n    {\n      *(__m128i *)((char *)v5 + v13) = _mm_loadu_si128((const __m128i *)((char *)v4 + v13));\n      *(__m128i *)((char *)&v5[1] + v13) = _mm_loadu_si128((const __m128i *)((char *)v4 + v13 + 16));\n      v13 -= 32LL;\n      --v6;\n    }\n    while ( v6 );\n  }\n  return v13;\n}\n", 
            "funcStartAddr": "0x408370L", 
            "funcEndAddr": "0x4085c6L", 
            "funcName": "sub_408370"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_4085D0(__m128i *a1, FILE *a2, char *a3)\n{\n  int result; // eax\n  char *v4; // [rsp+8h] [rbp-20h]\n\n  if ( !byte_61C759 )\n    goto LABEL_5;\n  if ( !(_QWORD)xmmword_61CB80 || (v4 = a3, result = sub_4082A0((const void **)a1, &xmmword_61CB80), a3 = v4, result) )\n  {\n    xmmword_61CB80 = (__int128)_mm_loadu_si128(a1);\n    xmmword_61CB90 = (__int128)_mm_loadu_si128(a1 + 1);\nLABEL_5:\n    result = sub_407E70((__int64)a1, a2, a3);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4085d0L", 
            "funcEndAddr": "0x408637L", 
            "funcName": "sub_4085D0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_408640(__int64 a1, unsigned __int64 a2, __int64 a3, FILE *a4, char *a5, FILE **a6)\n{\n  __int64 v6; // rdi\n  unsigned __int128 v7; // ax\n  __int64 v8; // rbx\n  unsigned __int64 v9; // r15\n  _QWORD *v10; // r13\n  unsigned __int64 *v11; // rbx\n  __int64 v12; // rbx\n  __int64 v13; // r13\n  __int64 v14; // rdx\n  char **v15; // rbp\n  __int64 v16; // rax\n  unsigned __int64 i; // rax\n  void *v18; // rdx\n  unsigned __int64 v19; // rbp\n  unsigned __int64 *v20; // r13\n  unsigned __int64 *v21; // r12\n  unsigned __int64 *v22; // r15\n  unsigned __int64 v23; // rbx\n  unsigned __int64 v24; // r14\n  int v25; // eax\n  char *v26; // r14\n  __int64 v27; // r15\n  const void ***v28; // r12\n  unsigned __int64 v29; // r13\n  char **v30; // r13\n  FILE *v31; // rsi\n  __int64 v32; // r15\n  char v33; // al\n  FILE **v34; // rcx\n  __int64 v35; // rax\n  unsigned __int64 v36; // r13\n  const void **v37; // rax\n  unsigned __int64 v38; // r12\n  char *v39; // rax\n  unsigned __int64 v40; // r14\n  unsigned __int64 v41; // r15\n  char *v42; // r13\n  unsigned __int64 v43; // rbp\n  int v44; // eax\n  unsigned __int64 v45; // r15\n  unsigned __int64 *v46; // rax\n  unsigned __int64 v47; // rdx\n  size_t v48; // rdx\n  void *v49; // rdi\n  const void *v50; // rsi\n  char *v51; // rax\n  unsigned __int64 *v52; // rax\n  unsigned __int64 v53; // rcx\n  unsigned __int64 v54; // rdi\n  __int64 v55; // rax\n  __int64 v56; // rax\n  const __m128i *v57; // rdx\n  __m128i v58; // xmm0\n  __m128i v59; // xmm1\n  __m128i v60; // xmm2\n  __int64 v61; // r9\n  __m128i v62; // xmm3\n  __int64 v63; // r9\n  __int64 v64; // r9\n  unsigned __int64 *v65; // rax\n  unsigned __int64 v66; // rdx\n  FILE *v67; // rax\n  unsigned __int64 v68; // rsi\n  void *v69; // [rsp+8h] [rbp-D0h]\n  FILE **v70; // [rsp+8h] [rbp-D0h]\n  const void **v71; // [rsp+8h] [rbp-D0h]\n  size_t v72; // [rsp+8h] [rbp-D0h]\n  _QWORD *v73; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v74; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v75; // [rsp+18h] [rbp-C0h]\n  _QWORD *v76; // [rsp+20h] [rbp-B8h]\n  __int64 v77; // [rsp+28h] [rbp-B0h]\n  char **v78; // [rsp+30h] [rbp-A8h]\n  unsigned __int64 *v79; // [rsp+38h] [rbp-A0h]\n  void **v80; // [rsp+38h] [rbp-A0h]\n  FILE **ptr; // [rsp+40h] [rbp-98h]\n  _QWORD *v82; // [rsp+48h] [rbp-90h]\n  __int64 v83; // [rsp+50h] [rbp-88h]\n  FILE *stream; // [rsp+58h] [rbp-80h]\n  char *v85; // [rsp+60h] [rbp-78h]\n  unsigned __int64 v86; // [rsp+68h] [rbp-70h]\n  size_t v87; // [rsp+70h] [rbp-68h]\n  __int64 v88; // [rsp+78h] [rbp-60h]\n  void *dest; // [rsp+80h] [rbp-58h]\n  size_t v90; // [rsp+88h] [rbp-50h]\n  char *v91; // [rsp+90h] [rbp-48h]\n  char *v92; // [rsp+98h] [rbp-40h]\n\n  v77 = a1;\n  v6 = a3;\n  v75 = a3;\n  v86 = a2;\n  v7 = (unsigned __int64)a3 * (unsigned __int128)0x38uLL;\n  stream = a4;\n  v85 = a5;\n  ptr = a6;\n  BYTE8(v7) = *((_QWORD *)&v7 + 1) != 0LL;\n  if ( (v7 & 0x8000000000000000LL) != 0LL\n    || (*((_QWORD *)&v7 + 1) = BYTE8(v7), BYTE8(v7))\n    || (v8 = 8 * v75, v6 = 56 * v75, v78 = (char **)sub_411210(56 * v75), v75 & 0x1000000000000000LL)\n    || v75 >> 61 != 0 )\n  {\n    sub_411460(v6, a2, *((_QWORD *)&v7 + 1));\n  }\n  v9 = 0LL;\n  v10 = (_QWORD *)sub_411210(v8);\n  v76 = (_QWORD *)sub_411210(v8);\n  dest = 0LL;\n  v11 = (unsigned __int64 *)sub_411210(v8);\n  v88 = qword_61C750;\n  if ( v75 )\n  {\n    v79 = v11;\n    v73 = v10;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v12 = 8 * v9;\n        v13 = (__int64)&v78[7 * v9];\n        v14 = qword_61C428;\n        if ( qword_61C778 / v75 >= qword_61C428 )\n          v14 = qword_61C778 / v75;\n        sub_405E30((__int64)&v78[7 * v9], 32LL, v14);\n        v15 = (char **)(v77 + 16 * v9);\n        if ( !(unsigned __int8)sub_4074D0((char **)v13, ptr[v9], *v15) )\n          break;\n        v16 = *(_QWORD *)v13 + *(_QWORD *)(v13 + 24);\n        v73[v9] = v16 - 32;\n        v76[v9++] = v16 - 32LL * *(_QWORD *)(v13 + 16);\n        if ( v9 >= v75 )\n        {\n          v11 = v79;\n          v10 = v73;\n          goto LABEL_12;\n        }\n      }\n      sub_407DF0(ptr[v9], *v15);\n      if ( v86 > v9 )\n      {\n        --v86;\n        sub_407920(*v15);\n      }\n      free(*(void **)v13);\n      if ( v75 - 1 <= v9 )\n        break;\n      do\n      {\n        v67 = ptr[(unsigned __int64)v12 / 8 + 1];\n        *(__m128i *)(v77 + 2 * v12) = _mm_loadu_si128((const __m128i *)(v77 + 2 * v12 + 16));\n        ptr[(unsigned __int64)v12 / 8] = v67;\n        v12 += 8LL;\n      }\n      while ( 8 * v75 - 8 != v12 );\n      --v75;\n    }\n    v11 = v79;\n    v10 = v73;\n    --v75;\nLABEL_12:\n    if ( !v75 )\n      goto LABEL_68;\n    for ( i = 0LL; i != v75; ++i )\n      v11[i] = i;\n    if ( v75 != 1 )\n    {\n      v18 = v10;\n      v19 = 1LL;\n      v20 = v11;\n      do\n      {\n        while ( 1 )\n        {\n          v69 = v18;\n          v21 = &v20[v19];\n          v22 = &v20[v19 - 1];\n          v23 = v20[v19];\n          v24 = *v22;\n          v25 = sub_4082A0(*((const void ***)v18 + *v22), *((_QWORD **)v18 + v23));\n          v18 = v69;\n          if ( v25 <= 0 )\n            break;\n          *v22 = v23;\n          v19 = 1LL;\n          *v21 = v24;\n        }\n        ++v19;\n      }\n      while ( v19 < v75 );\n      v11 = v20;\n      v10 = v69;\n    }\n    v87 = 0LL;\n    v26 = (char *)v10;\n    v80 = 0LL;\n    v83 = (__int64)(v11 - 1);\n    while ( 1 )\n    {\n      v27 = *v11;\n      v74 = *v11;\n      v28 = (const void ***)&v26[v27 * 8];\n      v29 = *(_QWORD *)&v26[v27 * 8];\n      if ( byte_61C759 )\n      {\n        if ( !v80 )\n          goto LABEL_42;\n        if ( sub_4082A0((const void **)v80, *(_QWORD **)&v26[v27 * 8]) )\n        {\n          sub_407E70((__int64)&dest, stream, v85);\nLABEL_42:\n          v48 = *(_QWORD *)(v29 + 8);\n          v49 = dest;\n          if ( v48 > v87 )\n          {\n            if ( v87 )\n            {\n              v68 = 2 * v87;\n              if ( v48 > 2 * v87 )\n              {\n                while ( v68 )\n                {\n                  v68 *= 2LL;\n                  if ( v48 <= v68 )\n                    goto LABEL_75;\n                }\n              }\n              else\n              {\nLABEL_75:\n                v48 = v68;\n              }\n            }\n            v72 = v48;\n            free(dest);\n            v49 = (void *)sub_411210(v72);\n            dest = v49;\n            v87 = v72;\n            v48 = *(_QWORD *)(v29 + 8);\n          }\n          v50 = *(const void **)v29;\n          v90 = v48;\n          memcpy(v49, v50, v48);\n          v80 = &dest;\n          if ( v88 )\n          {\n            v51 = (char *)dest + *(_QWORD *)(v29 + 24) - *(_QWORD *)v29;\n            v91 = (char *)dest + *(_QWORD *)(v29 + 16) - *(_QWORD *)v29;\n            v92 = v51;\n          }\n          goto LABEL_25;\n        }\n      }\n      else\n      {\n        sub_407E70(*(_QWORD *)&v26[v27 * 8], stream, v85);\n      }\nLABEL_25:\n      if ( v76[v27] < v29 )\n      {\n        *v28 = (const void **)(v29 - 32);\n        v36 = v75;\n        if ( v75 != 1 )\n          goto LABEL_28;\nLABEL_39:\n        *v11 = v74;\n      }\n      else\n      {\n        v82 = &v76[v27];\n        v30 = (char **)(v77 + 16 * v74);\n        v31 = ptr[v27];\n        v70 = &ptr[v27];\n        v32 = (__int64)&v78[7 * v74];\n        v33 = sub_4074D0(&v78[7 * v74], v31, *v30);\n        v34 = v70;\n        if ( v33 )\n        {\n          v35 = *(_QWORD *)v32 + *(_QWORD *)(v32 + 24);\n          v36 = v75;\n          *v28 = (const void **)(v35 - 32);\n          *v82 = v35 - 32LL * *(_QWORD *)(v32 + 16);\n          if ( v75 == 1 )\n            goto LABEL_39;\nLABEL_28:\n          v37 = *v28;\n          v38 = 1LL;\n          v71 = v37;\n          v39 = v26;\n          v40 = 1LL;\n          v41 = v36;\n          v42 = v39;\n          do\n          {\n            while ( 1 )\n            {\n              v43 = v11[v38];\n              v44 = sub_4082A0(v71, *(_QWORD **)&v42[8 * v43]);\n              if ( v44 < 0 || v74 < v43 && !v44 )\n                break;\n              v40 = v38 + 1;\n              v38 = (v38 + 1 + v41) >> 1;\n              if ( v40 >= v41 )\n                goto LABEL_34;\n            }\n            v41 = v38;\n            v38 = (v40 + v38) >> 1;\n          }\n          while ( v40 < v41 );\nLABEL_34:\n          v45 = v40;\n          v26 = v42;\n          if ( v45 != 1 )\n          {\n            v46 = v11;\n            do\n            {\n              v47 = v46[1];\n              ++v46;\n              *(v46 - 1) = v47;\n            }\n            while ( v46 != (unsigned __int64 *)(v83 + 8 * v45) );\n          }\n          v11[v45 - 1] = v74;\n        }\n        else\n        {\n          v52 = v11 + 1;\n          if ( v75 != 1 )\n          {\n            v53 = v74;\n            do\n            {\n              if ( *v52 > v53 )\n              {\n                --*v52;\n                v53 = *v11;\n              }\n              ++v52;\n            }\n            while ( &v11[v75] != v52 );\n            v54 = v53;\n            v55 = 8 * v53;\n            v74 = v53;\n            v30 = (char **)(v77 + 16 * v53);\n            v34 = &ptr[v53];\n            v32 = (__int64)&v78[v55 - v54];\n          }\n          sub_407DF0(*v34, *v30);\n          if ( v86 > v74 )\n          {\n            --v86;\n            sub_407920(*v30);\n          }\n          free(*(void **)v32);\n          if ( v75 - 1 > v74 )\n          {\n            v56 = 8 * v74;\n            v57 = (const __m128i *)&v78[7 * v74];\n            do\n            {\n              v58 = _mm_loadu_si128((const __m128i *)(v77 + 2 * v56 + 16));\n              v57 = (const __m128i *)((char *)v57 + 56);\n              v59 = _mm_loadu_si128(v57);\n              v60 = _mm_loadu_si128(v57 + 1);\n              ptr[(unsigned __int64)v56 / 8] = ptr[(unsigned __int64)v56 / 8 + 1];\n              v61 = v57[3].m128i_i64[0];\n              v62 = _mm_loadu_si128(v57 + 2);\n              *(__m128i *)(v77 + 2 * v56) = v58;\n              v57[-1].m128i_i64[1] = v61;\n              v63 = *(_QWORD *)&v26[v56 + 8];\n              *(__m128i *)((char *)v57 - 56) = v59;\n              *(_QWORD *)&v26[v56] = v63;\n              v64 = v76[(unsigned __int64)v56 / 8 + 1];\n              *(__m128i *)((char *)v57 - 40) = v60;\n              v76[(unsigned __int64)v56 / 8] = v64;\n              v56 += 8LL;\n              *(__m128i *)((char *)v57 - 24) = v62;\n            }\n            while ( 8 * v75 - 8 != v56 );\n          }\n          if ( v75 == 1 )\n          {\n            v10 = v26;\n            if ( v80 && byte_61C759 )\n            {\n              sub_407E70((__int64)&dest, stream, v85);\n              free(dest);\n            }\n            break;\n          }\n          v65 = v11;\n          do\n          {\n            v66 = v65[1];\n            ++v65;\n            *(v65 - 1) = v66;\n          }\n          while ( (unsigned __int64 *)(v83 + 8 * v75) != v65 );\n          --v75;\n        }\n      }\n    }\n  }\nLABEL_68:\n  sub_407DF0(stream, v85);\n  free(ptr);\n  free(v78);\n  free(v11);\n  free(v76);\n  free(v10);\n}\n", 
            "funcStartAddr": "0x408640L", 
            "funcEndAddr": "0x408e08L", 
            "funcName": "sub_408640"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_408E10(int fd, int a2)\n{\n  dup2(fd, a2);\n  return close(fd);\n}\n", 
            "funcStartAddr": "0x408e10L", 
            "funcEndAddr": "0x408e20L", 
            "funcName": "sub_408E10"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_408E20(__int64 a1, unsigned __int64 a2, __int64 *a3)\n{\n  __int64 v3; // rbp\n  __int64 v4; // rdi\n  __int64 *v5; // rbx\n  __int64 v6; // rax\n  __int64 v7; // r14\n  __int64 v8; // rbx\n  _IO_FILE *v9; // rax\n  __int64 v10; // r12\n  char v11; // al\n  int v12; // er15\n  int v13; // eax\n  int *v14; // rbp\n  FILE *v16; // rax\n  int *v17; // rax\n  int v18; // er13\n  int *v19; // rbp\n  int *v20; // rax\n  __int64 v21; // rbx\n  char *v22; // rax\n  int v23; // [rsp+8h] [rbp-40h]\n  int fd; // [rsp+Ch] [rbp-3Ch]\n\n  v3 = a1;\n  v4 = 8 * a2;\n  if ( a2 & 0x1000000000000000LL || a2 >> 61 != 0 )\n    sub_411460(v4, a2, a3);\n  v5 = a3;\n  v6 = sub_411210(v4);\n  *v5 = v6;\n  v7 = v6;\n  v8 = 0LL;\n  if ( !a2 )\n    return v8;\n  while ( 1 )\n  {\n    v10 = *(_QWORD *)(v3 + 8);\n    if ( !v10 || (v11 = *(_BYTE *)(v10 + 12)) == 0 )\n    {\n      v9 = sub_407CD0(*(char **)v3, \"r\");\n      *(_QWORD *)(v7 + 8 * v8) = v9;\n      if ( !v9 )\n        return v8;\n      goto LABEL_6;\n    }\n    if ( v11 == 1 )\n      sub_4060A0(*(_DWORD *)(v10 + 8));\n    v12 = open((const char *)(v10 + 13), 0);\n    if ( v12 < 0 )\n      goto LABEL_15;\n    v13 = sub_407A30(&v23, 9LL);\n    if ( v13 == -1 )\n      break;\n    if ( !v13 )\n    {\n      close(v23);\n      if ( v12 )\n        sub_408E10(v12, 0);\n      if ( fd != 1 )\n        sub_408E10(fd, 1);\n      execlp(s1, s1, \"-d\", 0LL);\n      v20 = __errno_location();\n      sub_4060D0(*v20, \"couldn't execute compress program (with -d)\");\n    }\n    *(_DWORD *)(v10 + 8) = v13;\n    sub_406190(v10);\n    close(v12);\n    close(fd);\n    v16 = fdopen(v23, \"r\");\n    if ( !v16 )\n    {\n      v17 = __errno_location();\n      v18 = *v17;\n      v19 = v17;\n      close(v23);\n      *(_QWORD *)(v7 + 8 * v8) = 0LL;\n      *v19 = v18;\n      return v8;\n    }\n    *(_QWORD *)(v7 + 8 * v8) = v16;\nLABEL_6:\n    ++v8;\n    v3 += 16LL;\n    if ( a2 == v8 )\n      return v8;\n  }\n  v14 = __errno_location();\n  if ( *v14 == 24 )\n  {\n    close(v12);\n    *v14 = 24;\nLABEL_15:\n    *(_QWORD *)(v7 + 8 * v8) = 0LL;\n    return v8;\n  }\n  v21 = sub_40F630(4LL, s1);\n  v22 = dcgettext(0LL, \"couldn't create process for %s -d\", 5);\n  error(2, *v14, v22, v21);\n  return sub_409030();\n}\n", 
            "funcStartAddr": "0x408e20L", 
            "funcEndAddr": "0x409030L", 
            "funcName": "sub_408E20"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_409030(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, FILE *a4, char *a5)\n{\n  char *v5; // r15\n  FILE *v6; // r14\n  unsigned __int64 v7; // r12\n  unsigned __int64 v8; // rax\n  unsigned __int64 v9; // rbx\n  char *v11; // rbx\n  char *v12; // rax\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  FILE **v16; // [rsp+8h] [rbp-40h]\n\n  v5 = a5;\n  v6 = a4;\n  v7 = a3;\n  v8 = sub_408E20(a1, a3, (__int64 *)&v16);\n  v9 = v8;\n  if ( v7 > v8 && v8 <= 1 )\n  {\n    v11 = *(char **)(a1 + 16 * v8);\n    v12 = dcgettext(0LL, \"open failed\", 5);\n    sub_405DD0((__int64)v12, v11, v13, v14, v15);\n  }\n  sub_408640(a1, a2, v8, v6, v5, v16);\n  return v9;\n}\n", 
            "funcStartAddr": "0x409030L", 
            "funcEndAddr": "0x4090b8L", 
            "funcName": "sub_409030"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4090C0(FILE **a1, char a2)\n{\n  const void *v2; // r13\n  size_t v3; // rax\n  size_t v4; // r12\n  __int64 v5; // rax\n  char *v6; // rbp\n  __int64 v7; // rbx\n  __int64 v8; // rax\n  int v9; // er12\n  int *v10; // rax\n  unsigned int *v11; // r14\n  __int64 *v12; // rax\n  bool v13; // zf\n  int v14; // eax\n  FILE *v15; // rax\n  int v17; // ebp\n  void *v18; // rdi\n  unsigned int v19; // er13\n  char *v20; // rax\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  __int64 v24; // rbx\n  char *v25; // rax\n  __int64 v26; // rsi\n  __int64 v27; // rdx\n  __int64 v28; // rcx\n  int fd; // [rsp+10h] [rbp-C8h]\n  int v30; // [rsp+14h] [rbp-C4h]\n  __sigset_t oldmask; // [rsp+18h] [rbp-C0h]\n\n  v2 = *(const void **)(qword_61C770 + 8 * qword_61C5E8);\n  v3 = strlen(*(const char **)(qword_61C770 + 8 * qword_61C5E8));\n  v4 = v3;\n  v5 = sub_411210((v3 + 32) & 0xFFFFFFFFFFFFFFF8LL);\n  v6 = (char *)(v5 + 13);\n  v7 = v5;\n  memcpy((void *)(v5 + 13), v2, v4);\n  *(_QWORD *)(v7 + v4 + 13) = 6365935330447553327LL;\n  *(_DWORD *)&v6[v4 + 8] = 5789784;\n  v8 = qword_61C5E8;\n  *(_QWORD *)v7 = 0LL;\n  qword_61C5E8 = v8 + 1;\n  if ( v8 + 1 == qword_61C768 )\n    qword_61C5E8 = 0LL;\n  LOBYTE(fd) = pthread_sigmask(0, &set, &oldmask) == 0;\n  v9 = sub_410680(v6, 0x80000LL);\n  v10 = __errno_location();\n  v11 = (unsigned int *)v10;\n  if ( v9 >= 0 )\n  {\n    v12 = off_61C418;\n    v13 = (_BYTE)fd == 0;\n    off_61C418 = (__int64 *)v7;\n    *v12 = v7;\n    if ( !v13 )\n    {\n      v19 = *v11;\n      sub_407880((__int64)&fd);\n      *v11 = v19;\n    }\n    v13 = s1 == 0LL;\n    *(_BYTE *)(v7 + 12) = 0;\n    if ( !v13 )\n    {\n      v14 = sub_407A30(&fd, 4LL);\n      *(_DWORD *)(v7 + 8) = v14;\n      if ( v14 > 0 )\n      {\n        close(v9);\n        close(fd);\n        v9 = v30;\n        sub_406190(v7);\n      }\n      else if ( !v14 )\n      {\n        close(v30);\n        if ( v9 != 1 )\n          sub_408E10(v9, 1);\n        if ( fd )\n          sub_408E10(fd, 0);\n        execlp(s1, s1, 0LL);\n        sub_4060D0(*v11, \"couldn't execute compress program\");\n      }\n    }\n    v15 = fdopen(v9, \"w\");\n    *a1 = v15;\n    if ( !v15 )\n    {\n      v20 = dcgettext(0LL, \"couldn't create temporary file\", 5);\n      sub_405DD0((__int64)v20, v6, v21, v22, v23);\n    }\n    return v7;\n  }\n  v17 = *v10;\n  if ( (_BYTE)fd )\n  {\n    sub_407880((__int64)&fd);\n    *v11 = v17;\n  }\n  if ( v17 == 24 && a2 == 1 )\n  {\n    v18 = (void *)v7;\n    v7 = 0LL;\n    free(v18);\n    return v7;\n  }\n  v24 = sub_40F630(4LL, v2);\n  v25 = dcgettext(0LL, \"cannot create temporary file in %s\", 5);\n  v26 = *v11;\n  error(2, v26, v25, v24);\n  return sub_409330(2LL, v26, v27, v28);\n}\n", 
            "funcStartAddr": "0x4090c0L", 
            "funcEndAddr": "0x409330L", 
            "funcName": "sub_4090C0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_409330(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, char *a4)\n{\n  _QWORD *v4; // r14\n  unsigned __int64 v5; // r13\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // rcx\n  unsigned __int64 v8; // rbp\n  __int64 v9; // rbx\n  __int64 v10; // rax\n  unsigned __int64 v11; // rsi\n  __int64 v12; // r13\n  __int64 v13; // r15\n  unsigned __int64 v14; // rax\n  unsigned __int64 v15; // rdx\n  unsigned __int64 v16; // rsi\n  __int64 v17; // rdx\n  unsigned __int64 v18; // rdx\n  _QWORD *v19; // r15\n  const void *v20; // r9\n  unsigned __int64 v21; // rax\n  unsigned __int64 v22; // rbx\n  __int64 v23; // r15\n  __int64 v24; // rbp\n  char v25; // r12\n  __int64 v26; // r14\n  _BOOL4 v27; // er13\n  int v28; // eax\n  unsigned __int64 v29; // rax\n  unsigned __int64 v30; // rbx\n  char **v31; // r15\n  char **v32; // rbp\n  __int64 v33; // rax\n  unsigned __int64 v34; // r15\n  unsigned __int64 v35; // r13\n  size_t v36; // rdx\n  FILE *v37; // rax\n  char *v38; // rax\n  __int64 v39; // rdx\n  __int64 v40; // rcx\n  __int64 v41; // r8\n  __int64 v42; // rax\n  unsigned __int64 v43; // rdx\n  unsigned __int64 v44; // rsi\n  bool v45; // cc\n  unsigned __int64 v46; // rax\n  unsigned __int64 v47; // rdx\n  char *v48; // rbx\n  char *v49; // rax\n  __int64 v50; // rdx\n  __int64 v51; // rcx\n  __int64 v52; // r8\n  unsigned __int64 v53; // [rsp+0h] [rbp-198h]\n  unsigned __int64 v54; // [rsp+0h] [rbp-198h]\n  __int64 v55; // [rsp+0h] [rbp-198h]\n  __int64 v56; // [rsp+8h] [rbp-190h]\n  unsigned __int64 v57; // [rsp+8h] [rbp-190h]\n  __int64 v58; // [rsp+8h] [rbp-190h]\n  struct stat *v59; // [rsp+10h] [rbp-188h]\n  char *s1; // [rsp+18h] [rbp-180h]\n  unsigned __int64 v61; // [rsp+20h] [rbp-178h]\n  __int64 v62; // [rsp+20h] [rbp-178h]\n  FILE *v63; // [rsp+38h] [rbp-160h]\n  FILE **v64; // [rsp+40h] [rbp-158h]\n  __int64 v65; // [rsp+48h] [rbp-150h]\n  struct stat stat_buf; // [rsp+D0h] [rbp-C8h]\n\n  v4 = (_QWORD *)a1;\n  v5 = a3;\n  v6 = a2;\n  s1 = a4;\n  v7 = (unsigned int)dword_61C420;\n  if ( (unsigned int)dword_61C420 < a3 )\n  {\n    v53 = a3;\n    do\n    {\n      v8 = 0LL;\n      v9 = 0LL;\n      if ( v7 > v53 )\n      {\n        v21 = v7;\n        v19 = (_QWORD *)a1;\n        v20 = (const void *)a1;\n        v16 = v53;\n        v18 = 0LL;\n      }\n      else\n      {\n        do\n        {\n          v10 = sub_4090C0((FILE **)&stat_buf, 0);\n          v11 = v6;\n          v12 = v10 + 13;\n          v13 = v10;\n          if ( (unsigned int)dword_61C420 <= v6 )\n            v11 = (unsigned int)dword_61C420;\n          v14 = sub_409030(a1 + 16 * v9, v11, (unsigned int)dword_61C420, (FILE *)stat_buf.st_dev, (char *)(v10 + 13));\n          v15 = v6;\n          v7 = (unsigned int)dword_61C420;\n          if ( v14 <= v6 )\n            v15 = v14;\n          v9 += v14;\n          v16 = v53 - v9;\n          v6 -= v15;\n          v17 = v8++;\n          v17 *= 16LL;\n          *(_QWORD *)(a1 + v17) = v12;\n          *(_QWORD *)(a1 + v17 + 8) = v13;\n        }\n        while ( v7 <= v53 - v9 );\n        v18 = v8 % v7;\n        v19 = (_QWORD *)(a1 + 16 * v8);\n        v20 = (const void *)(a1 + 16 * v9);\n        v21 = v7 - v8 % v7;\n      }\n      if ( v16 > v21 )\n      {\n        v62 = (__int64)v20;\n        v57 = v16 + v18 + 1 - v7;\n        v42 = sub_4090C0((FILE **)&stat_buf, 0);\n        v43 = v57;\n        v44 = v6;\n        v59 = (struct stat *)v42;\n        v45 = v57 <= v6;\n        v58 = v42 + 13;\n        if ( v45 )\n          v44 = v43;\n        v46 = sub_409030(v62, v44, v43, (FILE *)stat_buf.st_dev, (char *)(v42 + 13));\n        v47 = v6;\n        if ( v46 <= v6 )\n          v47 = v46;\n        ++v8;\n        v9 += v46;\n        *v19 = v58;\n        v19[1] = v59;\n        v6 -= v47;\n        v20 = (const void *)(a1 + 16 * v9);\n        v19 = (_QWORD *)(a1 + 16 * v8);\n      }\n      v6 += v8;\n      memmove(v19, v20, 16 * (v53 - v9));\n      v7 = (unsigned int)dword_61C420;\n      v53 += v8 - v9;\n    }\n    while ( (unsigned int)dword_61C420 < v53 );\n    v5 = v53;\n  }\n  if ( v5 <= v6 )\n  {\n    v29 = sub_408E20(a1, v5, (__int64 *)&v64);\n    goto LABEL_27;\n  }\n  v22 = v6;\n  v23 = 0LL;\n  v24 = a1 + 16 * v6;\n  v61 = v6;\n  v25 = 0;\n  v26 = v24;\n  v54 = v5;\n  while ( 1 )\n  {\n    v27 = strcmp(*(const char **)v26, \"-\") != 0;\n    if ( s1 )\n    {\n      v28 = strcmp(s1, *(const char **)v26);\n      if ( v27 && !v28 )\n      {\nLABEL_35:\n        if ( !v23 )\n        {\n          v23 = sub_4090C0(&v63, 0);\n          sub_409030(v26, 0LL, 1uLL, v63, (char *)(v23 + 13));\n        }\n        *(_QWORD *)v26 = v23 + 13;\n        *(_QWORD *)(v26 + 8) = v23;\n        goto LABEL_17;\n      }\n    }\n    if ( !v25 && __fxstat(1, 1, (struct stat *)&v64) )\n      break;\n    if ( !v27 )\n    {\n      v25 = 1;\n      if ( __fxstat(1, 0, &stat_buf) )\n        goto LABEL_17;\n      goto LABEL_16;\n    }\n    v25 = 1;\n    if ( __xstat(1, *(const char **)v26, &stat_buf) )\n    {\n      ++v22;\n      v26 += 16LL;\n      if ( v22 == v54 )\n        break;\n    }\n    else\n    {\nLABEL_16:\n      v25 = 1;\n      if ( stat_buf.st_ino == v65 && (FILE **)stat_buf.st_dev == v64 )\n        goto LABEL_35;\nLABEL_17:\n      ++v22;\n      v26 += 16LL;\n      if ( v22 == v54 )\n        break;\n    }\n  }\n  v4 = (_QWORD *)a1;\n  v6 = v61;\n  v5 = v54;\n  while ( 2 )\n  {\n    v29 = sub_408E20((__int64)v4, v5, (__int64 *)&v64);\nLABEL_27:\n    v30 = v29;\n    if ( v5 != v29 )\n    {\n      if ( v29 <= 2 )\n      {\n        v48 = (char *)v4[2 * v29];\n        v49 = dcgettext(0LL, \"open failed\", 5);\n        sub_405DD0((__int64)v49, v48, v50, v51, v52);\n      }\nLABEL_29:\n      v31 = (char **)&v4[2 * v30 - 2];\n      do\n      {\n        --v30;\n        v32 = v31;\n        sub_407DF0(v64[v30], *v31);\n        v31 -= 2;\n        v33 = sub_4090C0((FILE **)&stat_buf, v30 > 2);\n      }\n      while ( !v33 );\n      v34 = v30;\n      if ( v6 <= v30 )\n        v34 = v6;\n      v56 = v33;\n      v35 = v5 - v30;\n      v55 = v33 + 13;\n      sub_408640((__int64)v4, v34, v30, (FILE *)stat_buf.st_dev, (char *)(v33 + 13), v64);\n      v36 = 16 * v35;\n      v6 = v6 - v34 + 1;\n      *v4 = v55;\n      v5 = v35 + 1;\n      v4[1] = v56;\n      memmove(v4 + 2, v32, v36);\n      continue;\n    }\n    break;\n  }\n  v37 = sub_407CD0(s1, \"w\");\n  if ( !v37 )\n  {\n    if ( *__errno_location() != 24 || v5 <= 2 )\n    {\n      v38 = dcgettext(0LL, \"open failed\", 5);\n      sub_405DD0((__int64)v38, s1, v39, v40, v41);\n    }\n    goto LABEL_29;\n  }\n  sub_408640((__int64)v4, v6, v5, v37, s1, v64);\n}\n", 
            "funcStartAddr": "0x409330L", 
            "funcEndAddr": "0x409821L", 
            "funcName": "sub_409330"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_409830(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n\n  v2 = a2[1];\n  v3 = a2[3];\n  if ( *a2 == a2[2] )\n  {\n    if ( v2 != v3 && !a2[5] )\n      LODWORD(v3) = sub_406320(a1, (__int64)a2);\n  }\n  else if ( v2 != v3 || !a2[6] )\n  {\n    LODWORD(v3) = sub_406320(a1, (__int64)a2);\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x409830L", 
            "funcEndAddr": "0x409871L", 
            "funcName": "sub_409830"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_409880(__m128i *a1, unsigned __int64 a2, __int64 a3, __m128i **a4, pthread_cond_t *a5, __int64 a6, char *a7)\n{\n  FILE *v7; // r14\n  pthread_cond_t *v8; // r13\n  __m128i **v9; // rbx\n  unsigned __int64 v10; // r8\n  unsigned __int64 v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // r12\n  __m128i *v14; // r10\n  __int64 v15; // r9\n  __int64 v16; // rax\n  __int64 v17; // rbx\n  unsigned int v18; // eax\n  __int64 v19; // r12\n  __int64 v20; // rbp\n  __int64 v21; // r15\n  __int64 v22; // rsi\n  __int64 v23; // rdi\n  __int64 v24; // r8\n  __int64 v25; // rax\n  __m128i v26; // xmm2\n  const __m128i *v27; // r11\n  int v28; // eax\n  __m128i v29; // xmm0\n  __int64 v30; // r9\n  __int64 v31; // r10\n  __int64 v32; // rdx\n  __int64 v33; // rax\n  __int64 v34; // rsi\n  const __m128i *v35; // rdi\n  __m128i v36; // xmm4\n  const __m128i *v37; // rax\n  bool v38; // zf\n  __int64 v39; // rsi\n  __int64 v40; // rsi\n  __int64 v41; // rdi\n  __m128i *v42; // rdi\n  __int64 v43; // r15\n  const __m128i *v44; // r11\n  __int64 v45; // rdi\n  const __m128i *v46; // rdx\n  __m128i v47; // xmm6\n  const __m128i *v48; // rcx\n  __int64 v49; // r15\n  __m128i *v50; // rdi\n  pthread_mutex_t *mutexa; // [rsp+8h] [rbp-B0h]\n  pthread_mutex_t *mutexb; // [rsp+8h] [rbp-B0h]\n  pthread_mutex_t *mutex; // [rsp+8h] [rbp-B0h]\n  unsigned __int64 v55; // [rsp+10h] [rbp-A8h]\n  pthread_mutex_t *v56; // [rsp+18h] [rbp-A0h]\n  pthread_mutex_t *v57; // [rsp+18h] [rbp-A0h]\n  pthread_mutex_t *v58; // [rsp+18h] [rbp-A0h]\n  __int64 v59; // [rsp+20h] [rbp-98h]\n  pthread_cond_t *cond; // [rsp+28h] [rbp-90h]\n  pthread_t newthread; // [rsp+38h] [rbp-80h]\n  __m128i *arg; // [rsp+40h] [rbp-78h]\n  unsigned __int64 v63; // [rsp+48h] [rbp-70h]\n  __int64 v64; // [rsp+50h] [rbp-68h]\n  __int64 v65; // [rsp+58h] [rbp-60h]\n  pthread_cond_t *v66; // [rsp+60h] [rbp-58h]\n  __int64 v67; // [rsp+68h] [rbp-50h]\n  char *v68; // [rsp+70h] [rbp-48h]\n\n  v7 = (FILE *)a6;\n  v8 = a5;\n  v9 = a4;\n  v10 = (unsigned __int64)a4[5];\n  v11 = (unsigned __int64)a4[6];\n  v55 = a3;\n  v64 = a3;\n  v12 = (__int64)a4[8];\n  arg = a1;\n  v65 = v12;\n  v63 = a2 >> 1;\n  v66 = v8;\n  v67 = a6;\n  v68 = a7;\n  if ( v10 + v11 > 0x1FFFF && a2 > 1 )\n  {\n    if ( !pthread_create(&newthread, 0LL, start_routine, &arg) )\n    {\n      sub_409880((__int64)a1[-2 * (_QWORD)v9[5]].m128i_i64);\n      pthread_join(newthread, 0LL);\n      return (int)a7;\n    }\n    v10 = (unsigned __int64)v9[5];\n    v11 = (unsigned __int64)v9[6];\n  }\n  v13 = -32LL * v10;\n  v14 = &a1[-2 * v55];\n  v15 = (__int64)a1[-2 * v10].m128i_i64;\n  if ( v11 > 1 )\n  {\n    cond = (pthread_cond_t *)v10;\n    v56 = (pthread_mutex_t *)v11;\n    mutexa = (pthread_mutex_t *)&a1[-2 * v10];\n    sub_408370(&a1[-2 * v10], v11, &v14[-2 * (v10 >> 1)], 0);\n    v10 = (unsigned __int64)cond;\n    v14 = &a1[-2 * v55];\n    v11 = (unsigned __int64)v56;\n    v15 = (__int64)mutexa;\n  }\n  if ( v10 > 1 )\n  {\n    v57 = (pthread_mutex_t *)v15;\n    mutexb = (pthread_mutex_t *)v11;\n    sub_408370(a1, v10, v14, 0);\n    v15 = (__int64)v57;\n    v11 = (unsigned __int64)mutexb;\n  }\n  *v9 = a1;\n  v9[1] = (__m128i *)v15;\n  v9[2] = (__m128i *)v15;\n  v9[3] = (__m128i *)((char *)a1 + v13 - 32 * v11);\n  sub_406320((__int64)v8, (__int64)v9);\n  mutex = (pthread_mutex_t *)&v8->__total_seq;\n  while ( 1 )\n  {\n    pthread_mutex_lock(mutex);\n    while ( 1 )\n    {\n      v16 = sub_40D190(v8->__align);\n      if ( v16 )\n        break;\n      pthread_cond_wait(v8 + 1, mutex);\n    }\n    v17 = v16;\n    pthread_mutex_unlock(mutex);\n    v58 = (pthread_mutex_t *)(v17 + 88);\n    pthread_mutex_lock((pthread_mutex_t *)(v17 + 88));\n    v18 = *(_DWORD *)(v17 + 80);\n    *(_BYTE *)(v17 + 84) = 0;\n    if ( !v18 )\n      break;\n    v19 = *(_QWORD *)v17;\n    v20 = *(_QWORD *)(v17 + 8);\n    v21 = (v55 >> (2 * (unsigned __int8)v18 + 2)) + 1;\n    if ( v18 > 1 )\n    {\n      v22 = *(_QWORD *)(v17 + 8);\n      v23 = *(_QWORD *)v17;\n      v24 = **(_QWORD **)(v17 + 32);\n      while ( 1 )\n      {\n        v27 = *(const __m128i **)(v17 + 16);\n        if ( v27 == (const __m128i *)v23 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          v31 = *(_QWORD *)(v17 + 40);\n          v33 = (v19 - v23) >> 5;\n          if ( (v20 - v22) >> 5 == v30 )\n          {\n            v32 = *(_QWORD *)(v17 + 48);\n            goto LABEL_27;\n          }\n          goto LABEL_35;\n        }\n        if ( *(_QWORD *)(v17 + 24) == v22 )\n          break;\n        if ( !v21 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          v31 = *(_QWORD *)(v17 + 40);\n          v21 = -1LL;\n          v32 = (v20 - v22) >> 5;\n          v33 = (v19 - v23) >> 5;\n          if ( v30 == v32 )\n          {\n            v34 = -2LL;\nLABEL_23:\n            v35 = (const __m128i *)(v23 - 32);\n            do\n            {\n              v36 = _mm_loadu_si128(v35);\n              v24 -= 32LL;\n              *(_QWORD *)v17 = v35;\n              v37 = v35;\n              *(__m128i *)v24 = v36;\n              *(__m128i *)(v24 + 16) = _mm_loadu_si128(v35 + 1);\n              if ( v27 == v35 )\n              {\n                v30 = v32;\n                v33 = (v19 - (__int64)v27) >> 5;\n                goto LABEL_27;\n              }\n              --v34;\n              v35 -= 2;\n            }\n            while ( v34 != -1 );\n            v30 = v32;\n            v33 = (v19 - (__int64)v37) >> 5;\n            goto LABEL_27;\n          }\n          goto LABEL_35;\n        }\n        v59 = v24;\n        v28 = sub_4082A0((const void **)(v23 - 32), (_QWORD *)(v22 - 32));\n        v24 = v59 - 32;\n        if ( v28 > 0 )\n        {\n          v25 = *(_QWORD *)(v17 + 8);\n          v23 = *(_QWORD *)v17;\n          v26 = _mm_loadu_si128((const __m128i *)(v25 - 32));\n          v22 = v25 - 32;\n          *(_QWORD *)(v17 + 8) = v25 - 32;\n          *(__m128i *)v24 = v26;\n        }\n        else\n        {\n          v25 = *(_QWORD *)v17;\n          v22 = *(_QWORD *)(v17 + 8);\n          v29 = _mm_loadu_si128((const __m128i *)(*(_QWORD *)v17 - 32LL));\n          v23 = *(_QWORD *)v17 - 32LL;\n          *(_QWORD *)v17 = v23;\n          *(__m128i *)v24 = v29;\n        }\n        *(__m128i *)(v24 + 16) = _mm_loadu_si128((const __m128i *)(v25 - 16));\n        --v21;\n      }\n      v30 = *(_QWORD *)(v17 + 48);\n      v31 = *(_QWORD *)(v17 + 40);\n      v32 = (v20 - v22) >> 5;\n      v33 = (v19 - v23) >> 5;\n      if ( v30 == v32 )\n      {\n        v34 = v21 - 1;\n        if ( !v21 )\n          goto LABEL_27;\n        goto LABEL_23;\n      }\nLABEL_35:\n      if ( v33 == v31\n        && (v44 = *(const __m128i **)(v17 + 24), v44 != (const __m128i *)v22)\n        && (v45 = v21 - 1, v46 = (const __m128i *)(v22 - 32), v21) )\n      {\n        do\n        {\n          v47 = _mm_loadu_si128(v46);\n          v24 -= 32LL;\n          *(_QWORD *)(v17 + 8) = v46;\n          v48 = v46;\n          *(__m128i *)v24 = v47;\n          *(__m128i *)(v24 + 16) = _mm_loadu_si128(v46 + 1);\n          if ( v46 == v44 )\n          {\n            v32 = (v20 - (__int64)v46) >> 5;\n            goto LABEL_27;\n          }\n          --v45;\n          v46 -= 2;\n        }\n        while ( v45 != -1 );\n        v32 = (v20 - (__int64)v48) >> 5;\n      }\n      else\n      {\n        v32 = (v20 - v22) >> 5;\n      }\nLABEL_27:\n      **(_QWORD **)(v17 + 32) = v24;\n      goto LABEL_28;\n    }\n    v40 = *(_QWORD *)(v17 + 8);\n    v41 = *(_QWORD *)v17;\n    while ( 1 )\n    {\n      if ( *(_QWORD *)(v17 + 16) == v41 )\n      {\n        v32 = *(_QWORD *)(v17 + 48);\n        v31 = *(_QWORD *)(v17 + 40);\n        v33 = (v19 - v41) >> 5;\n        if ( (v20 - v40) >> 5 == v32 )\n        {\n          v30 = *(_QWORD *)(v17 + 48);\n          goto LABEL_28;\n        }\n        if ( v33 == v31 )\n          goto LABEL_56;\n        goto LABEL_53;\n      }\n      if ( *(_QWORD *)(v17 + 24) == v40 )\n        break;\n      if ( !v21 )\n      {\n        v21 = -1LL;\n        v33 = (v19 - v41) >> 5;\n        if ( *(_QWORD *)(v17 + 48) == (v20 - v40) >> 5 )\n        {\n          v49 = -2LL;\n          do\n          {\nLABEL_71:\n            v50 = (__m128i *)(v41 - 32);\n            *(_QWORD *)v17 = v50;\n            sub_4085D0(v50, v7, a7);\n            v41 = *(_QWORD *)v17;\n            if ( *(_QWORD *)v17 == *(_QWORD *)(v17 + 16) )\n              break;\n            --v49;\n          }\n          while ( v49 != -1 );\n          v31 = *(_QWORD *)(v17 + 40);\n          v30 = *(_QWORD *)(v17 + 48);\n          v33 = (v19 - v41) >> 5;\n          v32 = (v20 - *(_QWORD *)(v17 + 8)) >> 5;\n          goto LABEL_28;\n        }\nLABEL_55:\n        v31 = *(_QWORD *)(v17 + 40);\n        if ( v33 == v31 )\n        {\nLABEL_56:\n          if ( *(_QWORD *)(v17 + 24) != v40 && v21 )\n          {\n            v43 = v21 - 1;\n            do\n            {\n              *(_QWORD *)(v17 + 8) = v40 - 32;\n              sub_4085D0((__m128i *)(v40 - 32), v7, a7);\n              v40 = *(_QWORD *)(v17 + 8);\n              if ( v40 == *(_QWORD *)(v17 + 24) )\n                break;\n              --v43;\n            }\n            while ( v43 != -1 );\n            v31 = *(_QWORD *)(v17 + 40);\n            v30 = *(_QWORD *)(v17 + 48);\n            v33 = (v19 - *(_QWORD *)v17) >> 5;\n            v32 = (v20 - v40) >> 5;\n            goto LABEL_28;\n          }\n        }\nLABEL_53:\n        v30 = *(_QWORD *)(v17 + 48);\n        v32 = (v20 - v40) >> 5;\n        goto LABEL_28;\n      }\n      if ( sub_4082A0((const void **)(v41 - 32), (_QWORD *)(v40 - 32)) > 0 )\n      {\n        v42 = (__m128i *)(*(_QWORD *)(v17 + 8) - 32LL);\n        *(_QWORD *)(v17 + 8) = v42;\n      }\n      else\n      {\n        v42 = (__m128i *)(*(_QWORD *)v17 - 32LL);\n        *(_QWORD *)v17 = v42;\n      }\n      sub_4085D0(v42, v7, a7);\n      v41 = *(_QWORD *)v17;\n      v40 = *(_QWORD *)(v17 + 8);\n      --v21;\n    }\n    v32 = *(_QWORD *)(v17 + 48);\n    v33 = (v19 - v41) >> 5;\n    if ( (v20 - v40) >> 5 != v32 )\n      goto LABEL_55;\n    if ( v21 )\n    {\n      v49 = v21 - 1;\n      goto LABEL_71;\n    }\n    v31 = *(_QWORD *)(v17 + 40);\n    v30 = *(_QWORD *)(v17 + 48);\nLABEL_28:\n    v38 = *(_BYTE *)(v17 + 84) == 0;\n    *(_QWORD *)(v17 + 40) = v31 - v33;\n    *(_QWORD *)(v17 + 48) = v30 - v32;\n    if ( v38 )\n      sub_409830((__int64)v8, (_QWORD *)v17);\n    if ( *(_DWORD *)(v17 + 80) > 1u )\n    {\n      pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(v17 + 56) + 88LL));\n      v39 = *(_QWORD *)(v17 + 56);\n      if ( !*(_BYTE *)(v39 + 84) )\n      {\n        sub_409830((__int64)v8, (_QWORD *)v39);\n        v39 = *(_QWORD *)(v17 + 56);\n      }\n      pthread_mutex_unlock((pthread_mutex_t *)(v39 + 88));\n    }\n    else if ( !(*(_QWORD *)(v17 + 40) + *(_QWORD *)(v17 + 48)) )\n    {\n      sub_406320((__int64)v8, *(_QWORD *)(v17 + 56));\n    }\n    pthread_mutex_unlock(v58);\n  }\n  pthread_mutex_unlock(v58);\n  return sub_406320((__int64)v8, v17);\n}\n", 
            "funcStartAddr": "0x409880L", 
            "funcEndAddr": "0x409fdcL", 
            "funcName": "sub_409880"
        }, 
        {
            "decompiledFuncCode": "void *__fastcall start_routine(void *a1)\n{\n  sub_409880(\n    *(__m128i **)a1,\n    *((_QWORD *)a1 + 1),\n    *((_QWORD *)a1 + 2),\n    *((__m128i ***)a1 + 3),\n    *((pthread_cond_t **)a1 + 4),\n    *((_QWORD *)a1 + 5),\n    *((char **)a1 + 6));\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x409fe0L", 
            "funcEndAddr": "0x40a00aL", 
            "funcName": "start_routine"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40A010(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  unsigned __int64 v3; // rcx\n  __int64 result; // rax\n  __int64 v5; // rdx\n\n  v2 = qword_61C768;\n  v3 = qword_61C760;\n  result = qword_61C770;\n  if ( qword_61C768 == qword_61C760 )\n  {\n    if ( qword_61C770 )\n    {\n      v5 = 768614336404564649LL;\n      if ( (unsigned __int64)qword_61C760 <= 0xAAAAAAAAAAAAAA9LL )\n      {\n        v3 = qword_61C760 + ((unsigned __int64)qword_61C760 >> 1) + 1;\n        a2 = 8 * v3;\nLABEL_6:\n        qword_61C760 = v3;\n        result = sub_411270(qword_61C770, a2);\n        v2 = qword_61C768;\n        qword_61C770 = result;\n        goto LABEL_2;\n      }\n    }\n    else\n    {\n      if ( !qword_61C760 )\n      {\n        a2 = 128LL;\n        v3 = 16LL;\n        goto LABEL_6;\n      }\n      v5 = (unsigned __int64)qword_61C760 >> 61 != 0;\n      a2 = 8 * qword_61C760;\n      if ( !(qword_61C760 & 0x1000000000000000LL) && (unsigned __int64)qword_61C760 >> 61 == 0 )\n        goto LABEL_6;\n    }\n    sub_411460(a1, a2, v5);\n  }\nLABEL_2:\n  *(_QWORD *)(result + 8 * v2) = a1;\n  qword_61C768 = v2 + 1;\n  return result;\n}\n", 
            "funcStartAddr": "0x40a010L", 
            "funcEndAddr": "0x40a0c4L", 
            "funcName": "sub_40A010"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_40A0D0(int status)\n{\n  int v1; // ebx\n  __int64 v2; // rbp\n  char *v3; // rax\n  char *v4; // rax\n  FILE *v5; // rbp\n  char *v6; // rax\n  FILE *v7; // rbp\n  char *v8; // rax\n  FILE *v9; // rbp\n  char *v10; // rax\n  FILE *v11; // rbp\n  char *v12; // rax\n  FILE *v13; // rbp\n  char *v14; // rax\n  FILE *v15; // rbp\n  char *v16; // rax\n  FILE *v17; // rbp\n  char *v18; // rax\n  FILE *v19; // rbp\n  char *v20; // rax\n  FILE *v21; // rbp\n  char *v22; // rax\n  FILE *v23; // rbp\n  char *v24; // rax\n  FILE *v25; // rbp\n  char *v26; // rax\n  FILE *v27; // rbp\n  char *v28; // rax\n  FILE *v29; // rbp\n  char *v30; // rax\n  FILE *v31; // rbp\n  char *v32; // rax\n  FILE *v33; // rbp\n  char *v34; // rax\n  char *v35; // rax\n  FILE *v36; // rbp\n  char *v37; // rax\n  FILE *v38; // rbp\n  char *v39; // rax\n  FILE *v40; // rbp\n  char *v41; // rax\n  FILE *v42; // rbp\n  char *v43; // rax\n  FILE *v44; // rbp\n  char *v45; // rax\n  const char **v46; // rax\n  char *v47; // rax\n  char *v48; // rax\n  char *v49; // rax\n  char *v50; // rax\n  char *v51; // rax\n  char *v52; // rax\n  char *v53; // rax\n  char *v54; // rax\n  const char *v55; // [rsp+0h] [rbp-88h]\n  const char *v56; // [rsp+8h] [rbp-80h]\n  const char *v57; // [rsp+10h] [rbp-78h]\n  const char *v58; // [rsp+18h] [rbp-70h]\n  const char *v59; // [rsp+20h] [rbp-68h]\n  const char *v60; // [rsp+28h] [rbp-60h]\n  const char *v61; // [rsp+30h] [rbp-58h]\n  const char *v62; // [rsp+38h] [rbp-50h]\n  const char *v63; // [rsp+40h] [rbp-48h]\n  const char *v64; // [rsp+48h] [rbp-40h]\n  const char *v65; // [rsp+50h] [rbp-38h]\n  const char *v66; // [rsp+58h] [rbp-30h]\n  __int64 v67; // [rsp+60h] [rbp-28h]\n  __int64 v68; // [rsp+68h] [rbp-20h]\n\n  v1 = status;\n  v2 = qword_61CBC8;\n  if ( status )\n  {\n    v3 = dcgettext(0LL, \"Try '%s --help' for more information.\\n\", 5);\n    __fprintf_chk(stderr, 1LL, v3, v2);\n    goto LABEL_3;\n  }\n  v4 = dcgettext(0LL, \"Usage: %s [OPTION]... [FILE]...\\n  or:  %s [OPTION]... --files0-from=F\\n\", 5);\n  __printf_chk(1LL, v4);\n  v5 = stdout;\n  v6 = dcgettext(0LL, \"Write sorted concatenation of all FILE(s) to standard output.\\n\", 5);\n  fputs_unlocked(v6, v5);\n  v7 = stdout;\n  v8 = dcgettext(0LL, \"\\nWith no FILE, or when FILE is -, read standard input.\\n\", 5);\n  fputs_unlocked(v8, v7);\n  v9 = stdout;\n  v10 = dcgettext(0LL, \"\\nMandatory arguments to long options are mandatory for short options too.\\n\", 5);\n  fputs_unlocked(v10, v9);\n  v11 = stdout;\n  v12 = dcgettext(0LL, \"Ordering options:\\n\\n\", 5);\n  fputs_unlocked(v12, v11);\n  v13 = stdout;\n  v14 = dcgettext(\n          0LL,\n          \"  -b, --ignore-leading-blanks  ignore leading blanks\\n\"\n          \"  -d, --dictionary-order      consider only blanks and alphanumeric characters\\n\"\n          \"  -f, --ignore-case           fold lower case to upper case characters\\n\",\n          5);\n  fputs_unlocked(v14, v13);\n  v15 = stdout;\n  v16 = dcgettext(\n          0LL,\n          \"  -g, --general-numeric-sort  compare according to general numerical value\\n\"\n          \"  -i, --ignore-nonprinting    consider only printable characters\\n\"\n          \"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\\n\",\n          5);\n  fputs_unlocked(v16, v15);\n  v17 = stdout;\n  v18 = dcgettext(0LL, \"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\\n\", 5);\n  fputs_unlocked(v18, v17);\n  v19 = stdout;\n  v20 = dcgettext(\n          0LL,\n          \"  -n, --numeric-sort          compare according to string numerical value\\n\"\n          \"  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\\n\"\n          \"      --random-source=FILE    get random bytes from FILE\\n\"\n          \"  -r, --reverse               reverse the result of comparisons\\n\",\n          5);\n  fputs_unlocked(v20, v19);\n  v21 = stdout;\n  v22 = dcgettext(\n          0LL,\n          \"      --sort=WORD             sort according to WORD:\\n\"\n          \"                                general-numeric -g, human-numeric -h, month -M,\\n\"\n          \"                                numeric -n, random -R, version -V\\n\"\n          \"  -V, --version-sort          natural sort of (version) numbers within text\\n\"\n          \"\\n\",\n          5);\n  fputs_unlocked(v22, v21);\n  v23 = stdout;\n  v24 = dcgettext(0LL, \"Other options:\\n\\n\", 5);\n  fputs_unlocked(v24, v23);\n  v25 = stdout;\n  v26 = dcgettext(\n          0LL,\n          \"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\\n\"\n          \"                            for more use temp files\\n\",\n          5);\n  fputs_unlocked(v26, v25);\n  v27 = stdout;\n  v28 = dcgettext(\n          0LL,\n          \"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\\n\"\n          \"  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\\n\"\n          \"      --compress-program=PROG  compress temporaries with PROG;\\n\"\n          \"                              decompress them with PROG -d\\n\",\n          5);\n  fputs_unlocked(v28, v27);\n  v29 = stdout;\n  v30 = dcgettext(\n          0LL,\n          \"      --debug               annotate the part of the line used to sort,\\n\"\n          \"                              and warn about questionable usage to stderr\\n\"\n          \"      --files0-from=F       read input from the files specified by\\n\"\n          \"                            NUL-terminated names in file F;\\n\"\n          \"                            If F is - then read names from standard input\\n\",\n          5);\n  fputs_unlocked(v30, v29);\n  v31 = stdout;\n  v32 = dcgettext(\n          0LL,\n          \"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\\n\"\n          \"  -m, --merge               merge already sorted files; do not sort\\n\",\n          5);\n  fputs_unlocked(v32, v31);\n  v33 = stdout;\n  v34 = dcgettext(\n          0LL,\n          \"  -o, --output=FILE         write result to FILE instead of standard output\\n\"\n          \"  -s, --stable              stabilize sort by disabling last-resort comparison\\n\"\n          \"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\\n\",\n          5);\n  fputs_unlocked(v34, v33);\n  v35 = dcgettext(\n          0LL,\n          \"  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\\n\"\n          \"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\\n\"\n          \"                              multiple options specify multiple directories\\n\"\n          \"      --parallel=N          change the number of sorts run concurrently to N\\n\"\n          \"  -u, --unique              with -c, check for strict ordering;\\n\"\n          \"                              without -c, output only the first of an equal run\\n\",\n          5);\n  __printf_chk(1LL, v35);\n  v36 = stdout;\n  v37 = dcgettext(0LL, \"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\", 5);\n  fputs_unlocked(v37, v36);\n  v38 = stdout;\n  v39 = dcgettext(0LL, \"      --help     display this help and exit\\n\", 5);\n  fputs_unlocked(v39, v38);\n  v40 = stdout;\n  v41 = dcgettext(0LL, \"      --version  output version information and exit\\n\", 5);\n  fputs_unlocked(v41, v40);\n  v42 = stdout;\n  v43 = dcgettext(\n          0LL,\n          \"\\n\"\n          \"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\\n\"\n          \"field number and C a character position in the field; both are origin 1, and\\n\"\n          \"the stop position defaults to the line's end.  If neither -t nor -b is in\\n\"\n          \"effect, characters in a field are counted from the beginning of the preceding\\n\"\n          \"whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\\n\"\n          \"which override global ordering options for that key.  If no key is given, use\\n\"\n          \"the entire line as the key.  Use --debug to diagnose incorrect key usage.\\n\"\n          \"\\n\"\n          \"SIZE may be followed by the following multiplicative suffixes:\\n\",\n          5);\n  fputs_unlocked(v43, v42);\n  v44 = stdout;\n  v45 = dcgettext(\n          0LL,\n          \"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\\n\"\n          \"\\n\"\n          \"*** WARNING ***\\n\"\n          \"The locale specified by the environment affects sort order.\\n\"\n          \"Set LC_ALL=C to get the traditional sort order that uses\\n\"\n          \"native byte values.\\n\",\n          5);\n  fputs_unlocked(v45, v44);\n  v55 = \"[\";\n  v46 = &v55;\n  v56 = \"test invocation\";\n  v57 = \"coreutils\";\n  v58 = \"Multi-call invocation\";\n  v59 = \"sha224sum\";\n  v60 = \"sha2 utilities\";\n  v61 = \"sha256sum\";\n  v62 = \"sha2 utilities\";\n  v63 = \"sha384sum\";\n  v64 = \"sha2 utilities\";\n  v65 = \"sha512sum\";\n  v66 = \"sha2 utilities\";\n  v67 = 0LL;\n  v68 = 0LL;\n  do\n    v46 += 2;\n  while ( *v46 && memcmp(\"sort\", *v46, 5uLL) );\n  if ( v46[1] )\n  {\n    v47 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v47);\n    v48 = setlocale(5, 0LL);\n    if ( !v48 || !strncmp(v48, \"en_\", 3uLL) )\n      goto LABEL_10;\n  }\n  else\n  {\n    v51 = dcgettext(0LL, \"\\n%s online help: <%s>\\n\", 5);\n    __printf_chk(1LL, v51);\n    v52 = setlocale(5, 0LL);\n    if ( !v52 || !strncmp(v52, \"en_\", 3uLL) )\n    {\n      v53 = dcgettext(0LL, \"Full documentation at: <%s%s>\\n\", 5);\n      __printf_chk(1LL, v53);\n      goto LABEL_11;\n    }\n  }\n  v54 = dcgettext(0LL, \"Report %s translation bugs to <https://translationproject.org/team/>\\n\", 5);\n  __printf_chk(1LL, v54);\nLABEL_10:\n  v49 = dcgettext(0LL, \"Full documentation at: <%s%s>\\n\", 5);\n  __printf_chk(1LL, v49);\nLABEL_11:\n  v50 = dcgettext(0LL, \"or available locally via: info '(coreutils) %s%s'\\n\", 5);\n  __printf_chk(1LL, v50);\nLABEL_3:\n  exit(v1);\n}\n", 
            "funcStartAddr": "0x40a0d0L", 
            "funcEndAddr": "0x40a63dL", 
            "funcName": "sub_40A0D0"
        }, 
        {
            "decompiledFuncCode": "void __noreturn sub_40A640()\n{\n  sub_40A0D0(1);\n}\n", 
            "funcStartAddr": "0x40a640L", 
            "funcEndAddr": "0x40a64aL", 
            "funcName": "sub_40A640"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40A650(const char *a1, const char **a2, char *a3, size_t a4)\n{\n  size_t v4; // r13\n  char *v5; // rbp\n  size_t v6; // rax\n  const char *v7; // r14\n  size_t v8; // r12\n  __int64 v9; // rbx\n  bool v10; // zf\n  char v11; // al\n  __int64 v12; // rax\n  __int64 v14; // [rsp+0h] [rbp-58h]\n  char v15; // [rsp+17h] [rbp-41h]\n  char *v16; // [rsp+18h] [rbp-40h]\n\n  v4 = a4;\n  v5 = a3;\n  v16 = a3;\n  v6 = strlen(a1);\n  v7 = *a2;\n  v14 = -1LL;\n  if ( !*a2 )\n    return v14;\n  v8 = v6;\n  v15 = 0;\n  v9 = 0LL;\n  do\n  {\n    while ( strncmp(v7, a1, v8) )\n    {\nLABEL_7:\n      ++v9;\n      v5 += v4;\n      v7 = a2[v9];\n      if ( !v7 )\n        goto LABEL_12;\n    }\n    if ( strlen(v7) == v8 )\n      return v9;\n    if ( v14 != -1 )\n    {\n      if ( v16 )\n      {\n        v10 = memcmp(&v16[v4 * v14], v5, v4) == 0;\n        v11 = v15;\n        if ( !v10 )\n          v11 = 1;\n        v15 = v11;\n      }\n      else\n      {\n        v15 = 1;\n      }\n      goto LABEL_7;\n    }\n    v14 = v9++;\n    v5 += v4;\n    v7 = a2[v9];\n  }\n  while ( v7 );\nLABEL_12:\n  v12 = -2LL;\n  if ( !v15 )\n    v12 = v14;\n  return v12;\n}\n", 
            "funcStartAddr": "0x40a650L", 
            "funcEndAddr": "0x40a766L", 
            "funcName": "sub_40A650"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_40A770(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rbx\n  __int64 v4; // rbp\n  __int64 v5; // rax\n\n  if ( a3 == -1 )\n    v3 = dcgettext(0LL, \"invalid argument %s for %s\", 5);\n  else\n    v3 = dcgettext(0LL, \"ambiguous argument %s for %s\", 5);\n  v4 = sub_40F860(1LL, a1);\n  v5 = sub_40F550(0LL, 8LL, a2);\n  error(0, 0, v3, v5, v4);\n}\n", 
            "funcStartAddr": "0x40a770L", 
            "funcEndAddr": "0x40a7e1L", 
            "funcName": "sub_40A770"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_40A7F0(__int64 *a1, char *a2, size_t a3)\n{\n  const void *v3; // r14\n  size_t v4; // r13\n  char *v5; // rbp\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rsi\n  __int64 v9; // rbx\n  __int64 i; // r12\n  __int64 v11; // rax\n  __int64 v12; // rax\n  char *v13; // rax\n\n  v3 = 0LL;\n  v4 = a3;\n  v5 = a2;\n  v6 = stderr;\n  v7 = dcgettext(0LL, \"Valid arguments are:\", 5);\n  v8 = v6;\n  v9 = 0LL;\n  fputs_unlocked(v7, v8);\n  for ( i = *a1; i; i = a1[v9] )\n  {\n    while ( !v9 || memcmp(v3, v5, v4) )\n    {\n      ++v9;\n      v3 = v5;\n      v5 += v4;\n      v11 = sub_40F880(i);\n      __fprintf_chk(stderr, 1LL, \"\\n  - %s\", v11);\n      i = a1[v9];\n      if ( !i )\n        goto LABEL_7;\n    }\n    ++v9;\n    v5 += v4;\n    v12 = sub_40F880(i);\n    __fprintf_chk(stderr, 1LL, \", %s\", v12);\n  }\nLABEL_7:\n  v13 = stderr->_IO_write_ptr;\n  if ( v13 >= stderr->_IO_write_end )\n  {\n    LODWORD(v13) = __overflow(stderr, 10);\n  }\n  else\n  {\n    stderr->_IO_write_ptr = v13 + 1;\n    *v13 = 10;\n  }\n  return (int)v13;\n}\n", 
            "funcStartAddr": "0x40a7f0L", 
            "funcEndAddr": "0x40a908L", 
            "funcName": "sub_40A7F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40A910(__int64 a1, const char *a2, const char **a3, char *a4, size_t a5, void (*a6)(void))\n{\n  size_t v6; // r15\n  void (*v7)(void); // r13\n  char *v8; // rbp\n  __int64 *v9; // rbx\n  __int64 result; // rax\n\n  v6 = a5;\n  v7 = a6;\n  v8 = a4;\n  v9 = (__int64 *)a3;\n  result = sub_40A650(a2, a3, a4, a5);\n  if ( result < 0 )\n  {\n    sub_40A770(a1, (__int64)a2, result);\n    sub_40A7F0(v9, v8, v6);\n    v7();\n    result = -1LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40a910L", 
            "funcEndAddr": "0x40a980L", 
            "funcName": "sub_40A910"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40A980(void *s1, __int64 *a2, char *a3, size_t a4)\n{\n  __int64 v4; // r14\n  size_t v5; // r12\n  __int64 *v6; // rbx\n  char *v7; // rbp\n\n  v4 = *a2;\n  if ( *a2 )\n  {\n    v5 = a4;\n    v6 = a2 + 1;\n    v7 = a3;\n    do\n    {\n      if ( !memcmp(s1, v7, v5) )\n        break;\n      v4 = *v6;\n      v7 += v5;\n      ++v6;\n    }\n    while ( v4 );\n  }\n  return v4;\n}\n", 
            "funcStartAddr": "0x40a980L", 
            "funcEndAddr": "0x40a9cdL", 
            "funcName": "sub_40A980"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_40A9F0()\n{\n  int *v0; // rax\n  int *v1; // rbx\n  __int64 result; // rax\n  char *v3; // rax\n  char *v4; // rbp\n  __int64 v5; // rax\n\n  if ( (unsigned int)sub_413520(stdout) )\n  {\n    v0 = __errno_location();\n    v1 = v0;\n    if ( !byte_61CBB0 || *v0 != 32 )\n    {\n      v3 = dcgettext(0LL, \"write error\", 5);\n      v4 = v3;\n      if ( qword_61CBB8 )\n      {\n        v5 = sub_40F6D0();\n        error(0, *v1, \"%s: %s\", v5, v4);\n      }\n      else\n      {\n        error(0, *v1, \"%s\", v3);\n      }\nLABEL_8:\n      _exit(status);\n    }\n  }\n  result = sub_413520(stderr);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  return result;\n}\n", 
            "funcStartAddr": "0x40a9f0L", 
            "funcEndAddr": "0x40aa8eL", 
            "funcName": "sub_40A9F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40AA90(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_QWORD *)(a1 + 16) = 0LL;\n  *(_QWORD *)a1 = -1167088121787636991LL;\n  result = 1167088121787636990LL;\n  *(_QWORD *)(a1 + 8) = 1167088121787636990LL;\n  *(_DWORD *)(a1 + 24) = 0;\n  return result;\n}\n", 
            "funcStartAddr": "0x40aa90L", 
            "funcEndAddr": "0x40aabbL", 
            "funcName": "sub_40AA90"
        }, 
        {
            "decompiledFuncCode": "_DWORD *__fastcall sub_40AAC0(_DWORD *a1, _DWORD *a2)\n{\n  _DWORD *result; // rax\n\n  result = a2;\n  *a2 = *a1;\n  a2[1] = a1[1];\n  a2[2] = a1[2];\n  a2[3] = a1[3];\n  return result;\n}\n", 
            "funcStartAddr": "0x40aac0L", 
            "funcEndAddr": "0x40aadaL", 
            "funcName": "sub_40AAC0"
        }, 
        {
            "decompiledFuncCode": "_DWORD *__fastcall sub_40AAE0(int *a1, __int64 a2, _DWORD *a3)\n{\n  int *v3; // rbx\n  _DWORD *v4; // rdi\n  int v5; // er11\n  unsigned __int64 v6; // rcx\n  int v7; // er10\n  int v8; // edx\n  _BOOL4 v9; // eax\n  int v10; // esi\n  int v11; // er15\n  int v12; // er14\n  int v13; // er13\n  int v14; // eax\n  int v15; // ecx\n  int v16; // edx\n  int v17; // ecx\n  int v18; // er9\n  int v19; // esi\n  int v20; // eax\n  int v21; // edx\n  int v22; // ecx\n  int v23; // ebp\n  int v24; // esi\n  int v25; // er12\n  int v26; // eax\n  int v27; // edx\n  int v28; // er8\n  int v29; // ecx\n  int v30; // esi\n  int v31; // eax\n  int v32; // edx\n  int v33; // ecx\n  int v34; // esi\n  int v35; // eax\n  int v36; // edx\n  int v37; // ecx\n  int v38; // esi\n  int v39; // eax\n  int v40; // edx\n  int v41; // ecx\n  int v42; // esi\n  int v43; // eax\n  int v44; // edx\n  int v45; // ecx\n  int v46; // edi\n  int v47; // eax\n  int v48; // edx\n  int v49; // esi\n  int v50; // edi\n  int v51; // ecx\n  int v52; // edx\n  int v53; // esi\n  int v54; // eax\n  int v55; // ecx\n  int v56; // edi\n  int v57; // edx\n  int v58; // esi\n  int v59; // ecx\n  int v60; // eax\n  int v61; // edi\n  int v62; // esi\n  int v63; // edx\n  int v64; // ecx\n  int v65; // edi\n  int v66; // eax\n  int v67; // edx\n  int v68; // ecx\n  int v69; // esi\n  int v70; // eax\n  int v71; // edx\n  int v72; // ecx\n  int v73; // esi\n  int v74; // eax\n  int v75; // edx\n  int v76; // ecx\n  int v77; // esi\n  int v78; // edi\n  int v79; // eax\n  int v80; // edx\n  int v81; // ecx\n  _DWORD *result; // rax\n  int v83; // [rsp+0h] [rbp-74h]\n  int v84; // [rsp+4h] [rbp-70h]\n  int v85; // [rsp+8h] [rbp-6Ch]\n  int v86; // [rsp+Ch] [rbp-68h]\n  int v87; // [rsp+10h] [rbp-64h]\n  int v88; // [rsp+14h] [rbp-60h]\n  int v89; // [rsp+18h] [rbp-5Ch]\n  int v90; // [rsp+1Ch] [rbp-58h]\n  int v91; // [rsp+20h] [rbp-54h]\n  int v92; // [rsp+24h] [rbp-50h]\n  int v93; // [rsp+28h] [rbp-4Ch]\n  int v94; // [rsp+2Ch] [rbp-48h]\n  unsigned __int64 v95; // [rsp+34h] [rbp-40h]\n  _DWORD *v96; // [rsp+3Ch] [rbp-38h]\n\n  v3 = a1;\n  v4 = a3;\n  v5 = a3[1];\n  v6 = (unsigned __int64)v3 + (a2 & 0xFFFFFFFFFFFFFFFCLL);\n  v7 = a3[2];\n  v94 = *a3;\n  v96 = a3;\n  v92 = a3[3];\n  v8 = a3[4] + a2;\n  v9 = __CFADD__(v4[4], (_DWORD)a2);\n  v10 = v4[5] + HIDWORD(a2);\n  v95 = v6;\n  v4[4] = v8;\n  v4[5] = v9 + v10;\n  if ( (unsigned __int64)v3 < v6 )\n  {\n    v11 = v7;\n    do\n    {\n      v12 = *v3;\n      v83 = v3[1];\n      v13 = v3[7];\n      v87 = v3[5];\n      v85 = v3[3];\n      v89 = v3[9];\n      v91 = v3[11];\n      v14 = v5 + __ROL4__(*v3 + v94 - 680876936 + (v92 ^ v5 & (v11 ^ v92)), 7);\n      v15 = v3[2];\n      v16 = v14 + __ROL4__(v83 + v92 - 389564586 + (v11 ^ v14 & (v11 ^ v5)), 12);\n      v84 = v15;\n      v17 = v16 + __ROR4__(v15 + v11 + 606105819 + (v5 ^ v16 & (v5 ^ v14)), 15);\n      v86 = v3[4];\n      v18 = v3[15];\n      v19 = v17 + __ROR4__(v85 + v5 - 1044525330 + (v14 ^ v17 & (v16 ^ v14)), 10);\n      v93 = v3[6];\n      v20 = v19 + __ROL4__(v86 + v14 - 176418897 + (v16 ^ v19 & (v17 ^ v16)), 7);\n      v21 = v20 + __ROL4__(v87 + v16 + 1200080426 + (v17 ^ v20 & (v19 ^ v17)), 12);\n      v22 = v21 + __ROR4__(v93 + v17 - 1473231341 + (v19 ^ v21 & (v20 ^ v19)), 15);\n      v88 = v3[8];\n      v23 = v3[12];\n      v24 = v22 + __ROR4__(v13 + v19 - 45705983 + (v20 ^ v22 & (v21 ^ v20)), 10);\n      v25 = v3[14];\n      v26 = v24 + __ROL4__(v88 + v20 + 1770035416 + (v21 ^ v24 & (v22 ^ v21)), 7);\n      v90 = v3[10];\n      v27 = v26 + __ROL4__(v89 + v21 - 1958414417 + (v22 ^ v26 & (v24 ^ v22)), 12);\n      v28 = v3[13];\n      v3 += 16;\n      v29 = v27 + __ROR4__(v90 + v22 - 42063 + (v24 ^ v27 & (v26 ^ v24)), 15);\n      v30 = v29 + __ROR4__(v91 + v24 - 1990404162 + (v26 ^ v29 & (v27 ^ v26)), 10);\n      v31 = v30 + __ROL4__(v23 + v26 + 1804603682 + (v27 ^ v30 & (v29 ^ v27)), 7);\n      v32 = v31 + __ROL4__(v28 + v27 - 40341101 + (v29 ^ v31 & (v30 ^ v29)), 12);\n      v33 = v32 + __ROR4__(v25 + v29 - 1502002290 + (v30 ^ v32 & (v31 ^ v30)), 15);\n      v34 = v33 + __ROR4__(v18 + v30 + 1236535329 + (v31 ^ v33 & (v32 ^ v31)), 10);\n      v35 = v34 + __ROL4__(v83 + v31 - 165796510 + (v33 ^ v32 & (v34 ^ v33)), 5);\n      v36 = v35 + __ROL4__(v93 + v32 - 1069501632 + (v34 ^ v33 & (v35 ^ v34)), 9);\n      v37 = v36 + __ROL4__(v91 + v33 + 643717713 + (v35 ^ v34 & (v36 ^ v35)), 14);\n      v38 = v37 + __ROR4__(v12 + v34 - 373897302 + (v36 ^ v35 & (v37 ^ v36)), 12);\n      v39 = v38 + __ROL4__(v87 + v35 - 701558691 + (v37 ^ v36 & (v38 ^ v37)), 5);\n      v40 = v39 + __ROL4__(v90 + v36 + 38016083 + (v38 ^ v37 & (v39 ^ v38)), 9);\n      v41 = v40 + __ROL4__(v18 + v37 - 660478335 + (v39 ^ v38 & (v40 ^ v39)), 14);\n      v42 = v41 + __ROR4__(v86 + v38 - 405537848 + (v40 ^ v39 & (v41 ^ v40)), 12);\n      v43 = v42 + __ROL4__(v89 + v39 + 568446438 + (v41 ^ v40 & (v42 ^ v41)), 5);\n      v44 = v43 + __ROL4__(v25 + v40 - 1019803690 + (v42 ^ v41 & (v43 ^ v42)), 9);\n      v45 = v44 + __ROL4__(v85 + v41 - 187363961 + (v43 ^ v42 & (v44 ^ v43)), 14);\n      v46 = v45 + __ROR4__(v88 + v42 + 1163531501 + (v44 ^ v43 & (v45 ^ v44)), 12);\n      v47 = v46 + __ROL4__(v28 + v43 - 1444681467 + (v45 ^ v44 & (v46 ^ v45)), 5);\n      v48 = v47 + __ROL4__(v84 + v44 - 51403784 + (v46 ^ v45 & (v47 ^ v46)), 9);\n      v49 = v48 + __ROL4__(v13 + v45 + 1735328473 + (v47 ^ v46 & (v48 ^ v47)), 14);\n      v50 = v49 + __ROR4__(v23 + v46 - 1926607734 + (v48 ^ v47 & (v49 ^ v48)), 12);\n      v51 = v50 + __ROL4__(v87 + v47 - 378558 + (v50 ^ v49 ^ v48), 4);\n      v52 = v51 + __ROL4__(v88 + v48 - 2022574463 + (v51 ^ v50 ^ v49), 11);\n      v53 = v52 + __ROL4__(v91 + v49 + 1839030562 + (v52 ^ v51 ^ v50), 16);\n      v54 = v53 + __ROR4__(v25 + v50 - 35309556 + (v53 ^ v52 ^ v51), 9);\n      v55 = v54 + __ROL4__(v83 + v51 - 1530992060 + (v54 ^ v53 ^ v52), 4);\n      v56 = v55 + __ROL4__(v86 + v52 + 1272893353 + (v55 ^ v54 ^ v53), 11);\n      v57 = v56 + __ROL4__(v13 + v53 - 155497632 + (v56 ^ v55 ^ v54), 16);\n      v58 = v57 + __ROR4__(v90 + v54 - 1094730640 + (v57 ^ v56 ^ v55), 9);\n      v59 = v58 + __ROL4__(v28 + v55 + 681279174 + (v58 ^ v57 ^ v56), 4);\n      v60 = v59 + __ROL4__(v12 + v56 - 358537222 + (v59 ^ v58 ^ v57), 11);\n      v61 = v60 + __ROL4__(v85 + v57 - 722521979 + (v60 ^ v59 ^ v58), 16);\n      v62 = v61 + __ROR4__(v93 + v58 + 76029189 + (v61 ^ v60 ^ v59), 9);\n      v63 = v62 + __ROL4__(v89 + v59 - 640364487 + (v62 ^ v61 ^ v60), 4);\n      v64 = v63 + __ROL4__(v23 + v60 - 421815835 + (v63 ^ v62 ^ v61), 11);\n      v65 = v64 + __ROL4__(v18 + v61 + 530742520 + (v64 ^ v63 ^ v62), 16);\n      v66 = v65 + __ROR4__(v84 + v62 - 995338651 + (v65 ^ v64 ^ v63), 9);\n      v67 = v66 + __ROL4__(v12 + v63 - 198630844 + (v65 ^ (v66 | ~v64)), 6);\n      v68 = v67 + __ROL4__(v13 + v64 + 1126891415 + (v66 ^ (v67 | ~v65)), 10);\n      v69 = v68 + __ROL4__(v25 + v65 - 1416354905 + (v67 ^ (v68 | ~v66)), 15);\n      v70 = v69 + __ROR4__(v87 + v66 - 57434055 + (v68 ^ (v69 | ~v67)), 11);\n      v71 = v70 + __ROL4__(v23 + v67 + 1700485571 + (v69 ^ (v70 | ~v68)), 6);\n      v72 = v71 + __ROL4__(v85 + v68 - 1894986606 + (v70 ^ (v71 | ~v69)), 10);\n      v73 = v72 + __ROL4__(v90 + v69 - 1051523 + (v71 ^ (v72 | ~v70)), 15);\n      v74 = v73 + __ROR4__(v83 + v70 - 2054922799 + (v72 ^ (v73 | ~v71)), 11);\n      v75 = v74 + __ROL4__(v88 + v71 + 1873313359 + (v73 ^ (v74 | ~v72)), 6);\n      v76 = v75 + __ROL4__(v18 + v72 - 30611744 + (v74 ^ (v75 | ~v73)), 10);\n      v77 = v76 + __ROL4__(v93 + v73 - 1560198380 + (v75 ^ (v76 | ~v74)), 15);\n      v78 = v77 + __ROR4__(v28 + v74 + 1309151649 + (v76 ^ (v77 | ~v75)), 11);\n      v79 = v78 + __ROL4__(v86 + v75 - 145523070 + (v77 ^ (v78 | ~v76)), 6);\n      v80 = v79 + __ROL4__(v91 + v76 - 1120210379 + (v78 ^ (v79 | ~v77)), 10);\n      v81 = v80 + __ROL4__(v84 + v77 + 718787259 + (v79 ^ (v80 | ~v78)), 15);\n      v94 += v79;\n      v11 += v81;\n      v5 += v81 + __ROR4__(v89 + v78 - 343485551 + (v80 ^ (v81 | ~v79)), 11);\n      v92 += v80;\n    }\n    while ( v95 > (unsigned __int64)v3 );\n    v7 = v11;\n  }\n  result = v96;\n  *v96 = v94;\n  v96[1] = v5;\n  v96[2] = v7;\n  v96[3] = v92;\n  return result;\n}\n", 
            "funcStartAddr": "0x40aae0L", 
            "funcEndAddr": "0x40b24fL", 
            "funcName": "sub_40AAE0"
        }, 
        {
            "decompiledFuncCode": "_DWORD *__fastcall sub_40B250(_DWORD *a1, _DWORD *a2)\n{\n  _DWORD *v2; // rbp\n  __int64 v3; // rax\n  int v4; // edx\n  int v5; // esi\n  __int64 v6; // r8\n  bool v7; // cf\n  unsigned int v8; // esi\n  _QWORD *v9; // rdx\n  unsigned __int64 v10; // rcx\n\n  v2 = a2;\n  v3 = (unsigned int)a1[6];\n  v4 = a1[5];\n  v5 = a1[6];\n  v6 = (-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFC0LL) + 128;\n  v7 = __CFADD__(a1[4], v5);\n  v8 = a1[4] + v5;\n  a1[4] = v8;\n  if ( v7 )\n    a1[5] = ++v4;\n  a1[(-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFF0LL) + 37] = 8 * v8;\n  a1[(-(__int64)((unsigned int)v3 < 0x38) & 0xFFFFFFFFFFFFFFF0LL) + 38] = (v8 >> 29) | (8 * v4);\n  v9 = (_QWORD *)((char *)a1 + v3 + 28);\n  v10 = v6 - v3 - 8;\n  if ( v10 >= 8 )\n  {\n    *v9 = 128LL;\n    *(_QWORD *)((char *)v9 + v10 - 8) = *(_QWORD *)((char *)&unk_416AD8 + v10);\n    qmemcpy(\n      (void *)((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL),\n      (const void *)((char *)&qword_416AE0 - ((char *)v9 - ((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL))),\n      8 * (((unsigned __int64)v9 + v10 - ((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL)) >> 3));\n  }\n  else if ( v10 & 4 )\n  {\n    *(_DWORD *)v9 = 128;\n    *(_DWORD *)((char *)v9 + v10 - 4) = *(_DWORD *)((char *)&unk_416ADC + v10);\n  }\n  else if ( v6 - v3 != 8 )\n  {\n    *(_BYTE *)v9 = -128;\n    if ( v10 & 2 )\n      *(_WORD *)((char *)v9 + v10 - 2) = *(__int16 *)((char *)&word_416ADE + v10);\n  }\n  sub_40AAE0(a1 + 7, v6, a1);\n  return sub_40AAC0(a1, v2);\n}\n", 
            "funcStartAddr": "0x40b250L", 
            "funcEndAddr": "0x40b354L", 
            "funcName": "sub_40B250"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40B360(void *src, size_t n, __int64 a3)\n{\n  size_t v3; // r13\n  __int64 v4; // r12\n  __m128i *v5; // rbx\n  unsigned __int64 result; // rax\n  int *v7; // rbp\n  const __m128i *v8; // r14\n  __m128i v9; // xmm0\n  __int64 v10; // rcx\n  _QWORD *v11; // rsi\n  size_t v12; // r13\n  size_t v13; // rbp\n  int *v14; // rdi\n  __int64 v15; // rbp\n  __int64 v16; // r15\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18; // r14\n  unsigned int v19; // esi\n  unsigned __int64 v20; // rdi\n  signed __int64 v21; // r14\n  unsigned int v22; // edx\n  __int64 v23; // rsi\n  int v24; // ecx\n  __int64 v25; // rdx\n  unsigned __int64 v26; // rsi\n  unsigned __int64 v27; // r15\n  unsigned int v28; // er15\n  unsigned int v29; // er15\n  unsigned int v30; // edx\n  __int64 v31; // rcx\n\n  v3 = n;\n  v4 = a3;\n  v5 = (__m128i *)src;\n  result = *(unsigned int *)(a3 + 24);\n  if ( (_DWORD)result )\n  {\n    v15 = (unsigned int)result;\n    v16 = a3 + 28;\n    v17 = 128LL - (unsigned int)result;\n    if ( v17 > n )\n      v17 = n;\n    v18 = v17;\n    result = (unsigned __int64)memcpy((void *)(v4 + 28 + (unsigned int)result), src, v17);\n    v19 = v18 + *(_DWORD *)(v4 + 24);\n    *(_DWORD *)(v4 + 24) = v19;\n    if ( v19 > 0x40 )\n    {\n      sub_40AAE0((int *)(v4 + 28), v19 & 0xFFFFFFC0, (_DWORD *)v4);\n      v24 = *(_DWORD *)(v4 + 24);\n      result = v16 + ((v15 + v18) & 0xFFFFFFFFFFFFFFC0LL);\n      v25 = *(_DWORD *)(v4 + 24) & 0x3F;\n      *(_DWORD *)(v4 + 24) = v25;\n      if ( (unsigned int)v25 >= 8 )\n      {\n        *(_QWORD *)(v4 + 28) = *(_QWORD *)result;\n        *(_QWORD *)(v16 + (unsigned int)v25 - 8) = *(_QWORD *)(result + (unsigned int)v25 - 8);\n        v26 = (v4 + 36) & 0xFFFFFFFFFFFFFFF8LL;\n        v27 = v16 - v26;\n        result -= v27;\n        v28 = (v25 + v27) & 0xFFFFFFF8;\n        if ( v28 >= 8 )\n        {\n          v29 = v28 & 0xFFFFFFF8;\n          v30 = 0;\n          do\n          {\n            v31 = v30;\n            v30 += 8;\n            *(_QWORD *)(v26 + v31) = *(_QWORD *)(result + v31);\n          }\n          while ( v30 < v29 );\n        }\n      }\n      else if ( v24 & 4 )\n      {\n        *(_DWORD *)(v4 + 28) = *(_DWORD *)result;\n        result = *(unsigned int *)(result + v25 - 4);\n        *(_DWORD *)(v16 + v25 - 4) = result;\n      }\n      else if ( (_DWORD)v25 )\n      {\n        *(_BYTE *)(v4 + 28) = *(_BYTE *)result;\n        if ( v24 & 2 )\n        {\n          result = *(unsigned __int16 *)(result + v25 - 2);\n          *(_WORD *)(v16 + v25 - 2) = result;\n        }\n      }\n    }\n    v5 = (__m128i *)((char *)src + v18);\n    v3 -= v18;\n  }\n  if ( v3 > 0x3F )\n  {\n    if ( (unsigned __int8)v5 & 3 )\n    {\n      v7 = (int *)(v4 + 28);\n      if ( v3 == 64 )\n      {\n        v8 = v5;\n      }\n      else\n      {\n        v8 = &v5[4 * ((v3 - 65) >> 6) + 4];\n        do\n        {\n          v9 = _mm_loadu_si128(v5);\n          v5 += 4;\n          *(__m128i *)v7 = v9;\n          *(__m128i *)(v4 + 44) = _mm_loadu_si128(v5 - 3);\n          *(__m128i *)(v4 + 60) = _mm_loadu_si128(v5 - 2);\n          *(__m128i *)(v4 + 76) = _mm_loadu_si128(v5 - 1);\n          sub_40AAE0((int *)(v4 + 28), 64LL, (_DWORD *)v4);\n        }\n        while ( v5 != v8 );\n        v3 = v3 - ((v3 - 65) >> 6 << 6) - 64;\n      }\n      goto LABEL_8;\n    }\n    v13 = v3;\n    v14 = (int *)v5;\n    v3 &= 0x3Fu;\n    v5 = (__m128i *)((char *)v5 + (v13 & 0xFFFFFFFFFFFFFFC0LL));\n    result = (unsigned __int64)sub_40AAE0(v14, v13 & 0xFFFFFFFFFFFFFFC0LL, (_DWORD *)v4);\n  }\n  if ( !v3 )\n    return result;\n  v7 = (int *)(v4 + 28);\n  v8 = v5;\nLABEL_8:\n  v10 = *(unsigned int *)(v4 + 24);\n  result = (unsigned int)v3;\n  v11 = (_QWORD *)((char *)v7 + v10);\n  if ( (unsigned int)v3 >= 8 )\n  {\n    v20 = (unsigned __int64)(v11 + 1) & 0xFFFFFFFFFFFFFFF8LL;\n    *v11 = v8->m128i_i64[0];\n    *(_QWORD *)((char *)v11 + (unsigned int)v3 - 8) = *(__int64 *)((char *)&v8->m128i_i64[-1] + (unsigned int)v3);\n    v21 = (char *)v8 - ((char *)v11 - v20);\n    result = ((_DWORD)v3 + (_DWORD)v11 - (_DWORD)v20) & 0xFFFFFFF8;\n    if ( (unsigned int)result >= 8 )\n    {\n      result = ((_DWORD)v3 + (_DWORD)v11 - (_DWORD)v20) & 0xFFFFFFF8;\n      v22 = 0;\n      do\n      {\n        v23 = v22;\n        v22 += 8;\n        *(_QWORD *)(v20 + v23) = *(_QWORD *)(v21 + v23);\n      }\n      while ( v22 < (unsigned int)result );\n    }\n  }\n  else if ( v3 & 4 )\n  {\n    *(_DWORD *)v11 = v8->m128i_i64[0];\n    result = *(unsigned int *)((char *)v8->m128i_i64 + (unsigned int)v3 - 4);\n    *(_DWORD *)((char *)v11 + (unsigned int)v3 - 4) = result;\n  }\n  else if ( (_DWORD)v3 )\n  {\n    *(_BYTE *)v11 = v8->m128i_i64[0];\n    if ( v3 & 2 )\n    {\n      result = *(unsigned __int16 *)((char *)v8->m128i_i64 + (unsigned int)v3 - 2);\n      *(_WORD *)((char *)v11 + (unsigned int)v3 - 2) = result;\n    }\n  }\n  v12 = v10 + v3;\n  if ( v12 > 0x3F )\n  {\n    v12 -= 64LL;\n    sub_40AAE0(v7, 64LL, (_DWORD *)v4);\n    result = (unsigned __int64)memcpy(v7, (const void *)(v4 + 92), v12);\n  }\n  *(_DWORD *)(v4 + 24) = v12;\n  return result;\n}\n", 
            "funcStartAddr": "0x40b360L", 
            "funcEndAddr": "0x40b65eL", 
            "funcName": "sub_40B360"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_40B800(FILE *a1, int a2)\n{\n  int v2; // eax\n\n  if ( a1 )\n  {\n    v2 = fileno(a1);\n    posix_fadvise(v2, 0LL, 0LL, a2);\n  }\n}\n", 
            "funcStartAddr": "0x40b800L", 
            "funcEndAddr": "0x40b821L", 
            "funcName": "sub_40B800"
        }, 
        {
            "decompiledFuncCode": "char *__fastcall sub_40B830(char **a1)\n{\n  char *v1; // rsi\n  char v2; // dl\n  char v3; // cl\n  char *result; // rax\n  unsigned int v5; // ecx\n  __int64 v6; // r8\n\n  v1 = *a1;\n  v2 = **a1;\n  if ( v2 )\n  {\n    v3 = 0;\n    result = 0LL;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( v3 )\n        {\n          v5 = v2 - 65;\n          if ( v5 > 0x39 || (v6 = 1LL << v5, v3 = 0, !(v6 & 0x3FFFFFF03FFFFFFLL)) )\n          {\n            v3 = 0;\n            if ( v2 != 126 )\n              result = 0LL;\n          }\n          goto LABEL_7;\n        }\n        if ( v2 == 46 )\n        {\n          v3 = 1;\n          if ( !result )\n            result = v1;\n          goto LABEL_7;\n        }\n        if ( v2 <= 90 )\n          break;\n        if ( (unsigned __int8)(v2 - 97) > 0x19u )\n          goto LABEL_13;\nLABEL_7:\n        *a1 = ++v1;\n        v2 = *v1;\n        if ( !*v1 )\n          return result;\n      }\n      if ( v2 >= 65 || (unsigned __int8)(v2 - 48) <= 9u )\n        goto LABEL_7;\nLABEL_13:\n      if ( v2 != 126 )\n        result = 0LL;\n      *a1 = ++v1;\n      v2 = *v1;\n      if ( !*v1 )\n        return result;\n    }\n  }\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40b830L", 
            "funcEndAddr": "0x40b8f3L", 
            "funcName": "sub_40B830"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40B900(char *s1, char *s2)\n{\n  char *v2; // rbp\n  char *v3; // rbx\n  unsigned int v4; // er12\n  char v5; // r8\n  char v6; // r9\n  char *v7; // r13\n  char *v8; // rax\n  size_t v9; // r13\n  unsigned __int64 v10; // r14\n  unsigned __int64 v11; // rsi\n  size_t v12; // rdx\n  unsigned __int64 v13; // r9\n  unsigned __int8 v14; // al\n  unsigned int v15; // er10\n  int v16; // ecx\n  unsigned int v17; // ecx\n  unsigned __int8 v18; // di\n  int v19; // eax\n  int v20; // ecx\n  unsigned int v21; // ecx\n  int v22; // eax\n  unsigned int v23; // er9\n  size_t v25; // rdi\n  unsigned int v26; // er9\n  int v27; // eax\n  unsigned int v28; // [rsp+4h] [rbp-54h]\n  char *v29; // [rsp+10h] [rbp-48h]\n  char *v30; // [rsp+18h] [rbp-40h]\n\n  v2 = s2;\n  v3 = s1;\n  v4 = strcmp(s1, s2);\n  if ( v4 )\n  {\n    v5 = *s1;\n    if ( *s1 )\n    {\n      v6 = *s2;\n      if ( !*s2 )\n        return 1;\n      if ( !strcmp((const char *)&unk_416B21, s1) )\n        goto LABEL_50;\n      if ( !strcmp((const char *)&unk_416B21, s2) )\n        return 1;\n      if ( !strcmp((const char *)&unk_416B20, s1) )\n        goto LABEL_50;\n      if ( !strcmp((const char *)&unk_416B20, s2) )\n        return 1;\n      if ( v6 == 46 || v5 != 46 )\n      {\n        if ( v5 == 46 )\n        {\n          if ( v6 == 46 )\n          {\n            v3 = s1 + 1;\n            v2 = s2 + 1;\n          }\nLABEL_12:\n          v29 = v3;\n          v30 = v2;\n          v7 = sub_40B830(&v29);\n          v8 = sub_40B830(&v30);\n          if ( v7 )\n          {\n            v9 = v7 - v3;\n            if ( !v8 )\n            {\n              v10 = v30 - v2;\nLABEL_15:\n              if ( v9 != v10 || strncmp(v3, v2, v9) )\n                goto LABEL_16;\n              v9 = v29 - v3;\nLABEL_65:\n              v10 = v30 - v2;\nLABEL_16:\n              v11 = 0LL;\n              v12 = 0LL;\n              while ( 1 )\n              {\n                if ( v9 <= v12 && v10 <= v11 )\n                  return v4;\n                v13 = v11 - v12;\n                if ( v9 > v12 )\n                  break;\nLABEL_32:\n                while ( 1 )\n                {\n                  v18 = v2[v11];\n                  v20 = (char)v18;\n                  if ( v10 <= v11 || (unsigned int)((char)v18 - 48) <= 9 )\n                    break;\n                  if ( v9 != v12 )\n                  {\n                    v16 = (unsigned __int8)v3[v12];\n                    v14 = v3[v12];\n                    v15 = (unsigned __int8)v3[v12];\n                    if ( (unsigned int)(v16 - 48) > 9 )\n                      goto LABEL_23;\n                  }\nLABEL_36:\n                  v19 = v18;\n                  v15 = 0;\n                  if ( (unsigned int)v18 - 48 > 9 )\n                    goto LABEL_37;\nLABEL_31:\n                  ++v12;\n                  ++v11;\n                  if ( v9 > v12 )\n                    goto LABEL_20;\n                }\n                while ( 1 )\n                {\n                  v22 = v3[v12];\n                  if ( v3[v12] != 48 )\n                    break;\n                  ++v12;\n                }\n                if ( v18 == 48 )\n                {\n                  do\n                    v20 = v2[++v11];\n                  while ( v2[v11] == 48 );\n                }\n                v23 = v20 - 48;\n                if ( (unsigned int)(v22 - 48) > 9 )\n                {\n                  if ( v23 <= 9 )\n                    goto LABEL_50;\n                }\n                else\n                {\n                  if ( v23 > 9 )\n                    return 1;\n                  v25 = v12;\n                  v26 = 0;\n                  while ( 1 )\n                  {\n                    v27 = v22 - v20;\n                    if ( !v26 )\n                      v26 = v27;\n                    v20 = v2[v11 - v12 + ++v25];\n                    v22 = v3[v25];\n                    v28 = v20 - 48;\n                    if ( (unsigned int)(v22 - 48) > 9 )\n                      break;\n                    if ( v28 > 9 )\n                      return 1;\n                  }\n                  if ( v28 <= 9 )\n                    goto LABEL_50;\n                  if ( v26 )\n                    return v26;\n                  v11 += v25 - v12;\n                  v12 = v25;\n                }\n              }\nLABEL_20:\n              v14 = v3[v12];\n              if ( (unsigned int)((char)v14 - 48) <= 9 )\n                goto LABEL_32;\n              v15 = v14;\n              if ( (unsigned int)v14 - 48 <= 9 )\n              {\n                if ( v10 != v11 )\n                {\n                  v18 = v2[v11];\n                  goto LABEL_36;\n                }\n                goto LABEL_31;\n              }\n              v16 = v14;\nLABEL_23:\n              v17 = v16 - 65;\n              if ( v17 <= 0x39 && (1LL << v17) & 0x3FFFFFF03FFFFFFLL )\n              {\n                v19 = 0;\n                if ( v10 == v12 + v13 )\n                {\nLABEL_30:\n                  if ( v19 == v15 )\n                    goto LABEL_31;\n                  return v15 - v19;\n                }\n              }\n              else\n              {\n                if ( v14 == 126 )\n                  v15 = -1;\n                else\n                  v15 += 256;\n                if ( v10 == v12 + v13 )\n                  return v15;\n              }\n              v18 = v2[v11];\n              v19 = v18;\n              if ( (unsigned int)v18 - 48 > 9 )\n              {\nLABEL_37:\n                v21 = v18 - 65;\n                if ( v21 > 0x39 || !((1LL << v21) & 0x3FFFFFF03FFFFFFLL) )\n                {\n                  if ( v18 == 126 )\n                    v19 = -1;\n                  else\n                    v19 += 256;\n                }\n              }\n              else\n              {\n                v19 = 0;\n              }\n              goto LABEL_30;\n            }\n          }\n          else\n          {\n            v9 = v29 - v3;\n            if ( !v8 )\n              goto LABEL_65;\n          }\n          v10 = v8 - v2;\n          goto LABEL_15;\n        }\n        if ( v6 != 46 )\n          goto LABEL_12;\n        return 1;\n      }\n    }\nLABEL_50:\n    v4 = -1;\n  }\n  return v4;\n}\n", 
            "funcStartAddr": "0x40b900L", 
            "funcEndAddr": "0x40bd0dL", 
            "funcName": "sub_40B900"
        }, 
        {
            "decompiledFuncCode": "bool __fastcall sub_40BD10(int a1)\n{\n  char *v1; // rdx\n  bool result; // al\n\n  v1 = setlocale(a1, 0LL);\n  result = 1;\n  if ( v1 )\n  {\n    result = 0;\n    if ( strcmp(v1, \"C\") )\n      result = strcmp(v1, \"POSIX\") != 0;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40bd10L", 
            "funcEndAddr": "0x40bd6eL", 
            "funcName": "sub_40BD10"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40BD70(unsigned __int64 a1)\n{\n  __int64 v1; // rsi\n  unsigned __int64 v2; // rsi\n  unsigned __int64 v3; // rax\n  __int64 v4; // r8\n  unsigned __int64 v5; // rdi\n  unsigned __int64 v6; // rcx\n\n  v1 = 10LL;\n  if ( a1 >= 0xA )\n    v1 = a1;\n  v2 = v1 | 1;\n  if ( v2 != -1LL )\n  {\n    while ( 1 )\n    {\n      v3 = v2 % 3;\n      if ( v2 <= 9 )\n        goto LABEL_9;\n      if ( v2 % 3 )\n        break;\nLABEL_10:\n      v2 += 2LL;\n      if ( v2 == -1LL )\n        return v2;\n    }\n    v4 = 16LL;\n    v5 = 9LL;\n    v6 = 3LL;\n    while ( 1 )\n    {\n      v6 += 2LL;\n      v5 += v4;\n      v3 = v2 % v6;\n      if ( v5 >= v2 )\n        break;\n      v4 += 8LL;\n      if ( !(v2 % v6) )\n        goto LABEL_10;\n    }\nLABEL_9:\n    if ( v3 )\n      return v2;\n    goto LABEL_10;\n  }\n  return v2;\n}\n", 
            "funcStartAddr": "0x40bd70L", 
            "funcEndAddr": "0x40be03L", 
            "funcName": "sub_40BD70"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40BE10(__int64 a1, unsigned __int64 a2)\n{\n  return __ROR8__(a1, 3) % a2;\n}\n", 
            "funcStartAddr": "0x40be10L", 
            "funcEndAddr": "0x40be20L", 
            "funcName": "sub_40BE10"
        }, 
        {
            "decompiledFuncCode": "bool __fastcall sub_40BE20(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n", 
            "funcStartAddr": "0x40be20L", 
            "funcEndAddr": "0x40be27L", 
            "funcName": "sub_40BE20"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n\n__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n", 
            "funcStartAddr": "0x402f00L", 
            "funcEndAddr": "0x402f05L", 
            "funcName": "sub_40BE30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n\n__int64 __fastcall sub_40BE30(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n\n  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v2 )\n    abort();\n  return *(_QWORD *)a1 + 16 * v2;\n}\n", 
            "funcStartAddr": "0x402f00L", 
            "funcEndAddr": "0x402f05L", 
            "funcName": "sub_40BE30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40BE60(__int64 a1, __int64 a2, __m128i **a3, char a4)\n{\n  __m128i **v4; // r14\n  char v5; // r13\n  __int64 v6; // rbp\n  __m128i *v7; // rax\n  __int64 v8; // rsi\n  __m128i *v9; // rbx\n  __int64 *v10; // rax\n  const __m128i *v12; // rax\n\n  v4 = a3;\n  v5 = a4;\n  v6 = a2;\n  v7 = (__m128i *)sub_40BE30(a1, a2);\n  *v4 = v7;\n  v8 = v7->m128i_i64[0];\n  if ( v7->m128i_i64[0] )\n  {\n    v9 = v7;\n    if ( v8 != v6 )\n    {\n      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v6) )\n      {\n        v10 = (__int64 *)v9->m128i_i64[1];\n        if ( v10 )\n        {\n          v8 = *v10;\n          if ( v6 != *v10 )\n          {\n            while ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v6) )\n            {\n              v9 = (__m128i *)v9->m128i_i64[1];\n              v10 = (__int64 *)v9->m128i_i64[1];\n              if ( !v10 )\n                return 0LL;\n              v8 = *v10;\n              if ( *v10 == v6 )\n                goto LABEL_11;\n            }\n            v10 = (__int64 *)v9->m128i_i64[1];\n            v8 = *v10;\n          }\nLABEL_11:\n          if ( v5 )\n          {\n            v9->m128i_i64[1] = v10[1];\n            *v10 = 0LL;\n            v10[1] = *(_QWORD *)(a1 + 72);\n            *(_QWORD *)(a1 + 72) = v10;\n          }\n          return v8;\n        }\n        return 0LL;\n      }\n      v8 = v9->m128i_i64[0];\n    }\n    if ( v5 )\n    {\n      v12 = (const __m128i *)v9->m128i_i64[1];\n      if ( v12 )\n      {\n        *v9 = _mm_loadu_si128(v12);\n        v12->m128i_i64[0] = 0LL;\n        v12->m128i_i64[1] = *(_QWORD *)(a1 + 72);\n        *(_QWORD *)(a1 + 72) = v12;\n        return v8;\n      }\n      v9->m128i_i64[0] = 0LL;\n    }\n    return v8;\n  }\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40be60L", 
            "funcEndAddr": "0x40bf79L", 
            "funcName": "sub_40BE60"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40BF80(float **a1)\n{\n  float *v1; // rax\n  float v2; // xmm0_4\n  float v3; // xmm1_4\n  float v4; // xmm2_4\n  __int64 result; // rax\n\n  v1 = *a1;\n  if ( *a1 == (float *)&unk_416BA0 )\n    return 1LL;\n  v2 = v1[2];\n  if ( v2 <= 0.1\n    || v2 >= 0.89999998\n    || v1[3] <= 1.1\n    || *v1 < 0.0\n    || (v3 = *v1 + 0.1, v4 = v1[1], v4 <= v3)\n    || v4 > 1.0\n    || (result = 1LL, v2 <= v3) )\n  {\n    *a1 = (float *)&unk_416BA0;\n    result = 0LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40bf80L", 
            "funcEndAddr": "0x40bffeL", 
            "funcName": "sub_40BF80"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40C000(__int64 a1, __int64 a2, char a3)\n{\n  char v3; // r14\n  __int64 *v4; // r12\n  __int64 v5; // r15\n  __int64 *v6; // rbx\n  __int64 v7; // r15\n  _QWORD *v8; // rax\n  __int64 *v9; // rdx\n  _QWORD *v10; // rax\n  _QWORD *v11; // rbx\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n\n  v3 = a3;\n  v4 = *(__int64 **)a2;\n  if ( *(_QWORD *)a2 >= *(_QWORD *)(a2 + 8) )\n    return 1LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v5 = *v4;\n      if ( *v4 )\n      {\n        v6 = (__int64 *)v4[1];\n        if ( v6 )\n        {\n          do\n          {\n            while ( 1 )\n            {\n              v7 = *v6;\n              v8 = (_QWORD *)sub_40BE30(a1, *v6);\n              v9 = (__int64 *)v6[1];\n              if ( !*v8 )\n                break;\n              v6[1] = v8[1];\n              v8[1] = v6;\n              v6 = v9;\n              if ( !v9 )\n                goto LABEL_10;\n            }\n            *v8 = v7;\n            ++*(_QWORD *)(a1 + 24);\n            *v6 = 0LL;\n            v6[1] = *(_QWORD *)(a1 + 72);\n            *(_QWORD *)(a1 + 72) = v6;\n            v6 = v9;\n          }\n          while ( v9 );\nLABEL_10:\n          v5 = *v4;\n        }\n        v4[1] = 0LL;\n        if ( !v3 )\n          break;\n      }\n      v4 += 2;\n      if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )\n        return 1LL;\n    }\n    v10 = (_QWORD *)sub_40BE30(a1, v5);\n    v11 = v10;\n    if ( !*v10 )\n    {\n      *v10 = v5;\n      ++*(_QWORD *)(a1 + 24);\n      goto LABEL_16;\n    }\n    v12 = *(_QWORD **)(a1 + 72);\n    if ( !v12 )\n      break;\n    *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_15:\n    v13 = v11[1];\n    *v12 = v5;\n    v12[1] = v13;\n    v11[1] = v12;\nLABEL_16:\n    *v4 = 0LL;\n    v4 += 2;\n    --*(_QWORD *)(a2 + 24);\n    if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )\n      return 1LL;\n  }\n  v12 = malloc(0x10uLL);\n  if ( v12 )\n    goto LABEL_15;\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40c000L", 
            "funcEndAddr": "0x40c14aL", 
            "funcName": "sub_40C000"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40C440(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rcx\n  _QWORD *v3; // rdx\n  __int64 v4; // rax\n  __int64 result; // rax\n\n  v2 = (_QWORD *)sub_40BE30(a1, a2);\n  v3 = v2;\n  while ( 1 )\n  {\n    v4 = *v3;\n    v3 = (_QWORD *)v3[1];\n    if ( v4 == a2 )\n      break;\n    if ( !v3 )\n      goto LABEL_7;\n  }\n  if ( v3 )\n    return *v3;\nLABEL_7:\n  while ( 1 )\n  {\n    v2 += 2;\n    if ( *(_QWORD *)(a1 + 8) <= (unsigned __int64)v2 )\n      break;\n    result = *v2;\n    if ( *v2 )\n      return result;\n  }\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40c440L", 
            "funcEndAddr": "0x40c4aaL", 
            "funcName": "sub_40C440"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40C520(__int64 a1, unsigned __int8 (__fastcall *a2)(__int64, __int64), __int64 a3)\n{\n  __int64 *v3; // r14\n  __int64 v4; // r13\n  __int64 v5; // r15\n  __int64 v6; // rbp\n  __int64 v7; // rdi\n  __int64 *v9; // rbx\n\n  v3 = *(__int64 **)a1;\n  if ( *(_QWORD *)(a1 + 8) <= *(_QWORD *)a1 )\n    return 0LL;\n  v4 = a3;\n  v5 = a1;\n  v6 = 0LL;\n  while ( 1 )\n  {\n    v7 = *v3;\n    if ( *v3 )\n      break;\nLABEL_4:\n    v3 += 2;\n    if ( *(_QWORD *)(v5 + 8) <= (unsigned __int64)v3 )\n      return v6;\n  }\n  v9 = v3;\n  while ( a2(v7, v4) )\n  {\n    v9 = (__int64 *)v9[1];\n    ++v6;\n    if ( !v9 )\n      goto LABEL_4;\n    v7 = *v9;\n  }\n  return v6;\n}\n", 
            "funcStartAddr": "0x40c520L", 
            "funcEndAddr": "0x40c598L", 
            "funcName": "sub_40C520"
        }, 
        {
            "decompiledFuncCode": "_QWORD *__fastcall sub_40C600(unsigned __int64 a1, __int64 a2, unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2), bool (__fastcall *a4)(__int64 a1, __int64 a2), __int64 a5)\n{\n  __int64 v5; // r14\n  bool (__fastcall *v6)(__int64, __int64); // r13\n  unsigned __int64 (__fastcall *v7)(__int64, unsigned __int64); // r12\n  unsigned __int64 v8; // rbp\n  char *v9; // rax\n  _QWORD *v10; // rbx\n  float **v11; // rdi\n  unsigned __int64 v12; // rbp\n  char *v13; // rax\n  void *v14; // rdi\n  float v16; // xmm1_4\n  float v17; // xmm0_4\n  float v18; // xmm0_4\n\n  v5 = a5;\n  v6 = a4;\n  v7 = a3;\n  v8 = a1;\n  if ( !a3 )\n    v7 = sub_40BE10;\n  if ( !a4 )\n    v6 = sub_40BE20;\n  v9 = (char *)malloc(0x50uLL);\n  v10 = v9;\n  if ( v9 )\n  {\n    v11 = (float **)(v9 + 40);\n    if ( a2 )\n    {\n      *((_QWORD *)v9 + 5) = a2;\n      if ( !(unsigned __int8)sub_40BF80(v11) )\n        goto LABEL_14;\n      if ( *(_BYTE *)(a2 + 16) )\n      {\nLABEL_9:\n        v12 = sub_40BD70(v8);\n        if ( !_bittest64((const __int64 *)&v12, 0x3Cu) && v12 >> 61 == 0 )\n        {\n          v10[2] = v12;\n          if ( v12 )\n          {\n            v13 = (char *)calloc(v12, 0x10uLL);\n            *v10 = v13;\n            if ( v13 )\n            {\n              v10[3] = 0LL;\n              v10[4] = 0LL;\n              v10[1] = &v13[16 * v12];\n              v10[6] = v7;\n              v10[7] = v6;\n              v10[8] = v5;\n              v10[9] = 0LL;\n              return v10;\n            }\n          }\n        }\nLABEL_14:\n        v14 = v10;\n        v10 = 0LL;\n        free(v14);\n        return v10;\n      }\n      v16 = *(float *)(a2 + 8);\n      if ( (v8 & 0x8000000000000000LL) != 0LL )\n        goto LABEL_23;\n    }\n    else\n    {\n      *((_QWORD *)v9 + 5) = &unk_416BA0;\n      v16 = 0.80000001;\n      if ( !(unsigned __int8)sub_40BF80(v11) )\n        goto LABEL_14;\n      if ( (v8 & 0x8000000000000000LL) != 0LL )\n      {\nLABEL_23:\n        v17 = (float)(int)(v8 & 1 | (v8 >> 1)) + (float)(int)(v8 & 1 | (v8 >> 1));\n        goto LABEL_19;\n      }\n    }\n    v17 = (float)(int)v8;\nLABEL_19:\n    v18 = v17 / v16;\n    if ( v18 >= 1.8446744e19 )\n      goto LABEL_14;\n    if ( v18 < 9.223372e18 )\n      v8 = (unsigned int)(int)v18;\n    else\n      v8 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n    goto LABEL_9;\n  }\n  return v10;\n}\n", 
            "funcStartAddr": "0x40c600L", 
            "funcEndAddr": "0x40c78aL", 
            "funcName": "sub_40C600"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40C920(__int64 a1, unsigned __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rax\n  size_t v6; // rbx\n  bool v7; // sf\n  _BOOL8 v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  unsigned int v14; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h]\n  __int64 v17; // [rsp+8h] [rbp-60h]\n  size_t v18; // [rsp+10h] [rbp-58h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  __int64 v20; // [rsp+20h] [rbp-48h]\n  __int64 v21; // [rsp+28h] [rbp-40h]\n  __int64 v22; // [rsp+30h] [rbp-38h]\n  __int64 v23; // [rsp+38h] [rbp-30h]\n  __int64 v24; // [rsp+40h] [rbp-28h]\n  __int64 v25; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( (a2 & 0x8000000000000000LL) != 0LL )\n      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5;\n  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;\n  v8 = v5 >> 61 != 0;\n  if ( v7 )\n    v8 = 1LL;\n  if ( !v6 || v8 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v6 )\n    return 1LL;\n  v9 = (char *)calloc(v6, 0x10uLL);\n  ptr = v9;\n  if ( !v9 )\n    return 0;\n  v18 = v6;\n  v10 = (__int64)&v9[16 * v6];\n  v11 = *(_QWORD *)(a1 + 48);\n  v19 = 0LL;\n  v17 = v10;\n  v22 = v11;\n  v12 = *(_QWORD *)(a1 + 56);\n  v20 = 0LL;\n  v23 = v12;\n  v13 = *(_QWORD *)(a1 + 64);\n  v21 = v2;\n  v24 = v13;\n  v25 = *(_QWORD *)(a1 + 72);\n  v14 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v14 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v17;\n    *(_QWORD *)(a1 + 16) = v18;\n    *(_QWORD *)(a1 + 24) = v19;\n    *(_QWORD *)(a1 + 72) = v25;\n    return v14;\n  }\n  *(_QWORD *)(a1 + 72) = v25;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v14;\n}\n\n__int64 __fastcall sub_40C920(__int64 a1, unsigned __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rax\n  size_t v6; // rbx\n  bool v7; // sf\n  _BOOL8 v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  unsigned int v14; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h]\n  __int64 v17; // [rsp+8h] [rbp-60h]\n  size_t v18; // [rsp+10h] [rbp-58h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  __int64 v20; // [rsp+20h] [rbp-48h]\n  __int64 v21; // [rsp+28h] [rbp-40h]\n  __int64 v22; // [rsp+30h] [rbp-38h]\n  __int64 v23; // [rsp+38h] [rbp-30h]\n  __int64 v24; // [rsp+40h] [rbp-28h]\n  __int64 v25; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( (a2 & 0x8000000000000000LL) != 0LL )\n      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5;\n  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;\n  v8 = v5 >> 61 != 0;\n  if ( v7 )\n    v8 = 1LL;\n  if ( !v6 || v8 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v6 )\n    return 1LL;\n  v9 = (char *)calloc(v6, 0x10uLL);\n  ptr = v9;\n  if ( !v9 )\n    return 0;\n  v18 = v6;\n  v10 = (__int64)&v9[16 * v6];\n  v11 = *(_QWORD *)(a1 + 48);\n  v19 = 0LL;\n  v17 = v10;\n  v22 = v11;\n  v12 = *(_QWORD *)(a1 + 56);\n  v20 = 0LL;\n  v23 = v12;\n  v13 = *(_QWORD *)(a1 + 64);\n  v21 = v2;\n  v24 = v13;\n  v25 = *(_QWORD *)(a1 + 72);\n  v14 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v14 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v17;\n    *(_QWORD *)(a1 + 16) = v18;\n    *(_QWORD *)(a1 + 24) = v19;\n    *(_QWORD *)(a1 + 72) = v25;\n    return v14;\n  }\n  *(_QWORD *)(a1 + 72) = v25;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v14;\n}\n", 
            "funcStartAddr": "0x402f0aL", 
            "funcEndAddr": "0x402f0fL", 
            "funcName": "sub_40C920"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40C920(__int64 a1, unsigned __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rax\n  size_t v6; // rbx\n  bool v7; // sf\n  _BOOL8 v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  unsigned int v14; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h]\n  __int64 v17; // [rsp+8h] [rbp-60h]\n  size_t v18; // [rsp+10h] [rbp-58h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  __int64 v20; // [rsp+20h] [rbp-48h]\n  __int64 v21; // [rsp+28h] [rbp-40h]\n  __int64 v22; // [rsp+30h] [rbp-38h]\n  __int64 v23; // [rsp+38h] [rbp-30h]\n  __int64 v24; // [rsp+40h] [rbp-28h]\n  __int64 v25; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( (a2 & 0x8000000000000000LL) != 0LL )\n      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5;\n  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;\n  v8 = v5 >> 61 != 0;\n  if ( v7 )\n    v8 = 1LL;\n  if ( !v6 || v8 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v6 )\n    return 1LL;\n  v9 = (char *)calloc(v6, 0x10uLL);\n  ptr = v9;\n  if ( !v9 )\n    return 0;\n  v18 = v6;\n  v10 = (__int64)&v9[16 * v6];\n  v11 = *(_QWORD *)(a1 + 48);\n  v19 = 0LL;\n  v17 = v10;\n  v22 = v11;\n  v12 = *(_QWORD *)(a1 + 56);\n  v20 = 0LL;\n  v23 = v12;\n  v13 = *(_QWORD *)(a1 + 64);\n  v21 = v2;\n  v24 = v13;\n  v25 = *(_QWORD *)(a1 + 72);\n  v14 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v14 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v17;\n    *(_QWORD *)(a1 + 16) = v18;\n    *(_QWORD *)(a1 + 24) = v19;\n    *(_QWORD *)(a1 + 72) = v25;\n    return v14;\n  }\n  *(_QWORD *)(a1 + 72) = v25;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v14;\n}\n\n__int64 __fastcall sub_40C920(__int64 a1, unsigned __int64 a2)\n{\n  __int64 v2; // r12\n  float v3; // xmm0_4\n  float v4; // xmm0_4\n  unsigned __int64 v5; // rax\n  size_t v6; // rbx\n  bool v7; // sf\n  _BOOL8 v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  unsigned int v14; // ebx\n  void *ptr; // [rsp+0h] [rbp-68h]\n  __int64 v17; // [rsp+8h] [rbp-60h]\n  size_t v18; // [rsp+10h] [rbp-58h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  __int64 v20; // [rsp+20h] [rbp-48h]\n  __int64 v21; // [rsp+28h] [rbp-40h]\n  __int64 v22; // [rsp+30h] [rbp-38h]\n  __int64 v23; // [rsp+38h] [rbp-30h]\n  __int64 v24; // [rsp+40h] [rbp-28h]\n  __int64 v25; // [rsp+48h] [rbp-20h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( !*(_BYTE *)(v2 + 16) )\n  {\n    if ( (a2 & 0x8000000000000000LL) != 0LL )\n      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));\n    else\n      v3 = (float)(int)a2;\n    v4 = v3 / *(float *)(v2 + 8);\n    if ( v4 >= 1.8446744e19 )\n      return 0;\n    if ( v4 < 9.223372e18 )\n      a2 = (unsigned int)(int)v4;\n    else\n      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;\n  }\n  v5 = sub_40BD70(a2);\n  v6 = v5;\n  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;\n  v8 = v5 >> 61 != 0;\n  if ( v7 )\n    v8 = 1LL;\n  if ( !v6 || v8 )\n    return 0;\n  if ( *(_QWORD *)(a1 + 16) == v6 )\n    return 1LL;\n  v9 = (char *)calloc(v6, 0x10uLL);\n  ptr = v9;\n  if ( !v9 )\n    return 0;\n  v18 = v6;\n  v10 = (__int64)&v9[16 * v6];\n  v11 = *(_QWORD *)(a1 + 48);\n  v19 = 0LL;\n  v17 = v10;\n  v22 = v11;\n  v12 = *(_QWORD *)(a1 + 56);\n  v20 = 0LL;\n  v23 = v12;\n  v13 = *(_QWORD *)(a1 + 64);\n  v21 = v2;\n  v24 = v13;\n  v25 = *(_QWORD *)(a1 + 72);\n  v14 = sub_40C000((__int64)&ptr, a1, 0);\n  if ( (_BYTE)v14 )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = ptr;\n    *(_QWORD *)(a1 + 8) = v17;\n    *(_QWORD *)(a1 + 16) = v18;\n    *(_QWORD *)(a1 + 24) = v19;\n    *(_QWORD *)(a1 + 72) = v25;\n    return v14;\n  }\n  *(_QWORD *)(a1 + 72) = v25;\n  if ( !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_40C000(a1, (__int64)&ptr, 0) )\n    abort();\n  free(ptr);\n  return v14;\n}\n", 
            "funcStartAddr": "0x402f0aL", 
            "funcEndAddr": "0x402f0fL", 
            "funcName": "sub_40C920"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 *v3; // r12\n  __int64 v4; // rbp\n  __int64 v5; // rdx\n  __int64 result; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  unsigned __int64 v10; // rax\n  __int64 *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  unsigned __int64 v25; // rsi\n  __int64 *v26; // [rsp+8h] [rbp-20h]\n\n  if ( !a2 )\n    goto LABEL_35;\n  v3 = a3;\n  v4 = a2;\n  v5 = sub_40BE60(a1, a2, (__m128i **)&v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( (v7 & 0x8000000000000000LL) != 0LL )\n    {\n      v14 = v7 & 1 | (v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, v4, (__m128i **)&v26, 0) )\n        {\nLABEL_9:\n          v11 = v26;\n          if ( !*v26 )\n          {\n            *v26 = v4;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11[1];\n            *v12 = v4;\n            v12[1] = v13;\n            v11[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( v3 )\n    *v3 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 *v3; // r12\n  __int64 v4; // rbp\n  __int64 v5; // rdx\n  __int64 result; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  unsigned __int64 v10; // rax\n  __int64 *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  unsigned __int64 v25; // rsi\n  __int64 *v26; // [rsp+8h] [rbp-20h]\n\n  if ( !a2 )\n    goto LABEL_35;\n  v3 = a3;\n  v4 = a2;\n  v5 = sub_40BE60(a1, a2, (__m128i **)&v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( (v7 & 0x8000000000000000LL) != 0LL )\n    {\n      v14 = v7 & 1 | (v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, v4, (__m128i **)&v26, 0) )\n        {\nLABEL_9:\n          v11 = v26;\n          if ( !*v26 )\n          {\n            *v26 = v4;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11[1];\n            *v12 = v4;\n            v12[1] = v13;\n            v11[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( v3 )\n    *v3 = v5;\n  return result;\n}\n", 
            "funcStartAddr": "0x402f0fL", 
            "funcEndAddr": "0x402f14L", 
            "funcName": "sub_40CB20"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 *v3; // r12\n  __int64 v4; // rbp\n  __int64 v5; // rdx\n  __int64 result; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  unsigned __int64 v10; // rax\n  __int64 *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  unsigned __int64 v25; // rsi\n  __int64 *v26; // [rsp+8h] [rbp-20h]\n\n  if ( !a2 )\n    goto LABEL_35;\n  v3 = a3;\n  v4 = a2;\n  v5 = sub_40BE60(a1, a2, (__m128i **)&v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( (v7 & 0x8000000000000000LL) != 0LL )\n    {\n      v14 = v7 & 1 | (v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, v4, (__m128i **)&v26, 0) )\n        {\nLABEL_9:\n          v11 = v26;\n          if ( !*v26 )\n          {\n            *v26 = v4;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11[1];\n            *v12 = v4;\n            v12[1] = v13;\n            v11[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( v3 )\n    *v3 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_40CB20(__int64 a1, __int64 a2, __int64 *a3)\n{\n  __int64 *v3; // r12\n  __int64 v4; // rbp\n  __int64 v5; // rdx\n  __int64 result; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rdx\n  float v9; // xmm1_4\n  unsigned __int64 v10; // rax\n  __int64 *v11; // r12\n  _QWORD *v12; // rax\n  __int64 v13; // rdx\n  int v14; // edx\n  float v15; // xmm1_4\n  __int64 v16; // rdx\n  __int64 v17; // rax\n  float v18; // xmm2_4\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm1_4\n  float v22; // xmm0_4\n  __int64 v23; // rcx\n  __int64 v24; // rcx\n  unsigned __int64 v25; // rsi\n  __int64 *v26; // [rsp+8h] [rbp-20h]\n\n  if ( !a2 )\n    goto LABEL_35;\n  v3 = a3;\n  v4 = a2;\n  v5 = sub_40BE60(a1, a2, (__m128i **)&v26, 0);\n  if ( !v5 )\n  {\n    v7 = *(_QWORD *)(a1 + 24);\n    if ( (v7 & 0x8000000000000000LL) != 0LL )\n    {\n      v14 = v7 & 1 | (v7 >> 1);\n      v10 = *(_QWORD *)(a1 + 16);\n      v15 = (float)v14;\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = v15 + v15;\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n      {\nLABEL_8:\n        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )\n          goto LABEL_9;\nLABEL_15:\n        sub_40BF80((float **)(a1 + 40));\n        v16 = *(_QWORD *)(a1 + 40);\n        v17 = *(_QWORD *)(a1 + 16);\n        v18 = *(float *)(v16 + 8);\n        if ( v17 < 0 )\n        {\n          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n          v19 = (float)(int)v24 + (float)(int)v24;\n        }\n        else\n        {\n          v19 = (float)(int)v17;\n        }\n        v20 = *(_QWORD *)(a1 + 24);\n        if ( v20 < 0 )\n        {\n          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n          v21 = (float)(int)v23 + (float)(int)v23;\n        }\n        else\n        {\n          v21 = (float)(int)v20;\n        }\n        if ( v21 <= (float)(v18 * v19) )\n          goto LABEL_9;\n        v22 = v19 * *(float *)(v16 + 12);\n        if ( !*(_BYTE *)(v16 + 16) )\n          v22 = v22 * v18;\n        if ( v22 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;\n        if ( !(unsigned __int8)sub_40C920(a1, v25) )\n          return 0xFFFFFFFFLL;\n        if ( !sub_40BE60(a1, v4, (__m128i **)&v26, 0) )\n        {\nLABEL_9:\n          v11 = v26;\n          if ( !*v26 )\n          {\n            *v26 = v4;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            ++*(_QWORD *)(a1 + 24);\n            return result;\n          }\n          v12 = *(_QWORD **)(a1 + 72);\n          if ( v12 )\n          {\n            *(_QWORD *)(a1 + 72) = v12[1];\nLABEL_12:\n            v13 = v11[1];\n            *v12 = v4;\n            v12[1] = v13;\n            v11[1] = (__int64)v12;\n            result = 1LL;\n            ++*(_QWORD *)(a1 + 32);\n            return result;\n          }\n          v12 = malloc(0x10uLL);\n          if ( v12 )\n            goto LABEL_12;\n          return 0xFFFFFFFFLL;\n        }\nLABEL_35:\n        abort();\n      }\n    }\n    else\n    {\n      v8 = *(_QWORD *)(a1 + 40);\n      v9 = (float)(int)v7;\n      v10 = *(_QWORD *)(a1 + 16);\n      if ( (v10 & 0x8000000000000000LL) == 0LL )\n        goto LABEL_8;\n    }\n    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))\n                     * *(float *)(v8 + 8)) )\n      goto LABEL_9;\n    goto LABEL_15;\n  }\n  result = 0LL;\n  if ( v3 )\n    *v3 = v5;\n  return result;\n}\n", 
            "funcStartAddr": "0x402f0fL", 
            "funcEndAddr": "0x402f14L", 
            "funcName": "sub_40CB20"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40CDA0(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  int v3; // eax\n  __int64 v5; // [rsp+8h] [rbp-10h]\n\n  v2 = a2;\n  v3 = sub_40CB20(a1, a2, &v5);\n  if ( v3 == -1 )\n    return 0LL;\n  if ( !v3 )\n    v2 = v5;\n  return v2;\n}\n", 
            "funcStartAddr": "0x40cda0L", 
            "funcEndAddr": "0x40cddbL", 
            "funcName": "sub_40CDA0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40CDE0(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  __int64 v3; // rbp\n  _QWORD *v4; // rax\n  __int64 v6; // rax\n  float *v7; // rdx\n  float v8; // xmm0_4\n  unsigned __int64 v9; // rax\n  float v10; // xmm1_4\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  float v13; // xmm0_4\n  __int64 v14; // rax\n  float v15; // xmm1_4\n  float v16; // xmm0_4\n  unsigned __int64 v17; // rsi\n  _QWORD *v18; // rdi\n  _QWORD *v19; // r12\n  int v20; // edx\n  float v21; // xmm0_4\n  __int64 v22; // rcx\n  __int64 v23; // rcx\n  _QWORD *v24; // [rsp+8h] [rbp-20h]\n\n  v2 = a1;\n  v3 = sub_40BE60(a1, a2, (__m128i **)&v24, 1);\n  if ( !v3 )\n    return v3;\n  v4 = v24;\n  --*(_QWORD *)(a1 + 32);\n  if ( *v4 )\n    return v3;\n  v6 = *(_QWORD *)(a1 + 24) - 1LL;\n  *(_QWORD *)(a1 + 24) = v6;\n  if ( v6 < 0 )\n  {\n    v20 = v6 & 1 | ((unsigned __int64)v6 >> 1);\n    v9 = *(_QWORD *)(a1 + 16);\n    v21 = (float)v20;\n    v7 = *(float **)(a1 + 40);\n    v8 = v21 + v21;\n    if ( (v9 & 0x8000000000000000LL) == 0LL )\n      goto LABEL_6;\nLABEL_22:\n    v10 = (float)(int)(v9 & 1 | (v9 >> 1)) + (float)(int)(v9 & 1 | (v9 >> 1));\n    goto LABEL_7;\n  }\n  v7 = *(float **)(a1 + 40);\n  v8 = (float)(int)v6;\n  v9 = *(_QWORD *)(a1 + 16);\n  if ( (v9 & 0x8000000000000000LL) != 0LL )\n    goto LABEL_22;\nLABEL_6:\n  v10 = (float)(int)v9;\nLABEL_7:\n  if ( (float)(v10 * *v7) > v8 )\n  {\n    sub_40BF80((float **)(a1 + 40));\n    v11 = *(_QWORD *)(a1 + 16);\n    v12 = *(_QWORD *)(a1 + 40);\n    if ( v11 < 0 )\n    {\n      v23 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);\n      v13 = (float)(int)v23 + (float)(int)v23;\n    }\n    else\n    {\n      v13 = (float)(int)v11;\n    }\n    v14 = *(_QWORD *)(a1 + 24);\n    if ( v14 < 0 )\n    {\n      v22 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);\n      v15 = (float)(int)v22 + (float)(int)v22;\n    }\n    else\n    {\n      v15 = (float)(int)v14;\n    }\n    if ( (float)(*(float *)v12 * v13) > v15 )\n    {\n      v16 = v13 * *(float *)(v12 + 4);\n      if ( !*(_BYTE *)(v12 + 16) )\n        v16 = v16 * *(float *)(v12 + 8);\n      if ( v16 >= 9.223372e18 )\n        v17 = (unsigned int)(int)(float)(v16 - 9.223372e18) ^ 0x8000000000000000LL;\n      else\n        v17 = (unsigned int)(int)v16;\n      if ( !(unsigned __int8)sub_40C920(a1, v17) )\n      {\n        v18 = *(_QWORD **)(a1 + 72);\n        if ( v18 )\n        {\n          do\n          {\n            v19 = (_QWORD *)v18[1];\n            free(v18);\n            v18 = v19;\n          }\n          while ( v19 );\n        }\n        *(_QWORD *)(v2 + 72) = 0LL;\n      }\n    }\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x40cde0L", 
            "funcEndAddr": "0x40cfb7L", 
            "funcName": "sub_40CDE0"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_40CFC0()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40cfc0L", 
            "funcEndAddr": "0x40cfc3L", 
            "funcName": "sub_40CFC0"
        }, 
        {
            "decompiledFuncCode": "_QWORD *__fastcall sub_40CFD0(__int64 (*a1)(), unsigned __int64 a2)\n{\n  __int64 (*v2)(); // r12\n  __int64 v3; // rbp\n  __int64 v4; // rdx\n  _QWORD *v5; // rbx\n  __int64 v6; // rdi\n  _QWORD *v7; // rax\n  _QWORD *result; // rax\n\n  v2 = a1;\n  v3 = a2;\n  v5 = (_QWORD *)sub_411210(32LL);\n  if ( a2 )\n  {\n    v6 = 8 * a2;\n    if ( a2 & 0x1000000000000000LL || a2 >> 61 != 0 )\n      sub_411460(v6, a2, v4);\n  }\n  else\n  {\n    v6 = 8LL;\n    v3 = 1LL;\n  }\n  v7 = (_QWORD *)sub_411210(v6);\n  v5[1] = v3;\n  *v7 = 0LL;\n  *v5 = v7;\n  if ( !v2 )\n    v2 = sub_40CFC0;\n  v5[2] = 0LL;\n  result = v5;\n  v5[3] = v2;\n  return result;\n}\n", 
            "funcStartAddr": "0x40cfd0L", 
            "funcEndAddr": "0x40d04dL", 
            "funcName": "sub_40CFD0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_40D050(void *ptr)\n{\n  free(*(void **)ptr);\n  free(ptr);\n}\n", 
            "funcStartAddr": "0x40d050L", 
            "funcEndAddr": "0x40d065L", 
            "funcName": "sub_40D050"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D070(__int64 *a1, __int64 a2)\n{\n  __int64 v2; // r12\n  __int64 *v3; // rbp\n  unsigned __int64 v4; // rdx\n  unsigned __int64 v5; // rbx\n  __int64 v6; // rax\n  unsigned __int64 v7; // rbx\n  __int64 (__fastcall *v8)(_QWORD, __int64); // r13\n  __int64 v9; // rbp\n  __int64 v10; // r15\n  unsigned __int64 v11; // r14\n  _QWORD *v12; // r12\n  int v13; // eax\n  _QWORD *v14; // rdx\n\n  v2 = a2;\n  v3 = a1;\n  v4 = a1[1];\n  v5 = a1[2];\n  v6 = *a1;\n  if ( v4 - 1 <= v5 )\n  {\n    if ( v6 )\n    {\n      if ( v4 <= 0xAAAAAAAAAAAAAA9LL )\n      {\n        v4 += (v4 >> 1) + 1;\n        a2 = 8 * v4;\nLABEL_11:\n        v3[1] = v4;\n        v6 = sub_411270(v6, a2);\n        v5 = v3[2];\n        *v3 = v6;\n        goto LABEL_2;\n      }\n    }\n    else\n    {\n      if ( !v4 )\n      {\n        a2 = 128LL;\n        v4 = 16LL;\n        goto LABEL_11;\n      }\n      a1 = (__int64 *)(v4 >> 61);\n      a2 = 8 * v4;\n      if ( !(v4 & 0x1000000000000000LL) && v4 >> 61 == 0 )\n        goto LABEL_11;\n    }\n    sub_411460(a1, a2, v4);\n  }\nLABEL_2:\n  v7 = v5 + 1;\n  v3[2] = v7;\n  *(_QWORD *)(v6 + 8 * v7) = v2;\n  v8 = (__int64 (__fastcall *)(_QWORD, __int64))v3[3];\n  v9 = *v3;\n  v10 = *(_QWORD *)(v9 + 8 * v7);\n  if ( v7 == 1 )\n  {\nLABEL_7:\n    v14 = (_QWORD *)(v9 + 8);\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v11 = v7 >> 1;\n      v12 = (_QWORD *)(v9 + 8 * (v7 >> 1));\n      v13 = v8(*v12, v10);\n      v14 = (_QWORD *)(v9 + 8 * v7);\n      if ( v13 > 0 )\n        break;\n      v7 >>= 1;\n      *v14 = *v12;\n      if ( v11 == 1 )\n        goto LABEL_7;\n    }\n  }\n  *v14 = v10;\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40d070L", 
            "funcEndAddr": "0x40d184L", 
            "funcName": "sub_40D070"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D190(_QWORD *a1)\n{\n  __int64 v1; // rax\n  __int64 v2; // rdx\n  unsigned __int64 v3; // rbp\n  __int64 v4; // rax\n  __int64 v5; // rcx\n  __int64 v6; // r15\n  __int64 (__fastcall *v7)(_QWORD, __int64); // r13\n  __int64 v8; // r14\n  _QWORD *v9; // rbx\n  int v10; // eax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // r12\n  int v13; // eax\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  __int64 v16; // [rsp+10h] [rbp-58h]\n\n  v1 = a1[2];\n  v15 = 0LL;\n  if ( v1 )\n  {\n    v2 = *a1;\n    v3 = v1 - 1;\n    v4 = *(_QWORD *)(*a1 + 8 * v1);\n    v5 = *(_QWORD *)(*a1 + 8LL);\n    a1[2] = v3;\n    *(_QWORD *)(v2 + 8) = v4;\n    v6 = *a1;\n    v15 = v5;\n    v7 = (__int64 (__fastcall *)(_QWORD, __int64))a1[3];\n    v16 = *(_QWORD *)(*a1 + 8LL);\n    if ( v3 >> 1 )\n    {\n      v8 = 1LL;\n      while ( 1 )\n      {\n        v12 = 2 * v8;\n        if ( v3 <= 2 * v8 )\n        {\n          v9 = (_QWORD *)(v6 + 16 * v8);\n        }\n        else\n        {\n          v9 = (_QWORD *)(v6 + 16 * v8);\n          v13 = v7(*v9, *(_QWORD *)(v6 + 8 * (v12 + 1)));\n          if ( v13 < 0 )\n            v9 = (_QWORD *)(v6 + 8 * (v12 + 1));\n          if ( v13 < 0 )\n            ++v12;\n        }\n        v10 = v7(*v9, v16);\n        v11 = (_QWORD *)(v6 + 8 * v8);\n        if ( v10 <= 0 )\n          break;\n        v8 = v12;\n        *v11 = *v9;\n        if ( v12 > v3 >> 1 )\n        {\n          *v9 = v16;\n          return v15;\n        }\n      }\n    }\n    else\n    {\n      v11 = (_QWORD *)(v6 + 8);\n    }\n    *v11 = v16;\n  }\n  return v15;\n}\n", 
            "funcStartAddr": "0x40d190L", 
            "funcEndAddr": "0x40d2adL", 
            "funcName": "sub_40D190"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D2B0(int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n  __int64 result; // rax\n  int v4; // eax\n\n  v2 = a2 + 11;\n  *(_BYTE *)(a2 + 11) = 0;\n  if ( a1 < 0 )\n  {\n    while ( 1 )\n    {\n      v4 = 10 * (a1 / 10) + 48 - a1;\n      a1 /= 10;\n      *(_BYTE *)(v2 - 1) = v4;\n      if ( !a1 )\n        break;\n      --v2;\n    }\n    *(_BYTE *)(v2 - 2) = 45;\n    result = v2 - 2;\n  }\n  else\n  {\n    do\n    {\n      *(_BYTE *)--v2 = a1 % 0xAu + 48;\n      a1 /= 0xAu;\n    }\n    while ( a1 );\n    result = v2;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40d2b0L", 
            "funcEndAddr": "0x40d32cL", 
            "funcName": "sub_40D2B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D330(unsigned int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n\n  v2 = a2 + 10;\n  *(_BYTE *)(a2 + 10) = 0;\n  while ( 1 )\n  {\n    *(_BYTE *)--v2 = a1 % 0xA + 48;\n    if ( a1 <= 9 )\n      break;\n    a1 /= 0xAu;\n  }\n  return v2;\n}\n", 
            "funcStartAddr": "0x40d330L", 
            "funcEndAddr": "0x40d369L", 
            "funcName": "sub_40D330"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D370(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v2; // rcx\n\n  v2 = a2 + 20;\n  *(_BYTE *)(a2 + 20) = 0;\n  while ( 1 )\n  {\n    *(_BYTE *)--v2 = a1 % 0xA + 48;\n    if ( a1 <= 9 )\n      break;\n    a1 /= 0xAuLL;\n  }\n  return v2;\n}\n", 
            "funcStartAddr": "0x40d370L", 
            "funcEndAddr": "0x40d3b8L", 
            "funcName": "sub_40D370"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D3C0(char *s, __int64 a2, char a3)\n{\n  char v3; // r15\n  char *v4; // r13\n  char *v5; // rbx\n  unsigned int v6; // er12\n  char v7; // al\n  __int64 v8; // rax\n  __int64 v9; // rbp\n  int v10; // eax\n  int v12; // er15\n  const unsigned __int16 *v13; // rdx\n  unsigned __int16 v14; // ax\n  wchar_t c; // [rsp+4h] [rbp-44h]\n  mbstate_t ps; // [rsp+8h] [rbp-40h]\n\n  v3 = a3;\n  v4 = &s[a2];\n  v5 = s;\n  if ( __ctype_get_mb_cur_max() <= 1 )\n  {\n    v6 = 0;\n    if ( s >= v4 )\n      return v6;\n    v6 = 0;\n    v12 = v3 & 2;\n    v13 = *__ctype_b_loc();\n    while ( 1 )\n    {\n      v14 = v13[(unsigned __int8)*(++v5 - 1)];\n      if ( v14 & 0x4000 )\n        goto LABEL_42;\n      if ( v12 )\n        return (unsigned int)-1;\n      if ( !(v14 & 2) )\n      {\nLABEL_42:\n        if ( v6 == 0x7FFFFFFF )\n          return v6;\n        ++v6;\n      }\n      if ( v4 == v5 )\n        return v6;\n    }\n  }\n  v6 = 0;\n  if ( s < v4 )\n  {\n    do\n    {\n      v7 = *v5;\n      if ( *v5 <= 63 )\n      {\n        if ( v7 < 37 && (unsigned __int8)(v7 - 32) > 3u )\n        {\nLABEL_12:\n          ps = 0LL;\n          while ( 1 )\n          {\n            v8 = sub_412FB0(&c, v5);\n            v9 = v8;\n            if ( v8 == -1 )\n            {\n              if ( !(v3 & 1) )\n                goto LABEL_6;\n              return (unsigned int)-1;\n            }\n            if ( v8 == -2 )\n              break;\n            if ( !v8 )\n              v9 = 1LL;\n            v10 = wcwidth(c);\n            if ( v10 >= 0 )\n            {\n              if ( (int)(0x7FFFFFFF - v6) < v10 )\n                return 0x7FFFFFFF;\n              v6 += v10;\n            }\n            else\n            {\n              if ( v3 & 2 )\n                return (unsigned int)-1;\n              if ( !iswcntrl(c) )\n              {\n                if ( v6 == 0x7FFFFFFF )\n                  return 0x7FFFFFFF;\n                ++v6;\n              }\n            }\n            v5 += v9;\n            if ( mbsinit(&ps) )\n              goto LABEL_7;\n          }\n          if ( v3 & 1 )\n            return (unsigned int)-1;\n          ++v6;\n          v5 = &s[a2];\n          continue;\n        }\n      }\n      else if ( v7 < 65 || v7 > 95 && (unsigned __int8)(v7 - 97) > 0x1Du )\n      {\n        goto LABEL_12;\n      }\nLABEL_6:\n      ++v5;\n      ++v6;\nLABEL_7:\n      ;\n    }\n    while ( v5 < v4 );\n  }\n  return v6;\n}\n", 
            "funcStartAddr": "0x40d3c0L", 
            "funcEndAddr": "0x40d573L", 
            "funcName": "sub_40D3C0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D580(char *s, char a2)\n{\n  __int64 v2; // rax\n\n  v2 = strlen(s);\n  return sub_40D3C0(s, v2, a2);\n}\n", 
            "funcStartAddr": "0x40d580L", 
            "funcEndAddr": "0x40d5a3L", 
            "funcName": "sub_40D580"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_40D5B0()\n{\n  __int64 result; // rax\n  __int64 v1; // [rsp+0h] [rbp-88h]\n\n  if ( sched_getaffinity(0, 0x80uLL, (cpu_set_t *)&v1)\n    || (result = __sched_cpucount(0x80uLL, (const cpu_set_t *)&v1), !(_DWORD)result) )\n  {\n    result = 0LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40d5b0L", 
            "funcEndAddr": "0x40d5f4L", 
            "funcName": "sub_40D5B0"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40D600(const char *a1)\n{\n  unsigned __int64 v1; // rcx\n  int v2; // eax\n  __int64 v3; // rdx\n  char v4; // cl\n  unsigned int v5; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v7; // rcx\n  __int64 v8; // rsi\n  char *v9; // rdx\n  char *endptr; // [rsp+0h] [rbp-10h]\n\n  v1 = *(unsigned __int8 *)a1;\n  if ( !(_BYTE)v1 )\n    return 0LL;\n  v2 = (char)v1;\n  if ( (unsigned int)(char)v1 <= 0x20 )\n  {\n    v3 = 4294983168LL;\n    if ( _bittest64(&v3, v1) )\n    {\n      do\n      {\n        v4 = *++a1;\n        if ( !*a1 )\n          return 0LL;\n        v2 = v4;\n      }\n      while ( (unsigned int)v4 <= 0x20 && (1LL << v4) & 0x100003E00LL );\n    }\n  }\n  v5 = v2 - 48;\n  result = 0LL;\n  if ( v5 <= 9 )\n  {\n    endptr = 0LL;\n    result = strtoul(a1, &endptr, 10);\n    if ( endptr )\n    {\n      v7 = (unsigned __int8)*endptr;\n      if ( !(_BYTE)v7 )\n        return result;\n      if ( (unsigned int)(char)v7 <= 0x20 )\n      {\n        v8 = 4294983168LL;\n        if ( _bittest64(&v8, v7) )\n        {\n          v9 = endptr + 1;\n          while ( 1 )\n          {\n            endptr = v9;\n            LOBYTE(v7) = *v9;\n            if ( !*v9 )\n              return result;\n            if ( (unsigned int)(char)v7 <= 0x20 )\n            {\n              ++v9;\n              if ( (1LL << v7) & 0x100003E00LL )\n                continue;\n            }\n            break;\n          }\n        }\n      }\n      if ( (_BYTE)v7 == 44 )\n        return result;\n    }\n    result = 0LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40d600L", 
            "funcEndAddr": "0x40d6ebL", 
            "funcName": "sub_40D600"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40D6F0(int a1)\n{\n  __int64 result; // rax\n  char *v2; // rax\n  unsigned __int64 v3; // rbp\n  unsigned __int64 v4; // rbx\n  char *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rdx\n  char *v8; // rax\n\n  if ( a1 == 2 )\n  {\n    v2 = getenv(\"OMP_NUM_THREADS\");\n    if ( v2 )\n    {\n      v3 = -1LL;\n      v4 = sub_40D600(v2);\n      v5 = getenv(\"OMP_THREAD_LIMIT\");\n      if ( v5 )\n      {\n        v3 = sub_40D600(v5);\n        if ( !v3 )\n          v3 = -1LL;\n      }\n      if ( v4 )\n      {\n        result = v4;\n        if ( v3 <= v4 )\n          result = v3;\n        return result;\n      }\n    }\n    else\n    {\n      v8 = getenv(\"OMP_THREAD_LIMIT\");\n      if ( !v8 )\n        goto LABEL_27;\n      v3 = sub_40D600(v8);\n      if ( !v3 )\n        goto LABEL_27;\n    }\nLABEL_12:\n    result = sub_40D5B0();\n    if ( result )\n    {\n      if ( result > v3 )\n        result = v3;\n    }\n    else\n    {\n      v6 = sysconf(84);\n      result = 1LL;\n      if ( v6 > 0 )\n      {\n        result = v3;\n        if ( v6 <= v3 )\n          result = v6;\n      }\n    }\n    return result;\n  }\n  if ( a1 == 1 )\n  {\nLABEL_27:\n    v3 = -1LL;\n    goto LABEL_12;\n  }\n  result = sysconf(83);\n  if ( result == 1 )\n  {\n    v7 = sub_40D5B0();\n    result = 1LL;\n    if ( !v7 )\n      return result;\n    result = v7;\n  }\n  if ( result <= 0 )\n    result = 1LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x40d6f0L", 
            "funcEndAddr": "0x40d837L", 
            "funcName": "sub_40D6F0"
        }, 
        {
            "decompiledFuncCode": "int sub_40D840()\n{\n  int result; // eax\n  double v1; // [rsp+8h] [rbp-80h]\n  char v2; // [rsp+10h] [rbp-78h]\n  int v3; // [rsp+78h] [rbp-10h]\n\n  v1 = (double)(int)sysconf(85);\n  result = sysconf(30);\n  if ( v1 < 0.0 || (double)result < 0.0 )\n  {\n    result = sysinfo((struct sysinfo *)&v2);\n    if ( !result )\n      result = v3;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40d840L", 
            "funcEndAddr": "0x40d8fbL", 
            "funcName": "sub_40D840"
        }, 
        {
            "decompiledFuncCode": "int sub_40D900()\n{\n  int result; // eax\n  double v1; // [rsp+8h] [rbp-80h]\n  char v2; // [rsp+10h] [rbp-78h]\n  int v3; // [rsp+78h] [rbp-10h]\n\n  v1 = (double)(int)sysconf(86);\n  result = sysconf(30);\n  if ( v1 < 0.0 || (double)result < 0.0 )\n  {\n    if ( sysinfo((struct sysinfo *)&v2) )\n      result = sub_40D840();\n    else\n      result = v3;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40d900L", 
            "funcEndAddr": "0x40d9f6L", 
            "funcName": "sub_40D900"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40DA00(int pipedes[2], int a2)\n{\n  __int64 v2; // r13\n  unsigned int v3; // er12\n  int *v5; // rax\n  int v6; // er12\n  int *v7; // rbp\n  int v8; // er12\n\n  v2 = *(_QWORD *)pipedes;\n  if ( dword_61CBC0 >= 0 )\n  {\n    v8 = pipe2(pipedes, a2);\n    if ( v8 >= 0 || *__errno_location() != 38 )\n    {\n      dword_61CBC0 = 1;\n      return (unsigned int)v8;\n    }\n    dword_61CBC0 = -1;\n  }\n  v3 = a2 & 0xFFF7F7FF;\n  if ( a2 & 0xFFF7F7FF )\n  {\n    v3 = -1;\n    *__errno_location() = 22;\n    return v3;\n  }\n  if ( pipe(pipedes) < 0 )\n    return (unsigned int)-1;\n  if ( a2 & 0x800\n    && ((int)sub_412000(pipedes[1]) < 0\n     || (unsigned int)sub_412000(pipedes[1]) == -1\n     || (int)sub_412000(*pipedes) < 0\n     || (unsigned int)sub_412000(*pipedes) == -1) )\n  {\n    goto LABEL_25;\n  }\n  if ( !(a2 & 0x80000) )\n    return v3;\n  if ( (int)sub_412000(pipedes[1]) < 0\n    || (unsigned int)sub_412000(pipedes[1]) == -1\n    || (int)sub_412000(*pipedes) < 0\n    || (unsigned int)sub_412000(*pipedes) == -1 )\n  {\nLABEL_25:\n    v5 = __errno_location();\n    v6 = *v5;\n    v7 = v5;\n    close(*pipedes);\n    close(pipedes[1]);\n    *(_QWORD *)pipedes = v2;\n    *v7 = v6;\n    return (unsigned int)-1;\n  }\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x40da00L", 
            "funcEndAddr": "0x40dbd1L", 
            "funcName": "sub_40DA00"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_40DBE0()\n{\n  unsigned int v0; // ebx\n  char *v1; // rax\n  __int64 v3; // rax\n  unsigned int v4; // ebx\n  char *endptr; // [rsp+8h] [rbp-10h]\n\n  v0 = 200809;\n  v1 = getenv(\"_POSIX2_VERSION\");\n  if ( !v1 )\n    return v0;\n  if ( !*v1 )\n    return v0;\n  v3 = strtol(v1, &endptr, 10);\n  if ( *endptr )\n    return v0;\n  if ( v3 < -2147483648LL )\n    return 2147483648;\n  v4 = 0x7FFFFFFF;\n  if ( v3 <= 0x7FFFFFFF )\n    v4 = v3;\n  return v4;\n}\n", 
            "funcStartAddr": "0x40dbe0L", 
            "funcEndAddr": "0x40dc52L", 
            "funcName": "sub_40DBE0"
        }, 
        {
            "decompiledFuncCode": "char *__fastcall sub_40DC60(const char *a1)\n{\n  __int64 v1; // rbx\n  char *result; // rax\n\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v1 = (__int64)a1;\n  result = strrchr(a1, 47);\n  if ( result )\n  {\n    if ( result + 1 - a1 > 6 && !memcmp(result - 6, \"/.libs/\", 7uLL) )\n    {\n      v1 = (__int64)(result + 1);\n      if ( !memcmp(result + 1, \"lt-\", 3uLL) )\n      {\n        v1 = (__int64)(result + 4);\n        program_invocation_short_name = (__int64)(result + 4);\n      }\n    }\n  }\n  qword_61CBC8 = v1;\n  program_invocation_name = v1;\n  return result;\n}\n", 
            "funcStartAddr": "0x40dc60L", 
            "funcEndAddr": "0x40dcf9L", 
            "funcName": "sub_40DC60"
        }, 
        {
            "decompiledFuncCode": "const char *__fastcall sub_40DD00(char *msgid, int a2)\n{\n  char *v2; // rbx\n  _BYTE *v4; // rax\n  bool v5; // zf\n  const char *v6; // rbx\n\n  v2 = dcgettext(0LL, msgid, 5);\n  if ( msgid != v2 )\n    return v2;\n  v4 = (_BYTE *)sub_413750();\n  if ( (*v4 & 0xDF) == 85 )\n  {\n    if ( (v4[1] & 0xDF) == 84 && (v4[2] & 0xDF) == 70 && v4[3] == 45 && v4[4] == 56 && !v4[5] )\n    {\n      v5 = *v2 == 96;\n      v2 = (char *)&unk_416C61;\n      if ( !v5 )\n        v2 = (char *)&unk_416C56;\n      return v2;\n    }\n  }\n  else if ( (*v4 & 0xDF) == 71\n         && (v4[1] & 0xDF) == 66\n         && v4[2] == 49\n         && v4[3] == 56\n         && v4[4] == 48\n         && v4[5] == 51\n         && v4[6] == 48\n         && !v4[7] )\n  {\n    v5 = *v2 == 96;\n    v2 = (char *)&unk_416C5D;\n    if ( !v5 )\n      v2 = (char *)&unk_416C5A;\n    return v2;\n  }\n  v6 = \"\\\"\";\n  if ( a2 != 9 )\n    v6 = \"invalid number after ','\" + 23;\n  return v6;\n}\n", 
            "funcStartAddr": "0x40dd00L", 
            "funcEndAddr": "0x40ddf2L", 
            "funcName": "sub_40DD00"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40DE00(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, const char *a8, char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v11; // er13\n  int v12; // ebp\n  unsigned __int64 v13; // rdx\n  unsigned __int64 v14; // r11\n  int v15; // er10\n  unsigned __int64 v16; // rbx\n  unsigned __int64 v17; // r9\n  unsigned __int64 v18; // r12\n  int v19; // er11\n  char *v20; // r8\n  size_t v21; // rax\n  int v22; // eax\n  unsigned __int64 v23; // rbp\n  bool v24; // al\n  int v25; // eax\n  int v26; // eax\n  char v27; // di\n  const unsigned __int16 **v28; // rax\n  char v29; // cl\n  unsigned __int64 result; // rax\n  __int64 v31; // rcx\n  unsigned __int64 v32; // rdi\n  unsigned __int8 v33; // al\n  unsigned __int8 v34; // al\n  int v35; // er13\n  bool v36; // dl\n  bool v37; // dl\n  bool v38; // al\n  size_t v39; // rax\n  unsigned __int64 v40; // rbx\n  unsigned __int64 v41; // r15\n  const unsigned __int16 **v42; // r14\n  char *v43; // rax\n  int v44; // esi\n  unsigned __int64 v45; // rcx\n  unsigned __int8 v46; // di\n  const char *v47; // rax\n  size_t v48; // rax\n  __int64 v49; // rsi\n  unsigned __int64 v50; // rsi\n  char *v51; // rcx\n  char i; // al\n  char v53; // dl\n  const char *v54; // rax\n  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]\n  char v59; // [rsp+1Fh] [rbp-A9h]\n  char *s; // [rsp+20h] [rbp-A8h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  char *v62; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v63; // [rsp+30h] [rbp-98h]\n  char *v64; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v65; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v66; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v67; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v68; // [rsp+38h] [rbp-90h]\n  char v69; // [rsp+38h] [rbp-90h]\n  int v70; // [rsp+38h] [rbp-90h]\n  int v71; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v72; // [rsp+40h] [rbp-88h]\n  int v73; // [rsp+40h] [rbp-88h]\n  int v74; // [rsp+40h] [rbp-88h]\n  _BYTE *v75; // [rsp+40h] [rbp-88h]\n  int v76; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v77; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  __int64 v79; // [rsp+58h] [rbp-70h]\n  size_t v80; // [rsp+60h] [rbp-68h]\n  char v81; // [rsp+68h] [rbp-60h]\n  bool v82; // [rsp+6Ch] [rbp-5Ch]\n  char v83; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v85; // [rsp+70h] [rbp-58h]\n  char *v86; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h]\n  mbstate_t ps; // [rsp+88h] [rbp-40h]\n\n  v9 = a1;\n  v10 = a2;\n  v11 = a5;\n  s = a3;\n  v55 = a4;\n  v81 = a6;\n  v12 = a6 & 2;\n  v80 = __ctype_get_mb_cur_max();\n  v82 = v12 != 0;\n  v14 = v55;\n  switch ( v11 )\n  {\n    case 0:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v56 = 0;\n        goto LABEL_212;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 2;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v11 = 2;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v56 = 1;\nLABEL_212:\n      if ( a2 )\n      {\n        v15 = 0;\n        v38 = 0;\n        v59 = 1;\n        v79 = 0LL;\n        goto LABEL_138;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 1LL;\n      v11 = 2;\n      v79 = 0LL;\n      v83 = 0;\n      v82 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v17 = v14;\n      v18 = 0LL;\n      v19 = v11;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(v11) = v17 != v18;\n        if ( v17 == -1LL )\n          LOBYTE(v11) = s[v18] != 0;\n        if ( !(_BYTE)v11 )\n        {\n          v35 = v19;\n          v14 = v17;\n          v36 = v35 == 2;\n          if ( !v16 && v36 && v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v37 = !v82 && v36;\n          if ( v37 )\n          {\n            if ( v83 )\n            {\n              if ( v59 )\n                return sub_40DE00((__int64)v9, v79, s);\n              v38 = v79 != 0 && v10 == 0;\n              if ( v38 )\n              {\n                v10 = v79;\nLABEL_138:\n                *v9 = 39;\n                v11 = 2;\n                v16 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v82 = 0;\n                v83 = v38;\n                goto LABEL_3;\n              }\n              v37 = v83;\n            }\n          }\n          else\n          {\n            v37 = !v82;\n          }\n          if ( s2 )\n          {\n            if ( v37 )\n            {\n              v53 = *s2;\n              if ( *s2 )\n              {\n                v54 = &s2[-v16];\n                do\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = v53;\n                  v53 = v54[++v16];\n                }\n                while ( v53 );\n              }\n            }\n          }\n          if ( v10 > v16 )\n            v9[v16] = 0;\n          return v16;\n        }\n        v20 = &s[v18];\n        v57 = v56 & (v19 != 2);\n        if ( !(v56 & (v19 != 2)) )\n          break;\n        if ( n )\n        {\n          if ( v17 == -1LL && n > 1 )\n          {\n            v71 = v19;\n            v66 = v15;\n            v21 = strlen(s);\n            v19 = v71;\n            v15 = v66;\n            v20 = &s[v18];\n            v17 = v21;\n          }\n          if ( v18 + n <= v17 )\n          {\n            v76 = v19;\n            v72 = v17;\n            v67 = v15;\n            v62 = v20;\n            v22 = memcmp(v20, s2, n);\n            v20 = v62;\n            v15 = v67;\n            v17 = v72;\n            v19 = v76;\n            if ( !v22 )\n            {\n              if ( !v82 )\n              {\n                LOBYTE(v23) = *v62;\n                switch ( *v62 )\n                {\n                  case 0:\n                    goto LABEL_83;\n                  case 7:\n                    LOBYTE(v23) = 97;\n                    goto LABEL_79;\n                  case 8:\n                    LODWORD(v13) = 0;\n                    v11 = 0;\n                    LOBYTE(v23) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_72;\n                  case 10:\n                    goto LABEL_68;\n                  case 11:\n                    goto LABEL_80;\n                  case 12:\n                    goto LABEL_77;\n                  case 13:\n                    goto LABEL_76;\n                  case 32:\n                    v33 = v57;\n                    goto LABEL_128;\n                  case 33:\n                  case 34:\n                  case 36:\n                  case 38:\n                  case 40:\n                  case 41:\n                  case 42:\n                  case 59:\n                  case 60:\n                  case 61:\n                  case 62:\n                  case 91:\n                  case 94:\n                  case 96:\n                  case 124:\n                    goto LABEL_74;\n                  case 35:\n                  case 126:\n                    v34 = v57;\n                    goto LABEL_125;\n                  case 37:\n                  case 43:\n                  case 44:\n                  case 45:\n                  case 46:\n                  case 47:\n                  case 48:\n                  case 49:\n                  case 50:\n                  case 51:\n                  case 52:\n                  case 53:\n                  case 54:\n                  case 55:\n                  case 56:\n                  case 57:\n                  case 58:\n                  case 65:\n                  case 66:\n                  case 67:\n                  case 68:\n                  case 69:\n                  case 70:\n                  case 71:\n                  case 72:\n                  case 73:\n                  case 74:\n                  case 75:\n                  case 76:\n                  case 77:\n                  case 78:\n                  case 79:\n                  case 80:\n                  case 81:\n                  case 82:\n                  case 83:\n                  case 84:\n                  case 85:\n                  case 86:\n                  case 87:\n                  case 88:\n                  case 89:\n                  case 90:\n                  case 93:\n                  case 95:\n                  case 97:\n                  case 98:\n                  case 99:\n                  case 100:\n                  case 101:\n                  case 102:\n                  case 103:\n                  case 104:\n                  case 105:\n                  case 106:\n                  case 107:\n                  case 108:\n                  case 109:\n                  case 110:\n                  case 111:\n                  case 112:\n                  case 113:\n                  case 114:\n                  case 115:\n                  case 116:\n                  case 117:\n                  case 118:\n                  case 119:\n                  case 120:\n                  case 121:\n                  case 122:\n                    v33 = v57;\n                    goto LABEL_123;\n                  case 39:\n                    goto LABEL_62;\n                  case 63:\n                    goto LABEL_58;\n                  case 92:\n                    goto LABEL_65;\n                  case 123:\n                  case 125:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_98;\n                }\n              }\n              return sub_40DE00((__int64)v9, v10, s);\n            }\n          }\n        }\n        LOBYTE(v23) = *v20;\n        switch ( *v20 )\n        {\n          case 0:\n            goto LABEL_81;\n          case 7:\n            LOBYTE(v23) = 97;\n            goto LABEL_78;\n          case 8:\n            LOBYTE(v23) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_72:\n            LOBYTE(v23) = 116;\n            goto LABEL_69;\n          case 10:\nLABEL_68:\n            LOBYTE(v23) = 110;\nLABEL_69:\n            LODWORD(v13) = 0;\n            v11 = 0;\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            goto LABEL_29;\n          case 11:\nLABEL_80:\n            LOBYTE(v23) = 118;\n            goto LABEL_78;\n          case 12:\nLABEL_77:\n            LOBYTE(v23) = 102;\nLABEL_78:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_79:\n            v11 = 0;\n            goto LABEL_37;\n          case 13:\n            v57 = 0;\nLABEL_76:\n            LOBYTE(v23) = 13;\n            v29 = 114;\n            LOBYTE(v13) = v19 == 2;\n            goto LABEL_66;\n          case 32:\n            v33 = 0;\nLABEL_128:\n            LOBYTE(v23) = 32;\n            goto LABEL_123;\n          case 33:\n          case 34:\n          case 36:\n          case 38:\n          case 40:\n          case 41:\n          case 42:\n          case 59:\n          case 60:\n          case 61:\n          case 62:\n          case 91:\n          case 94:\n          case 96:\n          case 124:\n            v57 = 0;\nLABEL_74:\n            LODWORD(v13) = 0;\n            goto LABEL_67;\n          case 35:\n          case 126:\n            v34 = 0;\nLABEL_125:\n            if ( !v18 )\n            {\n              v11 = v57;\n              LODWORD(v13) = 0;\n              v57 = v34;\n              goto LABEL_23;\n            }\n            v57 = v34;\n            v11 = 0;\n            break;\n          case 37:\n          case 43:\n          case 44:\n          case 45:\n          case 46:\n          case 47:\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 58:\n          case 65:\n          case 66:\n          case 67:\n          case 68:\n          case 69:\n          case 70:\n          case 71:\n          case 72:\n          case 73:\n          case 74:\n          case 75:\n          case 76:\n          case 77:\n          case 78:\n          case 79:\n          case 80:\n          case 81:\n          case 82:\n          case 83:\n          case 84:\n          case 85:\n          case 86:\n          case 87:\n          case 88:\n          case 89:\n          case 90:\n          case 93:\n          case 95:\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n          case 111:\n          case 112:\n          case 113:\n          case 114:\n          case 115:\n          case 116:\n          case 117:\n          case 118:\n          case 119:\n          case 120:\n          case 121:\n          case 122:\n            v33 = 0;\nLABEL_123:\n            v11 = v57;\n            v57 = v33;\n            v25 = 0;\n            goto LABEL_25;\n          case 39:\n            v57 = 0;\n            goto LABEL_62;\n          case 63:\n            v57 = 0;\n            goto LABEL_58;\n          case 92:\n            v57 = 0;\n            goto LABEL_65;\n          case 123:\n          case 125:\n            v57 = 0;\n            goto LABEL_17;\n          default:\n            v57 = 0;\n            goto LABEL_98;\n        }\nLABEL_24:\n        v25 = 0;\nLABEL_25:\n        if ( a7 )\n        {\n          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;\n          if ( (_DWORD)v13 )\n          {\n            LOBYTE(v13) = v19 == 2;\nLABEL_28:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_29:\n            v26 = v15 ^ 1;\n            LOBYTE(v26) = v13 & (v15 ^ 1);\n            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )\n            {\n              if ( v10 > v16 )\n                v9[v16] = 39;\n              if ( v16 + 1 < v10 )\n                v9[v16 + 1] = 36;\n              LODWORD(v13) = v16 + 2;\n              if ( v16 + 2 < v10 )\n                v9[v16 + 2] = 39;\n              v16 += 3LL;\n              v15 = v26;\n            }\nLABEL_37:\n            if ( v10 > v16 )\n              v9[v16] = 92;\n            ++v16;\n            ++v18;\n            goto LABEL_40;\n          }\n        }\nLABEL_49:\n        LOBYTE(v13) = v19 == 2;\n        if ( v57 )\n          goto LABEL_28;\n        ++v18;\n        LODWORD(v28) = v15 & (v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v28 )\n        {\n          if ( v10 > v16 )\n            v9[v16] = 39;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 39;\n          v16 += 2LL;\n          v15 = 0;\n        }\nLABEL_40:\n        if ( v16 < v10 )\n          v9[v16] = v23;\n        v27 = v59;\n        ++v16;\n        if ( !(_BYTE)v11 )\n          v27 = 0;\n        v59 = v27;\n      }\n      LOBYTE(v23) = *v20;\n      switch ( *v20 )\n      {\n        case 0:\n          if ( !v56 )\n          {\n            if ( !(v81 & 1) )\n            {\n              v57 = 0;\n              LOBYTE(v13) = v19 == 2;\n              v11 = 0;\n              LOBYTE(v23) = 0;\n              goto LABEL_23;\n            }\n            ++v18;\n            goto LABEL_4;\n          }\nLABEL_81:\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v57 = 0;\nLABEL_83:\n          LOBYTE(v13) = v19 == 2;\n          v25 = v15 ^ 1;\n          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 36;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v31 = v16 + 3;\n            if ( v10 <= v16 + 3 )\n            {\n              v16 += 4LL;\n              v15 = v25;\n              v11 = 0;\n              LOBYTE(v23) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_91;\n          }\n          v31 = v16;\n          if ( v10 > v16 )\n          {\n            v25 = v15;\nLABEL_91:\n            v9[v31] = 92;\n            v15 = v25;\n          }\n          v16 = v31 + 1;\n          if ( v19 == 2 )\n          {\n            v25 = v11;\n            LOBYTE(v23) = 48;\n            v11 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v23) = 48;\n          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 48;\n            if ( v10 > v31 + 2 )\n              v9[v31 + 2] = 48;\n            v16 = v31 + 3;\n            LOBYTE(v23) = 48;\n          }\nLABEL_95:\n          v25 = v11;\n          v11 = 0;\n          if ( (unsigned __int8)v13 | v56 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v23) = 7;\n          v29 = 97;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v23) = 8;\n          v29 = 98;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v23) = 9;\n          v29 = 116;\n          goto LABEL_104;\n        case 10:\n          LOBYTE(v23) = 10;\n          v29 = 110;\n          goto LABEL_104;\n        case 11:\n          LOBYTE(v23) = 11;\n          v29 = 118;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 12:\n          LOBYTE(v23) = 12;\n          v29 = 102;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 13:\n          LOBYTE(v23) = 13;\n          v29 = 114;\nLABEL_104:\n          LOBYTE(v13) = v19 == 2;\n          v57 = v19 == 2 && v82;\n          if ( v57 )\n            return sub_40DE00((__int64)v9, v10, s);\n          goto LABEL_66;\n        case 32:\n          LOBYTE(v23) = 32;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_21;\n        case 33:\n        case 34:\n        case 36:\n        case 38:\n        case 40:\n        case 41:\n        case 42:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 91:\n        case 94:\n        case 96:\n        case 124:\n          LOBYTE(v13) = v19 == 2;\n          v11 = 0;\n          goto LABEL_21;\n        case 35:\n        case 126:\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_20;\n        case 37:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case 58:\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 93:\n        case 95:\n        case 97:\n        case 98:\n        case 99:\n        case 100:\n        case 101:\n        case 102:\n        case 103:\n        case 104:\n        case 105:\n        case 106:\n        case 107:\n        case 108:\n        case 109:\n        case 110:\n        case 111:\n        case 112:\n        case 113:\n        case 114:\n        case 115:\n        case 116:\n        case 117:\n        case 118:\n        case 119:\n        case 120:\n        case 121:\n        case 122:\n          goto LABEL_101;\n        case 39:\nLABEL_62:\n          if ( v19 != 2 )\n          {\n            v83 = v11;\n            LODWORD(v13) = 0;\n            LOBYTE(v23) = 39;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( !v10 || (v13 = 0LL, v79) )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 92;\n            v13 = v10;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v10 = v79;\n          }\n          v83 = v11;\n          v16 += 3LL;\n          v25 = 0;\n          v15 = 0;\n          v79 = v10;\n          LOBYTE(v23) = 39;\n          v10 = v13;\n          goto LABEL_49;\n        case 63:\nLABEL_58:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            v11 = 0;\n            v25 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_49;\n          }\n          if ( v19 != 5 )\n          {\n            LOBYTE(v23) = 63;\n            LOBYTE(v13) = v19 == 2;\n            v11 = 0;\n            goto LABEL_23;\n          }\n          if ( !(v81 & 4)\n            || v18 + 2 >= v17\n            || s[v18 + 1] != 63\n            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)\n            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )\n          {\n            LODWORD(v13) = 0;\n            v11 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( v10 > v16 )\n            v9[v16] = 63;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 34;\n          if ( v10 > v16 + 2 )\n            v9[v16 + 2] = 34;\n          if ( v10 > v16 + 3 )\n            v9[v16 + 3] = 63;\n          v16 += 4LL;\n          LODWORD(v13) = 0;\n          v11 = 0;\n          v18 += 2LL;\n          goto LABEL_95;\n        case 92:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            LOBYTE(v23) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LODWORD(v13) = v56;\n          LOBYTE(v23) = 92;\n          v29 = 92;\n          LOBYTE(v13) = (n != 0) & v82 & v56;\n          if ( (_BYTE)v13 )\n          {\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v56 )\n          {\nLABEL_67:\n            v11 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v23) = v29;\n          v11 = 0;\n          goto LABEL_28;\n        case 123:\n        case 125:\nLABEL_17:\n          v24 = v17 != 1;\n          if ( v17 == -1LL )\n            v24 = s[1] != 0;\n          LOBYTE(v13) = v19 == 2;\n          if ( v24 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v18 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v82 || !(_BYTE)v13 )\n            goto LABEL_23;\n          return sub_40DE00((__int64)v9, v10, s);\n        default:\nLABEL_98:\n          if ( v80 == 1 )\n          {\n            v73 = v19;\n            v68 = v17;\n            v63 = v15;\n            v28 = __ctype_b_loc();\n            LODWORD(v13) = (unsigned __int8)v23;\n            v15 = v63;\n            v17 = v68;\n            v19 = v73;\n            v32 = 1LL;\n            LODWORD(v28) = (*v28)[(unsigned __int8)v23];\n            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;\n            LOBYTE(v11) = (_WORD)v28 != 0;\n            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);\n            goto LABEL_100;\n          }\n          ps = 0LL;\n          if ( v17 == -1LL )\n          {\n            v74 = v19;\n            v69 = v15;\n            v64 = v20;\n            v39 = strlen(s);\n            v19 = v74;\n            LOBYTE(v15) = v69;\n            v20 = v64;\n            v17 = v39;\n          }\n          v85 = v16;\n          v86 = v20;\n          v40 = 0LL;\n          v84 = v15;\n          v75 = v9;\n          v77 = v10;\n          v65 = v17;\n          v70 = v19;\n          break;\n      }\n      while ( 2 )\n      {\n        v41 = v18 + v40;\n        v28 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, &s[v18 + v40]);\n        v42 = v28;\n        if ( !v28 )\n        {\nLABEL_241:\n          v32 = v40;\n          v16 = v85;\n          v15 = v84;\n          v9 = v75;\n          LODWORD(v13) = v11 ^ 1;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LOBYTE(v13) = v56 & (v11 ^ 1);\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-1LL )\n        {\n          v32 = v40;\n          v16 = v85;\n          v11 = 0;\n          v15 = v84;\n          v9 = v75;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LODWORD(v13) = v56;\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-2LL )\n        {\n          v17 = v65;\n          v50 = v18 + v40;\n          v51 = &s[v18 + v40];\n          v28 = (const unsigned __int16 **)v40;\n          v32 = v40;\n          v15 = v84;\n          v16 = v85;\n          v9 = v75;\n          v10 = v77;\n          v19 = v70;\n          if ( v50 < v65 && *v51 )\n          {\n            do\n              v28 = (const unsigned __int16 **)((char *)v28 + 1);\n            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );\n            v32 = (unsigned __int64)v28;\n          }\n          LODWORD(v13) = v56;\n          v11 = 0;\nLABEL_242:\n          if ( v32 > 1 )\n            goto LABEL_174;\nLABEL_100:\n          if ( (_BYTE)v13 )\n          {\n            LODWORD(v13) = v56;\n            LOBYTE(v11) = 0;\nLABEL_174:\n            v44 = 0;\n            v45 = v18 + v32;\n            v46 = v57;\n            while ( 1 )\n            {\n              if ( (_BYTE)v13 )\n              {\n                if ( v82 )\n                  return sub_40DE00((__int64)v9, v10, s);\n                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 36;\n                  if ( v10 > v16 + 2 )\n                    v9[v16 + 2] = 39;\n                  v16 += 3LL;\n                  v15 = (int)v28;\n                }\n                if ( v10 > v16 )\n                  v9[v16] = 92;\n                if ( v10 > v16 + 1 )\n                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;\n                LODWORD(v28) = v16 + 2;\n                if ( v10 > v16 + 2 )\n                {\n                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;\n                  v9[v16 + 2] = (_BYTE)v28;\n                }\n                ++v18;\n                v16 += 3LL;\n                LOBYTE(v23) = (v23 & 7) + 48;\n                if ( v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_40;\n                }\n                v44 = v13;\n              }\n              else\n              {\n                LODWORD(v28) = v15 & (v44 ^ 1);\n                if ( v46 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 92;\n                  ++v16;\n                }\n                if ( ++v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_51;\n                }\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  LODWORD(v28) = v16 + 1;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 39;\n                  v16 += 2LL;\n                  v46 = 0;\n                  v15 = 0;\n                }\n                else\n                {\n                  v46 = 0;\n                }\n              }\n              if ( v10 > v16 )\n                v9[v16] = v23;\n              LOBYTE(v23) = s[v18];\n              ++v16;\n            }\n          }\nLABEL_101:\n          LOBYTE(v13) = v19 == 2;\nLABEL_23:\n          v25 = (v13 | v56 ^ 1) ^ 1;\n          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;\n          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )\n            goto LABEL_49;\n          goto LABEL_24;\n        }\n        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )\n        {\nLABEL_148:\n          if ( !iswprint(wc) )\n            v11 = 0;\n          v40 += (unsigned __int64)v42;\n          LODWORD(v28) = mbsinit(&ps);\n          if ( (_DWORD)v28 )\n            goto LABEL_241;\n          continue;\n        }\n        break;\n      }\n      v43 = &s[v41 + 1];\n      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )\n      {\n        if ( &s[(_QWORD)v42 + v41] == ++v43 )\n          goto LABEL_148;\n      }\n      v9 = v75;\n      v10 = v77;\n      return sub_40DE00((__int64)v9, v10, s);\n    case 5:\n      if ( v12 )\n      {\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n          v79 = 0LL;\n        }\n        else\n        {\n          v79 = 0LL;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n        }\n        v82 = 0;\n        v16 = 1LL;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 5;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", v11);\n        v47 = sub_40DD00(\"'\", v11);\n        v14 = v55;\n        a9 = (char *)v47;\n      }\n      v16 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v16] )\n        {\n          if ( a2 > v16 )\n            a1[v16] = i;\n          ++v16;\n        }\n      }\n      v58 = v14;\n      v48 = strlen(a9);\n      v59 = 1;\n      v15 = 0;\n      v14 = v58;\n      n = v48;\n      v83 = 0;\n      s2 = a9;\n      v79 = 0LL;\n      v56 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n      return result;\n  }\n}\n\nunsigned __int64 __fastcall sub_40DE00(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, const char *a8, char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v11; // er13\n  int v12; // ebp\n  unsigned __int64 v13; // rdx\n  unsigned __int64 v14; // r11\n  int v15; // er10\n  unsigned __int64 v16; // rbx\n  unsigned __int64 v17; // r9\n  unsigned __int64 v18; // r12\n  int v19; // er11\n  char *v20; // r8\n  size_t v21; // rax\n  int v22; // eax\n  unsigned __int64 v23; // rbp\n  bool v24; // al\n  int v25; // eax\n  int v26; // eax\n  char v27; // di\n  const unsigned __int16 **v28; // rax\n  char v29; // cl\n  unsigned __int64 result; // rax\n  __int64 v31; // rcx\n  unsigned __int64 v32; // rdi\n  unsigned __int8 v33; // al\n  unsigned __int8 v34; // al\n  int v35; // er13\n  bool v36; // dl\n  bool v37; // dl\n  bool v38; // al\n  size_t v39; // rax\n  unsigned __int64 v40; // rbx\n  unsigned __int64 v41; // r15\n  const unsigned __int16 **v42; // r14\n  char *v43; // rax\n  int v44; // esi\n  unsigned __int64 v45; // rcx\n  unsigned __int8 v46; // di\n  const char *v47; // rax\n  size_t v48; // rax\n  __int64 v49; // rsi\n  unsigned __int64 v50; // rsi\n  char *v51; // rcx\n  char i; // al\n  char v53; // dl\n  const char *v54; // rax\n  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]\n  char v59; // [rsp+1Fh] [rbp-A9h]\n  char *s; // [rsp+20h] [rbp-A8h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  char *v62; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v63; // [rsp+30h] [rbp-98h]\n  char *v64; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v65; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v66; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v67; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v68; // [rsp+38h] [rbp-90h]\n  char v69; // [rsp+38h] [rbp-90h]\n  int v70; // [rsp+38h] [rbp-90h]\n  int v71; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v72; // [rsp+40h] [rbp-88h]\n  int v73; // [rsp+40h] [rbp-88h]\n  int v74; // [rsp+40h] [rbp-88h]\n  _BYTE *v75; // [rsp+40h] [rbp-88h]\n  int v76; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v77; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  __int64 v79; // [rsp+58h] [rbp-70h]\n  size_t v80; // [rsp+60h] [rbp-68h]\n  char v81; // [rsp+68h] [rbp-60h]\n  bool v82; // [rsp+6Ch] [rbp-5Ch]\n  char v83; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v85; // [rsp+70h] [rbp-58h]\n  char *v86; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h]\n  mbstate_t ps; // [rsp+88h] [rbp-40h]\n\n  v9 = a1;\n  v10 = a2;\n  v11 = a5;\n  s = a3;\n  v55 = a4;\n  v81 = a6;\n  v12 = a6 & 2;\n  v80 = __ctype_get_mb_cur_max();\n  v82 = v12 != 0;\n  v14 = v55;\n  switch ( v11 )\n  {\n    case 0:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v56 = 0;\n        goto LABEL_212;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 2;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v11 = 2;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v56 = 1;\nLABEL_212:\n      if ( a2 )\n      {\n        v15 = 0;\n        v38 = 0;\n        v59 = 1;\n        v79 = 0LL;\n        goto LABEL_138;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 1LL;\n      v11 = 2;\n      v79 = 0LL;\n      v83 = 0;\n      v82 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v17 = v14;\n      v18 = 0LL;\n      v19 = v11;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(v11) = v17 != v18;\n        if ( v17 == -1LL )\n          LOBYTE(v11) = s[v18] != 0;\n        if ( !(_BYTE)v11 )\n        {\n          v35 = v19;\n          v14 = v17;\n          v36 = v35 == 2;\n          if ( !v16 && v36 && v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v37 = !v82 && v36;\n          if ( v37 )\n          {\n            if ( v83 )\n            {\n              if ( v59 )\n                return sub_40DE00((__int64)v9, v79, s);\n              v38 = v79 != 0 && v10 == 0;\n              if ( v38 )\n              {\n                v10 = v79;\nLABEL_138:\n                *v9 = 39;\n                v11 = 2;\n                v16 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v82 = 0;\n                v83 = v38;\n                goto LABEL_3;\n              }\n              v37 = v83;\n            }\n          }\n          else\n          {\n            v37 = !v82;\n          }\n          if ( s2 )\n          {\n            if ( v37 )\n            {\n              v53 = *s2;\n              if ( *s2 )\n              {\n                v54 = &s2[-v16];\n                do\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = v53;\n                  v53 = v54[++v16];\n                }\n                while ( v53 );\n              }\n            }\n          }\n          if ( v10 > v16 )\n            v9[v16] = 0;\n          return v16;\n        }\n        v20 = &s[v18];\n        v57 = v56 & (v19 != 2);\n        if ( !(v56 & (v19 != 2)) )\n          break;\n        if ( n )\n        {\n          if ( v17 == -1LL && n > 1 )\n          {\n            v71 = v19;\n            v66 = v15;\n            v21 = strlen(s);\n            v19 = v71;\n            v15 = v66;\n            v20 = &s[v18];\n            v17 = v21;\n          }\n          if ( v18 + n <= v17 )\n          {\n            v76 = v19;\n            v72 = v17;\n            v67 = v15;\n            v62 = v20;\n            v22 = memcmp(v20, s2, n);\n            v20 = v62;\n            v15 = v67;\n            v17 = v72;\n            v19 = v76;\n            if ( !v22 )\n            {\n              if ( !v82 )\n              {\n                LOBYTE(v23) = *v62;\n                switch ( *v62 )\n                {\n                  case 0:\n                    goto LABEL_83;\n                  case 7:\n                    LOBYTE(v23) = 97;\n                    goto LABEL_79;\n                  case 8:\n                    LODWORD(v13) = 0;\n                    v11 = 0;\n                    LOBYTE(v23) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_72;\n                  case 10:\n                    goto LABEL_68;\n                  case 11:\n                    goto LABEL_80;\n                  case 12:\n                    goto LABEL_77;\n                  case 13:\n                    goto LABEL_76;\n                  case 32:\n                    v33 = v57;\n                    goto LABEL_128;\n                  case 33:\n                  case 34:\n                  case 36:\n                  case 38:\n                  case 40:\n                  case 41:\n                  case 42:\n                  case 59:\n                  case 60:\n                  case 61:\n                  case 62:\n                  case 91:\n                  case 94:\n                  case 96:\n                  case 124:\n                    goto LABEL_74;\n                  case 35:\n                  case 126:\n                    v34 = v57;\n                    goto LABEL_125;\n                  case 37:\n                  case 43:\n                  case 44:\n                  case 45:\n                  case 46:\n                  case 47:\n                  case 48:\n                  case 49:\n                  case 50:\n                  case 51:\n                  case 52:\n                  case 53:\n                  case 54:\n                  case 55:\n                  case 56:\n                  case 57:\n                  case 58:\n                  case 65:\n                  case 66:\n                  case 67:\n                  case 68:\n                  case 69:\n                  case 70:\n                  case 71:\n                  case 72:\n                  case 73:\n                  case 74:\n                  case 75:\n                  case 76:\n                  case 77:\n                  case 78:\n                  case 79:\n                  case 80:\n                  case 81:\n                  case 82:\n                  case 83:\n                  case 84:\n                  case 85:\n                  case 86:\n                  case 87:\n                  case 88:\n                  case 89:\n                  case 90:\n                  case 93:\n                  case 95:\n                  case 97:\n                  case 98:\n                  case 99:\n                  case 100:\n                  case 101:\n                  case 102:\n                  case 103:\n                  case 104:\n                  case 105:\n                  case 106:\n                  case 107:\n                  case 108:\n                  case 109:\n                  case 110:\n                  case 111:\n                  case 112:\n                  case 113:\n                  case 114:\n                  case 115:\n                  case 116:\n                  case 117:\n                  case 118:\n                  case 119:\n                  case 120:\n                  case 121:\n                  case 122:\n                    v33 = v57;\n                    goto LABEL_123;\n                  case 39:\n                    goto LABEL_62;\n                  case 63:\n                    goto LABEL_58;\n                  case 92:\n                    goto LABEL_65;\n                  case 123:\n                  case 125:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_98;\n                }\n              }\n              return sub_40DE00((__int64)v9, v10, s);\n            }\n          }\n        }\n        LOBYTE(v23) = *v20;\n        switch ( *v20 )\n        {\n          case 0:\n            goto LABEL_81;\n          case 7:\n            LOBYTE(v23) = 97;\n            goto LABEL_78;\n          case 8:\n            LOBYTE(v23) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_72:\n            LOBYTE(v23) = 116;\n            goto LABEL_69;\n          case 10:\nLABEL_68:\n            LOBYTE(v23) = 110;\nLABEL_69:\n            LODWORD(v13) = 0;\n            v11 = 0;\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            goto LABEL_29;\n          case 11:\nLABEL_80:\n            LOBYTE(v23) = 118;\n            goto LABEL_78;\n          case 12:\nLABEL_77:\n            LOBYTE(v23) = 102;\nLABEL_78:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_79:\n            v11 = 0;\n            goto LABEL_37;\n          case 13:\n            v57 = 0;\nLABEL_76:\n            LOBYTE(v23) = 13;\n            v29 = 114;\n            LOBYTE(v13) = v19 == 2;\n            goto LABEL_66;\n          case 32:\n            v33 = 0;\nLABEL_128:\n            LOBYTE(v23) = 32;\n            goto LABEL_123;\n          case 33:\n          case 34:\n          case 36:\n          case 38:\n          case 40:\n          case 41:\n          case 42:\n          case 59:\n          case 60:\n          case 61:\n          case 62:\n          case 91:\n          case 94:\n          case 96:\n          case 124:\n            v57 = 0;\nLABEL_74:\n            LODWORD(v13) = 0;\n            goto LABEL_67;\n          case 35:\n          case 126:\n            v34 = 0;\nLABEL_125:\n            if ( !v18 )\n            {\n              v11 = v57;\n              LODWORD(v13) = 0;\n              v57 = v34;\n              goto LABEL_23;\n            }\n            v57 = v34;\n            v11 = 0;\n            break;\n          case 37:\n          case 43:\n          case 44:\n          case 45:\n          case 46:\n          case 47:\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 58:\n          case 65:\n          case 66:\n          case 67:\n          case 68:\n          case 69:\n          case 70:\n          case 71:\n          case 72:\n          case 73:\n          case 74:\n          case 75:\n          case 76:\n          case 77:\n          case 78:\n          case 79:\n          case 80:\n          case 81:\n          case 82:\n          case 83:\n          case 84:\n          case 85:\n          case 86:\n          case 87:\n          case 88:\n          case 89:\n          case 90:\n          case 93:\n          case 95:\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n          case 111:\n          case 112:\n          case 113:\n          case 114:\n          case 115:\n          case 116:\n          case 117:\n          case 118:\n          case 119:\n          case 120:\n          case 121:\n          case 122:\n            v33 = 0;\nLABEL_123:\n            v11 = v57;\n            v57 = v33;\n            v25 = 0;\n            goto LABEL_25;\n          case 39:\n            v57 = 0;\n            goto LABEL_62;\n          case 63:\n            v57 = 0;\n            goto LABEL_58;\n          case 92:\n            v57 = 0;\n            goto LABEL_65;\n          case 123:\n          case 125:\n            v57 = 0;\n            goto LABEL_17;\n          default:\n            v57 = 0;\n            goto LABEL_98;\n        }\nLABEL_24:\n        v25 = 0;\nLABEL_25:\n        if ( a7 )\n        {\n          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;\n          if ( (_DWORD)v13 )\n          {\n            LOBYTE(v13) = v19 == 2;\nLABEL_28:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_29:\n            v26 = v15 ^ 1;\n            LOBYTE(v26) = v13 & (v15 ^ 1);\n            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )\n            {\n              if ( v10 > v16 )\n                v9[v16] = 39;\n              if ( v16 + 1 < v10 )\n                v9[v16 + 1] = 36;\n              LODWORD(v13) = v16 + 2;\n              if ( v16 + 2 < v10 )\n                v9[v16 + 2] = 39;\n              v16 += 3LL;\n              v15 = v26;\n            }\nLABEL_37:\n            if ( v10 > v16 )\n              v9[v16] = 92;\n            ++v16;\n            ++v18;\n            goto LABEL_40;\n          }\n        }\nLABEL_49:\n        LOBYTE(v13) = v19 == 2;\n        if ( v57 )\n          goto LABEL_28;\n        ++v18;\n        LODWORD(v28) = v15 & (v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v28 )\n        {\n          if ( v10 > v16 )\n            v9[v16] = 39;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 39;\n          v16 += 2LL;\n          v15 = 0;\n        }\nLABEL_40:\n        if ( v16 < v10 )\n          v9[v16] = v23;\n        v27 = v59;\n        ++v16;\n        if ( !(_BYTE)v11 )\n          v27 = 0;\n        v59 = v27;\n      }\n      LOBYTE(v23) = *v20;\n      switch ( *v20 )\n      {\n        case 0:\n          if ( !v56 )\n          {\n            if ( !(v81 & 1) )\n            {\n              v57 = 0;\n              LOBYTE(v13) = v19 == 2;\n              v11 = 0;\n              LOBYTE(v23) = 0;\n              goto LABEL_23;\n            }\n            ++v18;\n            goto LABEL_4;\n          }\nLABEL_81:\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v57 = 0;\nLABEL_83:\n          LOBYTE(v13) = v19 == 2;\n          v25 = v15 ^ 1;\n          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 36;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v31 = v16 + 3;\n            if ( v10 <= v16 + 3 )\n            {\n              v16 += 4LL;\n              v15 = v25;\n              v11 = 0;\n              LOBYTE(v23) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_91;\n          }\n          v31 = v16;\n          if ( v10 > v16 )\n          {\n            v25 = v15;\nLABEL_91:\n            v9[v31] = 92;\n            v15 = v25;\n          }\n          v16 = v31 + 1;\n          if ( v19 == 2 )\n          {\n            v25 = v11;\n            LOBYTE(v23) = 48;\n            v11 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v23) = 48;\n          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 48;\n            if ( v10 > v31 + 2 )\n              v9[v31 + 2] = 48;\n            v16 = v31 + 3;\n            LOBYTE(v23) = 48;\n          }\nLABEL_95:\n          v25 = v11;\n          v11 = 0;\n          if ( (unsigned __int8)v13 | v56 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v23) = 7;\n          v29 = 97;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v23) = 8;\n          v29 = 98;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v23) = 9;\n          v29 = 116;\n          goto LABEL_104;\n        case 10:\n          LOBYTE(v23) = 10;\n          v29 = 110;\n          goto LABEL_104;\n        case 11:\n          LOBYTE(v23) = 11;\n          v29 = 118;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 12:\n          LOBYTE(v23) = 12;\n          v29 = 102;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 13:\n          LOBYTE(v23) = 13;\n          v29 = 114;\nLABEL_104:\n          LOBYTE(v13) = v19 == 2;\n          v57 = v19 == 2 && v82;\n          if ( v57 )\n            return sub_40DE00((__int64)v9, v10, s);\n          goto LABEL_66;\n        case 32:\n          LOBYTE(v23) = 32;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_21;\n        case 33:\n        case 34:\n        case 36:\n        case 38:\n        case 40:\n        case 41:\n        case 42:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 91:\n        case 94:\n        case 96:\n        case 124:\n          LOBYTE(v13) = v19 == 2;\n          v11 = 0;\n          goto LABEL_21;\n        case 35:\n        case 126:\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_20;\n        case 37:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case 58:\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 93:\n        case 95:\n        case 97:\n        case 98:\n        case 99:\n        case 100:\n        case 101:\n        case 102:\n        case 103:\n        case 104:\n        case 105:\n        case 106:\n        case 107:\n        case 108:\n        case 109:\n        case 110:\n        case 111:\n        case 112:\n        case 113:\n        case 114:\n        case 115:\n        case 116:\n        case 117:\n        case 118:\n        case 119:\n        case 120:\n        case 121:\n        case 122:\n          goto LABEL_101;\n        case 39:\nLABEL_62:\n          if ( v19 != 2 )\n          {\n            v83 = v11;\n            LODWORD(v13) = 0;\n            LOBYTE(v23) = 39;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( !v10 || (v13 = 0LL, v79) )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 92;\n            v13 = v10;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v10 = v79;\n          }\n          v83 = v11;\n          v16 += 3LL;\n          v25 = 0;\n          v15 = 0;\n          v79 = v10;\n          LOBYTE(v23) = 39;\n          v10 = v13;\n          goto LABEL_49;\n        case 63:\nLABEL_58:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            v11 = 0;\n            v25 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_49;\n          }\n          if ( v19 != 5 )\n          {\n            LOBYTE(v23) = 63;\n            LOBYTE(v13) = v19 == 2;\n            v11 = 0;\n            goto LABEL_23;\n          }\n          if ( !(v81 & 4)\n            || v18 + 2 >= v17\n            || s[v18 + 1] != 63\n            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)\n            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )\n          {\n            LODWORD(v13) = 0;\n            v11 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( v10 > v16 )\n            v9[v16] = 63;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 34;\n          if ( v10 > v16 + 2 )\n            v9[v16 + 2] = 34;\n          if ( v10 > v16 + 3 )\n            v9[v16 + 3] = 63;\n          v16 += 4LL;\n          LODWORD(v13) = 0;\n          v11 = 0;\n          v18 += 2LL;\n          goto LABEL_95;\n        case 92:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            LOBYTE(v23) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LODWORD(v13) = v56;\n          LOBYTE(v23) = 92;\n          v29 = 92;\n          LOBYTE(v13) = (n != 0) & v82 & v56;\n          if ( (_BYTE)v13 )\n          {\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v56 )\n          {\nLABEL_67:\n            v11 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v23) = v29;\n          v11 = 0;\n          goto LABEL_28;\n        case 123:\n        case 125:\nLABEL_17:\n          v24 = v17 != 1;\n          if ( v17 == -1LL )\n            v24 = s[1] != 0;\n          LOBYTE(v13) = v19 == 2;\n          if ( v24 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v18 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v82 || !(_BYTE)v13 )\n            goto LABEL_23;\n          return sub_40DE00((__int64)v9, v10, s);\n        default:\nLABEL_98:\n          if ( v80 == 1 )\n          {\n            v73 = v19;\n            v68 = v17;\n            v63 = v15;\n            v28 = __ctype_b_loc();\n            LODWORD(v13) = (unsigned __int8)v23;\n            v15 = v63;\n            v17 = v68;\n            v19 = v73;\n            v32 = 1LL;\n            LODWORD(v28) = (*v28)[(unsigned __int8)v23];\n            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;\n            LOBYTE(v11) = (_WORD)v28 != 0;\n            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);\n            goto LABEL_100;\n          }\n          ps = 0LL;\n          if ( v17 == -1LL )\n          {\n            v74 = v19;\n            v69 = v15;\n            v64 = v20;\n            v39 = strlen(s);\n            v19 = v74;\n            LOBYTE(v15) = v69;\n            v20 = v64;\n            v17 = v39;\n          }\n          v85 = v16;\n          v86 = v20;\n          v40 = 0LL;\n          v84 = v15;\n          v75 = v9;\n          v77 = v10;\n          v65 = v17;\n          v70 = v19;\n          break;\n      }\n      while ( 2 )\n      {\n        v41 = v18 + v40;\n        v28 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, &s[v18 + v40]);\n        v42 = v28;\n        if ( !v28 )\n        {\nLABEL_241:\n          v32 = v40;\n          v16 = v85;\n          v15 = v84;\n          v9 = v75;\n          LODWORD(v13) = v11 ^ 1;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LOBYTE(v13) = v56 & (v11 ^ 1);\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-1LL )\n        {\n          v32 = v40;\n          v16 = v85;\n          v11 = 0;\n          v15 = v84;\n          v9 = v75;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LODWORD(v13) = v56;\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-2LL )\n        {\n          v17 = v65;\n          v50 = v18 + v40;\n          v51 = &s[v18 + v40];\n          v28 = (const unsigned __int16 **)v40;\n          v32 = v40;\n          v15 = v84;\n          v16 = v85;\n          v9 = v75;\n          v10 = v77;\n          v19 = v70;\n          if ( v50 < v65 && *v51 )\n          {\n            do\n              v28 = (const unsigned __int16 **)((char *)v28 + 1);\n            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );\n            v32 = (unsigned __int64)v28;\n          }\n          LODWORD(v13) = v56;\n          v11 = 0;\nLABEL_242:\n          if ( v32 > 1 )\n            goto LABEL_174;\nLABEL_100:\n          if ( (_BYTE)v13 )\n          {\n            LODWORD(v13) = v56;\n            LOBYTE(v11) = 0;\nLABEL_174:\n            v44 = 0;\n            v45 = v18 + v32;\n            v46 = v57;\n            while ( 1 )\n            {\n              if ( (_BYTE)v13 )\n              {\n                if ( v82 )\n                  return sub_40DE00((__int64)v9, v10, s);\n                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 36;\n                  if ( v10 > v16 + 2 )\n                    v9[v16 + 2] = 39;\n                  v16 += 3LL;\n                  v15 = (int)v28;\n                }\n                if ( v10 > v16 )\n                  v9[v16] = 92;\n                if ( v10 > v16 + 1 )\n                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;\n                LODWORD(v28) = v16 + 2;\n                if ( v10 > v16 + 2 )\n                {\n                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;\n                  v9[v16 + 2] = (_BYTE)v28;\n                }\n                ++v18;\n                v16 += 3LL;\n                LOBYTE(v23) = (v23 & 7) + 48;\n                if ( v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_40;\n                }\n                v44 = v13;\n              }\n              else\n              {\n                LODWORD(v28) = v15 & (v44 ^ 1);\n                if ( v46 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 92;\n                  ++v16;\n                }\n                if ( ++v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_51;\n                }\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  LODWORD(v28) = v16 + 1;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 39;\n                  v16 += 2LL;\n                  v46 = 0;\n                  v15 = 0;\n                }\n                else\n                {\n                  v46 = 0;\n                }\n              }\n              if ( v10 > v16 )\n                v9[v16] = v23;\n              LOBYTE(v23) = s[v18];\n              ++v16;\n            }\n          }\nLABEL_101:\n          LOBYTE(v13) = v19 == 2;\nLABEL_23:\n          v25 = (v13 | v56 ^ 1) ^ 1;\n          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;\n          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )\n            goto LABEL_49;\n          goto LABEL_24;\n        }\n        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )\n        {\nLABEL_148:\n          if ( !iswprint(wc) )\n            v11 = 0;\n          v40 += (unsigned __int64)v42;\n          LODWORD(v28) = mbsinit(&ps);\n          if ( (_DWORD)v28 )\n            goto LABEL_241;\n          continue;\n        }\n        break;\n      }\n      v43 = &s[v41 + 1];\n      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )\n      {\n        if ( &s[(_QWORD)v42 + v41] == ++v43 )\n          goto LABEL_148;\n      }\n      v9 = v75;\n      v10 = v77;\n      return sub_40DE00((__int64)v9, v10, s);\n    case 5:\n      if ( v12 )\n      {\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n          v79 = 0LL;\n        }\n        else\n        {\n          v79 = 0LL;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n        }\n        v82 = 0;\n        v16 = 1LL;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 5;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", v11);\n        v47 = sub_40DD00(\"'\", v11);\n        v14 = v55;\n        a9 = (char *)v47;\n      }\n      v16 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v16] )\n        {\n          if ( a2 > v16 )\n            a1[v16] = i;\n          ++v16;\n        }\n      }\n      v58 = v14;\n      v48 = strlen(a9);\n      v59 = 1;\n      v15 = 0;\n      v14 = v58;\n      n = v48;\n      v83 = 0;\n      s2 = a9;\n      v79 = 0LL;\n      v56 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n      return result;\n  }\n}\n", 
            "funcStartAddr": "0x402f14L", 
            "funcEndAddr": "0x402f19L", 
            "funcName": "sub_40DE00"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_40DE00(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, const char *a8, char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v11; // er13\n  int v12; // ebp\n  unsigned __int64 v13; // rdx\n  unsigned __int64 v14; // r11\n  int v15; // er10\n  unsigned __int64 v16; // rbx\n  unsigned __int64 v17; // r9\n  unsigned __int64 v18; // r12\n  int v19; // er11\n  char *v20; // r8\n  size_t v21; // rax\n  int v22; // eax\n  unsigned __int64 v23; // rbp\n  bool v24; // al\n  int v25; // eax\n  int v26; // eax\n  char v27; // di\n  const unsigned __int16 **v28; // rax\n  char v29; // cl\n  unsigned __int64 result; // rax\n  __int64 v31; // rcx\n  unsigned __int64 v32; // rdi\n  unsigned __int8 v33; // al\n  unsigned __int8 v34; // al\n  int v35; // er13\n  bool v36; // dl\n  bool v37; // dl\n  bool v38; // al\n  size_t v39; // rax\n  unsigned __int64 v40; // rbx\n  unsigned __int64 v41; // r15\n  const unsigned __int16 **v42; // r14\n  char *v43; // rax\n  int v44; // esi\n  unsigned __int64 v45; // rcx\n  unsigned __int8 v46; // di\n  const char *v47; // rax\n  size_t v48; // rax\n  __int64 v49; // rsi\n  unsigned __int64 v50; // rsi\n  char *v51; // rcx\n  char i; // al\n  char v53; // dl\n  const char *v54; // rax\n  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]\n  char v59; // [rsp+1Fh] [rbp-A9h]\n  char *s; // [rsp+20h] [rbp-A8h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  char *v62; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v63; // [rsp+30h] [rbp-98h]\n  char *v64; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v65; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v66; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v67; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v68; // [rsp+38h] [rbp-90h]\n  char v69; // [rsp+38h] [rbp-90h]\n  int v70; // [rsp+38h] [rbp-90h]\n  int v71; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v72; // [rsp+40h] [rbp-88h]\n  int v73; // [rsp+40h] [rbp-88h]\n  int v74; // [rsp+40h] [rbp-88h]\n  _BYTE *v75; // [rsp+40h] [rbp-88h]\n  int v76; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v77; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  __int64 v79; // [rsp+58h] [rbp-70h]\n  size_t v80; // [rsp+60h] [rbp-68h]\n  char v81; // [rsp+68h] [rbp-60h]\n  bool v82; // [rsp+6Ch] [rbp-5Ch]\n  char v83; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v85; // [rsp+70h] [rbp-58h]\n  char *v86; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h]\n  mbstate_t ps; // [rsp+88h] [rbp-40h]\n\n  v9 = a1;\n  v10 = a2;\n  v11 = a5;\n  s = a3;\n  v55 = a4;\n  v81 = a6;\n  v12 = a6 & 2;\n  v80 = __ctype_get_mb_cur_max();\n  v82 = v12 != 0;\n  v14 = v55;\n  switch ( v11 )\n  {\n    case 0:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v56 = 0;\n        goto LABEL_212;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 2;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v11 = 2;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v56 = 1;\nLABEL_212:\n      if ( a2 )\n      {\n        v15 = 0;\n        v38 = 0;\n        v59 = 1;\n        v79 = 0LL;\n        goto LABEL_138;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 1LL;\n      v11 = 2;\n      v79 = 0LL;\n      v83 = 0;\n      v82 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v17 = v14;\n      v18 = 0LL;\n      v19 = v11;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(v11) = v17 != v18;\n        if ( v17 == -1LL )\n          LOBYTE(v11) = s[v18] != 0;\n        if ( !(_BYTE)v11 )\n        {\n          v35 = v19;\n          v14 = v17;\n          v36 = v35 == 2;\n          if ( !v16 && v36 && v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v37 = !v82 && v36;\n          if ( v37 )\n          {\n            if ( v83 )\n            {\n              if ( v59 )\n                return sub_40DE00((__int64)v9, v79, s);\n              v38 = v79 != 0 && v10 == 0;\n              if ( v38 )\n              {\n                v10 = v79;\nLABEL_138:\n                *v9 = 39;\n                v11 = 2;\n                v16 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v82 = 0;\n                v83 = v38;\n                goto LABEL_3;\n              }\n              v37 = v83;\n            }\n          }\n          else\n          {\n            v37 = !v82;\n          }\n          if ( s2 )\n          {\n            if ( v37 )\n            {\n              v53 = *s2;\n              if ( *s2 )\n              {\n                v54 = &s2[-v16];\n                do\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = v53;\n                  v53 = v54[++v16];\n                }\n                while ( v53 );\n              }\n            }\n          }\n          if ( v10 > v16 )\n            v9[v16] = 0;\n          return v16;\n        }\n        v20 = &s[v18];\n        v57 = v56 & (v19 != 2);\n        if ( !(v56 & (v19 != 2)) )\n          break;\n        if ( n )\n        {\n          if ( v17 == -1LL && n > 1 )\n          {\n            v71 = v19;\n            v66 = v15;\n            v21 = strlen(s);\n            v19 = v71;\n            v15 = v66;\n            v20 = &s[v18];\n            v17 = v21;\n          }\n          if ( v18 + n <= v17 )\n          {\n            v76 = v19;\n            v72 = v17;\n            v67 = v15;\n            v62 = v20;\n            v22 = memcmp(v20, s2, n);\n            v20 = v62;\n            v15 = v67;\n            v17 = v72;\n            v19 = v76;\n            if ( !v22 )\n            {\n              if ( !v82 )\n              {\n                LOBYTE(v23) = *v62;\n                switch ( *v62 )\n                {\n                  case 0:\n                    goto LABEL_83;\n                  case 7:\n                    LOBYTE(v23) = 97;\n                    goto LABEL_79;\n                  case 8:\n                    LODWORD(v13) = 0;\n                    v11 = 0;\n                    LOBYTE(v23) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_72;\n                  case 10:\n                    goto LABEL_68;\n                  case 11:\n                    goto LABEL_80;\n                  case 12:\n                    goto LABEL_77;\n                  case 13:\n                    goto LABEL_76;\n                  case 32:\n                    v33 = v57;\n                    goto LABEL_128;\n                  case 33:\n                  case 34:\n                  case 36:\n                  case 38:\n                  case 40:\n                  case 41:\n                  case 42:\n                  case 59:\n                  case 60:\n                  case 61:\n                  case 62:\n                  case 91:\n                  case 94:\n                  case 96:\n                  case 124:\n                    goto LABEL_74;\n                  case 35:\n                  case 126:\n                    v34 = v57;\n                    goto LABEL_125;\n                  case 37:\n                  case 43:\n                  case 44:\n                  case 45:\n                  case 46:\n                  case 47:\n                  case 48:\n                  case 49:\n                  case 50:\n                  case 51:\n                  case 52:\n                  case 53:\n                  case 54:\n                  case 55:\n                  case 56:\n                  case 57:\n                  case 58:\n                  case 65:\n                  case 66:\n                  case 67:\n                  case 68:\n                  case 69:\n                  case 70:\n                  case 71:\n                  case 72:\n                  case 73:\n                  case 74:\n                  case 75:\n                  case 76:\n                  case 77:\n                  case 78:\n                  case 79:\n                  case 80:\n                  case 81:\n                  case 82:\n                  case 83:\n                  case 84:\n                  case 85:\n                  case 86:\n                  case 87:\n                  case 88:\n                  case 89:\n                  case 90:\n                  case 93:\n                  case 95:\n                  case 97:\n                  case 98:\n                  case 99:\n                  case 100:\n                  case 101:\n                  case 102:\n                  case 103:\n                  case 104:\n                  case 105:\n                  case 106:\n                  case 107:\n                  case 108:\n                  case 109:\n                  case 110:\n                  case 111:\n                  case 112:\n                  case 113:\n                  case 114:\n                  case 115:\n                  case 116:\n                  case 117:\n                  case 118:\n                  case 119:\n                  case 120:\n                  case 121:\n                  case 122:\n                    v33 = v57;\n                    goto LABEL_123;\n                  case 39:\n                    goto LABEL_62;\n                  case 63:\n                    goto LABEL_58;\n                  case 92:\n                    goto LABEL_65;\n                  case 123:\n                  case 125:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_98;\n                }\n              }\n              return sub_40DE00((__int64)v9, v10, s);\n            }\n          }\n        }\n        LOBYTE(v23) = *v20;\n        switch ( *v20 )\n        {\n          case 0:\n            goto LABEL_81;\n          case 7:\n            LOBYTE(v23) = 97;\n            goto LABEL_78;\n          case 8:\n            LOBYTE(v23) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_72:\n            LOBYTE(v23) = 116;\n            goto LABEL_69;\n          case 10:\nLABEL_68:\n            LOBYTE(v23) = 110;\nLABEL_69:\n            LODWORD(v13) = 0;\n            v11 = 0;\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            goto LABEL_29;\n          case 11:\nLABEL_80:\n            LOBYTE(v23) = 118;\n            goto LABEL_78;\n          case 12:\nLABEL_77:\n            LOBYTE(v23) = 102;\nLABEL_78:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_79:\n            v11 = 0;\n            goto LABEL_37;\n          case 13:\n            v57 = 0;\nLABEL_76:\n            LOBYTE(v23) = 13;\n            v29 = 114;\n            LOBYTE(v13) = v19 == 2;\n            goto LABEL_66;\n          case 32:\n            v33 = 0;\nLABEL_128:\n            LOBYTE(v23) = 32;\n            goto LABEL_123;\n          case 33:\n          case 34:\n          case 36:\n          case 38:\n          case 40:\n          case 41:\n          case 42:\n          case 59:\n          case 60:\n          case 61:\n          case 62:\n          case 91:\n          case 94:\n          case 96:\n          case 124:\n            v57 = 0;\nLABEL_74:\n            LODWORD(v13) = 0;\n            goto LABEL_67;\n          case 35:\n          case 126:\n            v34 = 0;\nLABEL_125:\n            if ( !v18 )\n            {\n              v11 = v57;\n              LODWORD(v13) = 0;\n              v57 = v34;\n              goto LABEL_23;\n            }\n            v57 = v34;\n            v11 = 0;\n            break;\n          case 37:\n          case 43:\n          case 44:\n          case 45:\n          case 46:\n          case 47:\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 58:\n          case 65:\n          case 66:\n          case 67:\n          case 68:\n          case 69:\n          case 70:\n          case 71:\n          case 72:\n          case 73:\n          case 74:\n          case 75:\n          case 76:\n          case 77:\n          case 78:\n          case 79:\n          case 80:\n          case 81:\n          case 82:\n          case 83:\n          case 84:\n          case 85:\n          case 86:\n          case 87:\n          case 88:\n          case 89:\n          case 90:\n          case 93:\n          case 95:\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n          case 111:\n          case 112:\n          case 113:\n          case 114:\n          case 115:\n          case 116:\n          case 117:\n          case 118:\n          case 119:\n          case 120:\n          case 121:\n          case 122:\n            v33 = 0;\nLABEL_123:\n            v11 = v57;\n            v57 = v33;\n            v25 = 0;\n            goto LABEL_25;\n          case 39:\n            v57 = 0;\n            goto LABEL_62;\n          case 63:\n            v57 = 0;\n            goto LABEL_58;\n          case 92:\n            v57 = 0;\n            goto LABEL_65;\n          case 123:\n          case 125:\n            v57 = 0;\n            goto LABEL_17;\n          default:\n            v57 = 0;\n            goto LABEL_98;\n        }\nLABEL_24:\n        v25 = 0;\nLABEL_25:\n        if ( a7 )\n        {\n          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;\n          if ( (_DWORD)v13 )\n          {\n            LOBYTE(v13) = v19 == 2;\nLABEL_28:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_29:\n            v26 = v15 ^ 1;\n            LOBYTE(v26) = v13 & (v15 ^ 1);\n            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )\n            {\n              if ( v10 > v16 )\n                v9[v16] = 39;\n              if ( v16 + 1 < v10 )\n                v9[v16 + 1] = 36;\n              LODWORD(v13) = v16 + 2;\n              if ( v16 + 2 < v10 )\n                v9[v16 + 2] = 39;\n              v16 += 3LL;\n              v15 = v26;\n            }\nLABEL_37:\n            if ( v10 > v16 )\n              v9[v16] = 92;\n            ++v16;\n            ++v18;\n            goto LABEL_40;\n          }\n        }\nLABEL_49:\n        LOBYTE(v13) = v19 == 2;\n        if ( v57 )\n          goto LABEL_28;\n        ++v18;\n        LODWORD(v28) = v15 & (v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v28 )\n        {\n          if ( v10 > v16 )\n            v9[v16] = 39;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 39;\n          v16 += 2LL;\n          v15 = 0;\n        }\nLABEL_40:\n        if ( v16 < v10 )\n          v9[v16] = v23;\n        v27 = v59;\n        ++v16;\n        if ( !(_BYTE)v11 )\n          v27 = 0;\n        v59 = v27;\n      }\n      LOBYTE(v23) = *v20;\n      switch ( *v20 )\n      {\n        case 0:\n          if ( !v56 )\n          {\n            if ( !(v81 & 1) )\n            {\n              v57 = 0;\n              LOBYTE(v13) = v19 == 2;\n              v11 = 0;\n              LOBYTE(v23) = 0;\n              goto LABEL_23;\n            }\n            ++v18;\n            goto LABEL_4;\n          }\nLABEL_81:\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v57 = 0;\nLABEL_83:\n          LOBYTE(v13) = v19 == 2;\n          v25 = v15 ^ 1;\n          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 36;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v31 = v16 + 3;\n            if ( v10 <= v16 + 3 )\n            {\n              v16 += 4LL;\n              v15 = v25;\n              v11 = 0;\n              LOBYTE(v23) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_91;\n          }\n          v31 = v16;\n          if ( v10 > v16 )\n          {\n            v25 = v15;\nLABEL_91:\n            v9[v31] = 92;\n            v15 = v25;\n          }\n          v16 = v31 + 1;\n          if ( v19 == 2 )\n          {\n            v25 = v11;\n            LOBYTE(v23) = 48;\n            v11 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v23) = 48;\n          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 48;\n            if ( v10 > v31 + 2 )\n              v9[v31 + 2] = 48;\n            v16 = v31 + 3;\n            LOBYTE(v23) = 48;\n          }\nLABEL_95:\n          v25 = v11;\n          v11 = 0;\n          if ( (unsigned __int8)v13 | v56 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v23) = 7;\n          v29 = 97;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v23) = 8;\n          v29 = 98;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v23) = 9;\n          v29 = 116;\n          goto LABEL_104;\n        case 10:\n          LOBYTE(v23) = 10;\n          v29 = 110;\n          goto LABEL_104;\n        case 11:\n          LOBYTE(v23) = 11;\n          v29 = 118;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 12:\n          LOBYTE(v23) = 12;\n          v29 = 102;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 13:\n          LOBYTE(v23) = 13;\n          v29 = 114;\nLABEL_104:\n          LOBYTE(v13) = v19 == 2;\n          v57 = v19 == 2 && v82;\n          if ( v57 )\n            return sub_40DE00((__int64)v9, v10, s);\n          goto LABEL_66;\n        case 32:\n          LOBYTE(v23) = 32;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_21;\n        case 33:\n        case 34:\n        case 36:\n        case 38:\n        case 40:\n        case 41:\n        case 42:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 91:\n        case 94:\n        case 96:\n        case 124:\n          LOBYTE(v13) = v19 == 2;\n          v11 = 0;\n          goto LABEL_21;\n        case 35:\n        case 126:\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_20;\n        case 37:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case 58:\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 93:\n        case 95:\n        case 97:\n        case 98:\n        case 99:\n        case 100:\n        case 101:\n        case 102:\n        case 103:\n        case 104:\n        case 105:\n        case 106:\n        case 107:\n        case 108:\n        case 109:\n        case 110:\n        case 111:\n        case 112:\n        case 113:\n        case 114:\n        case 115:\n        case 116:\n        case 117:\n        case 118:\n        case 119:\n        case 120:\n        case 121:\n        case 122:\n          goto LABEL_101;\n        case 39:\nLABEL_62:\n          if ( v19 != 2 )\n          {\n            v83 = v11;\n            LODWORD(v13) = 0;\n            LOBYTE(v23) = 39;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( !v10 || (v13 = 0LL, v79) )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 92;\n            v13 = v10;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v10 = v79;\n          }\n          v83 = v11;\n          v16 += 3LL;\n          v25 = 0;\n          v15 = 0;\n          v79 = v10;\n          LOBYTE(v23) = 39;\n          v10 = v13;\n          goto LABEL_49;\n        case 63:\nLABEL_58:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            v11 = 0;\n            v25 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_49;\n          }\n          if ( v19 != 5 )\n          {\n            LOBYTE(v23) = 63;\n            LOBYTE(v13) = v19 == 2;\n            v11 = 0;\n            goto LABEL_23;\n          }\n          if ( !(v81 & 4)\n            || v18 + 2 >= v17\n            || s[v18 + 1] != 63\n            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)\n            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )\n          {\n            LODWORD(v13) = 0;\n            v11 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( v10 > v16 )\n            v9[v16] = 63;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 34;\n          if ( v10 > v16 + 2 )\n            v9[v16 + 2] = 34;\n          if ( v10 > v16 + 3 )\n            v9[v16 + 3] = 63;\n          v16 += 4LL;\n          LODWORD(v13) = 0;\n          v11 = 0;\n          v18 += 2LL;\n          goto LABEL_95;\n        case 92:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            LOBYTE(v23) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LODWORD(v13) = v56;\n          LOBYTE(v23) = 92;\n          v29 = 92;\n          LOBYTE(v13) = (n != 0) & v82 & v56;\n          if ( (_BYTE)v13 )\n          {\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v56 )\n          {\nLABEL_67:\n            v11 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v23) = v29;\n          v11 = 0;\n          goto LABEL_28;\n        case 123:\n        case 125:\nLABEL_17:\n          v24 = v17 != 1;\n          if ( v17 == -1LL )\n            v24 = s[1] != 0;\n          LOBYTE(v13) = v19 == 2;\n          if ( v24 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v18 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v82 || !(_BYTE)v13 )\n            goto LABEL_23;\n          return sub_40DE00((__int64)v9, v10, s);\n        default:\nLABEL_98:\n          if ( v80 == 1 )\n          {\n            v73 = v19;\n            v68 = v17;\n            v63 = v15;\n            v28 = __ctype_b_loc();\n            LODWORD(v13) = (unsigned __int8)v23;\n            v15 = v63;\n            v17 = v68;\n            v19 = v73;\n            v32 = 1LL;\n            LODWORD(v28) = (*v28)[(unsigned __int8)v23];\n            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;\n            LOBYTE(v11) = (_WORD)v28 != 0;\n            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);\n            goto LABEL_100;\n          }\n          ps = 0LL;\n          if ( v17 == -1LL )\n          {\n            v74 = v19;\n            v69 = v15;\n            v64 = v20;\n            v39 = strlen(s);\n            v19 = v74;\n            LOBYTE(v15) = v69;\n            v20 = v64;\n            v17 = v39;\n          }\n          v85 = v16;\n          v86 = v20;\n          v40 = 0LL;\n          v84 = v15;\n          v75 = v9;\n          v77 = v10;\n          v65 = v17;\n          v70 = v19;\n          break;\n      }\n      while ( 2 )\n      {\n        v41 = v18 + v40;\n        v28 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, &s[v18 + v40]);\n        v42 = v28;\n        if ( !v28 )\n        {\nLABEL_241:\n          v32 = v40;\n          v16 = v85;\n          v15 = v84;\n          v9 = v75;\n          LODWORD(v13) = v11 ^ 1;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LOBYTE(v13) = v56 & (v11 ^ 1);\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-1LL )\n        {\n          v32 = v40;\n          v16 = v85;\n          v11 = 0;\n          v15 = v84;\n          v9 = v75;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LODWORD(v13) = v56;\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-2LL )\n        {\n          v17 = v65;\n          v50 = v18 + v40;\n          v51 = &s[v18 + v40];\n          v28 = (const unsigned __int16 **)v40;\n          v32 = v40;\n          v15 = v84;\n          v16 = v85;\n          v9 = v75;\n          v10 = v77;\n          v19 = v70;\n          if ( v50 < v65 && *v51 )\n          {\n            do\n              v28 = (const unsigned __int16 **)((char *)v28 + 1);\n            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );\n            v32 = (unsigned __int64)v28;\n          }\n          LODWORD(v13) = v56;\n          v11 = 0;\nLABEL_242:\n          if ( v32 > 1 )\n            goto LABEL_174;\nLABEL_100:\n          if ( (_BYTE)v13 )\n          {\n            LODWORD(v13) = v56;\n            LOBYTE(v11) = 0;\nLABEL_174:\n            v44 = 0;\n            v45 = v18 + v32;\n            v46 = v57;\n            while ( 1 )\n            {\n              if ( (_BYTE)v13 )\n              {\n                if ( v82 )\n                  return sub_40DE00((__int64)v9, v10, s);\n                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 36;\n                  if ( v10 > v16 + 2 )\n                    v9[v16 + 2] = 39;\n                  v16 += 3LL;\n                  v15 = (int)v28;\n                }\n                if ( v10 > v16 )\n                  v9[v16] = 92;\n                if ( v10 > v16 + 1 )\n                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;\n                LODWORD(v28) = v16 + 2;\n                if ( v10 > v16 + 2 )\n                {\n                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;\n                  v9[v16 + 2] = (_BYTE)v28;\n                }\n                ++v18;\n                v16 += 3LL;\n                LOBYTE(v23) = (v23 & 7) + 48;\n                if ( v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_40;\n                }\n                v44 = v13;\n              }\n              else\n              {\n                LODWORD(v28) = v15 & (v44 ^ 1);\n                if ( v46 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 92;\n                  ++v16;\n                }\n                if ( ++v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_51;\n                }\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  LODWORD(v28) = v16 + 1;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 39;\n                  v16 += 2LL;\n                  v46 = 0;\n                  v15 = 0;\n                }\n                else\n                {\n                  v46 = 0;\n                }\n              }\n              if ( v10 > v16 )\n                v9[v16] = v23;\n              LOBYTE(v23) = s[v18];\n              ++v16;\n            }\n          }\nLABEL_101:\n          LOBYTE(v13) = v19 == 2;\nLABEL_23:\n          v25 = (v13 | v56 ^ 1) ^ 1;\n          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;\n          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )\n            goto LABEL_49;\n          goto LABEL_24;\n        }\n        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )\n        {\nLABEL_148:\n          if ( !iswprint(wc) )\n            v11 = 0;\n          v40 += (unsigned __int64)v42;\n          LODWORD(v28) = mbsinit(&ps);\n          if ( (_DWORD)v28 )\n            goto LABEL_241;\n          continue;\n        }\n        break;\n      }\n      v43 = &s[v41 + 1];\n      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )\n      {\n        if ( &s[(_QWORD)v42 + v41] == ++v43 )\n          goto LABEL_148;\n      }\n      v9 = v75;\n      v10 = v77;\n      return sub_40DE00((__int64)v9, v10, s);\n    case 5:\n      if ( v12 )\n      {\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n          v79 = 0LL;\n        }\n        else\n        {\n          v79 = 0LL;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n        }\n        v82 = 0;\n        v16 = 1LL;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 5;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", v11);\n        v47 = sub_40DD00(\"'\", v11);\n        v14 = v55;\n        a9 = (char *)v47;\n      }\n      v16 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v16] )\n        {\n          if ( a2 > v16 )\n            a1[v16] = i;\n          ++v16;\n        }\n      }\n      v58 = v14;\n      v48 = strlen(a9);\n      v59 = 1;\n      v15 = 0;\n      v14 = v58;\n      n = v48;\n      v83 = 0;\n      s2 = a9;\n      v79 = 0LL;\n      v56 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n      return result;\n  }\n}\n\nunsigned __int64 __fastcall sub_40DE00(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, const char *a8, char *a9)\n{\n  _BYTE *v9; // r15\n  unsigned __int64 v10; // r14\n  int v11; // er13\n  int v12; // ebp\n  unsigned __int64 v13; // rdx\n  unsigned __int64 v14; // r11\n  int v15; // er10\n  unsigned __int64 v16; // rbx\n  unsigned __int64 v17; // r9\n  unsigned __int64 v18; // r12\n  int v19; // er11\n  char *v20; // r8\n  size_t v21; // rax\n  int v22; // eax\n  unsigned __int64 v23; // rbp\n  bool v24; // al\n  int v25; // eax\n  int v26; // eax\n  char v27; // di\n  const unsigned __int16 **v28; // rax\n  char v29; // cl\n  unsigned __int64 result; // rax\n  __int64 v31; // rcx\n  unsigned __int64 v32; // rdi\n  unsigned __int8 v33; // al\n  unsigned __int8 v34; // al\n  int v35; // er13\n  bool v36; // dl\n  bool v37; // dl\n  bool v38; // al\n  size_t v39; // rax\n  unsigned __int64 v40; // rbx\n  unsigned __int64 v41; // r15\n  const unsigned __int16 **v42; // r14\n  char *v43; // rax\n  int v44; // esi\n  unsigned __int64 v45; // rcx\n  unsigned __int8 v46; // di\n  const char *v47; // rax\n  size_t v48; // rax\n  __int64 v49; // rsi\n  unsigned __int64 v50; // rsi\n  char *v51; // rcx\n  char i; // al\n  char v53; // dl\n  const char *v54; // rax\n  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]\n  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]\n  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]\n  char v59; // [rsp+1Fh] [rbp-A9h]\n  char *s; // [rsp+20h] [rbp-A8h]\n  size_t n; // [rsp+28h] [rbp-A0h]\n  char *v62; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v63; // [rsp+30h] [rbp-98h]\n  char *v64; // [rsp+30h] [rbp-98h]\n  unsigned __int64 v65; // [rsp+30h] [rbp-98h]\n  unsigned __int8 v66; // [rsp+38h] [rbp-90h]\n  unsigned __int8 v67; // [rsp+38h] [rbp-90h]\n  unsigned __int64 v68; // [rsp+38h] [rbp-90h]\n  char v69; // [rsp+38h] [rbp-90h]\n  int v70; // [rsp+38h] [rbp-90h]\n  int v71; // [rsp+40h] [rbp-88h]\n  unsigned __int64 v72; // [rsp+40h] [rbp-88h]\n  int v73; // [rsp+40h] [rbp-88h]\n  int v74; // [rsp+40h] [rbp-88h]\n  _BYTE *v75; // [rsp+40h] [rbp-88h]\n  int v76; // [rsp+48h] [rbp-80h]\n  unsigned __int64 v77; // [rsp+48h] [rbp-80h]\n  const char *s2; // [rsp+50h] [rbp-78h]\n  __int64 v79; // [rsp+58h] [rbp-70h]\n  size_t v80; // [rsp+60h] [rbp-68h]\n  char v81; // [rsp+68h] [rbp-60h]\n  bool v82; // [rsp+6Ch] [rbp-5Ch]\n  char v83; // [rsp+6Dh] [rbp-5Bh]\n  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]\n  unsigned __int64 v85; // [rsp+70h] [rbp-58h]\n  char *v86; // [rsp+78h] [rbp-50h]\n  wint_t wc; // [rsp+84h] [rbp-44h]\n  mbstate_t ps; // [rsp+88h] [rbp-40h]\n\n  v9 = a1;\n  v10 = a2;\n  v11 = a5;\n  s = a3;\n  v55 = a4;\n  v81 = a6;\n  v12 = a6 & 2;\n  v80 = __ctype_get_mb_cur_max();\n  v82 = v12 != 0;\n  v14 = v55;\n  switch ( v11 )\n  {\n    case 0:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 0;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 1:\n      goto LABEL_2;\n    case 2:\n      if ( !v12 )\n      {\n        v56 = 0;\n        goto LABEL_212;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 3:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 2;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\n      goto LABEL_3;\n    case 4:\n      if ( v12 )\n      {\nLABEL_2:\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v11 = 2;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 0;\n        n = 1LL;\n        s2 = \"invalid number after ','\" + 23;\n        goto LABEL_3;\n      }\n      v56 = 1;\nLABEL_212:\n      if ( a2 )\n      {\n        v15 = 0;\n        v38 = 0;\n        v59 = 1;\n        v79 = 0LL;\n        goto LABEL_138;\n      }\n      v59 = 1;\n      v15 = 0;\n      v16 = 1LL;\n      v11 = 2;\n      v79 = 0LL;\n      v83 = 0;\n      v82 = 0;\n      n = 1LL;\n      s2 = \"invalid number after ','\" + 23;\nLABEL_3:\n      v17 = v14;\n      v18 = 0LL;\n      v19 = v11;\n      while ( 1 )\n      {\nLABEL_4:\n        LOBYTE(v11) = v17 != v18;\n        if ( v17 == -1LL )\n          LOBYTE(v11) = s[v18] != 0;\n        if ( !(_BYTE)v11 )\n        {\n          v35 = v19;\n          v14 = v17;\n          v36 = v35 == 2;\n          if ( !v16 && v36 && v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v37 = !v82 && v36;\n          if ( v37 )\n          {\n            if ( v83 )\n            {\n              if ( v59 )\n                return sub_40DE00((__int64)v9, v79, s);\n              v38 = v79 != 0 && v10 == 0;\n              if ( v38 )\n              {\n                v10 = v79;\nLABEL_138:\n                *v9 = 39;\n                v11 = 2;\n                v16 = 1LL;\n                s2 = \"invalid number after ','\" + 23;\n                n = 1LL;\n                v82 = 0;\n                v83 = v38;\n                goto LABEL_3;\n              }\n              v37 = v83;\n            }\n          }\n          else\n          {\n            v37 = !v82;\n          }\n          if ( s2 )\n          {\n            if ( v37 )\n            {\n              v53 = *s2;\n              if ( *s2 )\n              {\n                v54 = &s2[-v16];\n                do\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = v53;\n                  v53 = v54[++v16];\n                }\n                while ( v53 );\n              }\n            }\n          }\n          if ( v10 > v16 )\n            v9[v16] = 0;\n          return v16;\n        }\n        v20 = &s[v18];\n        v57 = v56 & (v19 != 2);\n        if ( !(v56 & (v19 != 2)) )\n          break;\n        if ( n )\n        {\n          if ( v17 == -1LL && n > 1 )\n          {\n            v71 = v19;\n            v66 = v15;\n            v21 = strlen(s);\n            v19 = v71;\n            v15 = v66;\n            v20 = &s[v18];\n            v17 = v21;\n          }\n          if ( v18 + n <= v17 )\n          {\n            v76 = v19;\n            v72 = v17;\n            v67 = v15;\n            v62 = v20;\n            v22 = memcmp(v20, s2, n);\n            v20 = v62;\n            v15 = v67;\n            v17 = v72;\n            v19 = v76;\n            if ( !v22 )\n            {\n              if ( !v82 )\n              {\n                LOBYTE(v23) = *v62;\n                switch ( *v62 )\n                {\n                  case 0:\n                    goto LABEL_83;\n                  case 7:\n                    LOBYTE(v23) = 97;\n                    goto LABEL_79;\n                  case 8:\n                    LODWORD(v13) = 0;\n                    v11 = 0;\n                    LOBYTE(v23) = 98;\n                    goto LABEL_29;\n                  case 9:\n                    goto LABEL_72;\n                  case 10:\n                    goto LABEL_68;\n                  case 11:\n                    goto LABEL_80;\n                  case 12:\n                    goto LABEL_77;\n                  case 13:\n                    goto LABEL_76;\n                  case 32:\n                    v33 = v57;\n                    goto LABEL_128;\n                  case 33:\n                  case 34:\n                  case 36:\n                  case 38:\n                  case 40:\n                  case 41:\n                  case 42:\n                  case 59:\n                  case 60:\n                  case 61:\n                  case 62:\n                  case 91:\n                  case 94:\n                  case 96:\n                  case 124:\n                    goto LABEL_74;\n                  case 35:\n                  case 126:\n                    v34 = v57;\n                    goto LABEL_125;\n                  case 37:\n                  case 43:\n                  case 44:\n                  case 45:\n                  case 46:\n                  case 47:\n                  case 48:\n                  case 49:\n                  case 50:\n                  case 51:\n                  case 52:\n                  case 53:\n                  case 54:\n                  case 55:\n                  case 56:\n                  case 57:\n                  case 58:\n                  case 65:\n                  case 66:\n                  case 67:\n                  case 68:\n                  case 69:\n                  case 70:\n                  case 71:\n                  case 72:\n                  case 73:\n                  case 74:\n                  case 75:\n                  case 76:\n                  case 77:\n                  case 78:\n                  case 79:\n                  case 80:\n                  case 81:\n                  case 82:\n                  case 83:\n                  case 84:\n                  case 85:\n                  case 86:\n                  case 87:\n                  case 88:\n                  case 89:\n                  case 90:\n                  case 93:\n                  case 95:\n                  case 97:\n                  case 98:\n                  case 99:\n                  case 100:\n                  case 101:\n                  case 102:\n                  case 103:\n                  case 104:\n                  case 105:\n                  case 106:\n                  case 107:\n                  case 108:\n                  case 109:\n                  case 110:\n                  case 111:\n                  case 112:\n                  case 113:\n                  case 114:\n                  case 115:\n                  case 116:\n                  case 117:\n                  case 118:\n                  case 119:\n                  case 120:\n                  case 121:\n                  case 122:\n                    v33 = v57;\n                    goto LABEL_123;\n                  case 39:\n                    goto LABEL_62;\n                  case 63:\n                    goto LABEL_58;\n                  case 92:\n                    goto LABEL_65;\n                  case 123:\n                  case 125:\n                    goto LABEL_17;\n                  default:\n                    goto LABEL_98;\n                }\n              }\n              return sub_40DE00((__int64)v9, v10, s);\n            }\n          }\n        }\n        LOBYTE(v23) = *v20;\n        switch ( *v20 )\n        {\n          case 0:\n            goto LABEL_81;\n          case 7:\n            LOBYTE(v23) = 97;\n            goto LABEL_78;\n          case 8:\n            LOBYTE(v23) = 98;\n            goto LABEL_69;\n          case 9:\nLABEL_72:\n            LOBYTE(v23) = 116;\n            goto LABEL_69;\n          case 10:\nLABEL_68:\n            LOBYTE(v23) = 110;\nLABEL_69:\n            LODWORD(v13) = 0;\n            v11 = 0;\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            goto LABEL_29;\n          case 11:\nLABEL_80:\n            LOBYTE(v23) = 118;\n            goto LABEL_78;\n          case 12:\nLABEL_77:\n            LOBYTE(v23) = 102;\nLABEL_78:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_79:\n            v11 = 0;\n            goto LABEL_37;\n          case 13:\n            v57 = 0;\nLABEL_76:\n            LOBYTE(v23) = 13;\n            v29 = 114;\n            LOBYTE(v13) = v19 == 2;\n            goto LABEL_66;\n          case 32:\n            v33 = 0;\nLABEL_128:\n            LOBYTE(v23) = 32;\n            goto LABEL_123;\n          case 33:\n          case 34:\n          case 36:\n          case 38:\n          case 40:\n          case 41:\n          case 42:\n          case 59:\n          case 60:\n          case 61:\n          case 62:\n          case 91:\n          case 94:\n          case 96:\n          case 124:\n            v57 = 0;\nLABEL_74:\n            LODWORD(v13) = 0;\n            goto LABEL_67;\n          case 35:\n          case 126:\n            v34 = 0;\nLABEL_125:\n            if ( !v18 )\n            {\n              v11 = v57;\n              LODWORD(v13) = 0;\n              v57 = v34;\n              goto LABEL_23;\n            }\n            v57 = v34;\n            v11 = 0;\n            break;\n          case 37:\n          case 43:\n          case 44:\n          case 45:\n          case 46:\n          case 47:\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 58:\n          case 65:\n          case 66:\n          case 67:\n          case 68:\n          case 69:\n          case 70:\n          case 71:\n          case 72:\n          case 73:\n          case 74:\n          case 75:\n          case 76:\n          case 77:\n          case 78:\n          case 79:\n          case 80:\n          case 81:\n          case 82:\n          case 83:\n          case 84:\n          case 85:\n          case 86:\n          case 87:\n          case 88:\n          case 89:\n          case 90:\n          case 93:\n          case 95:\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n          case 111:\n          case 112:\n          case 113:\n          case 114:\n          case 115:\n          case 116:\n          case 117:\n          case 118:\n          case 119:\n          case 120:\n          case 121:\n          case 122:\n            v33 = 0;\nLABEL_123:\n            v11 = v57;\n            v57 = v33;\n            v25 = 0;\n            goto LABEL_25;\n          case 39:\n            v57 = 0;\n            goto LABEL_62;\n          case 63:\n            v57 = 0;\n            goto LABEL_58;\n          case 92:\n            v57 = 0;\n            goto LABEL_65;\n          case 123:\n          case 125:\n            v57 = 0;\n            goto LABEL_17;\n          default:\n            v57 = 0;\n            goto LABEL_98;\n        }\nLABEL_24:\n        v25 = 0;\nLABEL_25:\n        if ( a7 )\n        {\n          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;\n          if ( (_DWORD)v13 )\n          {\n            LOBYTE(v13) = v19 == 2;\nLABEL_28:\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\nLABEL_29:\n            v26 = v15 ^ 1;\n            LOBYTE(v26) = v13 & (v15 ^ 1);\n            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )\n            {\n              if ( v10 > v16 )\n                v9[v16] = 39;\n              if ( v16 + 1 < v10 )\n                v9[v16 + 1] = 36;\n              LODWORD(v13) = v16 + 2;\n              if ( v16 + 2 < v10 )\n                v9[v16 + 2] = 39;\n              v16 += 3LL;\n              v15 = v26;\n            }\nLABEL_37:\n            if ( v10 > v16 )\n              v9[v16] = 92;\n            ++v16;\n            ++v18;\n            goto LABEL_40;\n          }\n        }\nLABEL_49:\n        LOBYTE(v13) = v19 == 2;\n        if ( v57 )\n          goto LABEL_28;\n        ++v18;\n        LODWORD(v28) = v15 & (v25 ^ 1);\nLABEL_51:\n        if ( (_BYTE)v28 )\n        {\n          if ( v10 > v16 )\n            v9[v16] = 39;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 39;\n          v16 += 2LL;\n          v15 = 0;\n        }\nLABEL_40:\n        if ( v16 < v10 )\n          v9[v16] = v23;\n        v27 = v59;\n        ++v16;\n        if ( !(_BYTE)v11 )\n          v27 = 0;\n        v59 = v27;\n      }\n      LOBYTE(v23) = *v20;\n      switch ( *v20 )\n      {\n        case 0:\n          if ( !v56 )\n          {\n            if ( !(v81 & 1) )\n            {\n              v57 = 0;\n              LOBYTE(v13) = v19 == 2;\n              v11 = 0;\n              LOBYTE(v23) = 0;\n              goto LABEL_23;\n            }\n            ++v18;\n            goto LABEL_4;\n          }\nLABEL_81:\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          v57 = 0;\nLABEL_83:\n          LOBYTE(v13) = v19 == 2;\n          v25 = v15 ^ 1;\n          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);\n          if ( (_BYTE)v25 )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 36;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v31 = v16 + 3;\n            if ( v10 <= v16 + 3 )\n            {\n              v16 += 4LL;\n              v15 = v25;\n              v11 = 0;\n              LOBYTE(v23) = 48;\n              goto LABEL_49;\n            }\n            goto LABEL_91;\n          }\n          v31 = v16;\n          if ( v10 > v16 )\n          {\n            v25 = v15;\nLABEL_91:\n            v9[v31] = 92;\n            v15 = v25;\n          }\n          v16 = v31 + 1;\n          if ( v19 == 2 )\n          {\n            v25 = v11;\n            LOBYTE(v23) = 48;\n            v11 = 0;\n            goto LABEL_49;\n          }\n          LOBYTE(v23) = 48;\n          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 48;\n            if ( v10 > v31 + 2 )\n              v9[v31 + 2] = 48;\n            v16 = v31 + 3;\n            LOBYTE(v23) = 48;\n          }\nLABEL_95:\n          v25 = v11;\n          v11 = 0;\n          if ( (unsigned __int8)v13 | v56 ^ 1 )\n            goto LABEL_49;\n          goto LABEL_25;\n        case 7:\n          LOBYTE(v23) = 7;\n          v29 = 97;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 8:\n          LOBYTE(v23) = 8;\n          v29 = 98;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 9:\n          LOBYTE(v23) = 9;\n          v29 = 116;\n          goto LABEL_104;\n        case 10:\n          LOBYTE(v23) = 10;\n          v29 = 110;\n          goto LABEL_104;\n        case 11:\n          LOBYTE(v23) = 11;\n          v29 = 118;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 12:\n          LOBYTE(v23) = 12;\n          v29 = 102;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_66;\n        case 13:\n          LOBYTE(v23) = 13;\n          v29 = 114;\nLABEL_104:\n          LOBYTE(v13) = v19 == 2;\n          v57 = v19 == 2 && v82;\n          if ( v57 )\n            return sub_40DE00((__int64)v9, v10, s);\n          goto LABEL_66;\n        case 32:\n          LOBYTE(v23) = 32;\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_21;\n        case 33:\n        case 34:\n        case 36:\n        case 38:\n        case 40:\n        case 41:\n        case 42:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 91:\n        case 94:\n        case 96:\n        case 124:\n          LOBYTE(v13) = v19 == 2;\n          v11 = 0;\n          goto LABEL_21;\n        case 35:\n        case 126:\n          LOBYTE(v13) = v19 == 2;\n          goto LABEL_20;\n        case 37:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case 58:\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 93:\n        case 95:\n        case 97:\n        case 98:\n        case 99:\n        case 100:\n        case 101:\n        case 102:\n        case 103:\n        case 104:\n        case 105:\n        case 106:\n        case 107:\n        case 108:\n        case 109:\n        case 110:\n        case 111:\n        case 112:\n        case 113:\n        case 114:\n        case 115:\n        case 116:\n        case 117:\n        case 118:\n        case 119:\n        case 120:\n        case 121:\n        case 122:\n          goto LABEL_101;\n        case 39:\nLABEL_62:\n          if ( v19 != 2 )\n          {\n            v83 = v11;\n            LODWORD(v13) = 0;\n            LOBYTE(v23) = 39;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( !v10 || (v13 = 0LL, v79) )\n          {\n            if ( v10 > v16 )\n              v9[v16] = 39;\n            if ( v10 > v16 + 1 )\n              v9[v16 + 1] = 92;\n            v13 = v10;\n            if ( v10 > v16 + 2 )\n              v9[v16 + 2] = 39;\n            v10 = v79;\n          }\n          v83 = v11;\n          v16 += 3LL;\n          v25 = 0;\n          v15 = 0;\n          v79 = v10;\n          LOBYTE(v23) = 39;\n          v10 = v13;\n          goto LABEL_49;\n        case 63:\nLABEL_58:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            v11 = 0;\n            v25 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_49;\n          }\n          if ( v19 != 5 )\n          {\n            LOBYTE(v23) = 63;\n            LOBYTE(v13) = v19 == 2;\n            v11 = 0;\n            goto LABEL_23;\n          }\n          if ( !(v81 & 4)\n            || v18 + 2 >= v17\n            || s[v18 + 1] != 63\n            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)\n            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )\n          {\n            LODWORD(v13) = 0;\n            v11 = 0;\n            LOBYTE(v23) = 63;\n            goto LABEL_23;\n          }\n          if ( v82 )\n            return sub_40DE00((__int64)v9, v10, s);\n          if ( v10 > v16 )\n            v9[v16] = 63;\n          if ( v10 > v16 + 1 )\n            v9[v16 + 1] = 34;\n          if ( v10 > v16 + 2 )\n            v9[v16 + 2] = 34;\n          if ( v10 > v16 + 3 )\n            v9[v16 + 3] = 63;\n          v16 += 4LL;\n          LODWORD(v13) = 0;\n          v11 = 0;\n          v18 += 2LL;\n          goto LABEL_95;\n        case 92:\n          if ( v19 == 2 )\n          {\n            if ( v82 )\n              return sub_40DE00((__int64)v9, v10, s);\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            LOBYTE(v23) = 92;\n            goto LABEL_51;\n          }\nLABEL_65:\n          LODWORD(v13) = v56;\n          LOBYTE(v23) = 92;\n          v29 = 92;\n          LOBYTE(v13) = (n != 0) & v82 & v56;\n          if ( (_BYTE)v13 )\n          {\n            ++v18;\n            LOBYTE(v28) = v15;\n            v11 = 0;\n            goto LABEL_51;\n          }\nLABEL_66:\n          if ( !v56 )\n          {\nLABEL_67:\n            v11 = 0;\n            goto LABEL_23;\n          }\n          LOBYTE(v23) = v29;\n          v11 = 0;\n          goto LABEL_28;\n        case 123:\n        case 125:\nLABEL_17:\n          v24 = v17 != 1;\n          if ( v17 == -1LL )\n            v24 = s[1] != 0;\n          LOBYTE(v13) = v19 == 2;\n          if ( v24 )\n            goto LABEL_67;\nLABEL_20:\n          if ( v18 )\n            goto LABEL_67;\nLABEL_21:\n          if ( !v82 || !(_BYTE)v13 )\n            goto LABEL_23;\n          return sub_40DE00((__int64)v9, v10, s);\n        default:\nLABEL_98:\n          if ( v80 == 1 )\n          {\n            v73 = v19;\n            v68 = v17;\n            v63 = v15;\n            v28 = __ctype_b_loc();\n            LODWORD(v13) = (unsigned __int8)v23;\n            v15 = v63;\n            v17 = v68;\n            v19 = v73;\n            v32 = 1LL;\n            LODWORD(v28) = (*v28)[(unsigned __int8)v23];\n            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;\n            LOBYTE(v11) = (_WORD)v28 != 0;\n            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);\n            goto LABEL_100;\n          }\n          ps = 0LL;\n          if ( v17 == -1LL )\n          {\n            v74 = v19;\n            v69 = v15;\n            v64 = v20;\n            v39 = strlen(s);\n            v19 = v74;\n            LOBYTE(v15) = v69;\n            v20 = v64;\n            v17 = v39;\n          }\n          v85 = v16;\n          v86 = v20;\n          v40 = 0LL;\n          v84 = v15;\n          v75 = v9;\n          v77 = v10;\n          v65 = v17;\n          v70 = v19;\n          break;\n      }\n      while ( 2 )\n      {\n        v41 = v18 + v40;\n        v28 = (const unsigned __int16 **)sub_412FB0((wchar_t *)&wc, &s[v18 + v40]);\n        v42 = v28;\n        if ( !v28 )\n        {\nLABEL_241:\n          v32 = v40;\n          v16 = v85;\n          v15 = v84;\n          v9 = v75;\n          LODWORD(v13) = v11 ^ 1;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LOBYTE(v13) = v56 & (v11 ^ 1);\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-1LL )\n        {\n          v32 = v40;\n          v16 = v85;\n          v11 = 0;\n          v15 = v84;\n          v9 = v75;\n          v10 = v77;\n          v17 = v65;\n          v19 = v70;\n          LODWORD(v13) = v56;\n          goto LABEL_242;\n        }\n        if ( v28 == (const unsigned __int16 **)-2LL )\n        {\n          v17 = v65;\n          v50 = v18 + v40;\n          v51 = &s[v18 + v40];\n          v28 = (const unsigned __int16 **)v40;\n          v32 = v40;\n          v15 = v84;\n          v16 = v85;\n          v9 = v75;\n          v10 = v77;\n          v19 = v70;\n          if ( v50 < v65 && *v51 )\n          {\n            do\n              v28 = (const unsigned __int16 **)((char *)v28 + 1);\n            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );\n            v32 = (unsigned __int64)v28;\n          }\n          LODWORD(v13) = v56;\n          v11 = 0;\nLABEL_242:\n          if ( v32 > 1 )\n            goto LABEL_174;\nLABEL_100:\n          if ( (_BYTE)v13 )\n          {\n            LODWORD(v13) = v56;\n            LOBYTE(v11) = 0;\nLABEL_174:\n            v44 = 0;\n            v45 = v18 + v32;\n            v46 = v57;\n            while ( 1 )\n            {\n              if ( (_BYTE)v13 )\n              {\n                if ( v82 )\n                  return sub_40DE00((__int64)v9, v10, s);\n                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 36;\n                  if ( v10 > v16 + 2 )\n                    v9[v16 + 2] = 39;\n                  v16 += 3LL;\n                  v15 = (int)v28;\n                }\n                if ( v10 > v16 )\n                  v9[v16] = 92;\n                if ( v10 > v16 + 1 )\n                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;\n                LODWORD(v28) = v16 + 2;\n                if ( v10 > v16 + 2 )\n                {\n                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;\n                  v9[v16 + 2] = (_BYTE)v28;\n                }\n                ++v18;\n                v16 += 3LL;\n                LOBYTE(v23) = (v23 & 7) + 48;\n                if ( v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_40;\n                }\n                v44 = v13;\n              }\n              else\n              {\n                LODWORD(v28) = v15 & (v44 ^ 1);\n                if ( v46 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 92;\n                  ++v16;\n                }\n                if ( ++v18 >= v45 )\n                {\n                  v11 = (unsigned __int8)v11;\n                  goto LABEL_51;\n                }\n                if ( (_BYTE)v28 )\n                {\n                  if ( v10 > v16 )\n                    v9[v16] = 39;\n                  LODWORD(v28) = v16 + 1;\n                  if ( v10 > v16 + 1 )\n                    v9[v16 + 1] = 39;\n                  v16 += 2LL;\n                  v46 = 0;\n                  v15 = 0;\n                }\n                else\n                {\n                  v46 = 0;\n                }\n              }\n              if ( v10 > v16 )\n                v9[v16] = v23;\n              LOBYTE(v23) = s[v18];\n              ++v16;\n            }\n          }\nLABEL_101:\n          LOBYTE(v13) = v19 == 2;\nLABEL_23:\n          v25 = (v13 | v56 ^ 1) ^ 1;\n          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;\n          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )\n            goto LABEL_49;\n          goto LABEL_24;\n        }\n        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )\n        {\nLABEL_148:\n          if ( !iswprint(wc) )\n            v11 = 0;\n          v40 += (unsigned __int64)v42;\n          LODWORD(v28) = mbsinit(&ps);\n          if ( (_DWORD)v28 )\n            goto LABEL_241;\n          continue;\n        }\n        break;\n      }\n      v43 = &s[v41 + 1];\n      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )\n      {\n        if ( &s[(_QWORD)v42 + v41] == ++v43 )\n          goto LABEL_148;\n      }\n      v9 = v75;\n      v10 = v77;\n      return sub_40DE00((__int64)v9, v10, s);\n    case 5:\n      if ( v12 )\n      {\n        v59 = 1;\n        v15 = 0;\n        v16 = 0LL;\n        v83 = 0;\n        v79 = 0LL;\n        v82 = 1;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      else\n      {\n        if ( a2 )\n        {\n          *a1 = 34;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n          v79 = 0LL;\n        }\n        else\n        {\n          v79 = 0LL;\n          v15 = 0;\n          v59 = 1;\n          v83 = 0;\n        }\n        v82 = 0;\n        v16 = 1LL;\n        v56 = 1;\n        n = 1LL;\n        s2 = \"\\\"\";\n      }\n      goto LABEL_3;\n    case 6:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v11 = 5;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 1;\n      v56 = 1;\n      n = 1LL;\n      s2 = \"\\\"\";\n      goto LABEL_3;\n    case 7:\n      v59 = 1;\n      v15 = 0;\n      v16 = 0LL;\n      v83 = 0;\n      v79 = 0LL;\n      v82 = 0;\n      v56 = 1;\n      n = 0LL;\n      s2 = 0LL;\n      goto LABEL_3;\n    case 8:\n    case 9:\n    case 10:\n      if ( v12 )\n      {\n        a8 = sub_40DD00(\"`\", v11);\n        v47 = sub_40DD00(\"'\", v11);\n        v14 = v55;\n        a9 = (char *)v47;\n      }\n      v16 = 0LL;\n      if ( !v12 )\n      {\n        for ( i = *a8; i; i = a8[v16] )\n        {\n          if ( a2 > v16 )\n            a1[v16] = i;\n          ++v16;\n        }\n      }\n      v58 = v14;\n      v48 = strlen(a9);\n      v59 = 1;\n      v15 = 0;\n      v14 = v58;\n      n = v48;\n      v83 = 0;\n      s2 = a9;\n      v79 = 0LL;\n      v56 = 1;\n      goto LABEL_3;\n    default:\n      abort();\n      return result;\n  }\n}\n", 
            "funcStartAddr": "0x402f14L", 
            "funcEndAddr": "0x402f19L", 
            "funcName": "sub_40DE00"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F030(__int64 a1, char *a2, unsigned __int64 a3, __int64 a4)\n{\n  unsigned __int64 v4; // r14\n  __int64 v5; // rbp\n  int *v6; // rax\n  __int64 v7; // rdx\n  __int128 *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // er8\n  char *v18; // [rsp+8h] [rbp-50h]\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = a3;\n  v5 = a4;\n  v18 = a2;\n  v6 = __errno_location();\n  v8 = off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__int128 *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (__int128 *)sub_411270(off_61C558, v10);\n      v8 = off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(v5 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, v18, v4, *(_DWORD *)v5, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)v5;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, v18, v4, v16, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n\n_BYTE *__fastcall sub_40F030(__int64 a1, char *a2, unsigned __int64 a3, __int64 a4)\n{\n  unsigned __int64 v4; // r14\n  __int64 v5; // rbp\n  int *v6; // rax\n  __int64 v7; // rdx\n  __int128 *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // er8\n  char *v18; // [rsp+8h] [rbp-50h]\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = a3;\n  v5 = a4;\n  v18 = a2;\n  v6 = __errno_location();\n  v8 = off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__int128 *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (__int128 *)sub_411270(off_61C558, v10);\n      v8 = off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(v5 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, v18, v4, *(_DWORD *)v5, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)v5;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, v18, v4, v16, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n", 
            "funcStartAddr": "0x402f19L", 
            "funcEndAddr": "0x402f1eL", 
            "funcName": "sub_40F030"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F030(__int64 a1, char *a2, unsigned __int64 a3, __int64 a4)\n{\n  unsigned __int64 v4; // r14\n  __int64 v5; // rbp\n  int *v6; // rax\n  __int64 v7; // rdx\n  __int128 *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // er8\n  char *v18; // [rsp+8h] [rbp-50h]\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = a3;\n  v5 = a4;\n  v18 = a2;\n  v6 = __errno_location();\n  v8 = off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__int128 *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (__int128 *)sub_411270(off_61C558, v10);\n      v8 = off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(v5 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, v18, v4, *(_DWORD *)v5, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)v5;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, v18, v4, v16, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n\n_BYTE *__fastcall sub_40F030(__int64 a1, char *a2, unsigned __int64 a3, __int64 a4)\n{\n  unsigned __int64 v4; // r14\n  __int64 v5; // rbp\n  int *v6; // rax\n  __int64 v7; // rdx\n  __int128 *v8; // rbx\n  int *v9; // r13\n  __int64 v10; // rsi\n  unsigned __int64 *v11; // rbx\n  _BYTE *v12; // r12\n  unsigned __int64 v13; // rax\n  unsigned __int64 v14; // rsi\n  _BYTE *v15; // rax\n  int v16; // er8\n  char *v18; // [rsp+8h] [rbp-50h]\n  unsigned __int64 v19; // [rsp+10h] [rbp-48h]\n  __int64 v20; // [rsp+10h] [rbp-48h]\n  int v21; // [rsp+18h] [rbp-40h]\n  int v22; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = a3;\n  v5 = a4;\n  v18 = a2;\n  v6 = __errno_location();\n  v8 = off_61C558;\n  v9 = v6;\n  v21 = *v6;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( dword_61C570 <= (int)a1 )\n  {\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_411460(a1, a2, v7);\n    v10 = 16LL * ((int)a1 + 1);\n    if ( off_61C558 == &xmmword_61C560 )\n    {\n      v8 = (__int128 *)sub_411270(0LL, v10);\n      off_61C558 = v8;\n      *v8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_61C560);\n    }\n    else\n    {\n      off_61C558 = (__int128 *)sub_411270(off_61C558, v10);\n      v8 = off_61C558;\n    }\n    memset(&v8[dword_61C570], 0, 16LL * ((int)a1 + 1 - dword_61C570));\n    dword_61C570 = a1 + 1;\n  }\n  v11 = (unsigned __int64 *)&v8[(int)a1];\n  v12 = (_BYTE *)v11[1];\n  v22 = *(_DWORD *)(v5 + 4) | 1;\n  v19 = *v11;\n  v13 = sub_40DE00(v12, *v11, v18, v4, *(_DWORD *)v5, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  if ( v19 <= v13 )\n  {\n    v14 = v13 + 1;\n    *v11 = v13 + 1;\n    if ( v12 != (_BYTE *)&unk_61CBE0 )\n    {\n      v20 = v13 + 1;\n      free(v12);\n      v14 = v20;\n    }\n    v15 = (_BYTE *)sub_411210(v14);\n    v16 = *(_DWORD *)v5;\n    v11[1] = (unsigned __int64)v15;\n    v12 = v15;\n    sub_40DE00(v15, v14, v18, v4, v16, v22, v5 + 8, *(const char **)(v5 + 40), *(char **)(v5 + 48));\n  }\n  *v9 = v21;\n  return v12;\n}\n", 
            "funcStartAddr": "0x402f19L", 
            "funcEndAddr": "0x402f1eL", 
            "funcName": "sub_40F030"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F550(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v5 = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n\n_BYTE *__fastcall sub_40F550(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v5 = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n", 
            "funcStartAddr": "0x402f1eL", 
            "funcEndAddr": "0x402f23L", 
            "funcName": "sub_40F550"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F550(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v5 = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n\n_BYTE *__fastcall sub_40F550(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v5 = 0;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n", 
            "funcStartAddr": "0x402f1eL", 
            "funcEndAddr": "0x402f23L", 
            "funcName": "sub_40F550"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, char *a3, unsigned __int64 a4)\n{\n  int v5; // [rsp+0h] [rbp-48h]\n  int v6; // [rsp+4h] [rbp-44h]\n  __int64 v7; // [rsp+8h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-38h]\n  __int64 v9; // [rsp+18h] [rbp-30h]\n  __int64 v10; // [rsp+20h] [rbp-28h]\n  __int64 v11; // [rsp+28h] [rbp-20h]\n  __int64 v12; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5 = a2;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  v12 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)&v5);\n}\n\n_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, char *a3, unsigned __int64 a4)\n{\n  int v5; // [rsp+0h] [rbp-48h]\n  int v6; // [rsp+4h] [rbp-44h]\n  __int64 v7; // [rsp+8h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-38h]\n  __int64 v9; // [rsp+18h] [rbp-30h]\n  __int64 v10; // [rsp+20h] [rbp-28h]\n  __int64 v11; // [rsp+28h] [rbp-20h]\n  __int64 v12; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5 = a2;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  v12 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)&v5);\n}\n", 
            "funcStartAddr": "0x402f23L", 
            "funcEndAddr": "0x402f28L", 
            "funcName": "sub_40F5C0"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, char *a3, unsigned __int64 a4)\n{\n  int v5; // [rsp+0h] [rbp-48h]\n  int v6; // [rsp+4h] [rbp-44h]\n  __int64 v7; // [rsp+8h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-38h]\n  __int64 v9; // [rsp+18h] [rbp-30h]\n  __int64 v10; // [rsp+20h] [rbp-28h]\n  __int64 v11; // [rsp+28h] [rbp-20h]\n  __int64 v12; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5 = a2;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  v12 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)&v5);\n}\n\n_BYTE *__fastcall sub_40F5C0(__int64 a1, int a2, char *a3, unsigned __int64 a4)\n{\n  int v5; // [rsp+0h] [rbp-48h]\n  int v6; // [rsp+4h] [rbp-44h]\n  __int64 v7; // [rsp+8h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-38h]\n  __int64 v9; // [rsp+18h] [rbp-30h]\n  __int64 v10; // [rsp+20h] [rbp-28h]\n  __int64 v11; // [rsp+28h] [rbp-20h]\n  __int64 v12; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v5 = a2;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  v12 = 0LL;\n  return sub_40F030(a1, a3, a4, (__int64)&v5);\n}\n", 
            "funcStartAddr": "0x402f23L", 
            "funcEndAddr": "0x402f28L", 
            "funcName": "sub_40F5C0"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F630(int a1, char *a2)\n{\n  return sub_40F550(0LL, a1, a2);\n}\n", 
            "funcStartAddr": "0x40f630L", 
            "funcEndAddr": "0x40f63cL", 
            "funcName": "sub_40F630"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F650(char *a1, unsigned __int64 a2, unsigned __int8 a3)\n{\n  char v3; // cl\n  int *v4; // r8\n  unsigned __int32 v5; // edx\n  __m128i v7; // [rsp+0h] [rbp-48h]\n  __m128i v8; // [rsp+10h] [rbp-38h]\n  __m128i v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-18h]\n\n  v3 = a3 & 0x1F;\n  v10 = qword_61CD10;\n  v7 = _mm_load_si128((const __m128i *)&xmmword_61CCE0);\n  v8 = _mm_load_si128((const __m128i *)&xmmword_61CCF0);\n  v4 = &v7.m128i_i32[(a3 >> 5) + 2];\n  v9 = _mm_load_si128((const __m128i *)&xmmword_61CD00);\n  v5 = v7.m128i_u32[(a3 >> 5) + 2];\n  *v4 = v5 ^ ((~(unsigned __int8)(v5 >> v3) & 1) << v3);\n  return sub_40F030(0LL, a1, a2, (__int64)&v7);\n}\n", 
            "funcStartAddr": "0x40f650L", 
            "funcEndAddr": "0x40f6c0L", 
            "funcName": "sub_40F650"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F6D0(char *a1)\n{\n  return sub_40F650(a1, 0xFFFFFFFFFFFFFFFFLL, 0x3Au);\n}\n", 
            "funcStartAddr": "0x40f6d0L", 
            "funcEndAddr": "0x40f6e1L", 
            "funcName": "sub_40F6D0"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F700(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v6 = 0x400000000000000LL;\n  v5 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n\n_BYTE *__fastcall sub_40F700(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v6 = 0x400000000000000LL;\n  v5 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n", 
            "funcStartAddr": "0x402f28L", 
            "funcEndAddr": "0x402f2dL", 
            "funcName": "sub_40F700"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F700(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v6 = 0x400000000000000LL;\n  v5 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n\n_BYTE *__fastcall sub_40F700(__int64 a1, int a2, char *a3)\n{\n  int v4; // [rsp+0h] [rbp-48h]\n  int v5; // [rsp+4h] [rbp-44h]\n  __int64 v6; // [rsp+8h] [rbp-40h]\n  __int64 v7; // [rsp+10h] [rbp-38h]\n  __int64 v8; // [rsp+18h] [rbp-30h]\n  __int64 v9; // [rsp+20h] [rbp-28h]\n  __int64 v10; // [rsp+28h] [rbp-20h]\n  __int64 v11; // [rsp+30h] [rbp-18h]\n\n  if ( a2 == 10 )\n    abort();\n  v4 = a2;\n  v6 = 0x400000000000000LL;\n  v5 = 0;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  return sub_40F030(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);\n}\n", 
            "funcStartAddr": "0x402f28L", 
            "funcEndAddr": "0x402f2dL", 
            "funcName": "sub_40F700"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F770(__int64 a1, __int64 a2, __int64 a3, char *a4, unsigned __int64 a5)\n{\n  __m128i v6; // [rsp+0h] [rbp-48h]\n  __m128i v7; // [rsp+10h] [rbp-38h]\n  __m128i v8; // [rsp+20h] [rbp-28h]\n  __int64 v9; // [rsp+30h] [rbp-18h]\n\n  v6 = _mm_load_si128((const __m128i *)&xmmword_61CCE0);\n  v7 = _mm_load_si128((const __m128i *)&xmmword_61CCF0);\n  v8 = _mm_load_si128((const __m128i *)&xmmword_61CD00);\n  v9 = qword_61CD10;\n  v6.m128i_i32[0] = 10;\n  if ( !a2 || !a3 )\n    abort();\n  v8.m128i_i64[1] = a2;\n  v9 = a3;\n  return sub_40F030(a1, a4, a5, (__int64)&v6);\n}\n", 
            "funcStartAddr": "0x40f770L", 
            "funcEndAddr": "0x40f7dcL", 
            "funcName": "sub_40F770"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F860(__int64 a1, char *a2)\n{\n  return sub_40F030(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_61C520);\n}\n", 
            "funcStartAddr": "0x40f860L", 
            "funcEndAddr": "0x40f871L", 
            "funcName": "sub_40F860"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_40F880(char *a1)\n{\n  return sub_40F030(0LL, a1, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_61C520);\n}\n", 
            "funcStartAddr": "0x40f880L", 
            "funcEndAddr": "0x40f896L", 
            "funcName": "sub_40F880"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_40F8A0(char *a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_40F8A0(char *a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n", 
            "funcStartAddr": "0x402f2dL", 
            "funcEndAddr": "0x402f32L", 
            "funcName": "sub_40F8A0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_40F8A0(char *a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_40F8A0(char *a1)\n{\n  _BYTE *v1; // rbp\n  int *v2; // rbx\n  char *v3; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40F880(a1);\n    v2 = __errno_location();\n    if ( *v2 )\n      v3 = dcgettext(0LL, \"%s: read error\", 5);\n    else\n      v3 = dcgettext(0LL, \"%s: end of file\", 5);\n    error(status, *v2, v3, v1);\n  }\n  abort();\n}\n", 
            "funcStartAddr": "0x402f2dL", 
            "funcEndAddr": "0x402f32L", 
            "funcName": "sub_40F8A0"
        }, 
        {
            "decompiledFuncCode": "__m128i *__fastcall sub_40F900(__int64 a1, unsigned __int64 a2)\n{\n  FILE *v2; // r13\n  __int64 v3; // rax\n  size_t v4; // rcx\n  __m128i *v5; // rbx\n  __m128i *v7; // rax\n  __int64 v8; // r13\n  int v9; // eax\n  int v10; // er15\n  __int64 v11; // rdx\n  __int64 v12; // rbp\n  unsigned __int64 v13; // r14\n  __int64 v14; // rbp\n  unsigned int v15; // eax\n  __int64 v16; // rdx\n  unsigned __int64 v17; // rbp\n  __int64 v18; // r14\n  unsigned int v19; // eax\n  __int64 v20; // rdx\n  unsigned __int64 v21; // rbp\n  int v22; // eax\n  unsigned int v23; // edi\n  unsigned int v24; // eax\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  struct timeval *v27; // r15\n  __int64 v28; // rbp\n  __int64 v29; // r14\n  unsigned __int64 v30; // rcx\n  unsigned int v31; // [rsp+8h] [rbp-50h]\n  struct timeval tv; // [rsp+10h] [rbp-48h]\n\n  if ( !a2 )\n  {\n    v5 = (__m128i *)sub_411210(4152LL);\n    v5->m128i_i64[0] = 0LL;\n    v5->m128i_i64[1] = (__int64)sub_40F8A0;\n    v5[1].m128i_i64[0] = 0LL;\n    return v5;\n  }\n  if ( !a1 )\n  {\n    v7 = (__m128i *)sub_411210(4152LL);\n    v7->m128i_i64[0] = 0LL;\n    v5 = v7;\n    v8 = (__int64)v7[2].m128i_i64;\n    v7->m128i_i64[1] = (__int64)sub_40F8A0;\n    v7[1].m128i_i64[0] = 0LL;\n    v7[1].m128i_i64[1] = 0LL;\n    v9 = open(\"/dev/urandom\", 0);\n    v10 = v9;\n    if ( v9 < 0 )\n    {\n      v13 = 20LL;\n      gettimeofday(&tv, 0LL);\n      v5[2] = _mm_load_si128((const __m128i *)&tv);\n      LODWORD(tv.tv_sec) = getpid();\n      v5[3].m128i_i32[0] = tv.tv_sec;\n    }\n    else\n    {\n      v11 = a2;\n      if ( a2 > 0x800 )\n        v11 = 2048LL;\n      v12 = __read_chk((unsigned int)v9, v8, v11, 4120LL);\n      close(v10);\n      if ( v12 > 2047 )\n        goto LABEL_12;\n      if ( v12 < 0 )\n        v12 = 0LL;\n      v26 = 2048 - v12;\n      v27 = (struct timeval *)(v8 + v12);\n      if ( (unsigned __int64)(2048 - v12) > 0x10 )\n        v26 = 16LL;\n      v28 = v26 + v12;\n      v31 = v26;\n      gettimeofday(&tv, 0LL);\n      qmemcpy(v27, &tv, v31);\n      if ( v28 > 2047 )\n        goto LABEL_12;\n      v29 = 2048 - v28;\n      if ( (unsigned __int64)(2048 - v28) > 4 )\n        v29 = 4LL;\n      LODWORD(tv.tv_sec) = getpid();\n      v30 = (unsigned int)v29;\n      v13 = v28 + v29;\n      qmemcpy((void *)(v8 + v28), &tv, v30);\n      if ( v13 > 0x7FF )\n        goto LABEL_12;\n    }\n    v14 = 2048 - v13;\n    if ( 2048 - v13 > 4 )\n      v14 = 4LL;\n    LODWORD(tv.tv_sec) = getppid();\n    if ( (_DWORD)v14 )\n    {\n      v15 = 0;\n      do\n      {\n        v16 = v15++;\n        *(_BYTE *)(v8 + v13 + v16) = *((_BYTE *)&tv.tv_sec + v16);\n      }\n      while ( v15 < (unsigned int)v14 );\n    }\n    v17 = v13 + v14;\n    if ( v17 <= 0x7FF )\n    {\n      v18 = 2048 - v17;\n      if ( 2048 - v17 > 4 )\n        v18 = 4LL;\n      LODWORD(tv.tv_sec) = getuid();\n      if ( (_DWORD)v18 )\n      {\n        v19 = 0;\n        do\n        {\n          v20 = v19++;\n          *(_BYTE *)(v8 + v17 + v20) = *((_BYTE *)&tv.tv_sec + v20);\n        }\n        while ( v19 < (unsigned int)v18 );\n      }\n      v21 = v18 + v17;\n      if ( v21 <= 0x7FF )\n      {\n        LODWORD(tv.tv_sec) = getgid();\n        v22 = 2048 - v21;\n        if ( 2048 - v21 > 4 )\n          v22 = 4;\n        v23 = v22;\n        if ( v22 )\n        {\n          v24 = 0;\n          do\n          {\n            v25 = v24++;\n            *(_BYTE *)(v8 + v21 + v25) = *((_BYTE *)&tv.tv_sec + v25);\n          }\n          while ( v24 < v23 );\n        }\n      }\n    }\nLABEL_12:\n    sub_410070(v8);\n    return v5;\n  }\n  v2 = (FILE *)sub_4136B0(a1, \"rb\");\n  if ( !v2 )\n    return 0LL;\n  v3 = sub_411210(4152LL);\n  v4 = 4096LL;\n  *(_QWORD *)v3 = v2;\n  if ( a2 <= 0x1000 )\n    v4 = a2;\n  *(_QWORD *)(v3 + 8) = sub_40F8A0;\n  v5 = (__m128i *)v3;\n  *(_QWORD *)(v3 + 16) = a1;\n  setvbuf(v2, (char *)(v3 + 24), 0, v4);\n  return v5;\n}\n", 
            "funcStartAddr": "0x40f900L", 
            "funcEndAddr": "0x40fbefL", 
            "funcName": "sub_40F900"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40FC10(__int64 a1, char *a2, size_t a3)\n{\n  __int64 v3; // r12\n  char *v4; // rbp\n  size_t v5; // rbx\n  FILE *v6; // r13\n  int *v7; // r14\n  __int64 v8; // rdi\n  int v9; // edx\n  __int64 result; // rax\n  size_t v11; // r15\n  char *v12; // r13\n  __int64 v13; // r14\n  void *v14; // rdi\n  char *v15; // rsi\n\n  v3 = a1;\n  v4 = a2;\n  v5 = a3;\n  v6 = *(FILE **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    v7 = __errno_location();\n    while ( 1 )\n    {\n      result = fread_unlocked(v4, 1uLL, v5, v6);\n      v9 = *v7;\n      v4 += result;\n      v5 -= result;\n      if ( !v5 )\n        break;\n      v8 = *(_QWORD *)(v3 + 16);\n      if ( !(**(_BYTE **)v3 & 0x20) )\n        v9 = 0;\n      *v7 = v9;\n      (*(void (__fastcall **)(__int64))(v3 + 8))(v8);\n      v6 = *(FILE **)v3;\n    }\n  }\n  else\n  {\n    v11 = *(_QWORD *)(a1 + 24);\n    v12 = (char *)(a1 + 2104);\n    v13 = a1 + 32;\n    if ( a3 <= v11 )\n    {\n      v12 = &v12[-v11 + 2048];\nLABEL_16:\n      result = (__int64)memcpy(v4, v12, v5);\n      *(_QWORD *)(v3 + 24) = v11 - v5;\n    }\n    else\n    {\n      while ( 1 )\n      {\n        v14 = v4;\n        v4 += v11;\n        v5 -= v11;\n        memcpy(v14, &v12[2048 - v11], v11);\n        if ( !((unsigned __int8)v4 & 7) )\n          break;\n        v11 = 2048LL;\n        sub_40FDC0(v13, v12);\n        if ( v5 <= 0x800 )\n        {\nLABEL_15:\n          v11 = 2048LL;\n          goto LABEL_16;\n        }\n      }\n      do\n      {\n        if ( v5 <= 0x7FF )\n        {\n          sub_40FDC0(v13, v12);\n          goto LABEL_15;\n        }\n        v15 = v4;\n        v4 += 2048;\n        result = sub_40FDC0(v13, v15);\n        v5 -= 2048LL;\n      }\n      while ( v5 );\n      *(_QWORD *)(v3 + 24) = 0LL;\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x40fc10L", 
            "funcEndAddr": "0x40fd6cL", 
            "funcName": "sub_40FC10"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_40FD70(void *ptr)\n{\n  FILE *v1; // rbp\n  __int64 result; // rax\n\n  v1 = *(FILE **)ptr;\n  __explicit_bzero_chk(ptr, 4152LL, -1LL);\n  free(ptr);\n  if ( v1 )\n    result = sub_411F80(v1);\n  else\n    result = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x40fd70L", 
            "funcEndAddr": "0x40fdb9L", 
            "funcName": "sub_40FD70"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 *__fastcall sub_40FDC0(unsigned __int64 *a1, __int64 *a2)\n{\n  unsigned __int64 v2; // r11\n  unsigned __int64 v3; // rdx\n  __int64 *v4; // r9\n  __int64 v5; // r8\n  unsigned __int64 *result; // rax\n  __int64 v7; // r11\n  unsigned __int64 v8; // rcx\n  unsigned __int64 v9; // rdx\n  unsigned __int64 v10; // r8\n  __int64 v11; // rbx\n  unsigned __int64 v12; // r8\n  unsigned __int64 v13; // r11\n  __int64 v14; // rdx\n  unsigned __int64 v15; // rcx\n  __int64 v16; // rbx\n  unsigned __int64 v17; // rcx\n  unsigned __int64 v18; // rdx\n  unsigned __int64 v19; // r8\n  __int64 v20; // rcx\n  unsigned __int64 v21; // r8\n  unsigned __int64 v22; // rcx\n  __int64 *v23; // rsi\n  unsigned __int64 v24; // rcx\n  unsigned __int64 v25; // rdx\n  __int64 v26; // rbx\n  __int64 v27; // rcx\n  unsigned __int64 v28; // r8\n  unsigned __int64 v29; // r10\n  __int64 v30; // rdx\n  unsigned __int64 v31; // rcx\n  __int64 v32; // r11\n  unsigned __int64 v33; // rcx\n  unsigned __int64 v34; // rdx\n  unsigned __int64 v35; // r8\n  __int64 v36; // rcx\n  unsigned __int64 v37; // r8\n  unsigned __int64 v38; // rcx\n\n  v2 = a1[257];\n  v3 = a1[256];\n  v4 = a2;\n  v5 = a1[258] + 1;\n  result = a1;\n  a1[258] = v5;\n  v7 = v5 + v2;\n  do\n  {\n    v8 = *result;\n    v9 = result[128] + ~((v3 << 21) ^ v3);\n    v10 = v7 + v9 + *(unsigned __int64 *)((char *)a1 + (*result & 0x7F8));\n    *result = v10;\n    v11 = v8 + *(unsigned __int64 *)((char *)a1 + ((v10 >> 8) & 0x7F8));\n    *v4 = v11;\n    v12 = result[1];\n    v13 = result[129] + ((v9 >> 5) ^ v9);\n    v14 = v13 ^ (v13 << 12);\n    v15 = v11 + v13 + *(unsigned __int64 *)((char *)a1 + (result[1] & 0x7F8));\n    result[1] = v15;\n    v16 = v12 + *(unsigned __int64 *)((char *)a1 + ((v15 >> 8) & 0x7F8));\n    v4[1] = v16;\n    v17 = result[2];\n    v18 = result[130] + v14;\n    v19 = v16 + v18 + *(unsigned __int64 *)((char *)a1 + (result[2] & 0x7F8));\n    result[2] = v19;\n    v20 = *(unsigned __int64 *)((char *)a1 + ((v19 >> 8) & 0x7F8)) + v17;\n    v4[2] = v20;\n    v21 = result[3];\n    v3 = result[131] + ((v18 >> 33) ^ v18);\n    v22 = v20 + v3 + *(unsigned __int64 *)((char *)a1 + (result[3] & 0x7F8));\n    result += 4;\n    v4 += 4;\n    *(result - 1) = v22;\n    v7 = v21 + *(unsigned __int64 *)((char *)a1 + ((v22 >> 8) & 0x7F8));\n    *(v4 - 1) = v7;\n  }\n  while ( result != a1 + 128 );\n  v23 = a2 + 128;\n  do\n  {\n    v24 = *result;\n    v25 = *(result - 128) + ~((v3 << 21) ^ v3);\n    v26 = v25 + *(unsigned __int64 *)((char *)a1 + (*result & 0x7F8));\n    *result = v7 + v26;\n    v27 = *(unsigned __int64 *)((char *)a1 + (((unsigned __int64)(v7 + v26) >> 8) & 0x7F8)) + v24;\n    *v23 = v27;\n    v28 = result[1];\n    v29 = *(result - 127) + ((v25 >> 5) ^ v25);\n    v30 = v29 ^ (v29 << 12);\n    v31 = v27 + v29 + *(unsigned __int64 *)((char *)a1 + (result[1] & 0x7F8));\n    result[1] = v31;\n    v32 = v28 + *(unsigned __int64 *)((char *)a1 + ((v31 >> 8) & 0x7F8));\n    v23[1] = v32;\n    v33 = result[2];\n    v34 = *(result - 126) + v30;\n    v35 = v32 + v34 + *(unsigned __int64 *)((char *)a1 + (result[2] & 0x7F8));\n    result[2] = v35;\n    v36 = *(unsigned __int64 *)((char *)a1 + ((v35 >> 8) & 0x7F8)) + v33;\n    v23[2] = v36;\n    v37 = result[3];\n    v3 = *(result - 125) + ((v34 >> 33) ^ v34);\n    v38 = v36 + v3 + *(unsigned __int64 *)((char *)a1 + (result[3] & 0x7F8));\n    result += 4;\n    v23 += 4;\n    *(result - 1) = v38;\n    v7 = v37 + *(unsigned __int64 *)((char *)a1 + ((v38 >> 8) & 0x7F8));\n    *(v23 - 1) = v7;\n  }\n  while ( result != a1 + 256 );\n  a1[256] = v3;\n  a1[257] = v7;\n  return result;\n}\n", 
            "funcStartAddr": "0x40fdc0L", 
            "funcEndAddr": "0x410065L", 
            "funcName": "sub_40FDC0"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_410070(_QWORD *a1)\n{\n  _QWORD *v1; // rdx\n  __int64 *v2; // rax\n  __int64 v3; // rcx\n  __int64 v4; // rsi\n  __int64 v5; // r11\n  __int64 v6; // r12\n  __int64 v7; // r10\n  __int64 v8; // r9\n  __int64 v9; // rbp\n  __int64 v10; // r8\n  __int64 v11; // rbx\n  __int64 v12; // rsi\n  unsigned __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // rbx\n  unsigned __int64 v16; // r9\n  __int64 v17; // r12\n  __int64 v18; // r10\n  unsigned __int64 v19; // rcx\n  unsigned __int64 v20; // r11\n  __int64 v21; // rsi\n  unsigned __int64 v22; // rbx\n  unsigned __int64 v23; // r13\n  __int64 v24; // r12\n  unsigned __int64 v25; // rcx\n  __int64 v26; // rsi\n  __int64 v27; // r8\n  __int64 v28; // rbx\n  unsigned __int64 v29; // r9\n  __int64 v30; // r12\n  __int64 v31; // r10\n  unsigned __int64 v32; // rcx\n  unsigned __int64 v33; // r11\n  __int64 v34; // rsi\n  unsigned __int64 v35; // rbx\n  unsigned __int64 result; // rax\n  __int64 v37; // r12\n\n  v1 = a1;\n  v2 = a1;\n  v3 = -7424904924229222229LL;\n  v4 = -9011610652101975858LL;\n  v5 = -5576812576440232668LL;\n  v6 = -5865837416287532563LL;\n  v7 = -8354558816804203872LL;\n  v8 = -5046086420515862430LL;\n  v9 = (__int64)(a1 + 256);\n  v10 = 7240739780546808700LL;\n  v11 = 5259722845879046933LL;\n  do\n  {\n    v12 = v2[4] + v4;\n    v13 = v2[7] + v3;\n    v14 = *v2 - v12 + v10;\n    v15 = (v13 >> 9) ^ (v2[5] + v11);\n    v16 = v2[1] - v15 + v8;\n    v17 = (v14 << 9) ^ (v2[6] + v6);\n    v18 = v2[2] - v17 + v7;\n    v19 = (v16 >> 23) ^ (v14 + v13);\n    v20 = v2[3] - v19 + v5;\n    v10 = (v18 << 15) ^ (v16 + v14);\n    v21 = v12 - v10;\n    *v2 = v10;\n    v8 = (v20 >> 14) ^ (v18 + v16);\n    v22 = v15 - v8;\n    v2[1] = v8;\n    v7 = (v21 << 20) ^ (v20 + v18);\n    v23 = v21 + v22;\n    v24 = v17 - v7;\n    v2[2] = v7;\n    v2 += 8;\n    v5 = (v22 >> 17) ^ (v21 + v20);\n    v11 = v24 + v22;\n    v3 = v19 - v5;\n    *(v2 - 5) = v5;\n    v4 = v23 ^ (v24 << 14);\n    v6 = v3 + v24;\n    *(v2 - 3) = v11;\n    *(v2 - 4) = v4;\n    *(v2 - 2) = v6;\n    *(v2 - 1) = v3;\n  }\n  while ( (__int64 *)v9 != v2 );\n  do\n  {\n    v25 = v1[7] + v3;\n    v26 = v1[4] + v4;\n    v27 = *v1 + v10 - v26;\n    v28 = (v25 >> 9) ^ (v1[5] + v11);\n    v29 = v1[1] + v8 - v28;\n    v30 = (v27 << 9) ^ (v1[6] + v6);\n    v31 = v1[2] + v7 - v30;\n    v32 = (v29 >> 23) ^ (v27 + v25);\n    v33 = v1[3] + v5 - v32;\n    v10 = (v31 << 15) ^ (v29 + v27);\n    v34 = v26 - v10;\n    *v1 = v10;\n    v8 = (v33 >> 14) ^ (v31 + v29);\n    v35 = v28 - v8;\n    v1[1] = v8;\n    v7 = (v34 << 20) ^ (v33 + v31);\n    result = v34 + v35;\n    v37 = v30 - v7;\n    v1[2] = v7;\n    v1 += 8;\n    v5 = (v35 >> 17) ^ (v34 + v33);\n    v11 = v37 + v35;\n    v3 = v32 - v5;\n    *(v1 - 5) = v5;\n    v4 = result ^ (v37 << 14);\n    v6 = v3 + v37;\n    *(v1 - 3) = v11;\n    *(v1 - 4) = v4;\n    *(v1 - 2) = v6;\n    *(v1 - 1) = v3;\n  }\n  while ( (_QWORD *)v9 != v1 );\n  a1[258] = 0LL;\n  a1[257] = 0LL;\n  a1[256] = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x410070L", 
            "funcEndAddr": "0x4102a4L", 
            "funcName": "sub_410070"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_4102B0(__int64 a1)\n{\n  __int64 v1; // rdx\n  _QWORD *v2; // rbx\n  __int64 v3; // r12\n  __int64 v4; // rbp\n  __int64 v5; // rcx\n  __int64 v6; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __int64 v9; // rcx\n  __int64 v10; // rdi\n  _QWORD *v11; // rdx\n  __int64 *v12; // rdx\n  __int64 v13; // rax\n  unsigned __int64 result; // rax\n\n  v1 = *(_QWORD *)(a1 + 48);\n  v2 = (_QWORD *)a1;\n  v3 = *(_QWORD *)(a1 + 40);\n  v4 = *(_QWORD *)(a1 + 48) - v3 - 1;\n  if ( v1 == v3 )\n    *(_BYTE *)(a1 + 104) |= 2u;\n  v5 = *(_QWORD *)(a1 + 72);\n  v6 = v1 + v5;\n  v7 = *(_QWORD *)(a1 + 56);\n  v8 = ~v5 & v6;\n  v9 = *(_QWORD *)(a1 + 32);\n  v10 = *(_QWORD *)(a1 + 56);\n  v2[6] = v8;\n  if ( v8 - v9 > (unsigned __int64)(v10 - v9) )\n  {\n    v2[6] = v7;\n    v8 = v7;\n  }\n  v2[5] = v8;\n  v11 = (_QWORD *)v2[17];\n  if ( v2[18] - (_QWORD)v11 <= 7uLL )\n  {\n    obstack_newchunk(v2 + 14, 8LL);\n    v11 = (_QWORD *)v2[17];\n  }\n  *v11 = v3;\n  v12 = (__int64 *)v2[28];\n  v13 = v2[29];\n  v2[17] += 8LL;\n  result = v13 - (_QWORD)v12;\n  if ( result <= 7 )\n  {\n    result = obstack_newchunk(v2 + 25, 8LL);\n    v12 = (__int64 *)v2[28];\n  }\n  *v12 = v4;\n  v2[28] += 8LL;\n  ++*v2;\n  return result;\n}\n", 
            "funcStartAddr": "0x4102b0L", 
            "funcEndAddr": "0x410399L", 
            "funcName": "sub_4102B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4103A0(_QWORD *a1)\n{\n  _QWORD *v1; // rbx\n  __int64 v2; // rdi\n\n  v1 = a1;\n  *a1 = 0LL;\n  v2 = (__int64)(a1 + 3);\n  *(_QWORD *)(v2 - 16) = 0LL;\n  *(_QWORD *)(v2 - 8) = 0LL;\n  obstack_begin(v2, 0LL, 0LL, malloc, free);\n  obstack_begin(v1 + 14, 0LL, 0LL, malloc, free);\n  return obstack_begin(v1 + 25, 0LL, 0LL, malloc, free);\n}\n", 
            "funcStartAddr": "0x4103a0L", 
            "funcEndAddr": "0x410407L", 
            "funcName": "sub_4103A0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_410410(__int64 a1)\n{\n  obstack_free((struct obstack *)(a1 + 24), 0LL);\n  obstack_free((struct obstack *)(a1 + 112), 0LL);\n  obstack_free((struct obstack *)(a1 + 200), 0LL);\n}\n", 
            "funcStartAddr": "0x410410L", 
            "funcEndAddr": "0x410439L", 
            "funcName": "sub_410410"
        }, 
        {
            "decompiledFuncCode": "bool __fastcall sub_410440(FILE *stream, _QWORD *a2)\n{\n  _QWORD *v2; // rbx\n  int i; // eax\n  _BYTE *v4; // rdx\n  _BYTE *v5; // rdx\n  _BYTE *v6; // rax\n  _QWORD *v7; // rdx\n  __int64 v8; // rsi\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  __int64 v14; // rcx\n  __int64 v15; // rdx\n  __int64 v16; // rsi\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rax\n  __int64 v21; // rcx\n  int v23; // [rsp+Ch] [rbp-1Ch]\n\n  v2 = a2;\nLABEL_3:\n  for ( i = fgetc(stream); i != -1; i = fgetc(stream) )\n  {\n    v4 = (_BYTE *)a2[6];\n    if ( (_BYTE *)a2[7] == v4 )\n    {\n      v23 = i;\n      obstack_newchunk(a2 + 3, 1LL);\n      v5 = (_BYTE *)a2[6];\n      a2[6] = v5 + 1;\n      *v5 = v23;\n      if ( v23 )\n        goto LABEL_3;\n    }\n    else\n    {\n      a2[6] = v4 + 1;\n      *v4 = i;\n      if ( i )\n        goto LABEL_3;\n    }\n    sub_4102B0((__int64)a2);\n  }\n  v6 = (_BYTE *)a2[6];\n  if ( v6 != (_BYTE *)a2[5] )\n  {\n    if ( v6 == (_BYTE *)a2[7] )\n    {\n      obstack_newchunk(a2 + 3, 1LL);\n      v6 = (_BYTE *)a2[6];\n    }\n    a2[6] = v6 + 1;\n    *v6 = 0;\n    sub_4102B0((__int64)a2);\n  }\n  v7 = (_QWORD *)a2[17];\n  if ( a2[18] - (_QWORD)v7 <= 7uLL )\n  {\n    obstack_newchunk(a2 + 14, 8LL);\n    v7 = (_QWORD *)a2[17];\n  }\n  *v7 = 0LL;\n  v8 = a2[16];\n  v9 = v2[17] + 8LL;\n  v2[17] = v9;\n  if ( v9 == v8 )\n    *((_BYTE *)v2 + 192) |= 2u;\n  v10 = v2[20];\n  v11 = v9 + v10;\n  v12 = v2[15];\n  v13 = ~v10 & v11;\n  v14 = v2[18];\n  v2[17] = v13;\n  if ( v13 - v12 > (unsigned __int64)(v14 - v12) )\n  {\n    v2[17] = v14;\n    v13 = v14;\n  }\n  v2[1] = v8;\n  v15 = v2[28];\n  v16 = v2[27];\n  v2[16] = v13;\n  if ( v15 == v16 )\n    *((_BYTE *)v2 + 280) |= 2u;\n  v17 = v2[31];\n  v18 = v15 + v17;\n  v19 = v2[26];\n  v20 = ~v17 & v18;\n  v21 = v2[29];\n  v2[28] = v20;\n  if ( v20 - v19 > (unsigned __int64)(v21 - v19) )\n  {\n    v2[28] = v21;\n    v20 = v21;\n  }\n  v2[27] = v20;\n  v2[2] = v16;\n  return ferror(stream) == 0;\n}\n", 
            "funcStartAddr": "0x410440L", 
            "funcEndAddr": "0x410653L", 
            "funcName": "sub_410440"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n", 
            "funcStartAddr": "0x410c40L", 
            "funcEndAddr": "0x410c6eL", 
            "funcName": "sub_410660"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n", 
            "funcStartAddr": "0x410c40L", 
            "funcEndAddr": "0x410c6eL", 
            "funcName": "sub_410660"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n\n__int64 __fastcall sub_410660(char *a1)\n{\n  unsigned int v1; // ebx\n  __int64 result; // rax\n  unsigned int v3; // er12\n  int *v4; // rax\n  int v5; // er13\n  int *v6; // rbp\n\n  v1 = mkstemp(a1);\n  if ( v1 > 2 )\n    return v1;\n  v3 = sub_413EA0();\n  v4 = __errno_location();\n  v5 = *v4;\n  v6 = v4;\n  close(v1);\n  result = v3;\n  *v6 = v5;\n  return result;\n}\n", 
            "funcStartAddr": "0x410c40L", 
            "funcEndAddr": "0x410c6eL", 
            "funcName": "sub_410660"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n", 
            "funcStartAddr": "0x413660L", 
            "funcEndAddr": "0x41368eL", 
            "funcName": "sub_410680"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n", 
            "funcStartAddr": "0x413660L", 
            "funcEndAddr": "0x41368eL", 
            "funcName": "sub_410680"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n\n__int64 __fastcall sub_410680(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdi\n  __int64 result; // rax\n  unsigned int v4; // er12\n  int *v5; // rax\n  int v6; // er13\n  int *v7; // rbp\n\n  v2 = (unsigned int)mkostemp(a1, a2);\n  if ( (unsigned int)v2 > 2 )\n    return (unsigned int)v2;\n  v4 = sub_413690(v2, a2);\n  v5 = __errno_location();\n  v6 = *v5;\n  v7 = v5;\n  close(v2);\n  result = v4;\n  *v7 = v6;\n  return result;\n}\n", 
            "funcStartAddr": "0x413660L", 
            "funcEndAddr": "0x41368eL", 
            "funcName": "sub_410680"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4106A0(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)\n{\n  unsigned __int8 v4; // r9\n  unsigned __int8 v5; // r8\n  int v6; // eax\n  unsigned int v7; // esi\n  __int64 result; // rax\n  unsigned __int8 v9; // al\n  int v10; // er9\n  int v11; // er10\n  int v12; // eax\n  int v13; // er10\n  unsigned __int8 v14; // r8\n  int v15; // er10\n  unsigned __int8 *v16; // rsi\n  int v17; // eax\n  unsigned int v18; // er8\n  unsigned int v19; // er10\n  unsigned __int64 v20; // r8\n  int v21; // edx\n  unsigned __int64 v22; // rdi\n  int v23; // edx\n  unsigned int v24; // er8\n  int v25; // eax\n  unsigned int v26; // er10\n  unsigned __int64 v27; // r8\n  int v28; // edx\n  int v29; // edx\n  unsigned __int8 v30; // r8\n  signed __int8 *v31; // rax\n  signed __int8 i; // dl\n  int v33; // eax\n  unsigned __int8 v34; // cl\n  int v35; // ecx\n  unsigned int v36; // er8\n  unsigned int v37; // er10\n  int v38; // eax\n  int v39; // ecx\n  unsigned int v40; // er8\n  unsigned int v41; // edx\n\n  v4 = *a1;\n  v5 = *a2;\n  if ( *a1 != 45 )\n  {\n    if ( v5 == 45 )\n    {\n      do\n      {\n        do\n          v6 = *++a2;\n        while ( (_BYTE)v6 == 48 );\n      }\n      while ( a4 == v6 );\n      if ( a3 == v6 )\n      {\n        do\n        {\n          v16 = a2 + 1;\n          v6 = *v16;\n          if ( (_BYTE)v6 != 48 )\n            break;\n          a2 = v16 + 1;\n          v6 = *a2;\n        }\n        while ( (_BYTE)v6 == 48 );\n      }\n      v7 = v6 - 48;\n      result = 1LL;\n      if ( v7 <= 9 )\n        return result;\n      while ( 1 )\n      {\n        if ( v4 != 48 )\n        {\n          v17 = v4;\n          if ( a4 != v4 )\n            break;\n        }\n        v4 = *++a1;\n      }\n      if ( a3 == v4 )\n      {\n        do\n          ++a1;\n        while ( *a1 == 48 );\n        v17 = *a1;\n      }\n      return (unsigned int)(v17 - 48) <= 9;\n    }\n    while ( 1 )\n    {\n      if ( v4 != 48 )\n      {\n        v12 = v4;\n        if ( a4 != v4 )\n          break;\n      }\n      v4 = *++a1;\n    }\n    if ( v5 != 48 )\n      goto LABEL_24;\n    do\n    {\n      do\n        v5 = *++a2;\n      while ( *a2 == 48 );\nLABEL_24:\n      v13 = v5;\n    }\n    while ( a4 == v5 );\n    while ( v4 == v5 && (unsigned int)(v13 - 48) <= 9 )\n    {\n      do\n      {\n        v12 = *++a1;\n        v4 = *a1;\n      }\n      while ( a4 == v12 );\n      do\n      {\n        v13 = *++a2;\n        v5 = *a2;\n        if ( a4 != v13 )\n          break;\n        v13 = *++a2;\n        v5 = *a2;\n      }\n      while ( a4 == v13 );\n    }\n    if ( a3 == v12 && (unsigned int)(v13 - 48) > 9 )\n    {\nLABEL_80:\n      v30 = *a2;\n      if ( (_BYTE)a3 != *a1 )\n      {\n        result = 0LL;\n        if ( (_BYTE)a3 != v30 )\n          return result;\n        v31 = (signed __int8 *)(a2 + 1);\nLABEL_84:\n        for ( i = a2[1]; i == 48; i = *v31 )\n          ++v31;\n        v33 = i;\n        return (unsigned int)-((unsigned int)(v33 - 48) <= 9);\n      }\n      v35 = (char)a1[1];\n      if ( (_BYTE)a3 == v30 )\n      {\n        while ( 1 )\n        {\n          i = *++a2;\n          ++a1;\n          v36 = (char)v35 - 48;\n          if ( *a2 != (_BYTE)v35 )\n            break;\n          if ( v36 > 9 )\n            return 0LL;\n          v35 = (char)a1[1];\n        }\n        v37 = i - 48;\n        if ( v36 > 9 )\n        {\n          result = 0LL;\n          if ( v37 > 9 )\n            return result;\n          v31 = (signed __int8 *)a2;\n          goto LABEL_84;\n        }\n        if ( v37 <= 9 )\n          return (unsigned int)((char)v35 - i);\n      }\n      else\n      {\n        ++a1;\n      }\n      while ( (_BYTE)v35 == 48 )\n        v35 = (char)*++a1;\n      return (unsigned int)(v35 - 48) <= 9;\n    }\n    v18 = v12 - 48;\n    if ( a3 == v13 )\n    {\n      if ( v18 > 9 )\n        goto LABEL_80;\n      result = (unsigned int)(v12 - a3);\n      v19 = a3 - 48;\n      goto LABEL_54;\n    }\n    result = (unsigned int)(v12 - v13);\n    v19 = v13 - 48;\n    if ( v18 <= 9 )\n    {\nLABEL_54:\n      v20 = 0LL;\n      do\n      {\n        do\n          v21 = *++a1;\n        while ( a4 == v21 );\n        ++v20;\n      }\n      while ( (unsigned int)(v21 - 48) <= 9 );\n      if ( v19 > 9 )\n        return v20 != 0;\n      goto LABEL_58;\n    }\n    v20 = 0LL;\n    if ( v19 <= 9 )\n    {\nLABEL_58:\n      v22 = 0LL;\n      do\n      {\n        do\n          v23 = *++a2;\n        while ( a4 == v23 );\n        ++v22;\n      }\n      while ( (unsigned int)(v23 - 48) <= 9 );\n      if ( v22 != v20 )\n        return v20 < v22 ? -1 : 1;\nLABEL_74:\n      if ( !v22 )\n        result = 0LL;\n      return result;\n    }\n    return 0LL;\n  }\n  do\n  {\n    do\n      v9 = *++a1;\n    while ( *a1 == 48 );\n    v10 = v9;\n  }\n  while ( a4 == v9 );\n  if ( v5 != 45 )\n  {\n    if ( a3 == v9 )\n    {\n      do\n        ++a1;\n      while ( *a1 == 48 );\n      v10 = *a1;\n    }\n    if ( (unsigned int)(v10 - 48) <= 9 )\n      return 0xFFFFFFFFLL;\n    while ( 1 )\n    {\n      if ( v5 != 48 )\n      {\n        v11 = v5;\n        if ( a4 != v5 )\n          break;\n      }\n      v5 = *++a2;\n    }\n    if ( a3 == v5 )\n    {\n      do\n        ++a2;\n      while ( *a2 == 48 );\n      v11 = *a2;\n    }\n    return (unsigned int)-((unsigned int)(v11 - 48) <= 9);\n  }\n  do\n  {\n    do\n      v14 = *++a2;\n    while ( *a2 == 48 );\n    v15 = v14;\n  }\n  while ( a4 == v14 );\n  while ( v9 == v14 && (unsigned int)(v15 - 48) <= 9 )\n  {\n    do\n    {\n      v10 = *++a1;\n      v9 = *a1;\n    }\n    while ( a4 == v10 );\n    do\n    {\n      v15 = *++a2;\n      v14 = *a2;\n      if ( a4 != v15 )\n        break;\n      v15 = *++a2;\n      v14 = *a2;\n    }\n    while ( a4 == v15 );\n  }\n  if ( a3 != v10 || (unsigned int)(v15 - 48) <= 9 )\n  {\n    v24 = v10 - 48;\n    if ( a3 == v15 )\n    {\n      if ( v24 > 9 )\n        goto LABEL_93;\n      v26 = a3 - 48;\n      result = (unsigned int)(a3 - v10);\n    }\n    else\n    {\n      v25 = v15;\n      v26 = v15 - 48;\n      result = (unsigned int)(v25 - v10);\n      if ( v24 > 9 )\n      {\n        v27 = 0LL;\n        if ( v26 > 9 )\n          return 0LL;\nLABEL_70:\n        v22 = 0LL;\n        do\n        {\n          do\n            v29 = *++a2;\n          while ( a4 == v29 );\n          ++v22;\n        }\n        while ( (unsigned int)(v29 - 48) <= 9 );\n        if ( v22 != v27 )\n          return v27 < v22 ? 1 : -1;\n        goto LABEL_74;\n      }\n    }\n    v27 = 0LL;\n    do\n    {\n      do\n        v28 = *++a1;\n      while ( a4 == v28 );\n      ++v27;\n    }\n    while ( (unsigned int)(v28 - 48) <= 9 );\n    if ( v26 > 9 )\n      return (unsigned int)-(v27 != 0);\n    goto LABEL_70;\n  }\nLABEL_93:\n  v34 = *a1;\n  if ( (_BYTE)a3 != *a2 )\n  {\n    result = 0LL;\n    if ( (_BYTE)a3 != v34 )\n      return result;\n    do\n    {\n      ++a1;\nLABEL_96:\n      v33 = (char)*a1;\n    }\n    while ( *a1 == 48 );\n    return (unsigned int)-((unsigned int)(v33 - 48) <= 9);\n  }\n  if ( (_BYTE)a3 != v34 )\n  {\n    do\n    {\n      ++a2;\nLABEL_117:\n      v17 = (char)*a2;\n    }\n    while ( *a2 == 48 );\n    return (unsigned int)(v17 - 48) <= 9;\n  }\n  while ( 1 )\n  {\n    ++a2;\n    ++a1;\n    v38 = (char)*a2;\n    v39 = (char)*a1;\n    v40 = v38 - 48;\n    if ( *a2 != *a1 )\n      break;\n    if ( v40 > 9 )\n      return 0LL;\n  }\n  v41 = v39 - 48;\n  if ( v40 > 9 )\n  {\n    result = 0LL;\n    if ( v41 <= 9 )\n      goto LABEL_96;\n  }\n  else\n  {\n    if ( v41 > 9 )\n      goto LABEL_117;\n    result = (unsigned int)(v38 - v39);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4106a0L", 
            "funcEndAddr": "0x410c1eL", 
            "funcName": "sub_4106A0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410C70(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)\n{\n  __int64 v6; // r12\n  __int64 *v7; // rbx\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  char *v11; // rax\n  __int64 result; // rax\n  const char *v13; // rsi\n  __int64 v14; // rbx\n  char *v15; // rax\n  __int64 v16; // rbx\n  char *v17; // rax\n  __int64 v18; // rbx\n  char *v19; // rax\n  __int64 v20; // r14\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // rbx\n  char *v24; // rax\n\n  v6 = a6;\n  v7 = a5;\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( v6 )\n  {\n    case 0LL:\n      abort();\n      return result;\n    case 1LL:\n      v14 = *v7;\n      v15 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v15, v14);\n    case 2LL:\n      v16 = *v7;\n      v17 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16);\n    case 3LL:\n      v18 = *v7;\n      v19 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v19, v18);\n    case 4LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v22, v21);\n      return v20;\n    case 6LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 7LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 8LL:\n      v10 = *v7;\n      v11 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n    case 9LL:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v10 = *v7;\n      goto LABEL_8;\n    default:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v10 = *v7;\nLABEL_8:\n      v11 = dcgettext(0LL, v13, 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n  }\n}\n\n__int64 __fastcall sub_410C70(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)\n{\n  __int64 v6; // r12\n  __int64 *v7; // rbx\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  char *v11; // rax\n  __int64 result; // rax\n  const char *v13; // rsi\n  __int64 v14; // rbx\n  char *v15; // rax\n  __int64 v16; // rbx\n  char *v17; // rax\n  __int64 v18; // rbx\n  char *v19; // rax\n  __int64 v20; // r14\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // rbx\n  char *v24; // rax\n\n  v6 = a6;\n  v7 = a5;\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( v6 )\n  {\n    case 0LL:\n      abort();\n      return result;\n    case 1LL:\n      v14 = *v7;\n      v15 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v15, v14);\n    case 2LL:\n      v16 = *v7;\n      v17 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16);\n    case 3LL:\n      v18 = *v7;\n      v19 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v19, v18);\n    case 4LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v22, v21);\n      return v20;\n    case 6LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 7LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 8LL:\n      v10 = *v7;\n      v11 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n    case 9LL:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v10 = *v7;\n      goto LABEL_8;\n    default:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v10 = *v7;\nLABEL_8:\n      v11 = dcgettext(0LL, v13, 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n  }\n}\n", 
            "funcStartAddr": "0x402f32L", 
            "funcEndAddr": "0x402f37L", 
            "funcName": "sub_410C70"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_410C70(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)\n{\n  __int64 v6; // r12\n  __int64 *v7; // rbx\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  char *v11; // rax\n  __int64 result; // rax\n  const char *v13; // rsi\n  __int64 v14; // rbx\n  char *v15; // rax\n  __int64 v16; // rbx\n  char *v17; // rax\n  __int64 v18; // rbx\n  char *v19; // rax\n  __int64 v20; // r14\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // rbx\n  char *v24; // rax\n\n  v6 = a6;\n  v7 = a5;\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( v6 )\n  {\n    case 0LL:\n      abort();\n      return result;\n    case 1LL:\n      v14 = *v7;\n      v15 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v15, v14);\n    case 2LL:\n      v16 = *v7;\n      v17 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16);\n    case 3LL:\n      v18 = *v7;\n      v19 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v19, v18);\n    case 4LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v22, v21);\n      return v20;\n    case 6LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 7LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 8LL:\n      v10 = *v7;\n      v11 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n    case 9LL:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v10 = *v7;\n      goto LABEL_8;\n    default:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v10 = *v7;\nLABEL_8:\n      v11 = dcgettext(0LL, v13, 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n  }\n}\n\n__int64 __fastcall sub_410C70(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)\n{\n  __int64 v6; // r12\n  __int64 *v7; // rbx\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // rbx\n  char *v11; // rax\n  __int64 result; // rax\n  const char *v13; // rsi\n  __int64 v14; // rbx\n  char *v15; // rax\n  __int64 v16; // rbx\n  char *v17; // rax\n  __int64 v18; // rbx\n  char *v19; // rax\n  __int64 v20; // r14\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // rbx\n  char *v24; // rax\n\n  v6 = a6;\n  v7 = a5;\n  if ( a2 )\n    __fprintf_chk(stream, 1LL, \"%s (%s) %s\\n\", a2);\n  else\n    __fprintf_chk(stream, 1LL, \"%s %s\\n\", a3);\n  v8 = dcgettext(0LL, \"(C)\", 5);\n  __fprintf_chk(stream, 1LL, \"Copyright %s %d Free Software Foundation, Inc.\", v8);\n  v9 = dcgettext(\n         0LL,\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\",\n         5);\n  fputs_unlocked(v9, stream);\n  switch ( v6 )\n  {\n    case 0LL:\n      abort();\n      return result;\n    case 1LL:\n      v14 = *v7;\n      v15 = dcgettext(0LL, \"Written by %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v15, v14);\n    case 2LL:\n      v16 = *v7;\n      v17 = dcgettext(0LL, \"Written by %s and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v17, v16);\n    case 3LL:\n      v18 = *v7;\n      v19 = dcgettext(0LL, \"Written by %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v19, v18);\n    case 4LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\nand %s.\\n\", 5);\n      goto LABEL_13;\n    case 5LL:\n      v20 = v7[3];\n      v21 = *v7;\n      v22 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, and %s.\\n\", 5);\nLABEL_13:\n      __fprintf_chk(stream, 1LL, v22, v21);\n      return v20;\n    case 6LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 7LL:\n      v23 = *v7;\n      v24 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v24, v23);\n    case 8LL:\n      v10 = *v7;\n      v11 = dcgettext(0LL, \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\", 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n    case 9LL:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n      v10 = *v7;\n      goto LABEL_8;\n    default:\n      v13 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n      v10 = *v7;\nLABEL_8:\n      v11 = dcgettext(0LL, v13, 5);\n      return __fprintf_chk(stream, 1LL, v11, v10);\n  }\n}\n", 
            "funcStartAddr": "0x402f32L", 
            "funcEndAddr": "0x402f37L", 
            "funcName": "sub_410C70"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_411070(FILE *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)\n{\n  __int64 i; // r9\n  __int64 *v6; // r10\n  __int64 v7; // rax\n  unsigned int v8; // eax\n  __int64 *v9; // r10\n  __int64 v10; // rax\n  __int64 v12[11]; // [rsp+0h] [rbp-58h]\n\n  for ( i = 0LL; i != 10; ++i )\n  {\n    v8 = *a5;\n    if ( (unsigned int)*a5 <= 0x2F )\n    {\n      v6 = (__int64 *)(*((_QWORD *)a5 + 2) + v8);\n      *a5 = v8 + 8;\n      v7 = *v6;\n      v12[i] = *v6;\n      if ( !v7 )\n        return sub_410C70(a1, a2, a3, a4, v12, i);\n      continue;\n    }\n    v9 = (__int64 *)*((_QWORD *)a5 + 1);\n    *((_QWORD *)a5 + 1) = v9 + 1;\n    v10 = *v9;\n    v12[i] = *v9;\n    if ( !v10 )\n      break;\n  }\n  return sub_410C70(a1, a2, a3, a4, v12, i);\n}\n", 
            "funcStartAddr": "0x411070L", 
            "funcEndAddr": "0x4110d0L", 
            "funcName": "sub_411070"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4110D0(FILE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)\n{\n  char *v7; // r10\n  unsigned int v8; // er8\n  __int64 i; // r9\n  __int64 v10; // rax\n  __int64 v11; // rax\n  __int64 *v12; // rax\n  __int64 v13; // rax\n  __int64 v15[10]; // [rsp+20h] [rbp-88h]\n  char v16[32]; // [rsp+70h] [rbp-38h]\n  __int64 v17; // [rsp+90h] [rbp-18h]\n  __int64 v18; // [rsp+98h] [rbp-10h]\n\n  v17 = a5;\n  v7 = &a7;\n  v8 = 32;\n  v18 = a6;\n  for ( i = 0LL; i != 10; ++i )\n  {\n    if ( v8 <= 0x2F )\n    {\n      v10 = v8;\n      v8 += 8;\n      v11 = *(_QWORD *)&v16[v10];\n      v15[i] = v11;\n      if ( !v11 )\n        return sub_410C70(a1, a2, a3, a4, v15, i);\n      continue;\n    }\n    v12 = (__int64 *)v7;\n    v7 += 8;\n    v13 = *v12;\n    v15[i] = v13;\n    if ( !v13 )\n      break;\n  }\n  return sub_410C70(a1, a2, a3, a4, v15, i);\n}\n", 
            "funcStartAddr": "0x4110d0L", 
            "funcEndAddr": "0x41118cL", 
            "funcName": "sub_4110D0"
        }, 
        {
            "decompiledFuncCode": "int sub_411190()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = dcgettext(0LL, \"\\nReport bugs to: %s\\n\", 5);\n  __printf_chk(1LL, v0);\n  v1 = dcgettext(0LL, \"%s home page: <%s>\\n\", 5);\n  __printf_chk(1LL, v1);\n  v2 = stdout;\n  v3 = dcgettext(0LL, \"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\", 5);\n  return fputs_unlocked(v3, v2);\n}\n", 
            "funcStartAddr": "0x411190L", 
            "funcEndAddr": "0x411204L", 
            "funcName": "sub_411190"
        }, 
        {
            "decompiledFuncCode": "void *__fastcall sub_411210(size_t a1, __int64 a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n\n  result = malloc(a1);\n  if ( !result )\n  {\n    if ( a1 )\n      sub_411460(a1, a2, v3);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x411210L", 
            "funcEndAddr": "0x41122aL", 
            "funcName": "sub_411210"
        }, 
        {
            "decompiledFuncCode": "void *__fastcall sub_411270(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n\n  if ( !a2 && a1 )\n  {\n    free(a1);\n    result = 0LL;\n  }\n  else\n  {\n    result = realloc(a1, a2);\n    if ( !result )\n    {\n      if ( a2 )\n        sub_411460(a1, a2, v3);\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x411270L", 
            "funcEndAddr": "0x4112a6L", 
            "funcName": "sub_411270"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4113E0(size_t a1, size_t a2)\n{\n  unsigned __int128 v2; // ax\n\n  v2 = a2 * (unsigned __int128)a1;\n  BYTE8(v2) = *((_QWORD *)&v2 + 1) != 0LL;\n  if ( (v2 & 0x8000000000000000LL) != 0LL\n    || (*((_QWORD *)&v2 + 1) = BYTE8(v2), BYTE8(v2))\n    || (*(_QWORD *)&v2 = calloc(a1, a2), !(_QWORD)v2) )\n  {\n    sub_411460(a1, a2, *((_QWORD *)&v2 + 1));\n  }\n  return v2;\n}\n", 
            "funcStartAddr": "0x4113e0L", 
            "funcEndAddr": "0x41140eL", 
            "funcName": "sub_4113E0"
        }, 
        {
            "decompiledFuncCode": "void *__fastcall sub_411410(void *src, size_t n)\n{\n  void *v2; // rax\n\n  v2 = sub_411210(n, n);\n  return memcpy(v2, src, n);\n}\n", 
            "funcStartAddr": "0x411410L", 
            "funcEndAddr": "0x411438L", 
            "funcName": "sub_411410"
        }, 
        {
            "decompiledFuncCode": "void __noreturn sub_411460()\n{\n  char *v0; // rax\n\n  v0 = dcgettext(0LL, \"memory exhausted\", 5);\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n", 
            "funcStartAddr": "0x411460L", 
            "funcEndAddr": "0x411491L", 
            "funcName": "sub_411460"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_4114A0(int errnum, char *a2, unsigned __int64 a3, char *a4, unsigned __int64 a5)\n{\n  unsigned __int64 v5; // r13\n  unsigned __int64 v6; // r12\n  char *v7; // rbp\n  char *v8; // rax\n  char *v9; // rax\n  _BYTE *v10; // rbp\n  _BYTE *v11; // rbx\n  char *v12; // rax\n\n  v5 = a5;\n  v6 = a3;\n  v7 = a4;\n  v8 = dcgettext(0LL, \"string comparison failed\", 5);\n  error(0, errnum, v8);\n  v9 = dcgettext(0LL, \"Set LC_ALL='C' to work around the problem.\", 5);\n  error(0, 0, v9);\n  v10 = sub_40F5C0(1LL, 8, v7, v5);\n  v11 = sub_40F5C0(0LL, 8, a2, v6);\n  v12 = dcgettext(0LL, \"The strings compared were %s and %s.\", 5);\n  error(status, 0, v12, v11, v10);\n}\n", 
            "funcStartAddr": "0x4114a0L", 
            "funcEndAddr": "0x411554L", 
            "funcName": "sub_4114A0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_411560(char *a1, size_t a2, char *a3, unsigned __int64 a4)\n{\n  unsigned __int64 v4; // r13\n  char *v5; // r12\n  char *v6; // rbx\n  unsigned int v7; // er14\n  int v8; // edi\n\n  v4 = a4;\n  v5 = a3;\n  v6 = a1;\n  v7 = sub_413D80(a1, a2, a3);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4114A0(v8, v6, a2, v5, v4);\n  return v7;\n}\n", 
            "funcStartAddr": "0x411560L", 
            "funcEndAddr": "0x4115b5L", 
            "funcName": "sub_411560"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4115C0(char *a1, size_t a2, char *a3, __int64 a4)\n{\n  __int64 v4; // r14\n  char *v5; // r12\n  char *v6; // rbp\n  unsigned int v7; // er13\n  int v8; // edi\n\n  v4 = a4;\n  v5 = a3;\n  v6 = a1;\n  v7 = sub_413E30(a1, a2, a3);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4114A0(v8, v6, a2 - 1, v5, v4 - 1);\n  return v7;\n}\n", 
            "funcStartAddr": "0x4115c0L", 
            "funcEndAddr": "0x411617L", 
            "funcName": "sub_4115C0"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_411620()\n{\n  __int64 v0; // rdx\n  int *v1; // rbx\n  __int64 result; // rax\n  __int64 v3; // [rsp+0h] [rbp-18h]\n  __int64 v4; // [rsp+8h] [rbp-10h]\n\n  v3 = sub_413580();\n  v4 = v0;\n  v1 = __errno_location();\n  while ( 1 )\n  {\n    *v1 = 0;\n    result = sub_413140(&v3, 0LL);\n    if ( !(_DWORD)result )\n      break;\n    if ( *v1 & 0xFFFFFFFB )\n      return 0xFFFFFFFFLL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x411620L", 
            "funcEndAddr": "0x411673L", 
            "funcName": "sub_411620"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_411680(char *nptr, char **a2, unsigned int a3, unsigned __int64 *a4, const char *a5)\n{\n  char **v5; // r15\n  unsigned __int64 *v6; // r14\n  const char *v7; // r13\n  int *v8; // rax\n  int *v9; // r12\n  unsigned __int8 v10; // bl\n  const unsigned __int16 *v11; // rsi\n  char *v12; // rax\n  unsigned __int64 v13; // rbx\n  unsigned int v14; // ebp\n  int v15; // er12\n  char *v17; // rax\n  char *v18; // r8\n  __int64 v19; // rax\n  char *v20; // rax\n  char v21; // al\n  int v22; // esi\n  unsigned __int64 v23; // rdx\n  char *v24; // r8\n  unsigned __int64 v25; // kr30_8\n  char *v26; // rax\n  int v27; // edi\n  int v28; // er9\n  bool v29; // of\n  int v30; // edi\n  int v31; // edi\n  int v32; // edi\n  int v33; // edi\n  int base; // [rsp+0h] [rbp-58h]\n  char *basea; // [rsp+0h] [rbp-58h]\n  char *baseb; // [rsp+0h] [rbp-58h]\n  char *v37; // [rsp+8h] [rbp-50h]\n  char *endptr; // [rsp+18h] [rbp-40h]\n\n  if ( a3 > 0x24 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"lib/xstrtol.c\", 0x60u, \"xstrtoul\");\n  v5 = a2;\n  base = a3;\n  v6 = a4;\n  v7 = a5;\n  if ( !a2 )\n    v5 = &endptr;\n  v8 = __errno_location();\n  *v8 = 0;\n  v9 = v8;\n  v10 = *nptr;\n  v11 = *__ctype_b_loc();\n  v12 = nptr;\n  while ( v11[v10] & 0x2000 )\n    v10 = *++v12;\n  if ( v10 == 45 )\n    return 4;\n  v13 = strtoul(nptr, v5, base);\n  if ( *v5 == nptr )\n  {\n    basea = *v5;\n    if ( v7 )\n    {\n      v15 = (unsigned __int8)*nptr;\n      if ( (_BYTE)v15 )\n      {\n        v14 = 0;\n        v13 = 1LL;\n        v17 = strchr(v7, (char)v15);\n        v18 = basea;\n        if ( v17 )\n          goto LABEL_20;\n      }\n    }\n    return 4;\n  }\n  if ( *v9 )\n  {\n    v14 = 1;\n    if ( *v9 == 34 )\n      goto LABEL_11;\n    return 4;\n  }\n  v14 = 0;\nLABEL_11:\n  if ( v7 )\n  {\n    v15 = (unsigned __int8)**v5;\n    if ( (_BYTE)v15 )\n    {\n      baseb = *v5;\n      v26 = strchr(v7, (char)v15);\n      v18 = baseb;\n      if ( !v26 )\n      {\nLABEL_39:\n        *v6 = v13;\n        v14 |= 2u;\n        return v14;\n      }\nLABEL_20:\n      v19 = 142129060940101LL;\n      if ( !_bittest64(&v19, (unsigned int)(v15 - 69)) || (v37 = v18, v20 = strchr(v7, 48), v18 = v37, !v20) )\n      {\nLABEL_26:\n        v22 = 1;\n        v23 = 1024LL;\n        goto LABEL_27;\n      }\n      v21 = v37[1];\n      if ( v21 != 68 )\n      {\n        if ( v21 == 105 )\n        {\n          v23 = 1024LL;\n          v22 = 2 * (v37[2] == 66) + 1;\nLABEL_27:\n          switch ( (_BYTE)v15 )\n          {\n            case 0x42:\n              if ( v13 >> 54 )\n                goto LABEL_37;\n              v13 <<= 10;\n              break;\n            case 0x45:\n              goto LABEL_70;\n            case 0x47:\n            case 0x67:\n              goto LABEL_76;\n            case 0x4B:\n            case 0x6B:\n              goto LABEL_36;\n            case 0x4D:\n            case 0x6D:\n              goto LABEL_29;\n            case 0x50:\n              goto LABEL_64;\n            case 0x54:\n            case 0x74:\n              goto LABEL_58;\n            case 0x59:\n              goto LABEL_52;\n            case 0x5A:\n              goto LABEL_46;\n            case 0x62:\n              goto LABEL_43;\n            case 0x63:\n              break;\n            case 0x77:\n              if ( (v13 & 0x8000000000000000LL) != 0LL )\n                goto LABEL_37;\n              v13 *= 2LL;\n              break;\n            default:\n              goto LABEL_39;\n          }\nLABEL_32:\n          v24 = &v18[v22];\n          *v5 = v24;\n          if ( *v24 )\n            v14 |= 2u;\n          goto LABEL_13;\n        }\n        if ( v21 != 66 )\n        {\n          switch ( (_BYTE)v15 )\n          {\n            case 0x45:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_70:\n              v33 = 6;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v33;\n              }\n              while ( v33 );\n              goto LABEL_50;\n            case 0x46:\n            case 0x48:\n            case 0x49:\n            case 0x4A:\n            case 0x4C:\n            case 0x4E:\n            case 0x4F:\n            case 0x51:\n            case 0x52:\n            case 0x53:\n            case 0x55:\n            case 0x56:\n            case 0x57:\n            case 0x58:\n            case 0x5B:\n            case 0x5C:\n            case 0x5D:\n            case 0x5E:\n            case 0x5F:\n            case 0x60:\n            case 0x61:\n            case 0x64:\n            case 0x65:\n            case 0x66:\n            case 0x68:\n            case 0x69:\n            case 0x6A:\n            case 0x6C:\n            case 0x6E:\n            case 0x6F:\n            case 0x70:\n            case 0x71:\n            case 0x72:\n            case 0x73:\n              goto LABEL_39;\n            case 0x47:\n            case 0x67:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_76:\n              if ( is_mul_ok((int)v23, v13)\n                && is_mul_ok((int)v23, (int)v23 * v13)\n                && is_mul_ok((int)v23, (int)v23 * (int)v23 * v13) )\n              {\n                v13 *= (int)v23 * (int)v23 * (__int64)(int)v23;\n              }\n              else\n              {\n                v13 = -1LL;\n                v14 |= 1u;\n              }\n              goto LABEL_32;\n            case 0x4B:\n            case 0x6B:\n              v22 = 1;\n              v23 = 1024LL;\nLABEL_36:\n              v25 = v13;\n              v13 *= v23;\n              if ( is_mul_ok(v23, v25) )\n                goto LABEL_32;\n              goto LABEL_37;\n            case 0x4D:\n            case 0x6D:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_29:\n              if ( !is_mul_ok((int)v23, v13) || !is_mul_ok((int)v23, (int)v23 * v13) )\n                goto LABEL_37;\n              v13 *= (int)v23 * (__int64)(int)v23;\n              break;\n            case 0x50:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_64:\n              v32 = 5;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v32;\n              }\n              while ( v32 );\n              goto LABEL_50;\n            case 0x54:\n            case 0x74:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_58:\n              v31 = 4;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v31;\n              }\n              while ( v31 );\n              goto LABEL_50;\n            case 0x59:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_52:\n              v30 = 8;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v30;\n              }\n              while ( v30 );\n              goto LABEL_50;\n            case 0x5A:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_46:\n              v27 = 7;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v27;\n              }\n              while ( v27 );\nLABEL_50:\n              v14 |= v28;\n              break;\n            case 0x62:\n              v22 = 1;\nLABEL_43:\n              if ( v13 >> 55 )\n              {\nLABEL_37:\n                v14 = 1;\n                v13 = -1LL;\n              }\n              else\n              {\n                v13 <<= 9;\n              }\n              break;\n            case 0x63:\n              v22 = 1;\n              goto LABEL_32;\n            default:\n              goto LABEL_26;\n          }\n          goto LABEL_32;\n        }\n      }\n      v22 = 2;\n      v23 = 1000LL;\n      goto LABEL_27;\n    }\n  }\nLABEL_13:\n  *v6 = v13;\n  return v14;\n}\n", 
            "funcStartAddr": "0x411680L", 
            "funcEndAddr": "0x411aa4L", 
            "funcName": "sub_411680"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  int v7; // er10\n  __int64 v8; // rbp\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13; // [rsp+Eh] [rbp-2Ah]\n  char v14; // [rsp+Fh] [rbp-29h]\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v7 = a2;\n    v8 = a5;\n    v9 = (&off_4181C0)[v5];\n    if ( v7 < 0 )\n    {\n      v13 = a3;\n      v11 = &v13;\n      v10 = &asc_418149[-v7];\n      v14 = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * v7);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, v8);\n    abort();\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  int v7; // er10\n  __int64 v8; // rbp\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13; // [rsp+Eh] [rbp-2Ah]\n  char v14; // [rsp+Fh] [rbp-29h]\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v7 = a2;\n    v8 = a5;\n    v9 = (&off_4181C0)[v5];\n    if ( v7 < 0 )\n    {\n      v13 = a3;\n      v11 = &v13;\n      v10 = &asc_418149[-v7];\n      v14 = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * v7);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, v8);\n    abort();\n  }\n  abort();\n}\n", 
            "funcStartAddr": "0x402f37L", 
            "funcEndAddr": "0x402f3cL", 
            "funcName": "sub_411AB0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  int v7; // er10\n  __int64 v8; // rbp\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13; // [rsp+Eh] [rbp-2Ah]\n  char v14; // [rsp+Fh] [rbp-29h]\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v7 = a2;\n    v8 = a5;\n    v9 = (&off_4181C0)[v5];\n    if ( v7 < 0 )\n    {\n      v13 = a3;\n      v11 = &v13;\n      v10 = &asc_418149[-v7];\n      v14 = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * v7);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, v8);\n    abort();\n  }\n  abort();\n}\n\nvoid __fastcall __noreturn sub_411AB0(int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rdi\n  int v6; // ebx\n  int v7; // er10\n  __int64 v8; // rbp\n  const char *v9; // rsi\n  char *v10; // r12\n  char *v11; // r13\n  char *v12; // rax\n  char v13; // [rsp+Eh] [rbp-2Ah]\n  char v14; // [rsp+Fh] [rbp-29h]\n\n  v5 = (unsigned int)(a1 - 1);\n  v6 = status;\n  if ( (unsigned int)v5 <= 3 )\n  {\n    v7 = a2;\n    v8 = a5;\n    v9 = (&off_4181C0)[v5];\n    if ( v7 < 0 )\n    {\n      v13 = a3;\n      v11 = &v13;\n      v10 = &asc_418149[-v7];\n      v14 = 0;\n    }\n    else\n    {\n      v10 = \"--\";\n      v11 = *(char **)(a4 + 32LL * v7);\n    }\n    v12 = dcgettext(0LL, v9, 5);\n    error(v6, 0, v12, v10, v11, v8);\n    abort();\n  }\n  abort();\n}\n", 
            "funcStartAddr": "0x402f37L", 
            "funcEndAddr": "0x402f3cL", 
            "funcName": "sub_411AB0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_411B40(char *nptr, char **a2, unsigned int a3, unsigned __int64 *a4, const char *a5)\n{\n  char **v5; // r15\n  unsigned __int64 *v6; // r14\n  const char *v7; // r13\n  int *v8; // rax\n  int *v9; // r12\n  unsigned __int8 v10; // bl\n  const unsigned __int16 *v11; // rsi\n  char *v12; // rax\n  unsigned __int64 v13; // rbx\n  unsigned int v14; // ebp\n  int v15; // er12\n  char *v17; // rax\n  char *v18; // r8\n  __int64 v19; // rax\n  char *v20; // rax\n  char v21; // al\n  int v22; // esi\n  unsigned __int64 v23; // rdx\n  char *v24; // r8\n  unsigned __int64 v25; // kr30_8\n  char *v26; // rax\n  int v27; // edi\n  int v28; // er9\n  bool v29; // of\n  int v30; // edi\n  int v31; // edi\n  int v32; // edi\n  int v33; // edi\n  int base; // [rsp+0h] [rbp-58h]\n  char *basea; // [rsp+0h] [rbp-58h]\n  char *baseb; // [rsp+0h] [rbp-58h]\n  char *v37; // [rsp+8h] [rbp-50h]\n  char *endptr; // [rsp+18h] [rbp-40h]\n\n  if ( a3 > 0x24 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"lib/xstrtol.c\", 0x60u, \"xstrtoumax\");\n  v5 = a2;\n  base = a3;\n  v6 = a4;\n  v7 = a5;\n  if ( !a2 )\n    v5 = &endptr;\n  v8 = __errno_location();\n  *v8 = 0;\n  v9 = v8;\n  v10 = *nptr;\n  v11 = *__ctype_b_loc();\n  v12 = nptr;\n  while ( v11[v10] & 0x2000 )\n    v10 = *++v12;\n  if ( v10 == 45 )\n    return 4;\n  v13 = __strtoul_internal(nptr, v5, base, 0);\n  if ( *v5 == nptr )\n  {\n    basea = *v5;\n    if ( v7 )\n    {\n      v15 = (unsigned __int8)*nptr;\n      if ( (_BYTE)v15 )\n      {\n        v14 = 0;\n        v13 = 1LL;\n        v17 = strchr(v7, (char)v15);\n        v18 = basea;\n        if ( v17 )\n          goto LABEL_20;\n      }\n    }\n    return 4;\n  }\n  if ( *v9 )\n  {\n    v14 = 1;\n    if ( *v9 == 34 )\n      goto LABEL_11;\n    return 4;\n  }\n  v14 = 0;\nLABEL_11:\n  if ( v7 )\n  {\n    v15 = (unsigned __int8)**v5;\n    if ( (_BYTE)v15 )\n    {\n      baseb = *v5;\n      v26 = strchr(v7, (char)v15);\n      v18 = baseb;\n      if ( !v26 )\n      {\nLABEL_39:\n        *v6 = v13;\n        v14 |= 2u;\n        return v14;\n      }\nLABEL_20:\n      v19 = 142129060940101LL;\n      if ( !_bittest64(&v19, (unsigned int)(v15 - 69)) || (v37 = v18, v20 = strchr(v7, 48), v18 = v37, !v20) )\n      {\nLABEL_26:\n        v22 = 1;\n        v23 = 1024LL;\n        goto LABEL_27;\n      }\n      v21 = v37[1];\n      if ( v21 != 68 )\n      {\n        if ( v21 == 105 )\n        {\n          v23 = 1024LL;\n          v22 = 2 * (v37[2] == 66) + 1;\nLABEL_27:\n          switch ( (_BYTE)v15 )\n          {\n            case 0x42:\n              if ( v13 >> 54 )\n                goto LABEL_37;\n              v13 <<= 10;\n              break;\n            case 0x45:\n              goto LABEL_70;\n            case 0x47:\n            case 0x67:\n              goto LABEL_76;\n            case 0x4B:\n            case 0x6B:\n              goto LABEL_36;\n            case 0x4D:\n            case 0x6D:\n              goto LABEL_29;\n            case 0x50:\n              goto LABEL_64;\n            case 0x54:\n            case 0x74:\n              goto LABEL_58;\n            case 0x59:\n              goto LABEL_52;\n            case 0x5A:\n              goto LABEL_46;\n            case 0x62:\n              goto LABEL_43;\n            case 0x63:\n              break;\n            case 0x77:\n              if ( (v13 & 0x8000000000000000LL) != 0LL )\n                goto LABEL_37;\n              v13 *= 2LL;\n              break;\n            default:\n              goto LABEL_39;\n          }\nLABEL_32:\n          v24 = &v18[v22];\n          *v5 = v24;\n          if ( *v24 )\n            v14 |= 2u;\n          goto LABEL_13;\n        }\n        if ( v21 != 66 )\n        {\n          switch ( (_BYTE)v15 )\n          {\n            case 0x45:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_70:\n              v33 = 6;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v33;\n              }\n              while ( v33 );\n              goto LABEL_50;\n            case 0x46:\n            case 0x48:\n            case 0x49:\n            case 0x4A:\n            case 0x4C:\n            case 0x4E:\n            case 0x4F:\n            case 0x51:\n            case 0x52:\n            case 0x53:\n            case 0x55:\n            case 0x56:\n            case 0x57:\n            case 0x58:\n            case 0x5B:\n            case 0x5C:\n            case 0x5D:\n            case 0x5E:\n            case 0x5F:\n            case 0x60:\n            case 0x61:\n            case 0x64:\n            case 0x65:\n            case 0x66:\n            case 0x68:\n            case 0x69:\n            case 0x6A:\n            case 0x6C:\n            case 0x6E:\n            case 0x6F:\n            case 0x70:\n            case 0x71:\n            case 0x72:\n            case 0x73:\n              goto LABEL_39;\n            case 0x47:\n            case 0x67:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_76:\n              if ( is_mul_ok((int)v23, v13)\n                && is_mul_ok((int)v23, (int)v23 * v13)\n                && is_mul_ok((int)v23, (int)v23 * (int)v23 * v13) )\n              {\n                v13 *= (int)v23 * (int)v23 * (__int64)(int)v23;\n              }\n              else\n              {\n                v13 = -1LL;\n                v14 |= 1u;\n              }\n              goto LABEL_32;\n            case 0x4B:\n            case 0x6B:\n              v22 = 1;\n              v23 = 1024LL;\nLABEL_36:\n              v25 = v13;\n              v13 *= v23;\n              if ( is_mul_ok(v23, v25) )\n                goto LABEL_32;\n              goto LABEL_37;\n            case 0x4D:\n            case 0x6D:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_29:\n              if ( !is_mul_ok((int)v23, v13) || !is_mul_ok((int)v23, (int)v23 * v13) )\n                goto LABEL_37;\n              v13 *= (int)v23 * (__int64)(int)v23;\n              break;\n            case 0x50:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_64:\n              v32 = 5;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v32;\n              }\n              while ( v32 );\n              goto LABEL_50;\n            case 0x54:\n            case 0x74:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_58:\n              v31 = 4;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v31;\n              }\n              while ( v31 );\n              goto LABEL_50;\n            case 0x59:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_52:\n              v30 = 8;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v30;\n              }\n              while ( v30 );\n              goto LABEL_50;\n            case 0x5A:\n              v22 = 1;\n              LODWORD(v23) = 1024;\nLABEL_46:\n              v27 = 7;\n              v28 = 0;\n              do\n              {\n                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;\n                v13 *= (int)v23;\n                if ( v29 )\n                {\n                  v28 = 1;\n                  v13 = -1LL;\n                }\n                --v27;\n              }\n              while ( v27 );\nLABEL_50:\n              v14 |= v28;\n              break;\n            case 0x62:\n              v22 = 1;\nLABEL_43:\n              if ( v13 >> 55 )\n              {\nLABEL_37:\n                v14 = 1;\n                v13 = -1LL;\n              }\n              else\n              {\n                v13 <<= 9;\n              }\n              break;\n            case 0x63:\n              v22 = 1;\n              goto LABEL_32;\n            default:\n              goto LABEL_26;\n          }\n          goto LABEL_32;\n        }\n      }\n      v22 = 2;\n      v23 = 1000LL;\n      goto LABEL_27;\n    }\n  }\nLABEL_13:\n  *v6 = v13;\n  return v14;\n}\n", 
            "funcStartAddr": "0x411b40L", 
            "funcEndAddr": "0x411f74L", 
            "funcName": "sub_411B40"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_411F80(FILE *stream)\n{\n  int *v1; // rax\n  int v2; // er12\n  int *v3; // rbp\n  int result; // eax\n  int v5; // eax\n\n  if ( fileno(stream) < 0 )\n    return fclose(stream);\n  if ( __freading(stream) )\n  {\n    v5 = fileno(stream);\n    if ( lseek(v5, 0LL, 1) == -1 )\n      return fclose(stream);\n  }\n  if ( !(unsigned int)sub_412140(stream) )\n    return fclose(stream);\n  v1 = __errno_location();\n  v2 = *v1;\n  v3 = v1;\n  result = fclose(stream);\n  if ( v2 )\n  {\n    *v3 = v2;\n    result = -1;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x411f80L", 
            "funcEndAddr": "0x411ffbL", 
            "funcName": "sub_411F80"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412000(char a1, int a2, __int64 a3)\n{\n  int v3; // ebx\n  int v5; // eax\n  int *v6; // rax\n  int v7; // edi\n  int v8; // er12\n  int *v9; // rbp\n\n  if ( a2 == 1030 )\n  {\n    if ( dword_61CD18 < 0 )\n    {\n      v3 = sub_412000(a1);\n      if ( v3 >= 0 && dword_61CD18 == -1 )\n      {\nLABEL_8:\n        v5 = fcntl((unsigned __int8)v3, 1);\n        if ( v5 < 0 || fcntl((unsigned __int8)v3, 2, v5 | 1u) == -1 )\n        {\n          v6 = __errno_location();\n          v7 = v3;\n          v3 = -1;\n          v8 = *v6;\n          v9 = v6;\n          close(v7);\n          *v9 = v8;\n        }\n        return (unsigned int)v3;\n      }\n    }\n    else\n    {\n      v3 = fcntl(a1, 1030, (unsigned int)a3);\n      if ( v3 >= 0 || *__errno_location() != 22 )\n      {\n        dword_61CD18 = 1;\n      }\n      else\n      {\n        v3 = sub_412000(a1);\n        if ( v3 >= 0 )\n        {\n          dword_61CD18 = -1;\n          goto LABEL_8;\n        }\n      }\n    }\n    return (unsigned int)v3;\n  }\n  return (unsigned int)fcntl(a1, a2, a3);\n}\n", 
            "funcStartAddr": "0x412000L", 
            "funcEndAddr": "0x412135L", 
            "funcName": "sub_412000"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_412140(FILE *stream)\n{\n  if ( !stream || !__freading(stream) || !(stream->_flags & 0x100) )\n    return fflush(stream);\n  sub_412180(stream, 0LL, 1LL);\n  return fflush(stream);\n}\n", 
            "funcStartAddr": "0x412140L", 
            "funcEndAddr": "0x412180L", 
            "funcName": "sub_412140"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_412180(FILE *a1, __off_t a2, int a3)\n{\n  __off_t v3; // rax\n  int v4; // er12\n  int v5; // eax\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n  {\n    LODWORD(v3) = fseeko(a1, a2, a3);\n  }\n  else\n  {\n    v4 = a3;\n    v5 = fileno(a1);\n    v3 = lseek(v5, a2, v4);\n    if ( v3 != -1 )\n    {\n      a1->_flags &= 0xFFFFFFEF;\n      a1->_offset = v3;\n      LODWORD(v3) = 0;\n    }\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x412180L", 
            "funcEndAddr": "0x4121d7L", 
            "funcName": "sub_412180"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4121E0(__int64 a1, int *a2)\n{\n  __int64 v2; // r11\n  int v3; // er12\n  int v4; // ebp\n  __int64 v5; // rbx\n  int v6; // er9\n  int v7; // er10\n  int v8; // er8\n  int v9; // er14\n  int v10; // edx\n  __int64 *v11; // rax\n  unsigned __int64 v12; // r13\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 result; // rax\n  __int64 *v16; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n\n  v2 = a1 + 8;\n  v3 = a2[11];\n  v4 = *a2;\n  v5 = a2[12];\n  v6 = a2[11];\n  v7 = *a2;\n  v8 = a2[12];\nLABEL_2:\n  if ( v7 > v8 )\n  {\n    while ( v6 < v8 )\n    {\n      v9 = v7 - v8;\n      v10 = v8 - v6;\n      if ( v7 - v8 <= v8 - v6 )\n      {\n        v16 = (__int64 *)(a1 + 8LL * v6);\n        v17 = v5 - v6;\n        do\n        {\n          v18 = *v16;\n          *v16 = v16[v17];\n          v16[v17] = v18;\n          ++v16;\n        }\n        while ( v16 != (__int64 *)(v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v9 - 1))) );\n        v6 += v9;\n        goto LABEL_2;\n      }\n      v7 -= v10;\n      v11 = (__int64 *)(a1 + 8LL * v6);\n      v12 = v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v10 - 1));\n      v13 = v7 - (__int64)v6;\n      do\n      {\n        v14 = *v11;\n        *v11 = v11[v13];\n        v11[v13] = v14;\n        ++v11;\n      }\n      while ( (__int64 *)v12 != v11 );\n      if ( v7 <= v8 )\n        break;\n    }\n  }\n  a2[12] = v4;\n  result = (unsigned int)(v4 - v8);\n  a2[11] = result + v3;\n  return result;\n}\n", 
            "funcStartAddr": "0x4121e0L", 
            "funcEndAddr": "0x4122bfL", 
            "funcName": "sub_4121E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4122C0(int a1, __int64 *a2, char *a3, char **a4, _DWORD *a5, int a6, int *a7, int a8, __int64 a9)\n{\n  const char *v9; // r14\n  char *v10; // rbp\n  size_t v11; // r13\n  char **v12; // rbx\n  __int64 v13; // r12\n  const char *v14; // r15\n  const char *v15; // rdi\n  __int64 v16; // r15\n  char **v17; // rbp\n  char *v18; // rdx\n  __int64 result; // rax\n  int v20; // edx\n  int v21; // eax\n  int v22; // ecx\n  char *v23; // rdx\n  __int64 v24; // rbx\n  char *v25; // rax\n  __int64 v26; // rbx\n  char *v27; // rax\n  __int64 v28; // rbp\n  char *v29; // rax\n  __int64 v30; // rbp\n  char *v31; // rax\n  FILE *v32; // rdi\n  char **v33; // rbx\n  _BYTE *v34; // rbp\n  __int64 v35; // r12\n  __int64 v36; // rbp\n  char *v37; // rax\n  char **v38; // [rsp+0h] [rbp-88h]\n  int v39; // [rsp+Ch] [rbp-7Ch]\n  char *s1; // [rsp+10h] [rbp-78h]\n  char *s1a; // [rsp+10h] [rbp-78h]\n  _BYTE *ptr; // [rsp+18h] [rbp-70h]\n  _DWORD *v43; // [rsp+20h] [rbp-68h]\n  char *s; // [rsp+30h] [rbp-58h]\n  int v45; // [rsp+38h] [rbp-50h]\n  char v46; // [rsp+3Fh] [rbp-49h]\n  int v47; // [rsp+40h] [rbp-48h]\n  int v48; // [rsp+44h] [rbp-44h]\n  int v49; // [rsp+48h] [rbp-40h]\n\n  v47 = a1;\n  v9 = (const char *)*((_QWORD *)a7 + 4);\n  s = a3;\n  v38 = a4;\n  v43 = a5;\n  v10 = (char *)*((_QWORD *)a7 + 4);\n  v39 = a6;\n  v46 = *v9;\n  if ( *v9 != 61 && *v9 )\n  {\n    do\n      ++v10;\n    while ( *v10 && *v10 != 61 );\n    v11 = v10 - v9;\n  }\n  else\n  {\n    v11 = 0LL;\n  }\n  v12 = a4;\n  v13 = 0LL;\n  s1 = *a4;\n  v14 = *a4;\n  if ( !*a4 )\n  {\nLABEL_24:\n    if ( !v39 || *(_BYTE *)(a2[*a7] + 1) == 45 || (v18 = strchr(s, v46), result = 0xFFFFFFFFLL, !v18) )\n    {\n      if ( a8 )\n      {\n        v24 = *a2;\n        v25 = dcgettext(0LL, \"%s: unrecognized option '%s%s'\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v25, v24);\n      }\n      *((_QWORD *)a7 + 4) = 0LL;\n      ++*a7;\n      a7[2] = 0;\n      result = 63LL;\n    }\n    return result;\n  }\n  while ( 1 )\n  {\n    if ( !strncmp(v14, v9, v11) && strlen(v14) == v11 )\n      goto LABEL_31;\n    v12 += 4;\n    v14 = *v12;\n    if ( !*v12 )\n      break;\n    v13 = (int)v13 + 1;\n  }\n  v12 = 0LL;\n  v48 = -1;\n  v15 = s1;\n  v16 = 0LL;\n  v45 = 0;\n  v49 = 0;\n  ptr = 0LL;\n  s1a = v10;\n  v17 = v38;\n  do\n  {\n    if ( strncmp(v15, v9, v11) )\n      goto LABEL_20;\n    if ( v12 )\n    {\n      if ( (v39\n         || *((_DWORD *)v12 + 2) != *((_DWORD *)v17 + 2)\n         || v12[2] != v17[2]\n         || *((_DWORD *)v12 + 6) != *((_DWORD *)v17 + 6))\n        && !v45 )\n      {\n        if ( a8 )\n        {\n          if ( ptr )\n            goto LABEL_19;\n          ptr = calloc((int)v13 + 1, 1uLL);\n          if ( ptr )\n          {\n            v49 = 1;\n            ptr[v48] = 1;\nLABEL_19:\n            ptr[v16] = 1;\n            goto LABEL_20;\n          }\n          v45 = 1;\n        }\n        else\n        {\n          v45 = 1;\n          if ( ptr )\n            goto LABEL_19;\n        }\n      }\n    }\n    else\n    {\n      v48 = v16;\n      v12 = v17;\n    }\nLABEL_20:\n    v17 += 4;\n    v15 = *v17;\n    ++v16;\n  }\n  while ( *v17 );\n  v10 = s1a;\n  if ( ptr || v45 )\n  {\n    if ( a8 )\n    {\n      if ( v45 )\n      {\n        v26 = *a2;\n        v27 = dcgettext(0LL, \"%s: option '%s%s' is ambiguous\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v27, v26);\n        v9 = (const char *)*((_QWORD *)a7 + 4);\n      }\n      else\n      {\n        flockfile(stderr);\n        v30 = *a2;\n        v31 = dcgettext(0LL, \"%s: option '%s%s' is ambiguous; possibilities:\", 5);\n        __fprintf_chk(stderr, 1LL, v31, v30);\n        v32 = stderr;\n        v33 = v38;\n        v34 = ptr;\n        v35 = (__int64)&ptr[v13 + 1];\n        do\n        {\n          if ( *v34 )\n          {\n            __fprintf_chk(v32, 1LL, \" '%s%s'\", a9);\n            v32 = stderr;\n          }\n          ++v34;\n          v33 += 4;\n        }\n        while ( (_BYTE *)v35 != v34 );\n        fputc(10, v32);\n        funlockfile(stderr);\n        v9 = (const char *)*((_QWORD *)a7 + 4);\n      }\n    }\n    if ( v49 )\n      free(ptr);\n    *((_QWORD *)a7 + 4) = &v9[strlen(v9)];\n    ++*a7;\n    a7[2] = 0;\n    result = 63LL;\n  }\n  else\n  {\n    if ( !v12 )\n      goto LABEL_24;\n    LODWORD(v13) = v48;\nLABEL_31:\n    v20 = *a7;\n    *((_QWORD *)a7 + 4) = 0LL;\n    v21 = v20 + 1;\n    *a7 = v20 + 1;\n    v22 = *((_DWORD *)v12 + 2);\n    if ( *v10 )\n    {\n      if ( v22 )\n      {\n        *((_QWORD *)a7 + 2) = v10 + 1;\n        goto LABEL_33;\n      }\n      if ( a8 )\n      {\n        v28 = *a2;\n        v29 = dcgettext(0LL, \"%s: option '%s%s' doesn't allow an argument\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v29, v28);\n      }\n      a7[2] = *((_DWORD *)v12 + 6);\n      result = 63LL;\n    }\n    else\n    {\n      if ( v22 != 1 )\n        goto LABEL_33;\n      if ( v21 >= v47 )\n      {\n        if ( a8 )\n        {\n          v36 = *a2;\n          v37 = dcgettext(0LL, \"%s: option '%s%s' requires an argument\\n\", 5);\n          __fprintf_chk(stderr, 1LL, v37, v36);\n        }\n        a7[2] = *((_DWORD *)v12 + 6);\n        result = 5 * (unsigned int)(*s != 58) + 58;\n      }\n      else\n      {\n        *a7 = v20 + 2;\n        *((_QWORD *)a7 + 2) = a2[v21];\nLABEL_33:\n        if ( v43 )\n          *v43 = v13;\n        v23 = v12[2];\n        result = *((unsigned int *)v12 + 6);\n        if ( v23 )\n        {\n          *(_DWORD *)v23 = result;\n          result = 0LL;\n        }\n      }\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4122c0L", 
            "funcEndAddr": "0x4128dcL", 
            "funcName": "sub_4122C0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4128E0(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int a6, int *a7, int a8)\n{\n  int v8; // er13\n  int v9; // eax\n  int v10; // ebp\n  __int64 *v11; // r12\n  char *v12; // r15\n  _BYTE *v13; // rdx\n  char v14; // al\n  char v15; // al\n  int v16; // eax\n  _BYTE *v17; // r14\n  int v18; // edx\n  int v19; // ecx\n  int v20; // eax\n  unsigned int v21; // er14\n  char *v22; // rax\n  __int64 v23; // r8\n  char v24; // cl\n  int v26; // edx\n  __int64 v27; // rax\n  _BYTE *v28; // rcx\n  int v29; // esi\n  char v30; // cl\n  char *v31; // rax\n  __int64 v32; // rax\n  char *v34; // rax\n  char v35; // dl\n  __int64 v36; // rax\n  int v37; // edx\n  __int64 v38; // rax\n  __int64 v39; // rbp\n  char *v40; // rax\n  __int64 v41; // rbp\n  char *v42; // rax\n  __int64 v43; // rbp\n  char *v44; // rax\n  char **v45; // [rsp+8h] [rbp-60h]\n  _DWORD *v46; // [rsp+10h] [rbp-58h]\n  char v47; // [rsp+1Ch] [rbp-4Ch]\n  int v48; // [rsp+1Ch] [rbp-4Ch]\n  int v49; // [rsp+1Ch] [rbp-4Ch]\n  int v50; // [rsp+1Ch] [rbp-4Ch]\n  _BYTE *v51; // [rsp+20h] [rbp-48h]\n  __int64 v52; // [rsp+28h] [rbp-40h]\n\n  v45 = a4;\n  v46 = a5;\n  v8 = a7[1];\n  if ( a1 <= 0 )\n    return (unsigned int)-1;\n  v9 = *a7;\n  v10 = a1;\n  v11 = (__int64 *)a2;\n  v12 = a3;\n  *((_QWORD *)a7 + 2) = 0LL;\n  if ( !v9 )\n  {\n    *a7 = 1;\n    v9 = 1;\nLABEL_4:\n    a7[12] = v9;\n    a7[11] = v9;\n    *((_QWORD *)a7 + 4) = 0LL;\n    if ( *a3 == 45 )\n    {\n      a7[10] = 2;\n      v12 = a3 + 1;\n      v13 = 0LL;\n    }\n    else if ( *a3 == 43 )\n    {\n      a7[10] = 0;\n      v12 = a3 + 1;\n      v13 = 0LL;\n    }\n    else\n    {\n      v13 = 0LL;\n      if ( !a8 )\n      {\n        v50 = a6;\n        v34 = getenv(\"POSIXLY_CORRECT\");\n        a6 = v50;\n        if ( !v34 )\n        {\n          a7[10] = 1;\n          v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n          goto LABEL_24;\n        }\n        v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n      }\n      a7[10] = 0;\n    }\nLABEL_24:\n    a7[6] = 1;\n    v14 = *v12;\n    goto LABEL_25;\n  }\n  if ( !a7[6] )\n    goto LABEL_4;\n  v14 = *a3;\n  v13 = (_BYTE *)*((_QWORD *)a7 + 4);\n  if ( !((v14 - 43) & 0xFD) )\n  {\n    v15 = *++v12;\n    if ( v15 == 58 )\n      v8 = 0;\n    if ( !v13 )\n      goto LABEL_12;\n    goto LABEL_28;\n  }\nLABEL_25:\n  if ( v14 == 58 )\n    v8 = 0;\n  if ( !v13 )\n    goto LABEL_12;\nLABEL_28:\n  if ( !*v13 )\n  {\nLABEL_12:\n    v16 = *a7;\n    if ( a7[12] > *a7 )\n      a7[12] = v16;\n    if ( v16 < a7[11] )\n      a7[11] = v16;\n    if ( a7[10] == 1 )\n    {\n      v26 = a7[12];\n      if ( a7[11] == v26 )\n      {\n        if ( v16 != v26 )\n        {\n          a7[11] = v16;\n          v26 = v16;\n        }\n      }\n      else if ( v16 != v26 )\n      {\n        v48 = a6;\n        sub_4121E0(a2, a7);\n        v26 = *a7;\n        a6 = v48;\n      }\n      if ( a1 <= v26 )\n      {\nLABEL_79:\n        v16 = v26;\n      }\n      else\n      {\n        v27 = v26;\n        while ( 1 )\n        {\n          v28 = (_BYTE *)v11[v27];\n          v29 = v27;\n          v26 = v27;\n          if ( *v28 == 45 )\n          {\n            if ( v28[1] )\n              break;\n          }\n          v26 = ++v27;\n          *a7 = v29 + 1;\n          if ( a1 <= (int)v27 )\n            goto LABEL_79;\n        }\n        v16 = *a7;\n      }\n      a7[12] = v26;\n    }\n    if ( a1 == v16 )\n    {\n      v10 = a7[12];\n      v18 = a7[11];\nLABEL_41:\n      if ( v18 != v10 )\n        *a7 = v18;\n      return (unsigned int)-1;\n    }\n    v17 = (_BYTE *)v11[v16];\n    if ( !strcmp((const char *)v11[v16], \"--\") )\n    {\n      v18 = a7[11];\n      v19 = a7[12];\n      v20 = v16 + 1;\n      *a7 = v20;\n      if ( v18 == v19 )\n      {\n        a7[11] = v20;\n        v18 = v20;\n      }\n      else if ( v20 != v19 )\n      {\n        sub_4121E0((__int64)v11, a7);\n        v18 = a7[11];\n      }\n      a7[12] = a1;\n      *a7 = a1;\n      goto LABEL_41;\n    }\n    if ( *v17 == 45 )\n    {\n      v30 = v17[1];\n      if ( v30 )\n      {\n        if ( v45 )\n        {\n          if ( v30 == 45 )\n          {\n            *((_QWORD *)a7 + 4) = v17 + 2;\n            return (unsigned int)sub_4122C0(a1, v11, v12, v45, v46, a6, a7, v8, (__int64)\"--\");\n          }\n          if ( a6 )\n          {\n            if ( v17[2] || (v49 = a6, v31 = strchr(v12, v30), a6 = v49, !v31) )\n            {\n              *((_QWORD *)a7 + 4) = v17 + 1;\n              v21 = sub_4122C0(a1, v11, v12, v45, v46, a6, a7, v8, 4292938LL);\n              if ( v21 != -1 )\n                return v21;\n              v17 = (_BYTE *)v11[*a7];\n            }\n          }\n        }\n        v13 = v17 + 1;\n        goto LABEL_29;\n      }\n    }\n    if ( a7[10] )\n    {\n      *((_QWORD *)a7 + 2) = v17;\n      v21 = 1;\n      *a7 = v16 + 1;\n      return v21;\n    }\n    return (unsigned int)-1;\n  }\nLABEL_29:\n  v51 = v13;\n  *((_QWORD *)a7 + 4) = v13 + 1;\n  v21 = (char)*v13;\n  v52 = (__int64)(v13 + 1);\n  v47 = *v13;\n  v22 = strchr(v12, v21);\n  v23 = v52;\n  if ( !v51[1] )\n    ++*a7;\n  if ( (unsigned __int8)(v47 - 58) > 1u && v22 )\n  {\n    v24 = v22[1];\n    if ( *v22 == 87 && v45 && v24 == 59 )\n    {\n      if ( v51[1] )\n      {\nLABEL_68:\n        *((_QWORD *)a7 + 4) = v23;\n        *((_QWORD *)a7 + 2) = 0LL;\n        return (unsigned int)sub_4122C0(a1, v11, v12, v45, v46, 0, a7, v8, (__int64)\"-W \");\n      }\n      v32 = *a7;\n      if ( (_DWORD)v32 != a1 )\n      {\n        v23 = v11[v32];\n        goto LABEL_68;\n      }\n      if ( v8 )\n      {\n        v43 = *v11;\n        v44 = dcgettext(0LL, \"%s: option requires an argument -- '%c'\\n\", 5);\n        __fprintf_chk(stderr, 1LL, v44, v43);\n      }\n      a7[2] = v21;\n      v21 = 5 * (*v12 != 58) + 58;\n    }\n    else if ( v24 == 58 )\n    {\n      v35 = v51[1];\n      if ( v22[2] == 58 )\n      {\n        if ( v35 )\n        {\n          *((_QWORD *)a7 + 2) = v52;\n          ++*a7;\n        }\n        else\n        {\n          *((_QWORD *)a7 + 2) = 0LL;\n        }\n      }\n      else\n      {\n        v36 = *a7;\n        if ( v35 )\n        {\n          *((_QWORD *)a7 + 2) = v52;\n          *a7 = v36 + 1;\n        }\n        else if ( a1 == (_DWORD)v36 )\n        {\n          if ( v8 )\n          {\n            v41 = *v11;\n            v42 = dcgettext(0LL, \"%s: option requires an argument -- '%c'\\n\", 5);\n            __fprintf_chk(stderr, 1LL, v42, v41);\n          }\n          a7[2] = v21;\n          v21 = 5 * (*v12 != 58) + 58;\n        }\n        else\n        {\n          v37 = v36 + 1;\n          v38 = v11[v36];\n          *a7 = v37;\n          *((_QWORD *)a7 + 2) = v38;\n        }\n      }\n      *((_QWORD *)a7 + 4) = 0LL;\n    }\n  }\n  else\n  {\n    if ( v8 )\n    {\n      v39 = *v11;\n      v40 = dcgettext(0LL, \"%s: invalid option -- '%c'\\n\", 5);\n      __fprintf_chk(stderr, 1LL, v40, v39);\n    }\n    a7[2] = v21;\n    v21 = 63;\n  }\n  return v21;\n}\n", 
            "funcStartAddr": "0x4128e0L", 
            "funcEndAddr": "0x412ea6L", 
            "funcName": "sub_4128E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412EB0(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int a6, int a7)\n{\n  __int64 result; // rax\n\n  dword_61CD20 = dword_61C57C;\n  dword_61CD24 = dword_61C578;\n  result = sub_4128E0(a1, a2, a3, a4, a5, a6, &dword_61CD20, a7);\n  dword_61C57C = dword_61CD20;\n  nptr = (char *)qword_61CD30;\n  dword_61C574 = dword_61CD28;\n  return result;\n}\n", 
            "funcStartAddr": "0x412eb0L", 
            "funcEndAddr": "0x412f06L", 
            "funcName": "sub_412EB0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412F10(int a1, __int64 a2, char *a3)\n{\n  return sub_412EB0(a1, a2, a3, 0LL, 0LL, 0, 1);\n}\n", 
            "funcStartAddr": "0x412f10L", 
            "funcEndAddr": "0x412f28L", 
            "funcName": "sub_412F10"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412F30(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5)\n{\n  return sub_412EB0(a1, a2, a3, a4, a5, 0, 0);\n}\n", 
            "funcStartAddr": "0x412f30L", 
            "funcEndAddr": "0x412f43L", 
            "funcName": "sub_412F30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412F50(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int *a6)\n{\n  return sub_4128E0(a1, a2, a3, a4, a5, 0, a6, 0);\n}\n", 
            "funcStartAddr": "0x412f50L", 
            "funcEndAddr": "0x412f65L", 
            "funcName": "sub_412F50"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412F70(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5)\n{\n  return sub_412EB0(a1, a2, a3, a4, a5, 1, 0);\n}\n", 
            "funcStartAddr": "0x412f70L", 
            "funcEndAddr": "0x412f86L", 
            "funcName": "sub_412F70"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_412F90(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int *a6)\n{\n  return sub_4128E0(a1, a2, a3, a4, a5, 1, a6, 0);\n}\n", 
            "funcStartAddr": "0x412f90L", 
            "funcEndAddr": "0x412fa8L", 
            "funcName": "sub_412F90"
        }, 
        {
            "decompiledFuncCode": "size_t __fastcall sub_412FB0(wchar_t *pwc, char *s, size_t a3, mbstate_t *a4)\n{\n  size_t v4; // rbx\n  wchar_t *v5; // r12\n  char *v6; // rbp\n  char v8; // [rsp+Ch] [rbp-1Ch]\n\n  if ( !s )\n  {\n    a3 = 1LL;\n    v6 = \"Ordering options:\\n\\n\" + 19;\nLABEL_7:\n    v5 = (wchar_t *)&v8;\n    goto LABEL_4;\n  }\n  v4 = -2LL;\n  if ( !a3 )\n    return v4;\n  v5 = pwc;\n  v6 = s;\n  if ( !pwc )\n    goto LABEL_7;\nLABEL_4:\n  v4 = mbrtowc(v5, v6, a3, a4);\n  if ( v4 > 0xFFFFFFFFFFFFFFFDLL && !sub_40BD10(0) )\n  {\n    v4 = 1LL;\n    *v5 = (unsigned __int8)*v6;\n  }\n  return v4;\n}\n", 
            "funcStartAddr": "0x412fb0L", 
            "funcEndAddr": "0x41302aL", 
            "funcName": "sub_412FB0"
        }, 
        {
            "decompiledFuncCode": "_BYTE *__fastcall sub_413030(_BYTE *a1, __int16 a2, unsigned __int64 a3)\n{\n  _BYTE *result; // rax\n  __int64 v4; // r9\n  __int64 v5; // rcx\n  _BYTE *v6; // rdi\n\n  if ( !a3 )\n    return 0LL;\n  if ( (unsigned __int8)a1 & 7 )\n  {\n    if ( (_BYTE)a2 == *a1 )\n      return a1;\n    while ( 1 )\n    {\n      ++a1;\n      if ( !--a3 )\n        return 0LL;\n      if ( !((unsigned __int8)a1 & 7) )\n        break;\n      if ( *a1 == (_BYTE)a2 )\n        return a1;\n    }\n  }\n  v4 = ((((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 32) | ((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8);\n  if ( a3 > 7 && !(((v4 ^ *(_QWORD *)a1) - 72340172838076673LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL) )\n  {\n    while ( 1 )\n    {\n      a3 -= 8LL;\n      a1 += 8;\n      if ( a3 <= 7 )\n        break;\n      if ( ((v4 ^ *(_QWORD *)a1) - 72340172838076673LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL )\n        goto LABEL_15;\n    }\n    if ( !a3 )\n      return 0LL;\n  }\nLABEL_15:\n  if ( (_BYTE)a2 != *a1 )\n  {\n    v5 = (__int64)(a1 + 1);\n    v6 = &a1[a3];\n    while ( 1 )\n    {\n      result = (_BYTE *)v5;\n      if ( (_BYTE *)v5 == v6 )\n        break;\n      if ( *(_BYTE *)(++v5 - 1) == (_BYTE)a2 )\n        return result;\n    }\n    return 0LL;\n  }\n  return a1;\n}\n", 
            "funcStartAddr": "0x413030L", 
            "funcEndAddr": "0x413134L", 
            "funcName": "sub_413030"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_413140(__int64 *a1, struct timespec *a2)\n{\n  __int64 v2; // rbx\n  int result; // eax\n  __int64 v4; // [rsp+0h] [rbp-28h]\n  __int64 v5; // [rsp+8h] [rbp-20h]\n\n  if ( (unsigned __int64)a1[1] > 0x3B9AC9FF )\n  {\n    *__errno_location() = 22;\n    result = -1;\n  }\n  else\n  {\n    v2 = *a1;\n    v5 = a1[1];\n    if ( v2 > 2073600 )\n    {\n      while ( 1 )\n      {\n        v4 = 2073600LL;\n        v2 -= 2073600LL;\n        result = nanosleep((const struct timespec *)&v4, a2);\n        if ( result )\n          break;\n        v5 = 0LL;\n        if ( v2 <= 2073600 )\n          goto LABEL_8;\n      }\n      if ( a2 )\n        a2->tv_sec += v2;\n    }\n    else\n    {\nLABEL_8:\n      v4 = v2;\n      result = nanosleep((const struct timespec *)&v4, a2);\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x413140L", 
            "funcEndAddr": "0x4131e2L", 
            "funcName": "sub_413140"
        }, 
        {
            "decompiledFuncCode": "void __noreturn sub_4131F0()\n{\n  char *v0; // rax\n\n  v0 = dcgettext(0LL, \"memory exhausted\", 5);\n  __fprintf_chk(stderr, 1LL, 4291023LL, v0);\n  exit(status);\n}\n", 
            "funcStartAddr": "0x4131f0L", 
            "funcEndAddr": "0x41322bL", 
            "funcName": "sub_4131F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413230(__int64 a1, __int64 a2)\n{\n  __int64 (__fastcall *v2)(__int64); // rax\n  __int64 result; // rax\n\n  v2 = *(__int64 (__fastcall **)(__int64))(a1 + 56);\n  if ( *(_BYTE *)(a1 + 80) & 1 )\n    result = v2(*(_QWORD *)(a1 + 72));\n  else\n    result = v2(a2);\n  return result;\n}\n", 
            "funcStartAddr": "0x413230L", 
            "funcEndAddr": "0x413245L", 
            "funcName": "sub_413230"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413250(__int64 a1, __int64 a2)\n{\n  __int64 (__fastcall *v2)(__int64); // rax\n  __int64 result; // rax\n\n  v2 = *(__int64 (__fastcall **)(__int64))(a1 + 64);\n  if ( *(_BYTE *)(a1 + 80) & 1 )\n    result = v2(*(_QWORD *)(a1 + 72));\n  else\n    result = v2(a2);\n  return result;\n}\n", 
            "funcStartAddr": "0x413250L", 
            "funcEndAddr": "0x413265L", 
            "funcName": "sub_413250"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n", 
            "funcStartAddr": "0x4132e0L", 
            "funcEndAddr": "0x4132f3L", 
            "funcName": "_obstack_begin"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n", 
            "funcStartAddr": "0x4132e0L", 
            "funcEndAddr": "0x4132f3L", 
            "funcName": "_obstack_begin"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n", 
            "funcStartAddr": "0x4132e0L", 
            "funcEndAddr": "0x4132f3L", 
            "funcName": "_obstack_begin"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_begin_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rbp\n  __int64 v7; // r12\n  _QWORD *v8; // rax\n  __int64 v9; // rbp\n  __int64 v10; // rdx\n  char *v11; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) |= 1u;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  *(_QWORD *)(a1 + 72) = a6;\n  if ( !a3 )\n    JUMPOUT(0x4132E0LL);\n  v6 = a3;\n  v7 = a3 - 1;\n  *(_QWORD *)(a1 + 48) = a3 - 1;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v8 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v8;\n  if ( !v8 )\n    JUMPOUT(0x4132EDLL);\n  v9 = ((unsigned __int64)v8 + v7 + 16) & -v6;\n  v10 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v9;\n  v11 = (char *)v8 + v10;\n  *(_QWORD *)(a1 + 24) = v9;\n  *v8 = v11;\n  *(_QWORD *)(a1 + 32) = v11;\n  v8[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n", 
            "funcStartAddr": "0x413270L", 
            "funcEndAddr": "0x4132ddL", 
            "funcName": "_obstack_begin_1"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_begin_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rbp\n  __int64 v7; // r12\n  _QWORD *v8; // rax\n  __int64 v9; // rbp\n  __int64 v10; // rdx\n  char *v11; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) |= 1u;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  *(_QWORD *)(a1 + 72) = a6;\n  if ( !a3 )\n    JUMPOUT(0x4132E0LL);\n  v6 = a3;\n  v7 = a3 - 1;\n  *(_QWORD *)(a1 + 48) = a3 - 1;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v8 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v8;\n  if ( !v8 )\n    JUMPOUT(0x4132EDLL);\n  v9 = ((unsigned __int64)v8 + v7 + 16) & -v6;\n  v10 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v9;\n  v11 = (char *)v8 + v10;\n  *(_QWORD *)(a1 + 24) = v9;\n  *v8 = v11;\n  *(_QWORD *)(a1 + 32) = v11;\n  v8[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n\n__int64 __fastcall obstack_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // rbp\n  __int64 v6; // r12\n  _QWORD *v7; // rax\n  __int64 v8; // rbp\n  __int64 v9; // rdx\n  char *v10; // rdx\n  __int64 result; // rax\n\n  *(_BYTE *)(a1 + 80) &= 0xFEu;\n  *(_QWORD *)(a1 + 56) = a4;\n  *(_QWORD *)(a1 + 64) = a5;\n  if ( a3 )\n  {\n    v5 = a3;\n    v6 = a3 - 1;\n  }\n  else\n  {\n    v6 = 15LL;\n    v5 = 16LL;\n  }\n  *(_QWORD *)(a1 + 48) = v6;\n  if ( !a2 )\n    a2 = 4064LL;\n  *(_QWORD *)a1 = a2;\n  v7 = (_QWORD *)sub_413230(a1, a2);\n  *(_QWORD *)(a1 + 8) = v7;\n  if ( !v7 )\n    obstack_alloc_failed_handler();\n  v8 = ((unsigned __int64)v7 + v6 + 16) & -v5;\n  v9 = *(_QWORD *)a1;\n  *(_QWORD *)(a1 + 16) = v8;\n  v10 = (char *)v7 + v9;\n  *(_QWORD *)(a1 + 24) = v8;\n  *v7 = v10;\n  *(_QWORD *)(a1 + 32) = v10;\n  v7[1] = 0LL;\n  result = 1LL;\n  *(_BYTE *)(a1 + 80) &= 0xF9u;\n  return result;\n}\n", 
            "funcStartAddr": "0x413270L", 
            "funcEndAddr": "0x4132ddL", 
            "funcName": "_obstack_begin_1"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_newchunk(__int64 a1, __int64 a2, __int64 a3, _BOOL8 a4)\n{\n  size_t v4; // r13\n  __int64 v5; // rbp\n  size_t v6; // rsi\n  _BOOL8 v7; // rax\n  bool v8; // cf\n  unsigned __int64 v9; // rsi\n  size_t v10; // rdx\n  unsigned __int64 v11; // rbx\n  _QWORD *v12; // rax\n  _QWORD *v13; // r14\n  char *v14; // rbx\n  __int64 result; // rax\n\n  v4 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);\n  v5 = *(_QWORD *)(a1 + 8);\n  v8 = __CFADD__(v4, a2);\n  v6 = v4 + a2;\n  v7 = v8;\n  v8 = __CFADD__(*(_QWORD *)(a1 + 48), v6);\n  v9 = *(_QWORD *)(a1 + 48) + v6;\n  LOBYTE(a4) = v8;\n  v10 = v4 >> 3;\n  v11 = v9 + (v4 >> 3) + 100;\n  if ( *(_QWORD *)a1 >= v9 )\n    v9 = *(_QWORD *)a1;\n  if ( v9 >= v11 )\n    v11 = v9;\n  if ( v7 || (a4 = v8) || (v9 = v11, v12 = (_QWORD *)sub_413230(a1, v11), (v13 = v12) == 0LL) )\n    obstack_alloc_failed_handler(a1, v9, v10, a4);\n  *(_QWORD *)(a1 + 8) = v12;\n  v12[1] = v5;\n  *(_QWORD *)(a1 + 32) = (char *)v12 + v11;\n  *v12 = (char *)v12 + v11;\n  v14 = (char *)(~*(_QWORD *)(a1 + 48) & ((unsigned __int64)v12 + *(_QWORD *)(a1 + 48) + 16));\n  result = (__int64)memcpy(v14, *(const void **)(a1 + 16), v4);\n  if ( !(*(_BYTE *)(a1 + 80) & 2) )\n  {\n    result = (v5 + *(_QWORD *)(a1 + 48) + 16) & ~*(_QWORD *)(a1 + 48);\n    if ( *(_QWORD *)(a1 + 16) == result )\n    {\n      v13[1] = *(_QWORD *)(v5 + 8);\n      result = sub_413250(a1, v5);\n    }\n  }\n  *(_QWORD *)(a1 + 16) = v14;\n  *(_QWORD *)(a1 + 24) = &v14[v4];\n  *(_BYTE *)(a1 + 80) &= 0xFDu;\n  return result;\n}\n", 
            "funcStartAddr": "0x413340L", 
            "funcEndAddr": "0x41343bL", 
            "funcName": "_obstack_newchunk"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall obstack_allocated_p(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 result; // rax\n\n  result = *(_QWORD *)(a1 + 8);\n  if ( result )\n  {\n    while ( a2 <= result || *(_QWORD *)result < a2 )\n    {\n      result = *(_QWORD *)(result + 8);\n      if ( !result )\n        return 0LL;\n    }\n    result = 1LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x413440L", 
            "funcEndAddr": "0x413477L", 
            "funcName": "_obstack_allocated_p"
        }, 
        {
            "decompiledFuncCode": "void obstack_free(struct obstack *obstack, void *block)\n{\n  char *v2; // rbp\n  struct _obstack_chunk *v3; // rsi\n  char *v4; // rax\n  struct _obstack_chunk *v5; // r12\n\n  v2 = (char *)block;\n  v3 = obstack->chunk;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      if ( v3 < (struct _obstack_chunk *)v2 )\n      {\n        v4 = v3->limit;\n        if ( v3->limit >= v2 )\n          break;\n      }\n      v5 = v3->prev;\n      sub_413250((__int64)obstack, (__int64)v3);\n      *((_BYTE *)obstack + 80) |= 2u;\n      v3 = v5;\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    obstack->next_free = v2;\n    obstack->object_base = v2;\n    obstack->chunk_limit = v4;\n    obstack->chunk = v3;\n  }\n  else\n  {\nLABEL_5:\n    if ( v2 )\n      abort();\n  }\n}\n\nvoid obstack_free(struct obstack *obstack, void *block)\n{\n  char *v2; // rbp\n  struct _obstack_chunk *v3; // rsi\n  char *v4; // rax\n  struct _obstack_chunk *v5; // r12\n\n  v2 = (char *)block;\n  v3 = obstack->chunk;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      if ( v3 < (struct _obstack_chunk *)v2 )\n      {\n        v4 = v3->limit;\n        if ( v3->limit >= v2 )\n          break;\n      }\n      v5 = v3->prev;\n      sub_413250((__int64)obstack, (__int64)v3);\n      *((_BYTE *)obstack + 80) |= 2u;\n      v3 = v5;\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    obstack->next_free = v2;\n    obstack->object_base = v2;\n    obstack->chunk_limit = v4;\n    obstack->chunk = v3;\n  }\n  else\n  {\nLABEL_5:\n    if ( v2 )\n      abort();\n  }\n}\n", 
            "funcStartAddr": "0x402f3cL", 
            "funcEndAddr": "0x402f41L", 
            "funcName": "_obstack_free"
        }, 
        {
            "decompiledFuncCode": "void obstack_free(struct obstack *obstack, void *block)\n{\n  char *v2; // rbp\n  struct _obstack_chunk *v3; // rsi\n  char *v4; // rax\n  struct _obstack_chunk *v5; // r12\n\n  v2 = (char *)block;\n  v3 = obstack->chunk;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      if ( v3 < (struct _obstack_chunk *)v2 )\n      {\n        v4 = v3->limit;\n        if ( v3->limit >= v2 )\n          break;\n      }\n      v5 = v3->prev;\n      sub_413250((__int64)obstack, (__int64)v3);\n      *((_BYTE *)obstack + 80) |= 2u;\n      v3 = v5;\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    obstack->next_free = v2;\n    obstack->object_base = v2;\n    obstack->chunk_limit = v4;\n    obstack->chunk = v3;\n  }\n  else\n  {\nLABEL_5:\n    if ( v2 )\n      abort();\n  }\n}\n\nvoid obstack_free(struct obstack *obstack, void *block)\n{\n  char *v2; // rbp\n  struct _obstack_chunk *v3; // rsi\n  char *v4; // rax\n  struct _obstack_chunk *v5; // r12\n\n  v2 = (char *)block;\n  v3 = obstack->chunk;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      if ( v3 < (struct _obstack_chunk *)v2 )\n      {\n        v4 = v3->limit;\n        if ( v3->limit >= v2 )\n          break;\n      }\n      v5 = v3->prev;\n      sub_413250((__int64)obstack, (__int64)v3);\n      *((_BYTE *)obstack + 80) |= 2u;\n      v3 = v5;\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    obstack->next_free = v2;\n    obstack->object_base = v2;\n    obstack->chunk_limit = v4;\n    obstack->chunk = v3;\n  }\n  else\n  {\nLABEL_5:\n    if ( v2 )\n      abort();\n  }\n}\n", 
            "funcStartAddr": "0x402f3cL", 
            "funcEndAddr": "0x402f41L", 
            "funcName": "_obstack_free"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall obstack_memory_used(__int64 a1)\n{\n  _QWORD *v1; // rdx\n  __int64 result; // rax\n  __int64 v3; // rcx\n\n  v1 = *(_QWORD **)(a1 + 8);\n  for ( result = 0LL; v1; result += v3 )\n  {\n    v3 = *v1 - (_QWORD)v1;\n    v1 = (_QWORD *)v1[1];\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4134f0L", 
            "funcEndAddr": "0x413519L", 
            "funcName": "_obstack_memory_used"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_413520(FILE *stream)\n{\n  size_t v1; // r12\n  int v2; // ebx\n  int result; // eax\n\n  v1 = __fpending(stream);\n  v2 = stream->_flags & 0x20;\n  result = sub_411F80(stream);\n  if ( v2 )\n  {\n    if ( !result )\n    {\n      *__errno_location() = 0;\n      return -1;\n    }\n  }\n  else\n  {\n    if ( !result )\n      return result;\n    if ( !v1 )\n      return -(*__errno_location() != 9);\n  }\n  return -1;\n}\n", 
            "funcStartAddr": "0x413520L", 
            "funcEndAddr": "0x41357dL", 
            "funcName": "sub_413520"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413580(double a1)\n{\n  __int64 result; // rax\n  __int64 v2; // rsi\n  signed __int64 v3; // rcx\n\n  if ( a1 <= -9.223372036854776e18 )\n    return 0x8000000000000000LL;\n  if ( a1 >= 9.223372036854776e18 )\n    return 0x7FFFFFFFFFFFFFFFLL;\n  v2 = (unsigned int)(int)a1;\n  v3 = (unsigned int)(int)((a1 - (double)(int)v2) * 1000000000.0)\n     + (unsigned __int64)((a1 - (double)(int)v2) * 1000000000.0 > (double)(int)((a1 - (double)(int)v2) * 1000000000.0));\n  result = v3 / 1000000000 + v2;\n  if ( v3 % 1000000000 < 0 )\n    --result;\n  return result;\n}\n", 
            "funcStartAddr": "0x413580L", 
            "funcEndAddr": "0x41363cL", 
            "funcName": "sub_413580"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413690(char a1, int a2)\n{\n  int v2; // esi\n\n  v2 = a2 & 0x80000;\n  if ( v2 )\n    v2 = 1030;\n  return sub_412000(a1, v2, 3LL);\n}\n", 
            "funcStartAddr": "0x413690L", 
            "funcEndAddr": "0x4136aaL", 
            "funcName": "sub_413690"
        }, 
        {
            "decompiledFuncCode": "FILE *__fastcall sub_4136B0(const char *a1, const char *a2)\n{\n  FILE *v2; // rax\n  FILE *v3; // rbx\n  unsigned int v4; // eax\n  int v6; // er12\n  int *v7; // rax\n  int v8; // ebp\n  int *v9; // rbx\n  int *v10; // rax\n  FILE *v11; // rdi\n  int v12; // er12\n  int *v13; // rbp\n\n  v2 = fopen(a1, a2);\n  v3 = v2;\n  if ( v2 )\n  {\n    v4 = fileno(v2);\n    if ( v4 <= 2 )\n    {\n      v6 = sub_413EA0(v4);\n      if ( v6 < 0 )\n      {\n        v10 = __errno_location();\n        v11 = v3;\n        v3 = 0LL;\n        v12 = *v10;\n        v13 = v10;\n        sub_411F80(v11);\n        *v13 = v12;\n      }\n      else if ( sub_411F80(v3) || (v3 = fdopen(v6, a2)) == 0LL )\n      {\n        v7 = __errno_location();\n        v8 = *v7;\n        v9 = v7;\n        close(v6);\n        *v9 = v8;\n        v3 = 0LL;\n      }\n    }\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x4136b0L", 
            "funcEndAddr": "0x413743L", 
            "funcName": "sub_4136B0"
        }, 
        {
            "decompiledFuncCode": "const char *sub_413750()\n{\n  char *v0; // rax\n  char *v1; // r15\n  const char *v2; // rbx\n  char v3; // bp\n  size_t v4; // rax\n  char *v6; // rax\n  const char *v7; // r13\n  size_t v8; // rax\n  __int64 v9; // r12\n  size_t v10; // r14\n  size_t v11; // rdi\n  char *v12; // rax\n  char *v13; // rbp\n  size_t v14; // rdi\n  char *v15; // rax\n  int v16; // eax\n  int v17; // er12\n  FILE *v18; // r13\n  const char *v19; // rax\n  FILE *v20; // rbx\n  const char *v21; // r13\n  char *v22; // rax\n  int v23; // edi\n  char *v24; // kr00_8\n  char *v25; // rdx\n  int v26; // esi\n  unsigned int v27; // eax\n  __int64 v28; // rdx\n  signed __int64 v29; // rax\n  char *v30; // rax\n  signed __int64 v31; // rcx\n  __int64 v32; // rdx\n  __int64 v33; // rsi\n  unsigned int v34; // ecx\n  __int64 v35; // rdi\n  char *v36; // rsi\n  unsigned int v37; // edx\n  char *v38; // rcx\n  FILE *v39; // rdi\n  int v40; // eax\n  bool v41; // dl\n  char *v42; // rax\n  __int64 v43; // rax\n  unsigned __int64 v44; // r9\n  char *v45; // rsi\n  char *v46; // r10\n  unsigned int v47; // ecx\n  unsigned int v48; // ecx\n  unsigned int v49; // esi\n  __int64 v50; // r8\n  unsigned __int64 v51; // rdi\n  char *v52; // rcx\n  char *v53; // r9\n  unsigned int v54; // edx\n  unsigned int v55; // edx\n  unsigned int v56; // ecx\n  __int64 v57; // rsi\n  const char *v58; // rax\n  char *v59; // rdi\n  FILE *v60; // r13\n  __int64 v61; // [rsp+8h] [rbp-D0h]\n  __int64 v62; // [rsp+18h] [rbp-C0h]\n  char v63[64]; // [rsp+20h] [rbp-B8h]\n  char v64[120]; // [rsp+60h] [rbp-78h]\n\n  v0 = nl_langinfo(14);\n  v1 = s;\n  v2 = v0;\n  if ( !v0 )\n    v2 = \"\";\n  if ( !s )\n  {\n    v6 = getenv(\"CHARSETALIASDIR\");\n    v7 = v6;\n    if ( v6 && *v6 )\n    {\n      v8 = strlen(v6);\n      v9 = v8;\n      v10 = v8;\n      if ( !v8 )\n      {\n        v11 = 14LL;\nLABEL_18:\n        v12 = (char *)malloc(v11);\n        v13 = v12;\n        if ( !v12 )\n        {\nLABEL_19:\n          v1 = \"Ordering options:\\n\\n\" + 19;\nLABEL_20:\n          s = v1;\n          goto LABEL_4;\n        }\n        memcpy(v12, v7, v10);\nLABEL_24:\n        strcpy(&v13[v9], \"charset.alias\");\n        v16 = open(v13, 0);\n        v17 = v16;\n        if ( v16 >= 0 )\n        {\n          v1 = 0LL;\n          v61 = 0LL;\n          v18 = fdopen(v16, \"r\");\n          if ( v18 )\n          {\n            v19 = v2;\n            v20 = v18;\n            v21 = v19;\nLABEL_30:\n            v22 = v20->_IO_read_ptr;\n            if ( v22 < v20->_IO_read_end )\n            {\nLABEL_31:\n              v20->_IO_read_ptr = v22 + 1;\n              v23 = (unsigned __int8)*v22;\n              goto LABEL_32;\n            }\n            while ( 1 )\n            {\n              v23 = __uflow(v20);\n              if ( v23 == -1 )\n                break;\nLABEL_32:\n              if ( (unsigned int)(v23 - 9) <= 1 || v23 == 32 )\n                goto LABEL_30;\n              if ( v23 == 35 )\n              {\n                do\n                {\n                  v42 = v20->_IO_read_ptr;\n                  if ( v42 < v20->_IO_read_end )\n                  {\n                    v20->_IO_read_ptr = v42 + 1;\n                    v40 = (unsigned __int8)*v42;\n                    v41 = 1;\n                  }\n                  else\n                  {\n                    v40 = __uflow(v20);\n                    v41 = v40 != -1;\n                  }\n                }\n                while ( v40 != 10 && v41 );\n                if ( v40 == -1 )\n                  break;\n                goto LABEL_30;\n              }\n              ungetc(v23, v20);\n              if ( fscanf(v20, \"%50s %50s\", v63, v64) <= 1 )\n                break;\n              v24 = &v63[strlen(v63)];\n              v25 = v64;\n              do\n              {\n                v26 = *(_DWORD *)v25;\n                v25 += 4;\n                v27 = ~v26 & (v26 - 16843009) & 0x80808080;\n              }\n              while ( !v27 );\n              if ( !(~v26 & (v26 - 16843009) & 0x8080) )\n                v27 >>= 16;\n              if ( !(~v26 & (v26 - 16843009) & 0x8080) )\n                v25 += 2;\n              v28 = &v25[-__CFADD__((_BYTE)v27, (_BYTE)v27) - 3] - v64;\n              v29 = v24 - v63 + v28;\n              v62 = v28;\n              if ( v61 )\n              {\n                v43 = v61 + v29;\n                v61 = v43 + 2;\n                v30 = (char *)realloc(v1, v43 + 3);\n                v32 = v62;\n                v31 = v24 - v63;\n              }\n              else\n              {\n                v61 = v29 + 2;\n                v30 = (char *)malloc(v29 + 3);\n                v31 = v24 - v63;\n                v32 = v62;\n              }\n              if ( !v30 )\n              {\n                v58 = v21;\n                v59 = v1;\n                v60 = v20;\n                v1 = \"Ordering options:\\n\\n\" + 19;\n                v2 = v58;\n                free(v59);\n                sub_411F80(v60);\n                goto LABEL_26;\n              }\n              v33 = -2 - v31;\n              v34 = v31 + 1;\n              v35 = v61 - v32;\n              v36 = &v30[v61 - v32 + v33];\n              if ( v34 >= 8 )\n              {\n                *(_QWORD *)v36 = *(_QWORD *)v63;\n                *(_QWORD *)&v36[v34 - 8] = *(_QWORD *)&v63[v34 - 8];\n                v44 = (unsigned __int64)(v36 + 8) & 0xFFFFFFFFFFFFFFF8LL;\n                v45 = &v36[-v44];\n                v46 = (char *)(v63 - v45);\n                v47 = ((_DWORD)v45 + v34) & 0xFFFFFFF8;\n                if ( v47 >= 8 )\n                {\n                  v48 = v47 & 0xFFFFFFF8;\n                  v49 = 0;\n                  do\n                  {\n                    v50 = v49;\n                    v49 += 8;\n                    *(_QWORD *)(v44 + v50) = *(_QWORD *)&v46[v50];\n                  }\n                  while ( v49 < v48 );\n                }\n              }\n              else if ( v34 & 4 )\n              {\n                *(_DWORD *)v36 = *(_DWORD *)v63;\n                *(_DWORD *)&v36[v34 - 4] = *(_DWORD *)&v63[v34 - 4];\n              }\n              else if ( v34 )\n              {\n                *v36 = v63[0];\n                if ( v34 & 2 )\n                  *(_WORD *)&v36[v34 - 2] = *(_WORD *)&v63[v34 - 2];\n              }\n              v37 = v32 + 1;\n              v38 = &v30[v35 - 1];\n              if ( v37 >= 8 )\n              {\n                *(_QWORD *)v38 = *(_QWORD *)v64;\n                *(_QWORD *)&v38[v37 - 8] = *(_QWORD *)&v64[v37 - 8];\n                v51 = (unsigned __int64)(v38 + 8) & 0xFFFFFFFFFFFFFFF8LL;\n                v52 = &v38[-v51];\n                v53 = (char *)(v64 - v52);\n                v54 = ((_DWORD)v52 + v37) & 0xFFFFFFF8;\n                if ( v54 >= 8 )\n                {\n                  v55 = v54 & 0xFFFFFFF8;\n                  v56 = 0;\n                  do\n                  {\n                    v57 = v56;\n                    v56 += 8;\n                    *(_QWORD *)(v51 + v57) = *(_QWORD *)&v53[v57];\n                  }\n                  while ( v56 < v55 );\n                }\n              }\n              else if ( v37 & 4 )\n              {\n                *(_DWORD *)v38 = *(_DWORD *)v64;\n                *(_DWORD *)&v38[v37 - 4] = *(_DWORD *)&v64[v37 - 4];\n              }\n              else if ( v37 )\n              {\n                *v38 = v64[0];\n                if ( v37 & 2 )\n                  *(_WORD *)&v38[v37 - 2] = *(_WORD *)&v64[v37 - 2];\n              }\n              v1 = v30;\n              v22 = v20->_IO_read_ptr;\n              if ( v22 < v20->_IO_read_end )\n                goto LABEL_31;\n            }\n            v39 = v20;\n            v2 = v21;\n            sub_411F80(v39);\n            if ( !v61 )\n              goto LABEL_25;\n            v1[v61] = 0;\n            goto LABEL_26;\n          }\n          close(v17);\n        }\nLABEL_25:\n        v1 = \"Ordering options:\\n\\n\" + 19;\nLABEL_26:\n        free(v13);\n        goto LABEL_20;\n      }\n      if ( v7[v8 - 1] == 47 )\n      {\n        v11 = v8 + 14;\n        goto LABEL_18;\n      }\n      v14 = v8 + 15;\n      v9 = v8 + 1;\n    }\n    else\n    {\n      v14 = 115LL;\n      v9 = 101LL;\n      v10 = 100LL;\n      v7 = \"/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib\";\n    }\n    v15 = (char *)malloc(v14);\n    v13 = v15;\n    if ( !v15 )\n      goto LABEL_19;\n    memcpy(v15, v7, v10);\n    v13[v10] = 47;\n    goto LABEL_24;\n  }\nLABEL_4:\n  v3 = *v1;\n  if ( *v1 )\n  {\n    while ( strcmp(v2, v1) && (v3 != 42 || v1[1]) )\n    {\n      v4 = strlen(v1);\n      v1 += v4 + strlen(&v1[v4 + 1]) + 2;\n      v3 = *v1;\n      if ( !*v1 )\n        goto LABEL_11;\n    }\n    v2 = &v1[strlen(v1) + 1];\n  }\nLABEL_11:\n  if ( !*v2 )\n    v2 = \"ASCII\";\n  return v2;\n}\n", 
            "funcStartAddr": "0x413750L", 
            "funcEndAddr": "0x413cb2L", 
            "funcName": "sub_413750"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_413CC0(char *s1, __int64 a2, const char *a3, __int64 a4)\n{\n  __int64 v4; // r14\n  __int64 v5; // r13\n  char *v6; // r12\n  const char *v7; // rbp\n  int *v8; // r15\n  size_t v9; // rbx\n  size_t v10; // rax\n  int result; // eax\n\n  v4 = a2;\n  v5 = a4;\n  v6 = s1;\n  v7 = a3;\n  v8 = __errno_location();\n  while ( 1 )\n  {\n    *v8 = 0;\n    result = strcoll(v6, v7);\n    if ( result )\n      break;\n    v9 = strlen(v6) + 1;\n    v6 += v9;\n    v10 = strlen(v7) + 1;\n    v7 += v10;\n    v5 -= v10;\n    v4 -= v9;\n    if ( !v4 )\n      return -(v5 != 0);\n    if ( !v5 )\n      return 1;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x413cc0L", 
            "funcEndAddr": "0x413d74L", 
            "funcName": "sub_413CC0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413D80(char *s1, size_t n, void *s2, __int64 a4)\n{\n  const char *v4; // r13\n  __int64 v5; // rbp\n  char v6; // r9\n  char v7; // r8\n  unsigned int v8; // edx\n  int *v10; // rax\n  char v11; // [rsp+8h] [rbp-40h]\n  char v12; // [rsp+Fh] [rbp-39h]\n\n  v4 = (const char *)s2;\n  v5 = a4;\n  if ( n == a4 && !memcmp(s1, s2, n) )\n  {\n    v10 = __errno_location();\n    v8 = 0;\n    *v10 = 0;\n  }\n  else\n  {\n    v6 = s1[n];\n    v7 = v4[v5];\n    s1[n] = 0;\n    v4[v5] = 0;\n    v12 = v6;\n    v11 = v7;\n    v8 = sub_413CC0(s1, n + 1, v4, v5 + 1);\n    s1[n] = v12;\n    v4[v5] = v11;\n  }\n  return v8;\n}\n", 
            "funcStartAddr": "0x413d80L", 
            "funcEndAddr": "0x413e21L", 
            "funcName": "sub_413D80"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_413E30(char *s1, size_t n, void *s2, __int64 a4)\n{\n  const char *v4; // r13\n  __int64 v5; // rbp\n\n  v4 = (const char *)s2;\n  v5 = a4;\n  if ( n != a4 || memcmp(s1, s2, n) )\n    return sub_413CC0(s1, n, v4, v5);\n  *__errno_location() = 0;\n  return 0;\n}\n", 
            "funcStartAddr": "0x413e30L", 
            "funcEndAddr": "0x413e93L", 
            "funcName": "sub_413E30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413EA0(char a1)\n{\n  return sub_412000(a1, 0, 3LL);\n}\n", 
            "funcStartAddr": "0x413ea0L", 
            "funcEndAddr": "0x413eaeL", 
            "funcName": "sub_413EA0"
        }, 
        {
            "decompiledFuncCode": "void init(void)\n{\n  init_proc();\n}\n", 
            "funcStartAddr": "0x413eb0L", 
            "funcEndAddr": "0x413f0dL", 
            "funcName": "init"
        }, 
        {
            "decompiledFuncCode": "void fini(void)\n{\n  ;\n}\n", 
            "funcStartAddr": "0x413f10L", 
            "funcEndAddr": "0x413f11L", 
            "funcName": "fini"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_413F20(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  v1 = 0LL;\n  if ( &unk_61C3E8 )\n    v1 = (void *)unk_61C3E8;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n", 
            "funcStartAddr": "0x413f20L", 
            "funcEndAddr": "0x413f38L", 
            "funcName": "sub_413F20"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_413F38(__int64 a1, __int64 a2, __int64 a3)\n{\n  void (**v3)(void); // rbx\n  __int64 v5; // [rsp-8h] [rbp-10h]\n\n  v3 = (void (**)(void))&qword_61BE20;\n  v5 = a3;\n  while ( *v3 != (void (*)(void))-1LL )\n  {\n    (*v3)();\n    --v3;\n  }\n  return v5;\n}\n", 
            "funcStartAddr": "0x413f38L", 
            "funcEndAddr": "0x413f58L", 
            "funcName": "sub_413F38"
        }
    ], 
    "binaryInfo": {
        "binaryName": "coreutils_strip-8.29_gcc-8.2.0_x86_64_O2_sort.elf", 
        "isStripped": "True"
    }, 
    "funcCount": 202, 
    "buildInfo": {
        "decompilerName": "IDA Pro", 
        "compilerVersion": "9.4.0", 
        "Optlevel": "-O", 
        "compilerName": "gcc"
    }
}