__int64 __usercall main@<rax>(char **a1@<rsi>, char **a2@<rdx>, int a3@<edi>, __int64 a4@<r13>)
{
  int v4; // ebp
  char *v5; // rdi
  int v6; // eax
  char *v7; // rdx
  char *v8; // rdi
  __int64 v9; // rax
  char **v10; // r12
  __int64 v11; // rbx
  int v12; // ebp
  int v13; // eax
  __int64 v14; // rdx
  unsigned int v15; // er14
  char *v16; // rax
  char *v17; // r8
  char *v18; // rax
  char *v19; // rax
  char v20; // r12
  int v21; // eax
  char *v22; // rdx
  char v23; // cl
  char *v24; // rax
  unsigned int v25; // ecx
  char v26; // r14
  __pid_t v27; // edi
  __int64 v28; // rcx
  void **v29; // rbp
  bool v30; // cf
  bool v31; // zf
  __int64 v32; // r8
  __int64 v33; // r9
  unsigned __int64 v34; // r12
  void **v35; // rax
  _BYTE *v36; // rsi
  __int64 v37; // rcx
  char *v38; // rdi
  __int64 v39; // rax
  void *v40; // rdx
  __int64 v41; // r15
  const char **v42; // r14
  const char *v43; // rax
  unsigned __int64 v44; // rsi
  __int64 v45; // rax
  __int64 v46; // rsi
  __int64 v47; // rdx
  __int64 v48; // rcx
  __int64 v49; // r8
  __int64 v50; // r9
  char *v51; // rax
  __int64 v52; // rdx
  __int64 v53; // rcx
  __int64 v54; // r8
  __int64 v55; // r9
  char *v56; // r14
  __int64 v57; // rsi
  size_t v58; // rbx
  __int64 v59; // rdi
  __int64 v60; // rbp
  unsigned int v61; // er12
  __int64 v62; // rsi
  __int64 v63; // rax
  __int64 v64; // rcx
  __int64 v65; // r8
  __int64 v66; // r9
  __int64 v67; // rdx
  __int64 v68; // rdi
  char *v69; // r12
  const char *v70; // rsi
  char *v71; // rax
  char *v72; // rax
  char *v73; // rax
  int v74; // eax
  char v75; // bl
  int *v76; // rax
  int *v77; // rbp
  int v78; // eax
  __int64 v79; // rax
  __int64 v80; // rdx
  __int64 v81; // rcx
  __int64 v82; // r8
  __int64 v83; // r9
  __int64 v84; // rbx
  char *v85; // rax
  __int64 result; // rax
  __int64 v87; // rdx
  __int64 v88; // rcx
  __int64 v89; // r8
  __int64 v90; // r9
  __int64 v91; // rcx
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rdx
  __int64 v95; // rcx
  __int64 v96; // r8
  __int64 v97; // r9
  __int64 v98; // rbp
  char *v99; // rbx
  int *v100; // rax
  unsigned int v101; // eax
  __int64 v102; // rax
  char *v103; // rdx
  unsigned __int64 v104; // rsi
  int v105; // eax
  const char *v106; // rdi
  __dev_t v107; // rcx
  __time_t v108; // rcx
  __syscall_slong_t v109; // rcx
  __int64 v110; // rax
  char *v111; // rbp
  char *v112; // rdx
  __int64 v113; // rcx
  __int64 v114; // r8
  __int64 v115; // r9
  __int64 v116; // rcx
  char *v117; // rdi
  char *v118; // rbx
  int *v119; // rax
  const char *v120; // rdi
  int *v121; // rbx
  __int64 v122; // rax
  __int64 v123; // rdx
  __int64 v124; // rcx
  __int64 v125; // r8
  __int64 v126; // r9
  __int64 v127; // rbp
  char *v128; // rax
  const char *v129; // rdi
  __int64 v130; // rax
  unsigned __int64 v131; // r12
  __int64 v132; // rax
  _QWORD *v133; // rbp
  __int64 v134; // rdx
  __int64 v135; // rcx
  __int64 v136; // r8
  __int64 v137; // r9
  _QWORD *v138; // r14
  _QWORD *v139; // rbx
  unsigned __int64 v140; // rax
  __int64 v141; // rax
  size_t v142; // rax
  __int64 v143; // rcx
  __int64 v144; // r8
  __int64 v145; // r9
  __int64 v146; // rdx
  size_t v147; // rsi
  unsigned int v148; // eax
  __int64 v149; // rbx
  char *v150; // rbp
  __int64 v151; // rbx
  char *v152; // rbp
  __off_t v153; // rbp
  signed __int64 v154; // rbx
  __blksize_t v155; // rax
  unsigned int v156; // er12
  char *v157; // rax
  __int64 v158; // rdi
  __int64 v159; // rbx
  __int64 v160; // rax
  __int64 v161; // rbx
  __int64 i; // rbx
  __off_t v163; // rbx
  signed __int64 v164; // rax
  __int64 v165; // rax
  unsigned __int64 v166; // rbp
  __int64 v167; // r12
  __int64 v168; // rbx
  int v169; // edi
  unsigned __int64 v170; // rsi
  bool v171; // dl
  __int64 v172; // rbx
  __int64 v173; // rax
  __int64 v174; // rax
  char v175; // cl
  char *v176; // rbx
  __int64 v177; // rax
  int v178; // eax
  int v179; // eax
  int v180; // edx
  __off_t v181; // rcx
  __int64 v182; // rax
  const char **v183; // rdi
  __int64 v184; // rax
  char *v185; // rax
  char v186; // al
  char *v187; // rbx
  __int64 v188; // rax
  __int64 v189; // rbp
  char *v190; // rax
  char *v191; // rax
  __off_t v192; // rax
  __mode_t v193; // eax
  __time_t v194; // rdx
  __syscall_slong_t v195; // rcx
  int v196; // er12
  char *v197; // rdx
  int *v198; // rax
  unsigned __int64 v199; // rax
  char *v200; // rax
  int *v201; // rax
  int *v202; // r12
  __int64 v203; // rax
  void *v204; // rdi
  _QWORD *v205; // rbx
  __int64 v206; // rcx
  __int64 v207; // r8
  __int64 v208; // r9
  unsigned __int64 v209; // rdx
  __int64 v210; // rsi
  unsigned __int64 v211; // rax
  _QWORD *v212; // rbx
  __int64 v213; // rbx
  char *v214; // r12
  char *v215; // rax
  __int64 v216; // rbx
  char *v217; // r12
  _QWORD *v218; // rdi
  __int64 v219; // rbx
  char *v220; // rax
  const char **v221; // rbx
  fd_set *v222; // r15
  __int64 v223; // rax
  int v224; // edx
  int v225; // eax
  unsigned __int64 v226; // rsi
  __int64 v227; // rcx
  __int64 v228; // r8
  __int64 v229; // r9
  __int64 v230; // rdx
  int v231; // eax
  unsigned __int64 v232; // rbp
  char *v233; // rbx
  const char *v234; // r15
  unsigned __int64 v235; // kr08_8
  __int64 v236; // r14
  const char *v237; // rsi
  int v238; // eax
  int *v239; // rax
  int *v240; // r14
  int v241; // eax
  char *v242; // rax
  char *v243; // rbx
  int *v244; // rax
  __int64 v245; // rbx
  int v246; // esi
  __int64 v247; // rbx
  char *v248; // rax
  char *v249; // rbx
  int *v250; // rax
  int *v251; // rax
  int *v252; // rax
  _QWORD *v253; // rbx
  __int64 v254; // rsi
  char *v255; // rax
  __int64 v256; // rax
  __int64 v257; // rax
  struct timeval *v258; // r8
  int v259; // edi
  int v260; // eax
  __int64 v261; // rdx
  int v262; // er9
  int v263; // ebx
  __int64 v264; // rbp
  const char **v265; // r15
  unsigned int v266; // er14
  int v267; // er13
  __int64 v268; // rbx
  int v269; // eax
  __int64 v270; // rdx
  char *v271; // rbx
  int v272; // eax
  char *v273; // rax
  __int64 v274; // rax
  int *v275; // rax
  __int64 v276; // rax
  char *v277; // rax
  __int64 v278; // rdx
  __int64 v279; // rcx
  int *v280; // r8
  __int64 v281; // r9
  char *v282; // rax
  int v283; // esi
  char *v284; // rsi
  __int64 v285; // rax
  __int64 v286; // rdx
  __int64 v287; // rax
  __int64 v288; // rax
  __int64 v289; // rdx
  __int64 v290; // rcx
  __int64 v291; // r8
  __int64 v292; // r9
  __int64 v293; // rbp
  char *v294; // r12
  int *v295; // rbx
  char *v296; // r14
  __int64 v297; // rdx
  __int64 v298; // rcx
  int *v299; // rbx
  __int64 v300; // r8
  __int64 v301; // r9
  __int64 v302; // rbp
  char *v303; // rax
  int *v304; // rax
  char *v305; // rbx
  int *v306; // rax
  char *v307; // rax
  __int64 v308; // [rsp+0h] [rbp-208h]
  int *fildes; // [rsp+8h] [rbp-200h]
  char fildesa; // [rsp+8h] [rbp-200h]
  char *v311; // [rsp+10h] [rbp-1F8h]
  __int64 ptr; // [rsp+18h] [rbp-1F0h]
  char *buf; // [rsp+20h] [rbp-1E8h]
  char bufa; // [rsp+20h] [rbp-1E8h]
  __off_t offset; // [rsp+28h] [rbp-1E0h]
  _BOOL4 mask; // [rsp+34h] [rbp-1D4h]
  double v317; // [rsp+38h] [rbp-1D0h]
  char v318; // [rsp+40h] [rbp-1C8h]
  __int64 v319; // [rsp+40h] [rbp-1C8h]
  _QWORD *v320; // [rsp+48h] [rbp-1C0h]
  __int64 v321; // [rsp+50h] [rbp-1B8h]
  int v322; // [rsp+58h] [rbp-1B0h]
  const char **v323; // [rsp+60h] [rbp-1A8h]
  __int64 v324; // [rsp+68h] [rbp-1A0h]
  unsigned __int64 v325; // [rsp+70h] [rbp-198h]
  __int64 v326; // [rsp+70h] [rbp-198h]
  fd_set *v327; // [rsp+78h] [rbp-190h]
  __int64 v328; // [rsp+78h] [rbp-190h]
  int *s1; // [rsp+80h] [rbp-188h]
  char v330; // [rsp+8Bh] [rbp-17Dh]
  int v331; // [rsp+8Ch] [rbp-17Ch]
  unsigned __int64 v332; // [rsp+90h] [rbp-178h]
  __int64 v333; // [rsp+98h] [rbp-170h]
  struct timeval timeout; // [rsp+A0h] [rbp-168h]
  struct stat v335; // [rsp+B0h] [rbp-158h]
  struct stat stat_buf; // [rsp+140h] [rbp-C8h]

  v4 = a3;
  v332 = 10LL;
  sub_407B40(*a1);
  setlocale(6, "");
  bindtextdomain(
    "coreutils",
    "/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/share/locale");
  textdomain("coreutils");
  sub_40C180(sub_406590);
  byte_61237A = 0;
  byte_612385 = 1;
  byte_612381 = 0;
  byte_612382 = 0;
  byte_612384 = 0;
  byte_612380 = 10;
  if ( a3 != 2 )
  {
    if ( a3 == 3 )
    {
      v5 = a1[2];
      if ( *v5 != 45 || !v5[1] )
        goto LABEL_6;
    }
    else
    {
      if ( a3 != 4 )
        goto LABEL_8;
      v5 = a1[2];
    }
    if ( strcmp(v5, "--") )
      goto LABEL_8;
  }
LABEL_6:
  v6 = sub_407AC0();
  v7 = a1[1];
  v8 = v7 + 1;
  if ( *v7 == 43 )
  {
    v20 = 1;
    if ( (unsigned int)(v6 - 200112) <= 0x2B8 )
      goto LABEL_8;
  }
  else
  {
    if ( *v7 != 45 || v6 > 200111 && !v7[(v7[1] == 99) + 1] )
      goto LABEL_8;
    v20 = 0;
  }
  v21 = v7[1];
  v22 = v7 + 1;
  v23 = v21;
  if ( (unsigned int)(v21 - 48) <= 9 )
  {
    do
      v23 = *++v22;
    while ( (unsigned int)(*v22 - 48) <= 9 );
  }
  switch ( v23 )
  {
    case 99:
      a4 = 0LL;
      v25 = 10;
      break;
    case 108:
      a4 = 1LL;
      v25 = 10;
      break;
    case 98:
      a4 = 0LL;
      v25 = 5120;
      break;
    default:
      v24 = v22;
      a4 = 1LL;
      v25 = 10;
      goto LABEL_67;
  }
  v24 = v22 + 1;
LABEL_67:
  v26 = 0;
  if ( *v24 == 102 )
  {
    ++v24;
    v26 = 1;
  }
  if ( !*v24 )
  {
    if ( v8 == v22 )
    {
      v332 = v25;
    }
    else if ( sub_40A260(v8) & 0xFFFFFFFD )
    {
      v232 = sub_409760(a1[1], 0LL);
      v233 = dcgettext(0LL, "invalid number", 5);
      v252 = __errno_location();
      error(1, *v252, "%s: %s", v233, v232);
      goto LABEL_412;
    }
    byte_612382 = v20;
    v9 = 1LL;
    byte_612385 = a4;
    byte_612384 = v26;
    goto LABEL_9;
  }
LABEL_8:
  v9 = 0LL;
LABEL_9:
  v10 = &a1[v9];
  LODWORD(v11) = 0;
  v12 = v4 - (unsigned __int8)v9;
  v317 = 1.0;
  while ( 1 )
  {
    v13 = sub_40B530((unsigned int)v12, v10, "c:n:fFqs:vz0123456789", &off_40D560, 0LL);
    if ( v13 == -1 )
      break;
    if ( v13 == 113 )
    {
      LODWORD(v11) = 2;
    }
    else if ( v13 <= 113 )
    {
      if ( v13 <= 57 )
      {
        v15 = v13;
        if ( v13 >= 48 )
        {
          v215 = dcgettext(0LL, "option used in invalid context -- %c", 5);
          error(1, 0, v215, v15);
        }
        else
        {
          if ( v13 == -131 )
          {
            sub_409C90((char)stdout);
            exit(0);
          }
          if ( v13 == -130 )
            sub_405D10(0);
        }
LABEL_365:
        sub_405D10(1);
      }
      if ( v13 == 99 )
      {
LABEL_38:
        byte_612385 = v13 == 110;
        if ( *(_BYTE *)qword_612540 == 43 )
        {
          byte_612382 = 1;
        }
        else if ( *(_BYTE *)qword_612540 == 45 )
        {
          ++qword_612540;
        }
        if ( v13 == 110 )
          v17 = dcgettext(0LL, "invalid number of lines", 5);
        else
          v17 = dcgettext(0LL, "invalid number of bytes", 5);
        v332 = sub_40A130(qword_612540, 0LL, -1LL, "bkKmMGTPEZY0", v17, 0LL);
      }
      else if ( v13 > 99 )
      {
        if ( v13 != 102 )
          goto LABEL_37;
LABEL_27:
        byte_612384 = 1;
        if ( qword_612540 )
          dword_6122A8 = dword_40D760[sub_406440("--follow", qword_612540, &off_40D770, dword_40D760, 4LL, off_6122B8)];
        else
          dword_6122A8 = 2;
      }
      else
      {
        if ( v13 != 70 )
          goto LABEL_365;
        byte_612384 = 1;
        dword_6122A8 = 1;
        byte_612386 = 1;
      }
    }
    else if ( v13 == 129 )
    {
      v18 = dcgettext(0LL, "invalid maximum number of unchanged stats between opens", 5);
      qword_6122A0 = sub_40A130(qword_612540, 0LL, -1LL, "", v18, 0LL);
    }
    else if ( v13 > 129 )
    {
      if ( v13 == 131 )
      {
        byte_612379 = 1;
      }
      else if ( v13 < 131 )
      {
        v19 = dcgettext(0LL, "invalid PID", 5);
        pid = sub_40A130(qword_612540, 0LL, 0x7FFFFFFFLL, "", v19, 0LL);
      }
      else
      {
        if ( v13 == 132 )
          goto LABEL_27;
        if ( v13 != 133 )
          goto LABEL_365;
        byte_612378 = 1;
      }
    }
    else if ( v13 == 118 )
    {
      LODWORD(v11) = 1;
    }
    else if ( v13 <= 118 )
    {
      if ( v13 != 115 )
        goto LABEL_365;
      if ( !(unsigned __int8)sub_40A1C0(qword_612540, 0LL, &stat_buf, sub_406500)
        || (v317 = *(double *)&stat_buf.st_dev, *(double *)&stat_buf.st_dev < 0.0) )
      {
        v11 = sub_409760(qword_612540, 0LL);
        v16 = dcgettext(0LL, "invalid number of seconds: %s", 5);
        error(1, 0, v16, v11);
LABEL_37:
        if ( v13 != 110 )
          goto LABEL_365;
        goto LABEL_38;
      }
    }
    else if ( v13 == 122 )
    {
      byte_612380 = 0;
    }
    else
    {
      if ( v13 != 128 )
        goto LABEL_365;
      byte_612386 = 1;
    }
  }
  if ( byte_612386 )
  {
    if ( byte_612384 )
    {
      if ( dword_6122A8 != 2 )
      {
        v27 = pid;
        if ( pid )
          goto LABEL_83;
        goto LABEL_84;
      }
      v70 = "warning: --retry only effective for the initial open";
    }
    else
    {
      byte_612386 = 0;
      v70 = "warning: --retry ignored; --retry is useful only when following";
    }
    v71 = dcgettext(0LL, v70, 5);
    error(0, 0, v71);
  }
  v27 = pid;
  if ( pid )
  {
    if ( byte_612384 )
    {
LABEL_83:
      if ( kill(v27, 0) && *__errno_location() == 38 )
      {
        v191 = dcgettext(0LL, "warning: --pid=PID is not supported on this system", 5);
        error(0, 0, v191);
        pid = 0;
      }
    }
    else
    {
      v72 = dcgettext(0LL, "warning: PID ignored; --pid=PID is useful only when following", 5);
      error(0, 0, v72);
    }
  }
LABEL_84:
  if ( byte_612382 && v332 )
    --v332;
  if ( dword_61233C >= v12 )
  {
    v29 = &off_612298;
    v308 = 1LL;
  }
  else
  {
    v28 = v12 - dword_61233C;
    v29 = (void **)&v10[dword_61233C];
    v308 = v28;
  }
  v30 = 0;
  v31 = 1;
  v32 = 0LL;
  v33 = 1LL;
  v34 = (unsigned __int64)&v29[v308];
  v35 = v29;
  do
  {
    v36 = *v35;
    v37 = 2LL;
    v38 = "-";
    do
    {
      if ( !v37 )
        break;
      v30 = *v36 < (unsigned __int8)*v38;
      v31 = *v36++ == *v38++;
      --v37;
    }
    while ( v31 );
    LOBYTE(v14) = (!v30 && !v31) - v30;
    if ( !(_BYTE)v14 )
      v32 = 1LL;
    ++v35;
    v30 = (unsigned __int64)v35 < v34;
    v31 = v35 == (void **)v34;
  }
  while ( v35 != (void **)v34 );
  if ( (_BYTE)v32 )
  {
    if ( dword_6122A8 == 1 )
    {
      v247 = sub_409510(4LL, "-", v14, v37, v32, 1LL);
      v248 = dcgettext(0LL, "cannot follow %s by name", 5);
      error(1, 0, v248, v247);
LABEL_407:
      __assert_fail("beg", "src/tail.c", 0x2C9u, "pipe_lines");
    }
    if ( byte_612384 )
    {
      if ( pid
        || v308 != 1
        || dword_6122A8 != 2
        || (v36 = 0LL, __fxstat(1, 0, &stat_buf))
        || (stat_buf.st_mode & 0xF000) == 0x8000 )
      {
        if ( isatty(0) )
        {
          v73 = dcgettext(0LL, "warning: following standard input indefinitely is ineffective", 5);
          v36 = 0LL;
          error(0, 0, v73);
        }
      }
      goto LABEL_104;
    }
    if ( !v332 )
    {
LABEL_232:
      result = 0LL;
      if ( !byte_612382 )
        return result;
    }
  }
  else
  {
LABEL_104:
    if ( !v332 && !byte_612384 )
      goto LABEL_232;
  }
  v324 = 96 * v308;
  v39 = sub_409DD0(96 * v308, v36, v14, v37, v32, v33);
  v321 = v39;
  do
  {
    v40 = *v29;
    ++v29;
    v39 += 96LL;
    *(_QWORD *)(v39 - 96) = v40;
  }
  while ( v29 != (void **)v34 );
  if ( (_DWORD)v11 == 1 || !(_DWORD)v11 && v308 != 1 )
    byte_612381 = 1;
  LODWORD(v41) = v321;
  LODWORD(v325) = -1;
  v330 = 1;
  v42 = (const char **)v321;
  v320 = (_QWORD *)(v321 + v324);
  while ( 2 )
  {
    offset = v332;
    v43 = *v42;
    v31 = strcmp(*v42, "-") == 0;
    v44 = !v31;
    mask = !v31;
    if ( v31 )
    {
      byte_61237A = 1;
      LODWORD(fildes) = 0;
      goto LABEL_114;
    }
    v44 = 0LL;
    v74 = sub_406780((char)v43);
    v75 = byte_612386;
    LODWORD(fildes) = v74;
    if ( !byte_612386 )
    {
      *((_BYTE *)v42 + 54) = 1;
      if ( v74 != -1 )
      {
        v43 = *v42;
        goto LABEL_115;
      }
LABEL_142:
      v76 = __errno_location();
      v77 = v76;
      if ( byte_612384 )
      {
        v78 = *v76;
        *((_DWORD *)v42 + 14) = -1;
        *((_BYTE *)v42 + 52) = v75 ^ 1;
        *((_DWORD *)v42 + 15) = v78;
        v42[5] = 0LL;
        v42[4] = 0LL;
      }
      v79 = sub_4047E0(*v42, 0LL);
      v84 = sub_409510(4LL, v79, v80, v81, v82, v83);
      v85 = dcgettext(0LL, "cannot open %s for reading", 5);
      error(0, *v77, v85, v84);
      LOBYTE(ptr) = 0;
      goto LABEL_145;
    }
    if ( v74 == -1 )
    {
      *((_BYTE *)v42 + 54) = 0;
      goto LABEL_142;
    }
    v43 = *v42;
LABEL_114:
    *((_BYTE *)v42 + 54) = 1;
LABEL_115:
    if ( byte_612381 )
    {
      v102 = sub_4047E0(v43, v44);
      v103 = "";
      if ( !byte_612290 )
        v103 = "\n";
      v44 = (unsigned __int64)"%s==> %s <==\n";
      __printf_chk(1LL, "%s==> %s <==\n", v103, v102);
      byte_612290 = 0;
    }
    v45 = sub_4047E0(*v42, v44);
    v46 = (unsigned int)fildes;
    v335.st_dev = 0LL;
    v319 = v45;
    LOBYTE(ptr) = byte_612385;
    if ( !byte_612385 )
    {
      if ( __fxstat(1, (int)fildes, &stat_buf) )
      {
        v151 = sub_409510(4LL, v319, v87, v88, v89, v90);
        v152 = dcgettext(0LL, "cannot fstat %s", 5);
        v57 = (unsigned int)*__errno_location();
        error(0, v57, v152, v151);
        goto LABEL_158;
      }
      v91 = (unsigned __int8)byte_612382;
      LOBYTE(ptr) = byte_612382;
      if ( byte_612382 )
      {
        if ( byte_612379
          || (v332 & 0x8000000000000000LL) != 0LL
          || ((stat_buf.st_mode & 0xF000) != 0x8000 || sub_404C20((unsigned int)fildes, v332, 1LL, v319) < 0)
          && lseek((int)fildes, v332, 1) == -1 )
        {
          v57 = (unsigned int)fildes;
          v101 = sub_404B40(v319, (unsigned int)fildes, v332, &v335);
          offset = -1LL;
          if ( v101 )
          {
            LODWORD(ptr) = v101 >> 31;
            goto LABEL_158;
          }
        }
        else
        {
          v335.st_dev += v332;
          offset = -1LL;
        }
        goto LABEL_157;
      }
      if ( !byte_612379 && (v332 & 0x8000000000000000LL) == 0LL )
      {
        if ( (stat_buf.st_mode & 0xD000) == 0x8000 )
        {
          v153 = stat_buf.st_size;
          v154 = -1LL;
        }
        else
        {
          LODWORD(v41) = v332;
          v46 = -(__int64)v332;
          v192 = lseek((int)fildes, -(__int64)v332, 2);
          v154 = v192;
          if ( v192 == -1 )
            goto LABEL_185;
          v153 = v192 + v332;
        }
        v155 = stat_buf.st_blksize;
        v46 = 0x1FFFFFFFFFFFFFFFLL;
        v87 = 512LL;
        if ( (unsigned __int64)(stat_buf.st_blksize - 1) > 0x1FFFFFFFFFFFFFFFLL )
          v155 = 512LL;
        if ( v153 > v155 )
        {
          if ( v154 == -1 )
            v154 = sub_404C20((unsigned int)fildes, 0LL, 1LL, v319);
          if ( v153 > v154 && v332 < v153 - v154 )
          {
            v154 = v153 - v332;
            sub_404C20((unsigned int)fildes, v153 - v332, 0LL, v319);
          }
          v335.st_dev = v154;
LABEL_157:
          v57 = v319;
          v92 = sub_404A20(0LL, v319, (unsigned int)fildes, offset);
          v335.st_dev += v92;
          LOBYTE(ptr) = 1;
          goto LABEL_158;
        }
      }
LABEL_185:
      v131 = 0LL;
      v132 = sub_409DD0(8208LL, v46, v87, v91, v89, v90);
      *(_QWORD *)(v132 + 0x2000) = 0LL;
      *(_QWORD *)(v132 + 8200) = 0LL;
      v133 = (_QWORD *)v132;
      v311 = (char *)v42;
      LODWORD(v41) = (_DWORD)fildes;
      v138 = (_QWORD *)v132;
      v139 = (_QWORD *)sub_409DD0(8208LL, v46, v134, v135, v136, v137);
      a4 = v332;
      while ( 1 )
      {
        v142 = sub_409780((int)fildes, v139, 0x2000uLL);
        if ( v142 - 1 > 0xFFFFFFFFFFFFFFFDLL )
          break;
        v335.st_dev += v142;
        v131 += v142;
        v139[1024] = v142;
        v146 = v138[1024];
        v139[1025] = 0LL;
        v147 = v142 + v146;
        if ( v142 + v146 > 0x1FFF )
        {
          v140 = v131 - v133[1024];
          v138[1025] = v139;
          if ( v332 >= v140 )
          {
            v141 = sub_409DD0(8208LL, v147, v146, v143, v144, v145);
          }
          else
          {
            v131 = v140;
            v141 = (__int64)v133;
            v133 = (_QWORD *)v133[1025];
          }
        }
        else
        {
          memcpy((char *)v138 + v146, v139, v142);
          v138[1024] += v139[1024];
          v141 = (__int64)v139;
          v139 = v138;
        }
        v138 = v139;
        v139 = (_QWORD *)v141;
      }
      v204 = v139;
      buf = (char *)v142;
      v42 = (const char **)v311;
      v205 = v133;
      free(v204);
      v209 = v332;
      if ( buf == (char *)-1LL )
      {
        v216 = sub_409510(4LL, v319, v332, v206, v207, v208);
        v217 = dcgettext(0LL, "error reading %s", 5);
        v57 = (unsigned int)*__errno_location();
        error(0, v57, v217, v216);
        v218 = v133;
      }
      else
      {
        while ( 1 )
        {
          v210 = v205[1024];
          if ( v332 >= v131 - v210 )
            break;
          v205 = (_QWORD *)v205[1025];
          v131 -= v210;
        }
        v211 = 0LL;
        if ( v332 < v131 )
          v211 = v131 - v332;
        v57 = v210 - v211;
        if ( v57 )
          sub_4048A0((char *)v205 + v211, v57, v332);
        while ( 1 )
        {
          v205 = (_QWORD *)v205[1025];
          if ( !v205 )
            break;
          v57 = v205[1024];
          if ( v57 )
            sub_4048A0(v205, v57, v209);
        }
        LOBYTE(ptr) = 1;
        v218 = v133;
      }
      while ( v218 )
      {
        v212 = (_QWORD *)v218[1025];
        free(v218);
        v218 = v212;
      }
      goto LABEL_158;
    }
    if ( __fxstat(1, (int)fildes, &stat_buf) )
    {
      v149 = sub_409510(4LL, v319, v47, v48, v49, v50);
      v150 = dcgettext(0LL, "cannot fstat %s", 5);
      v57 = (unsigned int)*__errno_location();
      error(0, v57, v150, v149);
      LOBYTE(v322) = 0;
      goto LABEL_181;
    }
    LOBYTE(v322) = byte_612382;
    if ( byte_612382 )
    {
      v57 = (unsigned int)fildes;
      v148 = sub_404920(v319, (unsigned int)fildes, v332, &v335);
      if ( v148 )
      {
        v322 = v148 >> 31;
      }
      else
      {
        v57 = v319;
        v165 = sub_404A20(0LL, v319, (unsigned int)fildes, -1LL);
        v335.st_dev += v165;
      }
      goto LABEL_181;
    }
    if ( byte_612379
      || (stat_buf.st_mode & 0xF000) != 0x8000
      || (LODWORD(v41) = (_DWORD)fildes, v46 = 0LL, v163 = lseek((int)fildes, 0LL, 1), v163 == -1) )
    {
LABEL_121:
      v51 = (char *)sub_409DD0(8216LL, v46, v47, v48, v49, v50);
      *((_QWORD *)v51 + 1025) = 0LL;
      *((_QWORD *)v51 + 1024) = 0LL;
      *((_QWORD *)v51 + 1026) = 0LL;
      v311 = v51;
      v323 = v42;
      v56 = v51;
      buf = 0LL;
      v41 = sub_409DD0(8216LL, v46, v52, v53, v54, v55);
      while ( 1 )
      {
        v57 = v41;
        v58 = sub_409780((int)fildes, (void *)v41, 0x2000uLL);
        if ( v58 - 1 > 0xFFFFFFFFFFFFFFFDLL )
          break;
        *(_QWORD *)(v41 + 0x2000) = v58;
        a4 = v41 + v58;
        v59 = v41;
        v60 = 0LL;
        v335.st_dev += v58;
        v61 = byte_612380;
        *(_QWORD *)(v41 + 8200) = 0LL;
        *(_QWORD *)(v41 + 8208) = 0LL;
        while ( 1 )
        {
          v62 = v61;
          v63 = sub_40B730(v59, v61, a4 - v59);
          v67 = v60 + 1;
          if ( !v63 )
            break;
          *(_QWORD *)(v41 + 8200) = v67;
          v59 = v63 + 1;
          ++v60;
        }
        v68 = *((_QWORD *)v311 + 1024);
        v69 = &buf[v60];
        if ( v58 + v68 <= 0x1FFF )
        {
          memcpy(&v311[v68], (const void *)v41, v58);
          buf += v60;
          *((_QWORD *)v311 + 1024) += *(_QWORD *)(v41 + 0x2000);
          *((_QWORD *)v311 + 1025) += *(_QWORD *)(v41 + 8200);
        }
        else
        {
          *((_QWORD *)v311 + 1026) = v41;
          buf = &v69[-*((_QWORD *)v56 + 1025)];
          v311 = (char *)v41;
          if ( v332 >= (unsigned __int64)buf )
          {
            buf = v69;
            v41 = sub_409DD0(8216LL, v62, v67, v64, v65, v66);
          }
          else
          {
            v41 = (__int64)v56;
            v56 = (char *)*((_QWORD *)v56 + 1026);
          }
        }
      }
      v111 = v56;
      v42 = v323;
      free((void *)v41);
      if ( v58 == -1LL )
      {
        v213 = sub_409510(4LL, v319, v112, v113, v114, v115);
        v214 = dcgettext(0LL, "error reading %s", 5);
        v57 = (unsigned int)*__errno_location();
        error(0, v57, v214, v213);
      }
      else
      {
        v116 = *((_QWORD *)v311 + 1024);
        LOBYTE(v112) = v332 == 0 || v116 == 0;
        LOBYTE(v322) = v332 == 0 || v116 == 0;
        if ( !(_BYTE)v112 )
        {
          v156 = byte_612380;
          if ( v311[v116 - 1] != byte_612380 )
          {
            ++*((_QWORD *)v311 + 1025);
            ++buf;
          }
          a4 = (__int64)v111;
          v157 = &buf[-*((_QWORD *)v111 + 1025)];
          if ( v332 < (unsigned __int64)v157 )
          {
            do
            {
              a4 = *(_QWORD *)(a4 + 8208);
              v112 = v157;
              v157 -= *(_QWORD *)(a4 + 8200);
            }
            while ( v332 < (unsigned __int64)v157 );
            buf = v112;
          }
          v158 = a4;
          LODWORD(v41) = (_DWORD)buf;
          v159 = a4 + *(_QWORD *)(a4 + 0x2000);
          if ( v332 < (unsigned __int64)buf )
          {
            v41 = (__int64)&buf[-v332];
            do
            {
              v57 = v156;
              v160 = sub_40B730(v158, v156, v159 - v158);
              if ( !v160 )
                goto LABEL_407;
              v158 = v160 + 1;
              --v41;
            }
            while ( v41 );
          }
          v161 = v159 - v158;
          if ( v161 )
          {
            v57 = v161;
            sub_4048A0(v158, v161, v112);
          }
          for ( i = *(_QWORD *)(a4 + 8208); i; i = *(_QWORD *)(i + 8208) )
          {
            v57 = *(_QWORD *)(i + 0x2000);
            if ( v57 )
              sub_4048A0(i, v57, v112);
          }
          v117 = v111;
          LOBYTE(v322) = ptr;
          do
          {
LABEL_180:
            v118 = (char *)*((_QWORD *)v117 + 1026);
            free(v117);
            v117 = v118;
          }
          while ( v118 );
          goto LABEL_181;
        }
      }
      v117 = v111;
      if ( !v111 )
        goto LABEL_181;
      goto LABEL_180;
    }
    v57 = 0LL;
    v164 = lseek((int)fildes, 0LL, 2);
    if ( v163 >= v164 )
    {
      v46 = v163;
      sub_404C20((unsigned int)fildes, v163, 0LL, v319);
      goto LABEL_121;
    }
    v335.st_dev = v164;
    LOBYTE(v322) = ptr;
    if ( v164 )
    {
      v57 = (unsigned int)fildes;
      LOBYTE(v322) = sub_404CD0(v319, (unsigned int)fildes, v332, v163, v164, &v335);
    }
LABEL_181:
    LOBYTE(ptr) = v322;
LABEL_158:
    if ( byte_612384 )
    {
      v104 = (unsigned int)fildes;
      *((_DWORD *)v42 + 15) = (unsigned __int8)ptr - 1;
      if ( __fxstat(1, (int)fildes, &stat_buf) < 0 )
      {
        v119 = __errno_location();
        v120 = *v42;
        v121 = v119;
        *((_DWORD *)v42 + 15) = *v119;
        v122 = sub_4047E0(v120, (unsigned int)fildes);
        v127 = sub_409510(4LL, v122, v123, v124, v125, v126);
        v128 = dcgettext(0LL, "error reading %s", 5);
        v104 = (unsigned int)*v121;
        error(0, v104, v128, v127);
        goto LABEL_183;
      }
      if ( ((stat_buf.st_mode & 0xF000) - 4096) & 0xFFFFE000 && (stat_buf.st_mode & 0xB000) != 0x8000 )
        goto LABEL_293;
      if ( (_BYTE)ptr )
      {
        v105 = 1;
        v106 = *v42;
        *((_DWORD *)v42 + 12) = stat_buf.st_mode;
        v107 = v335.st_dev;
        *((_BYTE *)v42 + 52) = 0;
        if ( !mask )
          v105 = v325;
        *((_DWORD *)v42 + 14) = (_DWORD)fildes;
        v42[1] = (const char *)v107;
        v108 = stat_buf.st_mtim.tv_sec;
        *((_DWORD *)v42 + 16) = v105;
        v42[2] = (const char *)v108;
        v109 = stat_buf.st_mtim.tv_nsec;
        v42[11] = 0LL;
        v42[3] = (const char *)v109;
        v42[4] = (const char *)stat_buf.st_dev;
        v42[5] = (const char *)stat_buf.st_ino;
        v110 = sub_4047E0(v106, (unsigned int)fildes);
        *((_BYTE *)v42 + 53) = sub_405090((unsigned int)fildes, v110);
      }
      else
      {
LABEL_183:
        v129 = *v42;
        *((_BYTE *)v42 + 52) = byte_612386 ^ 1;
        v130 = sub_4047E0(v129, v104);
        sub_404820((unsigned int)fildes, v130);
        *((_DWORD *)v42 + 14) = -1;
        LOBYTE(ptr) = 0;
      }
    }
    else if ( mask && close((int)fildes) )
    {
      v93 = sub_4047E0(*v42, v57);
      v98 = sub_409510(4LL, v93, v94, v95, v96, v97);
      v99 = dcgettext(0LL, "error reading %s", 5);
      v100 = __errno_location();
      error(0, *v100, v99, v98);
      LOBYTE(ptr) = 0;
    }
LABEL_145:
    v42 += 12;
    v330 &= ptr;
    if ( v320 != v42 )
      continue;
    break;
  }
  v318 = byte_612384;
  if ( !byte_612384 )
    goto LABEL_147;
  v166 = v321;
  v167 = (__int64)v320;
  v168 = 0LL;
  do
  {
    if ( !strcmp(*(const char **)v166, "-")
      && !*(_BYTE *)(v166 + 52)
      && (v169 = *(_DWORD *)(v166 + 56), v169 >= 0)
      && ((*(_DWORD *)(v166 + 48) & 0xF000) == 4096 || (unsigned int)sub_40B5B0(v169)) )
    {
      *(_DWORD *)(v166 + 56) = -1;
      *(_BYTE *)(v166 + 52) = 1;
    }
    else
    {
      ++v168;
    }
    v166 += 96LL;
  }
  while ( v320 != (_QWORD *)v166 );
  if ( !v168 )
    goto LABEL_147;
  v170 = 1LL;
  if ( __fxstat(1, 1, &v335) < 0 )
  {
    v249 = dcgettext(0LL, "standard output", 5);
    v250 = __errno_location();
    error(1, *v250, v249);
LABEL_409:
    v176 = dcgettext(0LL, "write error", 5);
    v251 = __errno_location();
    error(1, *v251, v176);
LABEL_410:
    v181 = -2LL;
LABEL_276:
    v170 = a4;
    v182 = sub_404A20(0LL, a4, (unsigned int)v166, v181);
    v42[1] += v182;
    LOBYTE(fildes) = (v182 != 0) | (unsigned __int8)fildes;
    while ( 1 )
    {
LABEL_277:
      while ( 1 )
      {
        ++v176;
        v42 += 12;
        if ( (char *)v308 == v176 )
          break;
        while ( 1 )
        {
LABEL_278:
          if ( *((_BYTE *)v42 + 52) )
            goto LABEL_277;
          v166 = *((unsigned int *)v42 + 14);
          if ( (v166 & 0x80000000) == 0LL )
            break;
          v183 = v42;
          v170 = (unsigned int)v41;
          ++v176;
          v42 += 12;
          sub_4056E0(v183, (unsigned int)v41);
          if ( (char *)v308 == v176 )
            goto LABEL_281;
        }
        v177 = sub_4047E0(*v42, v170);
        v167 = *((unsigned int *)v42 + 12);
        a4 = v177;
        v178 = *((_DWORD *)v42 + 16);
        if ( (_DWORD)v41 != v178 )
        {
          v179 = sub_40A6A0(v166);
          if ( (_DWORD)v41 )
          {
            if ( v179 >= 0 )
              goto LABEL_274;
          }
          else if ( v179 >= 0 )
          {
            v180 = v179;
            BYTE1(v180) |= 8u;
            if ( v179 == v180 || (unsigned int)sub_40A6A0(v166) != -1 )
            {
LABEL_274:
              *((_DWORD *)v42 + 16) = v41;
              v178 = v41;
              goto LABEL_275;
            }
          }
          v198 = __errno_location();
          if ( ((_DWORD)v42[6] & 0xF000) != 0x8000 || *v198 != 1 )
          {
            v308 = (__int64)v198;
            v219 = sub_4095E0(0LL, 3LL, a4);
            v220 = dcgettext(0LL, "%s: cannot change nonblocking mode", 5);
            error(1, *(_DWORD *)v308, v220, v219);
            goto LABEL_369;
          }
          v178 = *((_DWORD *)v42 + 16);
        }
LABEL_275:
        v181 = -2LL;
        if ( v178 )
          goto LABEL_276;
        v170 = (unsigned int)v166;
        if ( __fxstat(1, v166, &stat_buf) )
          goto LABEL_335;
        v193 = stat_buf.st_mode;
        if ( *((_DWORD *)v42 + 12) != stat_buf.st_mode )
        {
          v194 = stat_buf.st_mtim.tv_sec;
          v195 = stat_buf.st_mtim.tv_nsec;
LABEL_303:
          v196 = v167 & 0xF000;
          v42[2] = (const char *)v194;
          v42[3] = (const char *)v195;
          *((_DWORD *)v42 + 12) = v193;
          v42[11] = 0LL;
          if ( v196 == 0x8000 && stat_buf.st_size < (__int64)v42[1] )
          {
            offset = sub_4095E0(0LL, 3LL, a4);
            v200 = dcgettext(0LL, "%s: file truncated", 5);
            error(0, 0, v200, offset);
            sub_404C20((unsigned int)v166, 0LL, 0LL, a4);
            v42[1] = 0LL;
          }
          if ( v176 != v311 )
          {
            v311 = v176;
            if ( byte_612381 )
            {
              v197 = "\n";
              if ( byte_612290 )
                v197 = "";
              __printf_chk(1LL, "%s==> %s <==\n", v197, a4);
              byte_612290 = 0;
              v311 = v176;
            }
          }
          if ( !*((_DWORD *)v42 + 16) )
          {
            v181 = -1LL;
            if ( v196 == 0x8000 && *((_BYTE *)v42 + 53) )
              v181 = stat_buf.st_size - (_QWORD)v42[1];
            goto LABEL_276;
          }
          goto LABEL_410;
        }
        v194 = stat_buf.st_mtim.tv_sec;
        if ( (stat_buf.st_mode & 0xF000) == 0x8000 && v42[1] != (const char *)stat_buf.st_size )
        {
          v195 = stat_buf.st_mtim.tv_nsec;
          goto LABEL_303;
        }
        v195 = stat_buf.st_mtim.tv_nsec;
        if ( v42[2] != (const char *)stat_buf.st_mtim.tv_sec
          || *((_DWORD *)v42 + 6) != LODWORD(stat_buf.st_mtim.tv_nsec) )
        {
          goto LABEL_303;
        }
        v199 = (unsigned __int64)v42[11];
        v30 = v199 < qword_6122A0;
        v42[11] = (const char *)(v199 + 1);
        if ( !v30 && dword_6122A8 == 1 )
        {
          v170 = *((_DWORD *)v42 + 16) != 0;
          sub_4056E0(v42, v170);
          v42[11] = 0LL;
        }
      }
LABEL_281:
      if ( !byte_612386 || dword_6122A8 != 1 )
      {
        v184 = v321 + 52;
        do
        {
          v170 = *(unsigned int *)(v184 + 4);
          if ( (v170 & 0x80000000) == 0LL || *(_BYTE *)v184 != 1 && byte_612386 )
            goto LABEL_325;
          v184 += 96LL;
        }
        while ( ptr != v184 );
        v185 = dcgettext(0LL, "no files remaining", 5);
        error(0, 0, v185);
LABEL_147:
        if ( !byte_61237A || close(0) >= 0 )
          return (unsigned __int8)v330 ^ 1u;
        v104 = (unsigned int)*__errno_location();
        error(1, v104, "-");
LABEL_293:
        v186 = byte_612386;
        *((_BYTE *)v42 + 54) = 0;
        v187 = "";
        *((_DWORD *)v42 + 15) = -1;
        v186 ^= 1u;
        *((_BYTE *)v42 + 52) = v186;
        if ( v186 )
        {
          v104 = (unsigned __int64)"; giving up on this name";
          v187 = dcgettext(0LL, "; giving up on this name", 5);
        }
        v188 = sub_4047E0(*v42, v104);
        v189 = sub_4095E0(0LL, 3LL, v188);
        v190 = dcgettext(0LL, "%s: cannot follow end of this type of file%s", 5);
        v104 = 0LL;
        error(0, 0, v190, v189, v187);
        goto LABEL_183;
      }
LABEL_325:
      if ( (_BYTE)fildes != 1 || (_BYTE)buf )
      {
        if ( fflush_unlocked(stdout) )
          goto LABEL_409;
        if ( !byte_612383 )
          goto LABEL_330;
      }
      else if ( !byte_612383 )
      {
        goto LABEL_268;
      }
      timeout.tv_usec = 0LL;
      timeout.tv_sec = 0LL;
      memset(&stat_buf, 0, 0x80uLL);
      v170 = (unsigned __int64)&stat_buf;
      stat_buf.st_dev |= 2uLL;
      if ( select(2, (fd_set *)&stat_buf, 0LL, 0LL, &timeout) == 1 )
        raise(13);
LABEL_330:
      if ( (_BYTE)fildes )
        goto LABEL_268;
      if ( mask )
        goto LABEL_147;
      if ( pid )
      {
        v170 = 0LL;
        if ( kill(pid, 0) )
        {
          if ( *__errno_location() != 1 )
          {
            LOBYTE(mask) = v318;
LABEL_268:
            v42 = (const char **)v321;
            LOBYTE(fildes) = 0;
            v176 = 0LL;
            goto LABEL_278;
          }
        }
      }
      if ( !(unsigned int)sub_40A160(v317) )
        goto LABEL_268;
      v176 = dcgettext(0LL, "cannot read realtime clock", 5);
      v201 = __errno_location();
      error(1, *v201, v176);
LABEL_335:
      *((_DWORD *)v42 + 14) = -1;
      v202 = __errno_location();
      *((_DWORD *)v42 + 15) = *v202;
      v203 = sub_4095E0(0LL, 3LL, a4);
      v170 = (unsigned int)*v202;
      error(0, v170, "%s", v203);
      close(v166);
    }
  }
  v171 = 1;
  if ( (v335.st_mode & 0xF000) != 4096 )
    v171 = (unsigned int)sub_40B5B0(1) != 0;
  byte_612383 = v171;
  if ( byte_612378 )
    goto LABEL_263;
  v172 = v321;
  v166 = (unsigned __int64)v320;
  do
  {
    if ( !*(_BYTE *)(v172 + 52) )
    {
      v170 = (unsigned __int64)"-";
      if ( !strcmp(*(const char **)v172, "-") )
        goto LABEL_263;
    }
    v172 += 96LL;
  }
  while ( v320 != (_QWORD *)v172 );
  v173 = 0LL;
  do
  {
    if ( *(_DWORD *)(v321 + v173 + 56) >= 0 && *(_BYTE *)(v321 + v173 + 53) )
      goto LABEL_263;
    v173 += 96LL;
  }
  while ( v324 != v173 );
  v174 = 0LL;
  while ( 1 )
  {
    if ( *(_DWORD *)(v321 + v174 + 56) >= 0 )
    {
      v175 = *(_BYTE *)(v321 + v174 + 53);
      if ( !v175 )
        break;
    }
    v174 += 96LL;
    if ( v324 == v174 )
      goto LABEL_263;
  }
LABEL_369:
  LOBYTE(v311) = v175;
  v221 = (const char **)v321;
  v222 = (fd_set *)&stat_buf;
  do
  {
    v170 = (unsigned __int64)*v221;
    if ( !__lxstat(1, *v221, &stat_buf) && (stat_buf.st_mode & 0xF000) == 40960 )
      goto LABEL_263;
    v221 += 12;
  }
  while ( v320 != v221 );
  v223 = 0LL;
  do
  {
    if ( *(_DWORD *)(v321 + v223 + 56) >= 0 )
    {
      v224 = *(_DWORD *)(v321 + v223 + 48) & 0xF000;
      if ( v224 != 0x8000 && v224 != 4096 )
        goto LABEL_263;
    }
    v223 += 96LL;
  }
  while ( v324 != v223 );
  if ( !v330 && dword_6122A8 == 2 )
  {
LABEL_263:
    byte_612378 = 1;
    if ( pid || dword_6122A8 != 2 || v308 != 1 || *(_DWORD *)(v321 + 56) == -1 )
    {
      LODWORD(v41) = 0;
    }
    else
    {
      LODWORD(fildes) = *(_DWORD *)(v321 + 48);
      LODWORD(v41) = (*(_DWORD *)(v321 + 48) & 0xF000) != 0x8000;
    }
    LOBYTE(mask) = 0;
    LOBYTE(buf) = v41 & 1;
    v311 = (char *)(v308 - 1);
    ptr = v321 + v324 + 52;
    goto LABEL_268;
  }
  v225 = inotify_init();
  a4 = (unsigned int)v225;
  if ( v225 < 0 )
    goto LABEL_399;
  if ( !fflush_unlocked(stdout) )
  {
    v226 = 0LL;
    ptr = sub_407060(v308, 0LL, sub_4047C0, sub_4047D0, 0LL);
    if ( !ptr )
      goto LABEL_498;
    v230 = 2LL;
    v231 = 3078;
    if ( dword_6122A8 != 1 )
      v231 = 2;
    fildesa = 0;
    v20 = 0;
    v232 = 0LL;
    offset = (__off_t)&stat_buf;
    v233 = (char *)v321;
    mask = v231;
    while ( 1 )
    {
      if ( !v233[52] )
      {
        v234 = *(const char **)v233;
        v235 = strlen(*(const char **)v233) + 1;
        *((_DWORD *)v233 + 17) = -1;
        if ( v232 < v235 - 1 )
          v232 = v235 - 1;
        if ( dword_6122A8 == 1 )
        {
          v236 = sub_406630(v234);
          v322 = (_DWORD)v234 + v236;
          bufa = v234[v236];
          *((_QWORD *)v233 + 10) = sub_4066F0(v234) - (_QWORD)v234;
          v234[v236] = 0;
          v237 = ".";
          if ( v236 )
            v237 = *(const char **)v233;
          *((_DWORD *)v233 + 18) = inotify_add_watch(a4, v237, 0x784u);
          *(_BYTE *)(*(_QWORD *)v233 + v236) = bufa;
          if ( *((_DWORD *)v233 + 18) < 0 )
          {
            v296 = v233;
            v299 = __errno_location();
            if ( *v299 == 28 )
              goto LABEL_397;
            v302 = sub_409510(4LL, *(_QWORD *)v296, v297, v298, v300, v301);
            v303 = dcgettext(0LL, "cannot watch parent directory of %s", 5);
            error(0, *v299, v303, v302);
LABEL_398:
            sub_4072A0((void *)ptr);
            *__errno_location() = 0;
LABEL_399:
            v243 = dcgettext(0LL, "inotify cannot be used, reverting to polling", 5);
            v244 = __errno_location();
            error(0, *v244, v243);
            v245 = v321;
            LODWORD(v166) = (_DWORD)v320;
            do
            {
              v246 = *(_DWORD *)(v245 + 68);
              if ( v246 != -1 )
                inotify_rm_watch(a4, v246);
              v170 = *(unsigned int *)(v245 + 72);
              if ( (_DWORD)v170 != -1 )
                inotify_rm_watch(a4, v170);
              v245 += 96LL;
            }
            while ( v320 != (_QWORD *)v245 );
            goto LABEL_263;
          }
        }
        v226 = *(_QWORD *)v233;
        v238 = inotify_add_watch(a4, *(const char **)v233, mask);
        *((_DWORD *)v233 + 17) = v238;
        if ( v238 >= 0 )
        {
LABEL_412:
          v226 = (unsigned __int64)v233;
          if ( !sub_407800(ptr, v233) )
            goto LABEL_498;
          fildesa = v318;
        }
        else
        {
          if ( *((_DWORD *)v233 + 14) != -1 )
            v20 = v318;
          v239 = __errno_location();
          v240 = v239;
          v241 = *v239;
          v230 = v241 & 0xFFFFFFEF;
          if ( (_DWORD)v230 == 12 )
          {
LABEL_397:
            v242 = dcgettext(0LL, "inotify resources exhausted", 5);
            error(0, 0, v242);
            goto LABEL_398;
          }
          if ( v241 != *((_DWORD *)v233 + 15) )
          {
            buf = (char *)sub_409510(4LL, *(_QWORD *)v233, v230, v227, v228, v229);
            v255 = dcgettext(0LL, "cannot watch %s", 5);
            v226 = (unsigned int)*v240;
            error(0, v226, v255, buf);
          }
        }
      }
      v233 += 96;
      if ( v320 == (_QWORD *)v233 )
      {
        v222 = (fd_set *)offset;
        if ( dword_6122A8 != 2 )
          goto LABEL_416;
        if ( !v20 )
        {
          if ( !fildesa )
            return 1LL;
LABEL_416:
          v253 = (_QWORD *)v321;
          v333 = v321 + v324 - 96;
          while ( 1 )
          {
            if ( !*((_BYTE *)v253 + 52) )
            {
              if ( dword_6122A8 == 1 )
              {
                sub_4056E0(v253, 0LL);
              }
              else if ( *((_DWORD *)v253 + 14) != -1 )
              {
                v254 = *v253;
                if ( !__xstat(1, (const char *)*v253, (struct stat *)offset)
                  && (v253[4] != stat_buf.st_dev || v253[5] != stat_buf.st_ino) )
                {
                  v288 = sub_4047E0(*v253, v254);
                  v293 = sub_409510(4LL, v288, v289, v290, v291, v292);
                  v294 = dcgettext(0LL, "%s was replaced", 5);
                  v295 = __errno_location();
                  error(0, *v295, v294, v293);
                  sub_4072A0((void *)ptr);
                  *v295 = 0;
                  goto LABEL_399;
                }
              }
              v226 = (unsigned __int64)&v333;
              sub_404F00(v253, &v333);
            }
            v253 += 12;
            if ( v320 == v253 )
            {
              v256 = v232 + 17;
              v42 = 0LL;
              v166 = 0LL;
              offset = v256;
              v322 = 3;
              buf = (char *)sub_409DD0(v256, v226, v230, v227, v228, v229);
              v167 = 1LL << a4;
              fildes = (int *)(int)a4;
              goto LABEL_429;
            }
          }
        }
        goto LABEL_398;
      }
    }
  }
  v271 = dcgettext(0LL, "write error", 5);
  v304 = __errno_location();
  error(1, *v304, v271);
LABEL_502:
  v284 = 0LL;
  v326 = v285;
  sub_4056E0(v285, 0LL);
  v286 = v326;
LABEL_493:
  *(_DWORD *)(v286 + 68) = -1;
  v325 = v286;
  v287 = sub_4047E0(*(_QWORD *)v286, v284);
  sub_404820(*(unsigned int *)(v325 + 56), v287);
LABEL_494:
  if ( !sub_407800(ptr, v271) )
LABEL_498:
    sub_40A020();
LABEL_495:
  if ( dword_6122A8 == 1 )
  {
LABEL_496:
    sub_4056E0(v271, 0LL);
LABEL_455:
    if ( v271 )
      goto LABEL_456;
  }
  else
  {
LABEL_456:
    v272 = *((_DWORD *)v323 + 1);
    if ( v272 & 0xE04 )
    {
      if ( v272 & 0x400 )
      {
        inotify_rm_watch(a4, *((_DWORD *)v271 + 17));
        sub_407840(ptr, v271);
      }
      sub_4056E0(v271, 0LL);
    }
    else
    {
LABEL_470:
      sub_404F00(v271, &v333);
    }
  }
LABEL_429:
  while ( 2 )
  {
    if ( dword_6122A8 != 1 || byte_612386 || sub_406BD0(ptr) )
    {
      while ( 1 )
      {
        do
        {
          if ( v166 < (unsigned __int64)v42 )
            goto LABEL_447;
          if ( pid )
          {
            if ( (_BYTE)v311 )
              exit(0);
            if ( kill(pid, 0) && *__errno_location() != 1 )
            {
              timeout.tv_usec = 0LL;
              timeout.tv_sec = 0LL;
              LOBYTE(v311) = v318;
            }
            else
            {
              timeout.tv_sec = (unsigned int)(int)v317;
              timeout.tv_usec = (unsigned int)(int)(1000000.0 * (v317 - (double)(int)v317));
            }
          }
          memset(v222, 0, sizeof(fd_set));
          v257 = __fdelt_chk(fildes);
          *(&stat_buf.st_dev + v257) |= v167;
          if ( byte_612383 )
            stat_buf.st_dev |= 2uLL;
          v258 = 0LL;
          v259 = 1;
          if ( pid )
            v258 = &timeout;
          if ( (int)a4 > 0 )
            v259 = a4;
          v260 = select(v259 + 1, v222, 0LL, 0LL, v258);
        }
        while ( !v260 );
        if ( v260 == -1 )
        {
          v305 = dcgettext(0LL, "error waiting for inotify and output events", 5);
          v306 = __errno_location();
          error(1, *v306, v305);
LABEL_504:
          fildes = v280;
          v307 = dcgettext(0LL, "inotify resources exhausted", 5);
          error(0, 0, v307);
          sub_4072A0((void *)ptr);
          *fildes = 0;
          goto LABEL_399;
        }
        if ( !(stat_buf.st_dev & 2) )
          break;
        raise(13);
      }
      v274 = sub_409780(a4, buf, offset);
      v42 = (const char **)v274;
      if ( !v274 )
        goto LABEL_476;
      v166 = 0LL;
      if ( v274 == -1 )
      {
        if ( *__errno_location() != 22 )
          goto LABEL_469;
LABEL_476:
        if ( !v322 )
        {
LABEL_469:
          v271 = dcgettext(0LL, "error reading inotify event", 5);
          v275 = __errno_location();
          error(1, *v275, v271);
          goto LABEL_470;
        }
        v42 = 0LL;
        v166 = 0LL;
        --v322;
        offset *= 2LL;
        buf = (char *)sub_409E30(buf, offset);
        continue;
      }
LABEL_447:
      v261 = *(unsigned int *)&buf[v166 + 12];
      v262 = *(_DWORD *)&buf[v166 + 4];
      v323 = (const char **)&buf[v166];
      v263 = *(_DWORD *)&buf[v166];
      v166 += v261 + 16;
      if ( v262 & 0x400 )
      {
        if ( !(_DWORD)v261 )
        {
          v276 = 0LL;
          while ( *(_DWORD *)(v321 + 96 * v276 + 72) != v263 )
          {
            if ( v308 == ++v276 )
              goto LABEL_461;
          }
          sub_4072A0((void *)ptr);
          v277 = dcgettext(0LL, "directory containing watched file was removed", 5);
          error(0, 0, v277);
          *__errno_location() = 0;
          goto LABEL_399;
        }
      }
      else if ( !(_DWORD)v261 )
      {
LABEL_461:
        HIDWORD(stat_buf.st_blocks) = v263;
        v271 = (char *)sub_406DF0(ptr, v222);
        goto LABEL_455;
      }
      v325 = v166;
      v327 = v222;
      v264 = 0LL;
      v265 = v42;
      v266 = a4;
      v267 = v263;
      v268 = v321;
      while ( 1 )
      {
        if ( *(_DWORD *)(v268 + 72) == v267 )
        {
          v331 = v262;
          v269 = strcmp((const char *)v323 + 16, (const char *)(*(_QWORD *)v268 + *(_QWORD *)(v268 + 80)));
          v262 = v331;
          if ( !v269 )
            break;
        }
        ++v264;
        v268 += 96LL;
        if ( v308 == v264 )
        {
          a4 = v266;
          v166 = v325;
          v42 = v265;
          v222 = v327;
          goto LABEL_429;
        }
      }
      v270 = v264;
      a4 = v266;
      v166 = v325;
      v42 = v265;
      v222 = v327;
      v271 = (char *)(v321 + 96 * v270);
      if ( v331 & 0x200 )
      {
        if ( dword_6122A8 == 1 )
          goto LABEL_496;
        goto LABEL_455;
      }
      LODWORD(v325) = inotify_add_watch(a4, *(const char **)v271, mask);
      if ( (v325 & 0x80000000) != 0LL )
      {
        v280 = __errno_location();
        if ( (*v280 & 0xFFFFFFEF) == 12 )
          goto LABEL_504;
        s1 = v280;
        v328 = sub_409510(4LL, *(_QWORD *)v271, v278, v279, v280, v281);
        v282 = dcgettext(0LL, "cannot watch %s", 5);
        error(0, *s1, v282, v328);
      }
      v283 = *((_DWORD *)v271 + 17);
      if ( v283 < 0 || (_DWORD)v325 != v283 )
      {
        if ( v283 >= 0 )
        {
          inotify_rm_watch(a4, v283);
          sub_407840(ptr, v271);
        }
        *((_DWORD *)v271 + 17) = v325;
        if ( (_DWORD)v325 == -1 )
          continue;
        v284 = v271;
        v285 = sub_407840(ptr, v271);
        v286 = v285;
        if ( !v285 || v271 == (char *)v285 )
          goto LABEL_494;
        if ( dword_6122A8 == 1 )
          goto LABEL_502;
        goto LABEL_493;
      }
      goto LABEL_495;
    }
    break;
  }
  v273 = dcgettext(0LL, "no files remaining", 5);
  error(0, 0, v273);
  return 1LL;
}

// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(__int64 a1@<rax>, void (*a2)(void)@<rdx>)
{
  int v2; // esi
  int v3; // [rsp-8h] [rbp-8h]
  __int64 _0; // [rsp+0h] [rbp+0h]

  v2 = v3;
  *(_QWORD *)&v3 = a1;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v2, (char **)&_0, init, fini, a2, &v3);
  __halt();
}

__int64 *sub_40470B()
{
  __int64 *result; // rax

  result = &program_invocation_short_name;
  if ( &program_invocation_short_name != &program_invocation_short_name )
    result = 0LL;
  return result;
}

__int64 sub_40472A()
{
  return 0LL;
}

__int64 *sub_404761()
{
  __int64 *result; // rax

  if ( !byte_612368 )
  {
    while ( qword_612370 < (unsigned __int64)(&qword_611E48 - qword_611E40 - 1) )
      ((void (*)(void))qword_611E40[++qword_612370])();
    result = sub_40470B();
    byte_612368 = 1;
  }
  return result;
}

__int64 sub_4047B8()
{
  return sub_40472A();
}

unsigned __int64 __fastcall sub_4047C0(__int64 a1, unsigned __int64 a2)
{
  return *(int *)(a1 + 68) % a2;
}

bool __fastcall sub_4047D0(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 68);
}

char *__fastcall sub_4047E0(const char *a1)
{
  char *result; // rax

  result = (char *)a1;
  if ( !strcmp(a1, "-") )
    result = dcgettext(0LL, "standard input", 5);
  return result;
}

void __fastcall sub_404820(unsigned int a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r12
  char *v7; // rbp
  int *v8; // rax

  if ( a1 != -1 && a1 != 0 )
  {
    if ( close(a1) )
    {
      v6 = sub_409510(4LL, a2, v2, v3, v4, v5);
      v7 = dcgettext(0LL, "closing %s (fd=%d)", 5);
      v8 = __errno_location();
      error(0, *v8, v7, v6, a1);
    }
  }
}

size_t __fastcall sub_4048A0(const void *a1, size_t a2)
{
  size_t result; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rbp
  char *v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx

  result = fwrite_unlocked(a1, 1uLL, a2, stdout);
  if ( a2 > result )
  {
    clearerr_unlocked(stdout);
    v7 = sub_409510(4LL, "standard output", v3, v4, v5, v6);
    v8 = dcgettext(0LL, "error writing %s", 5);
    v9 = (unsigned int)*__errno_location();
    error(1, v9, v8, v7);
    result = sub_404920(1LL, v9, v10, v11);
  }
  return result;
}

__int64 __fastcall sub_404920(__int64 a1, int a2, __int64 a3, _QWORD *a4)
{
  __int64 result; // rax
  __int64 v5; // r15
  _QWORD *v6; // r13
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int v13; // er12
  char *v14; // rbp
  char *v15; // rdi
  __int64 v16; // rax
  size_t v17; // rbp
  __int64 v18; // rbp
  char *v19; // rbx
  int *v20; // rax
  unsigned int v21; // [rsp+0h] [rbp-203Ch]
  char buf[8248]; // [rsp+4h] [rbp-2038h]

  result = 0LL;
  if ( a3 )
  {
    v5 = a1;
    v6 = a4;
    v7 = a3;
    while ( 1 )
    {
      v8 = sub_409780(a2, buf, 0x2000uLL);
      if ( !v8 )
        return 0xFFFFFFFFLL;
      if ( v8 == -1 )
        break;
      *v6 += v8;
      v13 = byte_612380;
      v14 = &buf[v8];
      v15 = buf;
      while ( 1 )
      {
        v16 = sub_40B730(v15, v13, v14 - v15);
        if ( !v16 )
          break;
        v15 = (char *)(v16 + 1);
        if ( !--v7 )
        {
          result = 0LL;
          if ( v14 > v15 )
          {
            v17 = v14 - v15;
            if ( v17 )
            {
              v21 = 0;
              sub_4048A0(v15, v17);
              result = v21;
            }
          }
          return result;
        }
      }
    }
    v18 = sub_409510(4LL, v5, v9, v10, v11, v12);
    v19 = dcgettext(0LL, "error reading %s", 5);
    v20 = __errno_location();
    error(0, *v20, v19, v18);
    result = 1LL;
  }
  return result;
}

__int64 __fastcall sub_404A20(char a1, __int64 a2, int a3, unsigned __int64 a4)
{
  int v4; // er15
  unsigned __int64 v5; // r13
  __int64 v6; // r12
  char v7; // bp
  unsigned __int64 v8; // rbx
  size_t v9; // rdx
  __int64 v10; // rax
  size_t v11; // r14
  char *v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rcx
  int *v15; // rbx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v19; // rbp
  char *v20; // rax
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rcx
  char buf; // [rsp+10h] [rbp-2038h]

  v4 = a3;
  v5 = a4;
  v6 = 0LL;
  v7 = a1;
  v8 = a4;
  while ( 1 )
  {
    v9 = 0x2000LL;
    if ( v8 <= 0x2000 )
      v9 = v8;
    v10 = sub_409780(v4, &buf, v9);
    v11 = v10;
    if ( v10 == -1 )
      break;
    if ( !v10 )
      return v6;
    if ( v7 )
    {
      v12 = "";
      if ( !byte_612290 )
        v12 = "\n";
      __printf_chk(1LL, "%s==> %s <==\n", v12, a2);
      byte_612290 = 0;
    }
    v6 += v11;
    sub_4048A0(&buf, v11);
    if ( v5 != -1LL )
    {
      v8 -= v11;
      if ( !v8 || v5 == -2LL )
        return v6;
    }
    v7 = 0;
  }
  v15 = __errno_location();
  if ( *v15 == 11 )
    return v6;
  v19 = sub_409510(4LL, a2, v13, v14, v16, v17);
  v20 = dcgettext(0LL, "error reading %s", 5);
  v21 = (unsigned int)*v15;
  error(1, v21, v20, v19);
  return sub_404B40(1LL, v21, v22, v23);
}

__int64 __fastcall sub_404B40(__int64 a1, int a2, unsigned __int64 a3, _QWORD *a4)
{
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // rbp
  char *v13; // rbx
  int *v14; // rax
  char v15[8232]; // [rsp+0h] [rbp-2028h]

  if ( !a3 )
    return 0LL;
  v4 = a4;
  v5 = a3;
  while ( 1 )
  {
    v6 = sub_409780(a2, v15, 0x2000uLL);
    if ( !v6 )
      return 0xFFFFFFFFLL;
    if ( v6 == -1LL )
      break;
    *v4 += v6;
    if ( v6 > v5 )
    {
      sub_4048A0(&v15[v5], v6 - v5);
      return 0LL;
    }
    v5 -= v6;
    if ( !v5 )
      return 0LL;
  }
  v12 = sub_409510(4LL, a1, v7, v8, v9, v10);
  v13 = dcgettext(0LL, "error reading %s", 5);
  v14 = __errno_location();
  error(0, *v14, v13, v12);
  return 1LL;
}

__off_t __fastcall sub_404C20(int a1, __off_t a2, int a3, __int64 a4)
{
  __int64 v4; // r12
  int v5; // ebx
  __off_t result; // rax
  __int64 v7; // r13
  int *v8; // rbp
  __int64 v9; // rax
  const char *v10; // rsi
  __int64 v11; // rbx
  char *v12; // rax
  __int64 v13; // [rsp+0h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  result = lseek(a1, a2, a3);
  if ( result < 0 )
  {
    v7 = sub_407A20(a2, &v13);
    v8 = __errno_location();
    v9 = sub_4095E0(0LL, 3LL, v4);
    if ( v5 == 1 )
      v10 = "%s: cannot seek to relative offset %s";
    else
      v10 = "%s: cannot seek to offset %s";
    v11 = v9;
    v12 = dcgettext(0LL, v10, 5);
    error(0, *v8, v12, v11, v7);
    exit(1);
  }
  return result;
}

__int64 __fastcall sub_404CD0(__int64 a1, int a2, __int64 a3, __int64 a4, unsigned __int64 a5, _QWORD *a6)
{
  __int64 v6; // r15
  __int64 v7; // rbp
  __off_t v8; // r13
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r12
  __int64 v15; // rax
  int v16; // ebp
  size_t v17; // rdx
  char *v18; // rax
  __int64 v20; // rbp
  char *v21; // rbx
  int *v22; // rax
  _QWORD *v23; // [rsp+8h] [rbp-2050h]
  __int64 v24; // [rsp+10h] [rbp-2048h]
  unsigned __int64 v25; // [rsp+18h] [rbp-2040h]
  char s; // [rsp+20h] [rbp-2038h]

  v24 = a4;
  v25 = a5;
  v23 = a6;
  if ( !a3 )
    return 1LL;
  v6 = a3;
  v7 = (__int64)(v25 - a4) % 0x2000;
  if ( !v7 )
    v7 = 0x2000LL;
  v8 = v25 - v7;
  sub_404C20(a2, v25 - v7, 0, a1);
  v9 = sub_409780(a2, &s, v7);
  v14 = v9;
  if ( v9 != -1 )
  {
    *v23 = v8 + v9;
    if ( v9 )
    {
      v6 -= *((_BYTE *)&v25 + v9 + 7) != byte_612380;
      goto LABEL_9;
    }
LABEL_6:
    while ( v8 != v24 )
    {
      v8 -= 0x2000LL;
      sub_404C20(a2, v8, 0, a1);
      v15 = sub_409780(a2, &s, 0x2000uLL);
      v14 = v15;
      if ( v15 == -1 )
        goto LABEL_20;
      *v23 = v8 + v15;
      if ( !v15 )
        return 1LL;
LABEL_9:
      v16 = byte_612380;
      v17 = v14;
      while ( 1 )
      {
        v18 = (char *)memrchr(&s, v16, v17);
        if ( !v18 )
          break;
        v17 = v18 - &s;
        if ( !v6 )
        {
          if ( v14 - 1 != v17 )
            sub_4048A0(v18 + 1, v14 - 1 - v17);
          *v23 += sub_404A20(0, a1, a2, v25 - v14 - v8);
          return 1LL;
        }
        --v6;
        if ( !v17 )
          goto LABEL_6;
      }
    }
    sub_404C20(a2, v8, 0, a1);
    *v23 = sub_404A20(0, a1, a2, v25) + v8;
    return 1LL;
  }
LABEL_20:
  v20 = sub_409510(4LL, a1, v10, v11, v12, v13);
  v21 = dcgettext(0LL, "error reading %s", 5);
  v22 = __errno_location();
  error(0, *v22, v21, v20);
  return 0LL;
}

void __fastcall sub_404F00(__int64 a1, _QWORD *a2)
{
  char *v2; // rbx
  char *v3; // r13
  int v4; // eax
  bool v5; // bp
  __int64 v6; // rax
  __int64 v7; // rax
  int *v8; // rax
  int *v9; // rax
  unsigned int v10; // edi
  __int64 v11; // r14
  char *v12; // rax
  __int64 v13; // [rsp-30h] [rbp-B8h]
  __int64 v14; // [rsp+0h] [rbp-88h]
  __int64 v15; // [rsp+28h] [rbp-60h]
  __int64 v16; // [rsp+30h] [rbp-58h]

  if ( *(_DWORD *)(a1 + 56) != -1 )
  {
    v2 = (char *)a1;
    v3 = sub_4047E0(*(const char **)a1);
    v4 = __fxstat(1, *(_DWORD *)(a1 + 56), (struct stat *)&v13);
    v5 = v4;
    if ( v4 )
    {
LABEL_16:
      v9 = __errno_location();
      v10 = *((_DWORD *)v2 + 14);
      *((_DWORD *)v2 + 15) = *v9;
      sub_404820(v10, (__int64)v3);
      *((_DWORD *)v2 + 14) = -1;
      return;
    }
    if ( (*(_DWORD *)(a1 + 48) & 0xF000) == 0x8000 )
    {
      v7 = *(_QWORD *)(a1 + 8);
      if ( v14 < v7 )
      {
        v11 = sub_4095E0(0LL, 3LL, v3);
        v12 = dcgettext(0LL, "%s: file truncated", 5);
        error(0, 0, v12, v11);
        sub_404C20(*(_DWORD *)(a1 + 56), 0LL, 0, (__int64)v3);
        *(_QWORD *)(a1 + 8) = 0LL;
      }
      else if ( v14 == v7 && *(_QWORD *)(a1 + 16) == v15 && *(_DWORD *)(a1 + 24) == (_DWORD)v16 )
      {
        return;
      }
    }
    if ( byte_612381 )
      v5 = *a2 != a1;
    v6 = sub_404A20(v5, (__int64)v3, *(_DWORD *)(a1 + 56), 0xFFFFFFFFFFFFFFFFLL);
    *(_QWORD *)(a1 + 8) += v6;
    if ( v6 )
    {
      *a2 = a1;
      if ( fflush_unlocked(stdout) )
      {
        v2 = dcgettext(0LL, "write error", 5);
        v8 = __errno_location();
        error(1, *v8, v2);
        goto LABEL_16;
      }
    }
  }
}

__int64 __usercall sub_405090@<rax>(unsigned int a1@<ebx>, int a2@<edi>, __int64 a3@<rsi>)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  int *v5; // rbp
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // r12
  char *v10; // rax
  struct statfs v11; // [rsp+0h] [rbp-98h]

  if ( !fstatfs(a2, &v11) )
  {
    if ( v11.f_type != 352400198 )
    {
      if ( v11.f_type > 352400198 )
      {
        if ( v11.f_type != 1650746742 )
        {
          if ( v11.f_type > 1650746742 )
          {
            if ( v11.f_type != 1936880249 )
            {
              if ( v11.f_type > 1936880249 )
              {
                if ( v11.f_type != 3380511080LL )
                {
                  if ( v11.f_type > 3380511080LL )
                  {
                    if ( v11.f_type != 4076150800LL )
                    {
                      if ( v11.f_type > 4076150800LL )
                      {
                        if ( v11.f_type != 4185718668LL )
                        {
                          LOBYTE(a1) = v11.f_type != 4187351113LL;
                          return a1;
                        }
                      }
                      else if ( v11.f_type != 3405662737LL )
                      {
                        LOBYTE(a1) = v11.f_type != 3730735588LL;
                        return a1;
                      }
                    }
                  }
                  else if ( v11.f_type != 2435016766LL )
                  {
                    if ( v11.f_type > 2435016766LL )
                    {
                      if ( v11.f_type != 2508478710LL )
                      {
                        LOBYTE(a1) = v11.f_type != 2881100148LL;
                        return a1;
                      }
                    }
                    else if ( v11.f_type != 1953653091 )
                    {
                      LOBYTE(a1) = v11.f_type != 2240043254LL;
                      return a1;
                    }
                  }
                }
              }
              else if ( v11.f_type != 1684300152 )
              {
                if ( v11.f_type > 1684300152 )
                {
                  if ( v11.f_type != 1853056627 )
                  {
                    if ( v11.f_type > 1853056627 )
                    {
                      if ( v11.f_type != 1935894131 )
                      {
                        LOBYTE(a1) = v11.f_type != 1936814952;
                        return a1;
                      }
                    }
                    else if ( v11.f_type != 1733912937 )
                    {
                      LOBYTE(a1) = v11.f_type != 1746473250;
                      return a1;
                    }
                  }
                }
                else if ( v11.f_type != 1650812274 )
                {
                  if ( v11.f_type <= 1650812274 )
                  {
                    LOBYTE(a1) = v11.f_type != 1650812272;
                    return a1;
                  }
                  if ( v11.f_type != 1667723888 )
                  {
                    LOBYTE(a1) = v11.f_type != 1684170528;
                    return a1;
                  }
                }
              }
            }
          }
          else if ( v11.f_type != 1161678120 )
          {
            if ( v11.f_type > 1161678120 )
            {
              if ( v11.f_type != 1410924800 )
              {
                if ( v11.f_type > 1410924800 )
                {
                  if ( v11.f_type != 1481003842 )
                  {
                    if ( v11.f_type > 1481003842 )
                    {
                      if ( v11.f_type != 1513908720 )
                      {
                        LOBYTE(a1) = v11.f_type != 1634035564;
                        return a1;
                      }
                    }
                    else if ( v11.f_type != 1448756819 )
                    {
                      LOBYTE(a1) = v11.f_type != 1479104553;
                      return a1;
                    }
                  }
                }
                else if ( v11.f_type != 1397114950 )
                {
                  if ( v11.f_type > 1397114950 )
                  {
                    if ( v11.f_type != 1397118030 )
                    {
                      LOBYTE(a1) = v11.f_type != 1397703499;
                      return a1;
                    }
                  }
                  else if ( v11.f_type != 1382369651 )
                  {
                    LOBYTE(a1) = v11.f_type != 1397109069;
                    return a1;
                  }
                }
              }
            }
            else if ( v11.f_type != 732765674 )
            {
              if ( v11.f_type > 732765674 )
              {
                if ( v11.f_type != 1111905073 )
                {
                  if ( v11.f_type > 1111905073 )
                  {
                    if ( v11.f_type != 1112100429 )
                    {
                      LOBYTE(a1) = v11.f_type != 1128357203;
                      return a1;
                    }
                  }
                  else if ( v11.f_type != 801189825 )
                  {
                    LOBYTE(a1) = v11.f_type != 827541066;
                    return a1;
                  }
                }
              }
              else if ( v11.f_type != 464386766 )
              {
                if ( v11.f_type <= 464386766 )
                {
                  LOBYTE(a1) = v11.f_type != 427819522;
                  return a1;
                }
                if ( v11.f_type != 604313861 )
                {
                  LOBYTE(a1) = v11.f_type != 684539205;
                  return a1;
                }
              }
            }
          }
        }
      }
      else if ( v11.f_type != 29366 )
      {
        if ( v11.f_type > 29366 )
        {
          if ( v11.f_type != 4278867 )
          {
            if ( v11.f_type > 4278867 )
            {
              if ( v11.f_type > 19920823 )
              {
                if ( v11.f_type != 195894762 )
                {
                  if ( v11.f_type > 195894762 )
                  {
                    if ( v11.f_type != 288389204 )
                    {
                      LOBYTE(a1) = v11.f_type != 325456742;
                      return a1;
                    }
                  }
                  else if ( v11.f_type != 124082209 )
                  {
                    LOBYTE(a1) = v11.f_type != 151263540;
                    return a1;
                  }
                }
              }
              else if ( v11.f_type < 19920820 && v11.f_type != 16914836 )
              {
                if ( v11.f_type <= 16914836 )
                {
                  LOBYTE(a1) = v11.f_type != 12648430;
                  return a1;
                }
                if ( v11.f_type != 16914839 )
                {
                  LOBYTE(a1) = v11.f_type != 19911021;
                  return a1;
                }
              }
            }
            else if ( v11.f_type != 44543 )
            {
              if ( v11.f_type > 44543 )
              {
                if ( v11.f_type != 61791 )
                {
                  if ( v11.f_type > 61791 )
                  {
                    if ( v11.f_type != 72020 )
                    {
                      LOBYTE(a1) = v11.f_type != 2613483;
                      return a1;
                    }
                  }
                  else if ( v11.f_type != 61265 )
                  {
                    LOBYTE(a1) = v11.f_type != 61267;
                    return a1;
                  }
                }
              }
              else
              {
                if ( v11.f_type > 40866 )
                {
                  LOBYTE(a1) = v11.f_type != 44533;
                  return a1;
                }
                if ( v11.f_type < 40864 )
                {
                  LOBYTE(a1) = v11.f_type != 38496;
                  return a1;
                }
              }
            }
          }
        }
        else if ( v11.f_type != 13364 )
        {
          if ( v11.f_type > 13364 )
          {
            if ( v11.f_type != 18475 )
            {
              if ( v11.f_type > 18475 )
              {
                if ( v11.f_type != 19802 )
                {
                  if ( v11.f_type > 19802 )
                  {
                    if ( v11.f_type != 24053 )
                    {
                      LOBYTE(a1) = v11.f_type != 29301;
                      return a1;
                    }
                  }
                  else if ( v11.f_type != 18520 )
                  {
                    LOBYTE(a1) = v11.f_type != 19780;
                    return a1;
                  }
                }
              }
              else if ( v11.f_type != 16388 )
              {
                if ( v11.f_type <= 16388 )
                {
                  LOBYTE(a1) = v11.f_type != 0x4000;
                  return a1;
                }
                if ( v11.f_type != 16390 )
                {
                  LOBYTE(a1) = v11.f_type != 16964;
                  return a1;
                }
              }
            }
          }
          else if ( v11.f_type != 4989 )
          {
            if ( v11.f_type > 4989 )
            {
              if ( v11.f_type != 7377 )
              {
                if ( v11.f_type > 7377 )
                {
                  if ( v11.f_type != 9320 )
                  {
                    LOBYTE(a1) = v11.f_type != 9336;
                    return a1;
                  }
                }
                else if ( v11.f_type != 4991 )
                {
                  LOBYTE(a1) = v11.f_type != 5007;
                  return a1;
                }
              }
            }
            else if ( v11.f_type != 391 )
            {
              if ( v11.f_type <= 391 )
              {
                LOBYTE(a1) = v11.f_type != 47;
                return a1;
              }
              if ( v11.f_type != 1984 )
              {
                LOBYTE(a1) = v11.f_type != 4979;
                return a1;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  a1 = 1;
  v5 = __errno_location();
  if ( *v5 == 38 )
    return a1;
  v9 = sub_409510(4LL, a3, v3, v4, v6, v7);
  v10 = dcgettext(0LL, "cannot determine location of %s. reverting to polling", 5);
  error(0, *v5, v10, v9);
  return 1LL;
}

void __fastcall sub_4056E0(__int64 a1, char a2)
{
  int v2; // er13
  __int64 v3; // rbx
  int v4; // er14
  bool v5; // zf
  _BOOL4 v6; // ebp
  unsigned int v7; // er12
  int v8; // eax
  char v9; // r15
  char v10; // al
  int *v11; // rax
  char v12; // r15
  const char *v13; // rbp
  int *v14; // r13
  int v15; // eax
  char *v16; // rax
  char *v17; // rax
  char *v18; // rax
  char v19; // al
  int v20; // eax
  char *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  const char *v26; // rsi
  __int64 v27; // r14
  char *v28; // rax
  __time_t v29; // rax
  const char *v30; // rdi
  __syscall_slong_t v31; // rax
  __dev_t v32; // rax
  char *v33; // rax
  char *v34; // rax
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v39; // rbp
  char *v40; // rax
  char *v41; // rax
  __int64 v42; // rax
  const char *v43; // rdi
  char *v44; // rax
  char *v45; // rax
  __int64 v46; // rdx
  __int64 v47; // rcx
  __int64 v48; // r8
  __int64 v49; // r9
  __int64 v50; // r14
  char *v51; // rax
  char *v52; // rax
  char *v53; // r13
  char *v54; // rax
  char *v55; // rax
  __int64 v56; // rdx
  __int64 v57; // rcx
  __int64 v58; // r8
  __int64 v59; // r9
  __int64 v60; // rbp
  char *v61; // rax
  const char *v62; // rdi
  char *v63; // rax
  __int64 v64; // rdx
  __int64 v65; // rcx
  __int64 v66; // r8
  __int64 v67; // r9
  __int64 v68; // rbp
  char *v69; // rax
  char *v70; // rax
  __int64 v71; // rdx
  __int64 v72; // rcx
  __int64 v73; // r8
  __int64 v74; // r9
  __int64 v75; // rbp
  char *v76; // rax
  char *v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 v80; // r8
  __int64 v81; // r9
  char v82; // [rsp+7h] [rbp-D1h]
  struct stat stat_buf; // [rsp+10h] [rbp-C8h]

  LOBYTE(v2) = a2;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 60);
  v5 = strcmp(*(const char **)a1, "-") == 0;
  v82 = *(_BYTE *)(a1 + 54);
  v6 = !v5;
  if ( v5 )
  {
    v8 = *(_DWORD *)(a1 + 60);
    v7 = 0;
  }
  else
  {
    v7 = sub_406780(*(_QWORD *)a1);
    v8 = *(_DWORD *)(a1 + 60);
  }
  if ( (*(_DWORD *)(a1 + 56) == -1) == (v8 == 0) )
    __assert_fail("valid_file_spec (f)", "src/tail.c", 0x3C7u, "recheck");
  v9 = byte_612386;
  v10 = byte_612378;
  if ( byte_612386 )
  {
    if ( v7 == -1 )
    {
      *(_BYTE *)(a1 + 54) = 0;
      v13 = *(const char **)a1;
      if ( v10 )
      {
        *(_DWORD *)(a1 + 60) = *__errno_location();
        goto LABEL_29;
      }
      if ( !__lxstat(1, *(const char **)a1, &stat_buf) && (stat_buf.st_mode & 0xF000) == 40960 )
        goto LABEL_54;
LABEL_7:
      v11 = __errno_location();
      v12 = *(_BYTE *)(a1 + 54);
      v13 = *(const char **)a1;
      v14 = v11;
      v15 = *v11;
      *(_DWORD *)(a1 + 60) = v15;
      if ( v12 )
      {
        if ( v15 != v4 )
        {
          v41 = sub_4047E0(v13);
          v42 = sub_4095E0(0LL, 3LL, v41);
          error(0, *v14, "%s", v42);
          v13 = *(const char **)a1;
        }
        goto LABEL_10;
      }
LABEL_29:
      if ( v82 )
      {
        v34 = sub_4047E0(v13);
        v39 = sub_409510(4LL, v34, v35, v36, v37, v38);
        v40 = dcgettext(0LL, "%s has become inaccessible", 5);
        error(0, *(_DWORD *)(a1 + 60), v40, v39);
        v13 = *(const char **)a1;
      }
      goto LABEL_10;
    }
    *(_BYTE *)(a1 + 54) = 1;
    if ( !v10 && !__lxstat(1, *(const char **)a1, &stat_buf) && (stat_buf.st_mode & 0xF000) == 40960 )
      goto LABEL_54;
  }
  else
  {
    *(_BYTE *)(a1 + 54) = 1;
    if ( !v10 && !__lxstat(1, *(const char **)a1, &stat_buf) && (stat_buf.st_mode & 0xF000) == 40960 )
    {
LABEL_54:
      *(_DWORD *)(a1 + 60) = -1;
      v62 = *(const char **)a1;
      *(_BYTE *)(v3 + 52) = 1;
      v63 = sub_4047E0(v62);
      v68 = sub_409510(4LL, v63, v64, v65, v66, v67);
      v69 = dcgettext(0LL, "%s has been replaced with an untailable symbolic link", 5);
      error(0, 0, v69, v68);
      v13 = *(const char **)v3;
      goto LABEL_10;
    }
    if ( v7 == -1 )
      goto LABEL_7;
  }
  if ( __fxstat(1, v7, &stat_buf) < 0 )
    goto LABEL_7;
  if ( ((stat_buf.st_mode & 0xF000) - 4096) & 0xFFFFE000 && (stat_buf.st_mode & 0xB000) != 0x8000 )
  {
    *(_DWORD *)(a1 + 60) = -1;
    *(_BYTE *)(a1 + 54) = 0;
    if ( v9 && dword_6122A8 == 1 )
    {
      v13 = *(const char **)a1;
      *(_BYTE *)(a1 + 52) = 0;
      if ( v82 )
      {
        v53 = "";
      }
      else
      {
        v53 = "";
        if ( v4 == -1 )
          goto LABEL_10;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 52) = 1;
      if ( !v82 && v4 == -1 )
        goto LABEL_51;
      v54 = dcgettext(0LL, "; giving up on this name", 5);
      v13 = *(const char **)a1;
      v53 = v54;
    }
    v55 = sub_4047E0(v13);
    v60 = sub_409510(4LL, v55, v56, v57, v58, v59);
    v61 = dcgettext(0LL, "%s has been replaced with an untailable file%s", 5);
    error(0, 0, v61, v60, v53);
LABEL_51:
    v13 = *(const char **)a1;
LABEL_10:
    v16 = sub_4047E0(v13);
    sub_404820(v7, (__int64)v16);
    v17 = sub_4047E0(*(const char **)v3);
    sub_404820(*(_DWORD *)(v3 + 56), (__int64)v17);
    *(_DWORD *)(v3 + 56) = -1;
    return;
  }
  v18 = sub_4047E0(*(const char **)a1);
  v19 = sub_405090(a1, v7, (__int64)v18);
  *(_BYTE *)(a1 + 53) = v19;
  if ( v19 && !byte_612378 )
  {
    *(_DWORD *)(a1 + 60) = -1;
    v70 = sub_4047E0(*(const char **)a1);
    v75 = sub_409510(4LL, v70, v71, v72, v73, v74);
    v76 = dcgettext(0LL, "%s has been replaced with an untailable remote file", 5);
    error(0, 0, v76, v75);
    v13 = *(const char **)a1;
    *(_WORD *)(a1 + 52) = 257;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 60) = 0;
  v20 = *(_DWORD *)(a1 + 56);
  if ( v4 & 0xFFFFFFFD )
  {
    if ( v20 != -1 )
      __assert_fail("f->fd == -1", "src/tail.c", 0x414u, "recheck");
    v21 = sub_4047E0(*(const char **)a1);
    v26 = "%s has become accessible";
    v27 = sub_409510(4LL, v21, v22, v23, v24, v25);
    goto LABEL_23;
  }
  v43 = *(const char **)a1;
  if ( v20 == -1 )
  {
    v77 = sub_4047E0(v43);
    v26 = "%s has appeared;  following new file";
    v27 = sub_409510(4LL, v77, v78, v79, v80, v81);
LABEL_23:
    v28 = dcgettext(0LL, v26, 5);
    error(0, 0, v28, v27);
    goto LABEL_24;
  }
  if ( *(_QWORD *)(v3 + 40) == stat_buf.st_ino && *(_QWORD *)(v3 + 32) == stat_buf.st_dev )
  {
    v44 = sub_4047E0(v43);
    sub_404820(v7, (__int64)v44);
    return;
  }
  v45 = sub_4047E0(v43);
  v50 = sub_409510(4LL, v45, v46, v47, v48, v49);
  v51 = dcgettext(0LL, "%s has been replaced;  following new file", 5);
  error(0, 0, v51, v50);
  v52 = sub_4047E0(*(const char **)v3);
  sub_404820(*(_DWORD *)(v3 + 56), (__int64)v52);
LABEL_24:
  v2 = (unsigned __int8)v2;
  *(_DWORD *)(v3 + 56) = v7;
  if ( !v6 )
    v2 = -1;
  v29 = stat_buf.st_mtim.tv_sec;
  v30 = *(const char **)v3;
  *(_BYTE *)(v3 + 52) = 0;
  *(_QWORD *)(v3 + 8) = 0LL;
  *(_QWORD *)(v3 + 16) = v29;
  v31 = stat_buf.st_mtim.tv_nsec;
  *(_DWORD *)(v3 + 64) = v2;
  *(_QWORD *)(v3 + 24) = v31;
  v32 = stat_buf.st_dev;
  *(_QWORD *)(v3 + 88) = 0LL;
  *(_QWORD *)(v3 + 32) = v32;
  *(_QWORD *)(v3 + 40) = stat_buf.st_ino;
  *(_DWORD *)(v3 + 48) = stat_buf.st_mode;
  v33 = sub_4047E0(v30);
  sub_404C20(v7, 0LL, 0, (__int64)v33);
}

void __fastcall __noreturn sub_405D10(int status)
{
  __int64 v1; // rbp
  char *v2; // rax
  char *v3; // rax
  __int64 v4; // rcx
  char *v5; // rax
  __int64 v6; // rcx
  FILE *v7; // rbp
  char *v8; // rax
  FILE *v9; // rbp
  char *v10; // rax
  FILE *v11; // rbp
  char *v12; // rax
  FILE *v13; // rbp
  char *v14; // rax
  char *v15; // rax
  FILE *v16; // rbp
  char *v17; // rax
  FILE *v18; // rbp
  char *v19; // rax
  FILE *v20; // rbp
  char *v21; // rax
  FILE *v22; // rbp
  char *v23; // rax
  FILE *v24; // rbp
  char *v25; // rax
  FILE *v26; // rbp
  char *v27; // rax
  FILE *v28; // rbp
  char *v29; // rax
  const char **v30; // rax
  char *v31; // rbp
  char *v32; // rax
  char *v33; // rax
  char *v34; // r12
  char *v35; // rax
  char *v36; // rax
  char *v37; // rax
  char *v38; // rax
  char *v39; // rax
  char *v40; // rax
  __int64 v41; // rcx
  const char *v42; // [rsp+0h] [rbp-88h]
  const char *v43; // [rsp+8h] [rbp-80h]
  const char *v44; // [rsp+10h] [rbp-78h]
  const char *v45; // [rsp+18h] [rbp-70h]
  const char *v46; // [rsp+20h] [rbp-68h]
  const char *v47; // [rsp+28h] [rbp-60h]
  const char *v48; // [rsp+30h] [rbp-58h]
  const char *v49; // [rsp+38h] [rbp-50h]
  const char *v50; // [rsp+40h] [rbp-48h]
  const char *v51; // [rsp+48h] [rbp-40h]
  const char *v52; // [rsp+50h] [rbp-38h]
  const char *v53; // [rsp+58h] [rbp-30h]
  __int64 v54; // [rsp+60h] [rbp-28h]
  __int64 v55; // [rsp+68h] [rbp-20h]

  v1 = qword_6123A0;
  if ( status )
  {
    v2 = dcgettext(0LL, "Try '%s --help' for more information.\n", 5);
    __fprintf_chk(stderr, 1LL, v2, v1);
    goto LABEL_3;
  }
  v3 = dcgettext(0LL, "Usage: %s [OPTION]... [FILE]...\n", 5);
  __printf_chk(1LL, v3, v1, v4);
  v5 = dcgettext(
         0LL,
         "Print the last %d lines of each FILE to standard output.\n"
         "With more than one FILE, precede each with a header giving the file name.\n",
         5);
  __printf_chk(1LL, v5, 10LL, v6);
  v7 = stdout;
  v8 = dcgettext(0LL, "\nWith no FILE, or when FILE is -, read standard input.\n", 5);
  fputs_unlocked(v8, v7);
  v9 = stdout;
  v10 = dcgettext(0LL, "\nMandatory arguments to long options are mandatory for short options too.\n", 5);
  fputs_unlocked(v10, v9);
  v11 = stdout;
  v12 = dcgettext(
          0LL,
          "  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
          "                             output starting with byte NUM of each file\n",
          5);
  fputs_unlocked(v12, v11);
  v13 = stdout;
  v14 = dcgettext(
          0LL,
          "  -f, --follow[={name|descriptor}]\n"
          "                           output appended data as the file grows;\n"
          "                             an absent option argument means 'descriptor'\n"
          "  -F                       same as --follow=name --retry\n",
          5);
  fputs_unlocked(v14, v13);
  v15 = dcgettext(
          0LL,
          "  -n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\n"
          "                             or use -n +NUM to output starting with line NUM\n"
          "      --max-unchanged-stats=N\n"
          "                           with --follow=name, reopen a FILE which has not\n"
          "                             changed size after N (default %d) iterations\n"
          "                             to see if it has been unlinked or renamed\n"
          "                             (this is the usual case of rotated log files);\n"
          "                             with inotify, this option is rarely useful\n",
          5);
  __printf_chk(1LL, v15, 10LL, 5LL);
  v16 = stdout;
  v17 = dcgettext(
          0LL,
          "      --pid=PID            with -f, terminate after process ID, PID dies\n"
          "  -q, --quiet, --silent    never output headers giving file names\n"
          "      --retry              keep trying to open a file if it is inaccessible\n",
          5);
  fputs_unlocked(v17, v16);
  v18 = stdout;
  v19 = dcgettext(
          0LL,
          "  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
          "                             (default 1.0) between iterations;\n"
          "                             with inotify and --pid=P, check process P at\n"
          "                             least once every N seconds\n"
          "  -v, --verbose            always output headers giving file names\n",
          5);
  fputs_unlocked(v19, v18);
  v20 = stdout;
  v21 = dcgettext(0LL, "  -z, --zero-terminated    line delimiter is NUL, not newline\n", 5);
  fputs_unlocked(v21, v20);
  v22 = stdout;
  v23 = dcgettext(0LL, "      --help     display this help and exit\n", 5);
  fputs_unlocked(v23, v22);
  v24 = stdout;
  v25 = dcgettext(0LL, "      --version  output version information and exit\n", 5);
  fputs_unlocked(v25, v24);
  v26 = stdout;
  v27 = dcgettext(
          0LL,
          "\n"
          "NUM may have a multiplier suffix:\n"
          "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
          "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
          "\n",
          5);
  fputs_unlocked(v27, v26);
  v28 = stdout;
  v29 = dcgettext(
          0LL,
          "With --follow (-f), tail defaults to following the file descriptor, which\n"
          "means that even if a tail'ed file is renamed, tail will continue to track\n"
          "its end.  This default behavior is not desirable when you really want to\n"
          "track the actual name of the file, not the file descriptor (e.g., log\n"
          "rotation).  Use --follow=name in that case.  That causes tail to track the\n"
          "named file in a way that accommodates renaming, removal and creation.\n",
          5);
  fputs_unlocked(v29, v28);
  v42 = "[";
  v30 = &v42;
  v43 = "test invocation";
  v44 = "coreutils";
  v45 = "Multi-call invocation";
  v46 = "sha224sum";
  v47 = "sha2 utilities";
  v48 = "sha256sum";
  v49 = "sha2 utilities";
  v50 = "sha384sum";
  v51 = "sha2 utilities";
  v52 = "sha512sum";
  v53 = "sha2 utilities";
  v54 = 0LL;
  v55 = 0LL;
  do
    v30 += 2;
  while ( *v30 && strcmp("tail", *v30) );
  v31 = (char *)v30[1];
  if ( v31 )
  {
    v32 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
    __printf_chk(1LL, v32, &unk_40C375, "https://www.gnu.org/software/coreutils/");
    v33 = setlocale(5, 0LL);
    if ( !v33 || !strncmp(v33, "en_", 3uLL) )
      goto LABEL_10;
  }
  else
  {
    v37 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
    __printf_chk(1LL, v37, &unk_40C375, "https://www.gnu.org/software/coreutils/");
    v38 = setlocale(5, 0LL);
    if ( !v38 || !strncmp(v38, "en_", 3uLL) )
    {
      v31 = "tail";
      v39 = dcgettext(0LL, "Full documentation at: <%s%s>\n", 5);
      v34 = "Multi-call invocation" + 10;
      __printf_chk(1LL, v39, "https://www.gnu.org/software/coreutils/", "tail");
LABEL_12:
      v36 = dcgettext(0LL, "or available locally via: info '(coreutils) %s%s'\n", 5);
      __printf_chk(1LL, v36, v31, v34);
LABEL_3:
      exit(status);
    }
    v31 = "tail";
  }
  v40 = dcgettext(0LL, "Report %s translation bugs to <https://translationproject.org/team/>\n", 5);
  __printf_chk(1LL, v40, "tail", v41);
LABEL_10:
  v34 = "Multi-call invocation" + 10;
  v35 = dcgettext(0LL, "Full documentation at: <%s%s>\n", 5);
  __printf_chk(1LL, v35, "https://www.gnu.org/software/coreutils/", "tail");
  if ( v31 != "tail" )
    v34 = "";
  goto LABEL_12;
}

void __noreturn sub_406170()
{
  sub_405D10(1);
}

__int64 __fastcall sub_406180(const char *a1, const char **a2, char *a3, size_t a4)
{
  size_t v4; // r13
  char *v5; // rbp
  size_t v6; // rax
  const char *v7; // r14
  size_t v8; // r12
  __int64 v9; // rbx
  bool v10; // zf
  char v11; // al
  __int64 v12; // rax
  __int64 v14; // [rsp+0h] [rbp-58h]
  char v15; // [rsp+17h] [rbp-41h]
  char *v16; // [rsp+18h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v16 = a3;
  v6 = strlen(a1);
  v7 = *a2;
  v14 = -1LL;
  if ( !*a2 )
    return v14;
  v8 = v6;
  v15 = 0;
  v9 = 0LL;
  do
  {
    while ( strncmp(v7, a1, v8) )
    {
LABEL_7:
      ++v9;
      v5 += v4;
      v7 = a2[v9];
      if ( !v7 )
        goto LABEL_12;
    }
    if ( strlen(v7) == v8 )
      return v9;
    if ( v14 != -1 )
    {
      if ( v16 )
      {
        v10 = memcmp(&v16[v4 * v14], v5, v4) == 0;
        v11 = v15;
        if ( !v10 )
          v11 = 1;
        v15 = v11;
      }
      else
      {
        v15 = 1;
      }
      goto LABEL_7;
    }
    v14 = v9++;
    v5 += v4;
    v7 = a2[v9];
  }
  while ( v7 );
LABEL_12:
  v12 = -2LL;
  if ( !v15 )
    v12 = v14;
  return v12;
}

void __fastcall sub_4062A0(__int64 a1, __int64 a2, __int64 a3)
{
  char *v3; // rbx
  __int64 v4; // rbp
  __int64 v5; // rax

  if ( a3 == -1 )
    v3 = dcgettext(0LL, "invalid argument %s for %s", 5);
  else
    v3 = dcgettext(0LL, "ambiguous argument %s for %s", 5);
  v4 = sub_409740(1LL, a1);
  v5 = sub_409430(0LL, 8LL, a2);
  error(0, 0, v3, v5, v4);
}

int __fastcall sub_406320(__int64 *a1, char *a2, size_t a3)
{
  const void *v3; // r14
  size_t v4; // r13
  char *v5; // rbp
  FILE *v6; // rbx
  char *v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rbx
  __int64 i; // r12
  __int64 v11; // rax
  __int64 v12; // rax
  char *v13; // rax

  v3 = 0LL;
  v4 = a3;
  v5 = a2;
  v6 = stderr;
  v7 = dcgettext(0LL, "Valid arguments are:", 5);
  v8 = (__int64)v6;
  v9 = 0LL;
  fputs_unlocked(v7, (FILE *)v8);
  for ( i = *a1; i; i = a1[v9] )
  {
    while ( 1 )
    {
      if ( v9 )
      {
        v8 = (__int64)v5;
        if ( !memcmp(v3, v5, v4) )
          break;
      }
      ++v9;
      v3 = v5;
      v5 += v4;
      v11 = sub_409760(i, v8);
      v8 = 1LL;
      __fprintf_chk(stderr, 1LL, "\n  - %s", v11);
      i = a1[v9];
      if ( !i )
        goto LABEL_7;
    }
    ++v9;
    v5 += v4;
    v12 = sub_409760(i, v8);
    v8 = 1LL;
    __fprintf_chk(stderr, 1LL, ", %s", v12);
  }
LABEL_7:
  v13 = stderr->_IO_write_ptr;
  if ( v13 >= stderr->_IO_write_end )
  {
    LODWORD(v13) = __overflow(stderr, 10);
  }
  else
  {
    stderr->_IO_write_ptr = v13 + 1;
    *v13 = 10;
  }
  return (int)v13;
}

__int64 __fastcall sub_406440(__int64 a1, const char *a2, const char **a3, char *a4, size_t a5, void (*a6)(void))
{
  size_t v6; // r15
  void (*v7)(void); // r13
  char *v8; // rbp
  __int64 *v9; // rbx
  __int64 result; // rax

  v6 = a5;
  v7 = a6;
  v8 = a4;
  v9 = (__int64 *)a3;
  result = sub_406180(a2, a3, a4, a5);
  if ( result < 0 )
  {
    sub_4062A0(a1, (__int64)a2, result);
    sub_406320(v9, v8, v6);
    v7();
    result = -1LL;
  }
  return result;
}

__int64 __fastcall sub_4064B0(void *s1, __int64 *a2, char *a3, size_t a4)
{
  __int64 v4; // r14
  size_t v5; // r12
  __int64 *v6; // rbx
  char *v7; // rbp

  v4 = *a2;
  if ( *a2 )
  {
    v5 = a4;
    v6 = a2 + 1;
    v7 = a3;
    do
    {
      if ( !memcmp(s1, v7, v5) )
        break;
      v4 = *v6;
      v7 += v5;
      ++v6;
    }
    while ( v4 );
  }
  return v4;
}

void __fastcall sub_406500(char *nptr, char **endptr)
{
  if ( !loc )
    loc = newlocale(8127, "C", 0LL);
  if ( loc )
  {
    strtod_l(nptr, endptr, loc);
  }
  else if ( endptr )
  {
    *endptr = nptr;
  }
}

__int64 sub_406590()
{
  int *v0; // rax
  int *v1; // rbx
  __int64 result; // rax
  char *v3; // rax
  char *v4; // rbp
  __int64 v5; // rax

  if ( (unsigned int)sub_40B8F0(stdout) )
  {
    v0 = __errno_location();
    v1 = v0;
    if ( !byte_612390 || *v0 != 32 )
    {
      v3 = dcgettext(0LL, "write error", 5);
      v4 = v3;
      if ( qword_612398 )
      {
        v5 = sub_4095B0();
        error(0, *v1, "%s: %s", v5, v4);
      }
      else
      {
        error(0, *v1, "%s", v3);
      }
LABEL_8:
      _exit(status);
    }
  }
  result = sub_40B8F0(stderr);
  if ( (_DWORD)result )
    goto LABEL_8;
  return result;
}

__int64 __fastcall sub_406630(_BYTE *a1)
{
  unsigned __int64 v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rdx

  v1 = *a1 == 47;
  v2 = sub_4066F0(a1);
  if ( v2 - (__int64)a1 <= v1 )
    return v2 - (_QWORD)a1;
  v3 = v2 - (_QWORD)a1 - 1;
  if ( *(_BYTE *)(v2 - 1) != 47 )
    return v2 - (_QWORD)a1;
  while ( v1 != v3 && a1[v3 - 1] == 47 )
    --v3;
  return v3;
}

_BYTE *__fastcall sub_406690(void *src)
{
  __int64 v1; // rax
  size_t v2; // rbx
  _BYTE *v3; // rax
  _BYTE *v4; // rcx
  _BYTE *v5; // rax

  v1 = sub_406630(src);
  v2 = v1;
  v3 = malloc(v1 + (v1 == 0) + 1);
  v4 = v3;
  if ( v3 )
  {
    v5 = memcpy(v3, src, v2);
    v4 = v5;
    if ( !v2 )
    {
      *v5 = 46;
      v2 = 1LL;
    }
    v5[v2] = 0;
  }
  return v4;
}

_BYTE *__fastcall sub_4066F0(_BYTE *a1)
{
  char v1; // dl
  _BYTE *result; // rax
  _BYTE *v3; // rcx
  char v4; // si

  v1 = *a1;
  for ( result = a1; *result == 47; v1 = *result )
    ++result;
  if ( v1 )
  {
    v3 = result;
    v4 = 0;
    do
    {
      while ( v1 == 47 )
      {
        v1 = *++v3;
        v4 = 1;
        if ( !*v3 )
          return result;
      }
      if ( v4 )
      {
        result = v3;
        v4 = 0;
      }
      v1 = *++v3;
    }
    while ( *v3 );
  }
  return result;
}

__int64 __fastcall sub_406780(const char *a1, char a2, unsigned int a3)
{
  __int64 v3; // rdx
  int v4; // eax
  unsigned int v6; // [rsp+30h] [rbp-28h]

  v6 = a3;
  v3 = 0LL;
  if ( a2 & 0x40 )
    v3 = v6;
  v4 = open(a1, a2, v3);
  return sub_4097E0(v4);
}

unsigned __int64 __fastcall sub_4067D0(unsigned __int64 a1)
{
  __int64 v1; // rsi
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // rax
  __int64 v4; // r8
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rcx

  v1 = 10LL;
  if ( a1 >= 0xA )
    v1 = a1;
  v2 = v1 | 1;
  if ( v2 != -1LL )
  {
    while ( 1 )
    {
      v3 = v2 % 3;
      if ( v2 <= 9 )
        goto LABEL_9;
      if ( v2 % 3 )
        break;
LABEL_10:
      v2 += 2LL;
      if ( v2 == -1LL )
        return v2;
    }
    v4 = 16LL;
    v5 = 9LL;
    v6 = 3LL;
    while ( 1 )
    {
      v6 += 2LL;
      v5 += v4;
      v3 = v2 % v6;
      if ( v5 >= v2 )
        break;
      v4 += 8LL;
      if ( !(v2 % v6) )
        goto LABEL_10;
    }
LABEL_9:
    if ( v3 )
      return v2;
    goto LABEL_10;
  }
  return v2;
}

unsigned __int64 __fastcall sub_406870(__int64 a1, unsigned __int64 a2)
{
  return __ROR8__(a1, 3) % a2;
}

bool __fastcall sub_406880(__int64 a1, __int64 a2)
{
  return a1 == a2;
}

__int64 __fastcall sub_406890(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rax

  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));
  if ( *(_QWORD *)(a1 + 16) <= v2 )
    abort();
  return *(_QWORD *)a1 + 16 * v2;
}

__int64 __fastcall sub_406890(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rax

  v2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));
  if ( *(_QWORD *)(a1 + 16) <= v2 )
    abort();
  return *(_QWORD *)a1 + 16 * v2;
}

__int64 __fastcall sub_4068C0(__int64 a1, __int64 a2, __m128i **a3, char a4)
{
  __m128i **v4; // r14
  char v5; // r13
  __int64 v6; // rbp
  __m128i *v7; // rax
  __int64 v8; // rsi
  __m128i *v9; // rbx
  __int64 *v10; // rax
  const __m128i *v12; // rax

  v4 = a3;
  v5 = a4;
  v6 = a2;
  v7 = (__m128i *)sub_406890(a1, a2);
  *v4 = v7;
  v8 = v7->m128i_i64[0];
  if ( v7->m128i_i64[0] )
  {
    v9 = v7;
    if ( v8 != v6 )
    {
      if ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v6) )
      {
        v10 = (__int64 *)v9->m128i_i64[1];
        if ( v10 )
        {
          v8 = *v10;
          if ( v6 != *v10 )
          {
            while ( !(*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v6) )
            {
              v9 = (__m128i *)v9->m128i_i64[1];
              v10 = (__int64 *)v9->m128i_i64[1];
              if ( !v10 )
                return 0LL;
              v8 = *v10;
              if ( *v10 == v6 )
                goto LABEL_11;
            }
            v10 = (__int64 *)v9->m128i_i64[1];
            v8 = *v10;
          }
LABEL_11:
          if ( v5 )
          {
            v9->m128i_i64[1] = v10[1];
            *v10 = 0LL;
            v10[1] = *(_QWORD *)(a1 + 72);
            *(_QWORD *)(a1 + 72) = v10;
          }
          return v8;
        }
        return 0LL;
      }
      v8 = v9->m128i_i64[0];
    }
    if ( v5 )
    {
      v12 = (const __m128i *)v9->m128i_i64[1];
      if ( v12 )
      {
        *v9 = _mm_loadu_si128(v12);
        v12->m128i_i64[0] = 0LL;
        v12->m128i_i64[1] = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 72) = v12;
        return v8;
      }
      v9->m128i_i64[0] = 0LL;
    }
    return v8;
  }
  return 0LL;
}

__int64 __fastcall sub_4069E0(float **a1)
{
  float *v1; // rax
  float v2; // xmm0_4
  float v3; // xmm1_4
  float v4; // xmm2_4
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 == (float *)&unk_40D880 )
    return 1LL;
  v2 = v1[2];
  if ( v2 <= 0.1
    || v2 >= 0.89999998
    || v1[3] <= 1.1
    || *v1 < 0.0
    || (v3 = *v1 + 0.1, v4 = v1[1], v4 <= v3)
    || v4 > 1.0
    || (result = 1LL, v2 <= v3) )
  {
    *a1 = (float *)&unk_40D880;
    result = 0LL;
  }
  return result;
}

__int64 __fastcall sub_406A60(__int64 a1, __int64 a2, char a3)
{
  char v3; // r14
  __int64 *v4; // r12
  __int64 v5; // r15
  __int64 *v6; // rbx
  __int64 v7; // r15
  _QWORD *v8; // rax
  __int64 *v9; // rdx
  _QWORD *v10; // rax
  _QWORD *v11; // rbx
  _QWORD *v12; // rax
  __int64 v13; // rdx

  v3 = a3;
  v4 = *(__int64 **)a2;
  if ( *(_QWORD *)a2 >= *(_QWORD *)(a2 + 8) )
    return 1LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v5 = *v4;
      if ( *v4 )
      {
        v6 = (__int64 *)v4[1];
        if ( v6 )
        {
          do
          {
            while ( 1 )
            {
              v7 = *v6;
              v8 = (_QWORD *)sub_406890(a1, *v6);
              v9 = (__int64 *)v6[1];
              if ( !*v8 )
                break;
              v6[1] = v8[1];
              v8[1] = v6;
              v6 = v9;
              if ( !v9 )
                goto LABEL_10;
            }
            *v8 = v7;
            ++*(_QWORD *)(a1 + 24);
            *v6 = 0LL;
            v6[1] = *(_QWORD *)(a1 + 72);
            *(_QWORD *)(a1 + 72) = v6;
            v6 = v9;
          }
          while ( v9 );
LABEL_10:
          v5 = *v4;
        }
        v4[1] = 0LL;
        if ( !v3 )
          break;
      }
      v4 += 2;
      if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )
        return 1LL;
    }
    v10 = (_QWORD *)sub_406890(a1, v5);
    v11 = v10;
    if ( !*v10 )
    {
      *v10 = v5;
      ++*(_QWORD *)(a1 + 24);
      goto LABEL_16;
    }
    v12 = *(_QWORD **)(a1 + 72);
    if ( !v12 )
      break;
    *(_QWORD *)(a1 + 72) = v12[1];
LABEL_15:
    v13 = v11[1];
    *v12 = v5;
    v12[1] = v13;
    v11[1] = v12;
LABEL_16:
    *v4 = 0LL;
    v4 += 2;
    --*(_QWORD *)(a2 + 24);
    if ( *(_QWORD *)(a2 + 8) <= (unsigned __int64)v4 )
      return 1LL;
  }
  v12 = malloc(0x10uLL);
  if ( v12 )
    goto LABEL_15;
  return 0LL;
}

__int64 __fastcall sub_406BD0(__int64 a1)
{
  return *(_QWORD *)(a1 + 32);
}

__int64 __fastcall sub_406DF0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  _QWORD *v3; // rax
  __int64 v4; // rsi
  _QWORD *v5; // rbx

  v2 = a2;
  v3 = (_QWORD *)sub_406890(a1, a2);
  v4 = *v3;
  if ( !*v3 )
    return 0LL;
  v5 = v3;
  while ( v4 != v2 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(a1 + 56))(v2) )
      return *v5;
    v5 = (_QWORD *)v5[1];
    if ( !v5 )
      return 0LL;
    v4 = *v5;
  }
  return v2;
}

__int64 __fastcall sub_406EA0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rcx
  _QWORD *v3; // rdx
  __int64 v4; // rax
  __int64 result; // rax

  v2 = (_QWORD *)sub_406890(a1, a2);
  v3 = v2;
  while ( 1 )
  {
    v4 = *v3;
    v3 = (_QWORD *)v3[1];
    if ( v4 == a2 )
      break;
    if ( !v3 )
      goto LABEL_7;
  }
  if ( v3 )
    return *v3;
LABEL_7:
  while ( 1 )
  {
    v2 += 2;
    if ( *(_QWORD *)(a1 + 8) <= (unsigned __int64)v2 )
      break;
    result = *v2;
    if ( *v2 )
      return result;
  }
  return 0LL;
}

__int64 __fastcall sub_406F80(__int64 a1, unsigned __int8 (__fastcall *a2)(__int64, __int64), __int64 a3)
{
  __int64 *v3; // r14
  __int64 v4; // r13
  __int64 v5; // r15
  __int64 v6; // rbp
  __int64 v7; // rdi
  __int64 *v9; // rbx

  v3 = *(__int64 **)a1;
  if ( *(_QWORD *)(a1 + 8) <= *(_QWORD *)a1 )
    return 0LL;
  v4 = a3;
  v5 = a1;
  v6 = 0LL;
  while ( 1 )
  {
    v7 = *v3;
    if ( *v3 )
      break;
LABEL_4:
    v3 += 2;
    if ( *(_QWORD *)(v5 + 8) <= (unsigned __int64)v3 )
      return v6;
  }
  v9 = v3;
  while ( a2(v7, v4) )
  {
    v9 = (__int64 *)v9[1];
    ++v6;
    if ( !v9 )
      goto LABEL_4;
    v7 = *v9;
  }
  return v6;
}

_QWORD *__fastcall sub_407060(unsigned __int64 a1, __int64 a2, unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2), bool (__fastcall *a4)(__int64 a1, __int64 a2), __int64 a5)
{
  __int64 v5; // r14
  bool (__fastcall *v6)(__int64, __int64); // r13
  unsigned __int64 (__fastcall *v7)(__int64, unsigned __int64); // r12
  unsigned __int64 v8; // rbp
  char *v9; // rax
  _QWORD *v10; // rbx
  float **v11; // rdi
  unsigned __int64 v12; // rbp
  char *v13; // rax
  void *v14; // rdi
  float v16; // xmm1_4
  float v17; // xmm0_4
  float v18; // xmm0_4

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  if ( !a3 )
    v7 = sub_406870;
  if ( !a4 )
    v6 = sub_406880;
  v9 = (char *)malloc(0x50uLL);
  v10 = v9;
  if ( v9 )
  {
    v11 = (float **)(v9 + 40);
    if ( a2 )
    {
      *((_QWORD *)v9 + 5) = a2;
      if ( !(unsigned __int8)sub_4069E0(v11) )
        goto LABEL_14;
      if ( *(_BYTE *)(a2 + 16) )
      {
LABEL_9:
        v12 = sub_4067D0(v8);
        if ( !_bittest64((const __int64 *)&v12, 0x3Cu) && v12 >> 61 == 0 )
        {
          v10[2] = v12;
          if ( v12 )
          {
            v13 = (char *)calloc(v12, 0x10uLL);
            *v10 = v13;
            if ( v13 )
            {
              v10[3] = 0LL;
              v10[4] = 0LL;
              v10[1] = &v13[16 * v12];
              v10[6] = v7;
              v10[7] = v6;
              v10[8] = v5;
              v10[9] = 0LL;
              return v10;
            }
          }
        }
LABEL_14:
        v14 = v10;
        v10 = 0LL;
        free(v14);
        return v10;
      }
      v16 = *(float *)(a2 + 8);
      if ( (v8 & 0x8000000000000000LL) != 0LL )
        goto LABEL_23;
    }
    else
    {
      *((_QWORD *)v9 + 5) = &unk_40D880;
      v16 = 0.80000001;
      if ( !(unsigned __int8)sub_4069E0(v11) )
        goto LABEL_14;
      if ( (v8 & 0x8000000000000000LL) != 0LL )
      {
LABEL_23:
        v17 = (float)(int)(v8 & 1 | (v8 >> 1)) + (float)(int)(v8 & 1 | (v8 >> 1));
        goto LABEL_19;
      }
    }
    v17 = (float)(int)v8;
LABEL_19:
    v18 = v17 / v16;
    if ( v18 >= 1.8446744e19 )
      goto LABEL_14;
    if ( v18 < 9.223372e18 )
      v8 = (unsigned int)(int)v18;
    else
      v8 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;
    goto LABEL_9;
  }
  return v10;
}

void __fastcall sub_4072A0(void *ptr)
{
  void **v1; // r12
  _QWORD *v2; // rbp
  unsigned __int64 v3; // rax
  _QWORD *v4; // rbx
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx
  _QWORD *v7; // rdi
  _QWORD *v8; // rbx

  v1 = (void **)ptr;
  v2 = *(_QWORD **)ptr;
  v3 = *((_QWORD *)ptr + 1);
  if ( *((_QWORD *)ptr + 8) && *((_QWORD *)ptr + 4) )
  {
    if ( (unsigned __int64)v2 >= v3 )
      goto LABEL_15;
    do
    {
      while ( !*v2 )
      {
        v2 += 2;
        if ( v3 <= (unsigned __int64)v2 )
          goto LABEL_10;
      }
      v4 = v2;
      do
      {
        (*((void (**)(void))ptr + 8))();
        v4 = (_QWORD *)v4[1];
      }
      while ( v4 );
      v3 = *((_QWORD *)ptr + 1);
      v2 += 2;
    }
    while ( v3 > (unsigned __int64)v2 );
LABEL_10:
    v2 = *(_QWORD **)ptr;
  }
  if ( (unsigned __int64)v2 < v3 )
  {
    do
    {
      v5 = (_QWORD *)v2[1];
      if ( v5 )
      {
        do
        {
          v6 = (_QWORD *)v5[1];
          free(v5);
          v5 = v6;
        }
        while ( v6 );
      }
      v2 += 2;
    }
    while ( v1[1] > v2 );
  }
LABEL_15:
  v7 = v1[9];
  if ( v7 )
  {
    do
    {
      v8 = (_QWORD *)v7[1];
      free(v7);
      v7 = v8;
    }
    while ( v8 );
  }
  free(*v1);
  free(v1);
}

__int64 __fastcall sub_407380(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r12
  float v3; // xmm0_4
  float v4; // xmm0_4
  unsigned __int64 v5; // rax
  size_t v6; // rbx
  bool v7; // sf
  _BOOL8 v8; // rax
  char *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  unsigned int v14; // ebx
  void *ptr; // [rsp+0h] [rbp-68h]
  __int64 v17; // [rsp+8h] [rbp-60h]
  size_t v18; // [rsp+10h] [rbp-58h]
  __int64 v19; // [rsp+18h] [rbp-50h]
  __int64 v20; // [rsp+20h] [rbp-48h]
  __int64 v21; // [rsp+28h] [rbp-40h]
  __int64 v22; // [rsp+30h] [rbp-38h]
  __int64 v23; // [rsp+38h] [rbp-30h]
  __int64 v24; // [rsp+40h] [rbp-28h]
  __int64 v25; // [rsp+48h] [rbp-20h]

  v2 = *(_QWORD *)(a1 + 40);
  if ( !*(_BYTE *)(v2 + 16) )
  {
    if ( (a2 & 0x8000000000000000LL) != 0LL )
      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));
    else
      v3 = (float)(int)a2;
    v4 = v3 / *(float *)(v2 + 8);
    if ( v4 >= 1.8446744e19 )
      return 0;
    if ( v4 < 9.223372e18 )
      a2 = (unsigned int)(int)v4;
    else
      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;
  }
  v5 = sub_4067D0(a2);
  v6 = v5;
  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;
  v8 = v5 >> 61 != 0;
  if ( v7 )
    v8 = 1LL;
  if ( !v6 || v8 )
    return 0;
  if ( *(_QWORD *)(a1 + 16) == v6 )
    return 1LL;
  v9 = (char *)calloc(v6, 0x10uLL);
  ptr = v9;
  if ( !v9 )
    return 0;
  v18 = v6;
  v10 = (__int64)&v9[16 * v6];
  v11 = *(_QWORD *)(a1 + 48);
  v19 = 0LL;
  v17 = v10;
  v22 = v11;
  v12 = *(_QWORD *)(a1 + 56);
  v20 = 0LL;
  v23 = v12;
  v13 = *(_QWORD *)(a1 + 64);
  v21 = v2;
  v24 = v13;
  v25 = *(_QWORD *)(a1 + 72);
  v14 = sub_406A60((__int64)&ptr, a1, 0);
  if ( (_BYTE)v14 )
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = ptr;
    *(_QWORD *)(a1 + 8) = v17;
    *(_QWORD *)(a1 + 16) = v18;
    *(_QWORD *)(a1 + 24) = v19;
    *(_QWORD *)(a1 + 72) = v25;
    return v14;
  }
  *(_QWORD *)(a1 + 72) = v25;
  if ( !(unsigned __int8)sub_406A60(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_406A60(a1, (__int64)&ptr, 0) )
    abort();
  free(ptr);
  return v14;
}

__int64 __fastcall sub_407380(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r12
  float v3; // xmm0_4
  float v4; // xmm0_4
  unsigned __int64 v5; // rax
  size_t v6; // rbx
  bool v7; // sf
  _BOOL8 v8; // rax
  char *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  unsigned int v14; // ebx
  void *ptr; // [rsp+0h] [rbp-68h]
  __int64 v17; // [rsp+8h] [rbp-60h]
  size_t v18; // [rsp+10h] [rbp-58h]
  __int64 v19; // [rsp+18h] [rbp-50h]
  __int64 v20; // [rsp+20h] [rbp-48h]
  __int64 v21; // [rsp+28h] [rbp-40h]
  __int64 v22; // [rsp+30h] [rbp-38h]
  __int64 v23; // [rsp+38h] [rbp-30h]
  __int64 v24; // [rsp+40h] [rbp-28h]
  __int64 v25; // [rsp+48h] [rbp-20h]

  v2 = *(_QWORD *)(a1 + 40);
  if ( !*(_BYTE *)(v2 + 16) )
  {
    if ( (a2 & 0x8000000000000000LL) != 0LL )
      v3 = (float)(int)(a2 & 1 | (a2 >> 1)) + (float)(int)(a2 & 1 | (a2 >> 1));
    else
      v3 = (float)(int)a2;
    v4 = v3 / *(float *)(v2 + 8);
    if ( v4 >= 1.8446744e19 )
      return 0;
    if ( v4 < 9.223372e18 )
      a2 = (unsigned int)(int)v4;
    else
      a2 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;
  }
  v5 = sub_4067D0(a2);
  v6 = v5;
  v7 = ((8 * v5) & 0x8000000000000000LL) != 0LL;
  v8 = v5 >> 61 != 0;
  if ( v7 )
    v8 = 1LL;
  if ( !v6 || v8 )
    return 0;
  if ( *(_QWORD *)(a1 + 16) == v6 )
    return 1LL;
  v9 = (char *)calloc(v6, 0x10uLL);
  ptr = v9;
  if ( !v9 )
    return 0;
  v18 = v6;
  v10 = (__int64)&v9[16 * v6];
  v11 = *(_QWORD *)(a1 + 48);
  v19 = 0LL;
  v17 = v10;
  v22 = v11;
  v12 = *(_QWORD *)(a1 + 56);
  v20 = 0LL;
  v23 = v12;
  v13 = *(_QWORD *)(a1 + 64);
  v21 = v2;
  v24 = v13;
  v25 = *(_QWORD *)(a1 + 72);
  v14 = sub_406A60((__int64)&ptr, a1, 0);
  if ( (_BYTE)v14 )
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = ptr;
    *(_QWORD *)(a1 + 8) = v17;
    *(_QWORD *)(a1 + 16) = v18;
    *(_QWORD *)(a1 + 24) = v19;
    *(_QWORD *)(a1 + 72) = v25;
    return v14;
  }
  *(_QWORD *)(a1 + 72) = v25;
  if ( !(unsigned __int8)sub_406A60(a1, (__int64)&ptr, 1) || !(unsigned __int8)sub_406A60(a1, (__int64)&ptr, 0) )
    abort();
  free(ptr);
  return v14;
}

__int64 __fastcall sub_407580(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r12
  __int64 v4; // rbp
  __int64 v5; // rdx
  __int64 result; // rax
  unsigned __int64 v7; // rax
  __int64 v8; // rdx
  float v9; // xmm1_4
  unsigned __int64 v10; // rax
  __int64 *v11; // r12
  _QWORD *v12; // rax
  __int64 v13; // rdx
  int v14; // edx
  float v15; // xmm1_4
  __int64 v16; // rdx
  __int64 v17; // rax
  float v18; // xmm2_4
  float v19; // xmm0_4
  __int64 v20; // rax
  float v21; // xmm1_4
  float v22; // xmm0_4
  __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned __int64 v25; // rsi
  __int64 *v26; // [rsp+8h] [rbp-20h]

  if ( !a2 )
    goto LABEL_35;
  v3 = a3;
  v4 = a2;
  v5 = sub_4068C0(a1, a2, (__m128i **)&v26, 0);
  if ( !v5 )
  {
    v7 = *(_QWORD *)(a1 + 24);
    if ( (v7 & 0x8000000000000000LL) != 0LL )
    {
      v14 = v7 & 1 | (v7 >> 1);
      v10 = *(_QWORD *)(a1 + 16);
      v15 = (float)v14;
      v8 = *(_QWORD *)(a1 + 40);
      v9 = v15 + v15;
      if ( (v10 & 0x8000000000000000LL) == 0LL )
      {
LABEL_8:
        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )
          goto LABEL_9;
LABEL_15:
        sub_4069E0((float **)(a1 + 40));
        v16 = *(_QWORD *)(a1 + 40);
        v17 = *(_QWORD *)(a1 + 16);
        v18 = *(float *)(v16 + 8);
        if ( v17 < 0 )
        {
          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);
          v19 = (float)(int)v24 + (float)(int)v24;
        }
        else
        {
          v19 = (float)(int)v17;
        }
        v20 = *(_QWORD *)(a1 + 24);
        if ( v20 < 0 )
        {
          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);
          v21 = (float)(int)v23 + (float)(int)v23;
        }
        else
        {
          v21 = (float)(int)v20;
        }
        if ( v21 <= (float)(v18 * v19) )
          goto LABEL_9;
        v22 = v19 * *(float *)(v16 + 12);
        if ( !*(_BYTE *)(v16 + 16) )
          v22 = v22 * v18;
        if ( v22 >= 1.8446744e19 )
          return 0xFFFFFFFFLL;
        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;
        if ( !(unsigned __int8)sub_407380(a1, v25) )
          return 0xFFFFFFFFLL;
        if ( !sub_4068C0(a1, v4, (__m128i **)&v26, 0) )
        {
LABEL_9:
          v11 = v26;
          if ( !*v26 )
          {
            *v26 = v4;
            result = 1LL;
            ++*(_QWORD *)(a1 + 32);
            ++*(_QWORD *)(a1 + 24);
            return result;
          }
          v12 = *(_QWORD **)(a1 + 72);
          if ( v12 )
          {
            *(_QWORD *)(a1 + 72) = v12[1];
LABEL_12:
            v13 = v11[1];
            *v12 = v4;
            v12[1] = v13;
            v11[1] = (__int64)v12;
            result = 1LL;
            ++*(_QWORD *)(a1 + 32);
            return result;
          }
          v12 = malloc(0x10uLL);
          if ( v12 )
            goto LABEL_12;
          return 0xFFFFFFFFLL;
        }
LABEL_35:
        abort();
      }
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = (float)(int)v7;
      v10 = *(_QWORD *)(a1 + 16);
      if ( (v10 & 0x8000000000000000LL) == 0LL )
        goto LABEL_8;
    }
    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))
                     * *(float *)(v8 + 8)) )
      goto LABEL_9;
    goto LABEL_15;
  }
  result = 0LL;
  if ( v3 )
    *v3 = v5;
  return result;
}

__int64 __fastcall sub_407580(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r12
  __int64 v4; // rbp
  __int64 v5; // rdx
  __int64 result; // rax
  unsigned __int64 v7; // rax
  __int64 v8; // rdx
  float v9; // xmm1_4
  unsigned __int64 v10; // rax
  __int64 *v11; // r12
  _QWORD *v12; // rax
  __int64 v13; // rdx
  int v14; // edx
  float v15; // xmm1_4
  __int64 v16; // rdx
  __int64 v17; // rax
  float v18; // xmm2_4
  float v19; // xmm0_4
  __int64 v20; // rax
  float v21; // xmm1_4
  float v22; // xmm0_4
  __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned __int64 v25; // rsi
  __int64 *v26; // [rsp+8h] [rbp-20h]

  if ( !a2 )
    goto LABEL_35;
  v3 = a3;
  v4 = a2;
  v5 = sub_4068C0(a1, a2, (__m128i **)&v26, 0);
  if ( !v5 )
  {
    v7 = *(_QWORD *)(a1 + 24);
    if ( (v7 & 0x8000000000000000LL) != 0LL )
    {
      v14 = v7 & 1 | (v7 >> 1);
      v10 = *(_QWORD *)(a1 + 16);
      v15 = (float)v14;
      v8 = *(_QWORD *)(a1 + 40);
      v9 = v15 + v15;
      if ( (v10 & 0x8000000000000000LL) == 0LL )
      {
LABEL_8:
        if ( v9 <= (float)((float)(int)v10 * *(float *)(v8 + 8)) )
          goto LABEL_9;
LABEL_15:
        sub_4069E0((float **)(a1 + 40));
        v16 = *(_QWORD *)(a1 + 40);
        v17 = *(_QWORD *)(a1 + 16);
        v18 = *(float *)(v16 + 8);
        if ( v17 < 0 )
        {
          v24 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);
          v19 = (float)(int)v24 + (float)(int)v24;
        }
        else
        {
          v19 = (float)(int)v17;
        }
        v20 = *(_QWORD *)(a1 + 24);
        if ( v20 < 0 )
        {
          v23 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);
          v21 = (float)(int)v23 + (float)(int)v23;
        }
        else
        {
          v21 = (float)(int)v20;
        }
        if ( v21 <= (float)(v18 * v19) )
          goto LABEL_9;
        v22 = v19 * *(float *)(v16 + 12);
        if ( !*(_BYTE *)(v16 + 16) )
          v22 = v22 * v18;
        if ( v22 >= 1.8446744e19 )
          return 0xFFFFFFFFLL;
        v25 = v22 >= 9.223372e18 ? (unsigned int)(int)(float)(v22 - 9.223372e18) ^ 0x8000000000000000LL : (unsigned __int64)(unsigned int)(int)v22;
        if ( !(unsigned __int8)sub_407380(a1, v25) )
          return 0xFFFFFFFFLL;
        if ( !sub_4068C0(a1, v4, (__m128i **)&v26, 0) )
        {
LABEL_9:
          v11 = v26;
          if ( !*v26 )
          {
            *v26 = v4;
            result = 1LL;
            ++*(_QWORD *)(a1 + 32);
            ++*(_QWORD *)(a1 + 24);
            return result;
          }
          v12 = *(_QWORD **)(a1 + 72);
          if ( v12 )
          {
            *(_QWORD *)(a1 + 72) = v12[1];
LABEL_12:
            v13 = v11[1];
            *v12 = v4;
            v12[1] = v13;
            v11[1] = (__int64)v12;
            result = 1LL;
            ++*(_QWORD *)(a1 + 32);
            return result;
          }
          v12 = malloc(0x10uLL);
          if ( v12 )
            goto LABEL_12;
          return 0xFFFFFFFFLL;
        }
LABEL_35:
        abort();
      }
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = (float)(int)v7;
      v10 = *(_QWORD *)(a1 + 16);
      if ( (v10 & 0x8000000000000000LL) == 0LL )
        goto LABEL_8;
    }
    if ( v9 <= (float)((float)((float)(int)(v10 & 1 | (v10 >> 1)) + (float)(int)(v10 & 1 | (v10 >> 1)))
                     * *(float *)(v8 + 8)) )
      goto LABEL_9;
    goto LABEL_15;
  }
  result = 0LL;
  if ( v3 )
    *v3 = v5;
  return result;
}

__int64 __fastcall sub_407800(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v3; // eax
  __int64 v5; // [rsp+8h] [rbp-10h]

  v2 = a2;
  v3 = sub_407580(a1, a2, &v5);
  if ( v3 == -1 )
    return 0LL;
  if ( !v3 )
    v2 = v5;
  return v2;
}

__int64 __fastcall sub_407840(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rbp
  _QWORD *v4; // rax
  __int64 v6; // rax
  float *v7; // rdx
  float v8; // xmm0_4
  unsigned __int64 v9; // rax
  float v10; // xmm1_4
  __int64 v11; // rax
  __int64 v12; // rdx
  float v13; // xmm0_4
  __int64 v14; // rax
  float v15; // xmm1_4
  float v16; // xmm0_4
  unsigned __int64 v17; // rsi
  _QWORD *v18; // rdi
  _QWORD *v19; // r12
  int v20; // edx
  float v21; // xmm0_4
  __int64 v22; // rcx
  __int64 v23; // rcx
  _QWORD *v24; // [rsp+8h] [rbp-20h]

  v2 = a1;
  v3 = sub_4068C0(a1, a2, (__m128i **)&v24, 1);
  if ( !v3 )
    return v3;
  v4 = v24;
  --*(_QWORD *)(a1 + 32);
  if ( *v4 )
    return v3;
  v6 = *(_QWORD *)(a1 + 24) - 1LL;
  *(_QWORD *)(a1 + 24) = v6;
  if ( v6 < 0 )
  {
    v20 = v6 & 1 | ((unsigned __int64)v6 >> 1);
    v9 = *(_QWORD *)(a1 + 16);
    v21 = (float)v20;
    v7 = *(float **)(a1 + 40);
    v8 = v21 + v21;
    if ( (v9 & 0x8000000000000000LL) == 0LL )
      goto LABEL_6;
LABEL_22:
    v10 = (float)(int)(v9 & 1 | (v9 >> 1)) + (float)(int)(v9 & 1 | (v9 >> 1));
    goto LABEL_7;
  }
  v7 = *(float **)(a1 + 40);
  v8 = (float)(int)v6;
  v9 = *(_QWORD *)(a1 + 16);
  if ( (v9 & 0x8000000000000000LL) != 0LL )
    goto LABEL_22;
LABEL_6:
  v10 = (float)(int)v9;
LABEL_7:
  if ( (float)(v10 * *v7) > v8 )
  {
    sub_4069E0((float **)(a1 + 40));
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_QWORD *)(a1 + 40);
    if ( v11 < 0 )
    {
      v23 = *(_QWORD *)(a1 + 16) & 1LL | (*(_QWORD *)(a1 + 16) >> 1);
      v13 = (float)(int)v23 + (float)(int)v23;
    }
    else
    {
      v13 = (float)(int)v11;
    }
    v14 = *(_QWORD *)(a1 + 24);
    if ( v14 < 0 )
    {
      v22 = *(_QWORD *)(a1 + 24) & 1LL | (*(_QWORD *)(a1 + 24) >> 1);
      v15 = (float)(int)v22 + (float)(int)v22;
    }
    else
    {
      v15 = (float)(int)v14;
    }
    if ( (float)(*(float *)v12 * v13) > v15 )
    {
      v16 = v13 * *(float *)(v12 + 4);
      if ( !*(_BYTE *)(v12 + 16) )
        v16 = v16 * *(float *)(v12 + 8);
      if ( v16 >= 9.223372e18 )
        v17 = (unsigned int)(int)(float)(v16 - 9.223372e18) ^ 0x8000000000000000LL;
      else
        v17 = (unsigned int)(int)v16;
      if ( !(unsigned __int8)sub_407380(a1, v17) )
      {
        v18 = *(_QWORD **)(a1 + 72);
        if ( v18 )
        {
          do
          {
            v19 = (_QWORD *)v18[1];
            free(v18);
            v18 = v19;
          }
          while ( v19 );
        }
        *(_QWORD *)(v2 + 72) = 0LL;
      }
    }
  }
  return v3;
}

__int64 __fastcall sub_407A20(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 result; // rax
  int v4; // eax

  v2 = a2 + 20;
  *(_BYTE *)(a2 + 20) = 0;
  if ( a1 < 0 )
  {
    while ( 1 )
    {
      v4 = 10 * (unsigned __int64)(a1 / 10) + 48 - a1;
      a1 /= 10LL;
      *(_BYTE *)(v2 - 1) = v4;
      if ( !a1 )
        break;
      --v2;
    }
    *(_BYTE *)(v2 - 2) = 45;
    result = v2 - 2;
  }
  else
  {
    do
    {
      *(_BYTE *)--v2 = a1 % 0xAuLL + 48;
      a1 /= 0xAuLL;
    }
    while ( a1 );
    result = v2;
  }
  return result;
}

__int64 sub_407AC0()
{
  unsigned int v0; // ebx
  char *v1; // rax
  __int64 v3; // rax
  unsigned int v4; // ebx
  char *endptr; // [rsp+8h] [rbp-10h]

  v0 = 200809;
  v1 = getenv("_POSIX2_VERSION");
  if ( !v1 )
    return v0;
  if ( !*v1 )
    return v0;
  v3 = strtol(v1, &endptr, 10);
  if ( *endptr )
    return v0;
  if ( v3 < -2147483648LL )
    return 2147483648;
  v4 = 0x7FFFFFFF;
  if ( v3 <= 0x7FFFFFFF )
    v4 = v3;
  return v4;
}

char *__fastcall sub_407B40(const char *a1)
{
  __int64 v1; // rbx
  char *result; // rax

  if ( !a1 )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1uLL, 0x37uLL, stderr);
    abort();
  }
  v1 = (__int64)a1;
  result = strrchr(a1, 47);
  if ( result )
  {
    if ( result + 1 - a1 > 6 && !memcmp(result - 6, "/.libs/", 7uLL) )
    {
      v1 = (__int64)(result + 1);
      if ( !memcmp(result + 1, "lt-", 3uLL) )
      {
        v1 = (__int64)(result + 4);
        program_invocation_short_name = (__int64)(result + 4);
      }
    }
  }
  qword_6123A0 = v1;
  program_invocation_name = v1;
  return result;
}

char *__fastcall sub_407BE0(char *msgid, int a2)
{
  char *v2; // rbx
  _BYTE *v4; // rax
  bool v5; // zf
  char *v6; // rbx

  v2 = dcgettext(0LL, msgid, 5);
  if ( msgid != v2 )
    return v2;
  v4 = (_BYTE *)sub_40BA70();
  if ( (*v4 & 0xDF) == 85 )
  {
    if ( (v4[1] & 0xDF) == 84 && (v4[2] & 0xDF) == 70 && v4[3] == 45 && v4[4] == 56 && !v4[5] )
    {
      v5 = *v2 == 96;
      v2 = (char *)&unk_40D921;
      if ( !v5 )
        v2 = (char *)&unk_40D916;
      return v2;
    }
  }
  else if ( (*v4 & 0xDF) == 71
         && (v4[1] & 0xDF) == 66
         && v4[2] == 49
         && v4[3] == 56
         && v4[4] == 48
         && v4[5] == 51
         && v4[6] == 48
         && !v4[7] )
  {
    v5 = *v2 == 96;
    v2 = (char *)&unk_40D91D;
    if ( !v5 )
      v2 = (char *)&unk_40D91A;
    return v2;
  }
  v6 = "\"";
  if ( a2 != 9 )
    v6 = "'";
  return v6;
}

unsigned __int64 __fastcall sub_407CE0(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, char *a8, char *a9)
{
  _BYTE *v9; // r15
  unsigned __int64 v10; // r14
  int v11; // er13
  int v12; // ebp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r11
  int v15; // er10
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // r12
  int v19; // er11
  char *v20; // r8
  size_t v21; // rax
  int v22; // eax
  unsigned __int64 v23; // rbp
  bool v24; // al
  int v25; // eax
  int v26; // eax
  char v27; // di
  const unsigned __int16 **v28; // rax
  char v29; // cl
  unsigned __int64 result; // rax
  __int64 v31; // rcx
  unsigned __int64 v32; // rdi
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  int v35; // er13
  bool v36; // dl
  bool v37; // dl
  bool v38; // al
  size_t v39; // rax
  unsigned __int64 v40; // rbx
  unsigned __int64 v41; // r15
  const unsigned __int16 **v42; // r14
  char *v43; // rax
  int v44; // esi
  unsigned __int64 v45; // rcx
  unsigned __int8 v46; // di
  char *v47; // rax
  size_t v48; // rax
  __int64 v49; // rsi
  unsigned __int64 v50; // rsi
  char *v51; // rcx
  char i; // al
  char v53; // dl
  char *v54; // rax
  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]
  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]
  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]
  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]
  char v59; // [rsp+1Fh] [rbp-A9h]
  char *s; // [rsp+20h] [rbp-A8h]
  size_t n; // [rsp+28h] [rbp-A0h]
  char *v62; // [rsp+30h] [rbp-98h]
  unsigned __int8 v63; // [rsp+30h] [rbp-98h]
  char *v64; // [rsp+30h] [rbp-98h]
  unsigned __int64 v65; // [rsp+30h] [rbp-98h]
  unsigned __int8 v66; // [rsp+38h] [rbp-90h]
  unsigned __int8 v67; // [rsp+38h] [rbp-90h]
  unsigned __int64 v68; // [rsp+38h] [rbp-90h]
  char v69; // [rsp+38h] [rbp-90h]
  int v70; // [rsp+38h] [rbp-90h]
  int v71; // [rsp+40h] [rbp-88h]
  unsigned __int64 v72; // [rsp+40h] [rbp-88h]
  int v73; // [rsp+40h] [rbp-88h]
  int v74; // [rsp+40h] [rbp-88h]
  _BYTE *v75; // [rsp+40h] [rbp-88h]
  int v76; // [rsp+48h] [rbp-80h]
  unsigned __int64 v77; // [rsp+48h] [rbp-80h]
  char *s2; // [rsp+50h] [rbp-78h]
  __int64 v79; // [rsp+58h] [rbp-70h]
  size_t v80; // [rsp+60h] [rbp-68h]
  char v81; // [rsp+68h] [rbp-60h]
  bool v82; // [rsp+6Ch] [rbp-5Ch]
  char v83; // [rsp+6Dh] [rbp-5Bh]
  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]
  unsigned __int64 v85; // [rsp+70h] [rbp-58h]
  char *v86; // [rsp+78h] [rbp-50h]
  wint_t wc; // [rsp+84h] [rbp-44h]
  mbstate_t ps; // [rsp+88h] [rbp-40h]

  v9 = a1;
  v10 = a2;
  v11 = a5;
  s = a3;
  v55 = a4;
  v81 = a6;
  v12 = a6 & 2;
  v80 = __ctype_get_mb_cur_max();
  v82 = v12 != 0;
  v14 = v55;
  switch ( v11 )
  {
    case 0:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 0;
      v56 = 0;
      n = 0LL;
      s2 = 0LL;
      goto LABEL_3;
    case 1:
      goto LABEL_2;
    case 2:
      if ( !v12 )
      {
        v56 = 0;
        goto LABEL_212;
      }
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 0;
      n = 1LL;
      s2 = "'";
      goto LABEL_3;
    case 3:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v11 = 2;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 1;
      n = 1LL;
      s2 = "'";
      goto LABEL_3;
    case 4:
      if ( v12 )
      {
LABEL_2:
        v59 = 1;
        v15 = 0;
        v16 = 0LL;
        v11 = 2;
        v83 = 0;
        v79 = 0LL;
        v82 = 1;
        v56 = 0;
        n = 1LL;
        s2 = "'";
        goto LABEL_3;
      }
      v56 = 1;
LABEL_212:
      if ( a2 )
      {
        v15 = 0;
        v38 = 0;
        v59 = 1;
        v79 = 0LL;
        goto LABEL_138;
      }
      v59 = 1;
      v15 = 0;
      v16 = 1LL;
      v11 = 2;
      v79 = 0LL;
      v83 = 0;
      v82 = 0;
      n = 1LL;
      s2 = "'";
LABEL_3:
      v17 = v14;
      v18 = 0LL;
      v19 = v11;
      while ( 1 )
      {
LABEL_4:
        LOBYTE(v11) = v17 != v18;
        if ( v17 == -1LL )
          LOBYTE(v11) = s[v18] != 0;
        if ( !(_BYTE)v11 )
        {
          v35 = v19;
          v14 = v17;
          v36 = v35 == 2;
          if ( !v16 && v36 && v82 )
            return sub_407CE0((__int64)v9, v10, s);
          v37 = !v82 && v36;
          if ( v37 )
          {
            if ( v83 )
            {
              if ( v59 )
                return sub_407CE0((__int64)v9, v79, s);
              v38 = v79 != 0 && v10 == 0;
              if ( v38 )
              {
                v10 = v79;
LABEL_138:
                *v9 = 39;
                v11 = 2;
                v16 = 1LL;
                s2 = "'";
                n = 1LL;
                v82 = 0;
                v83 = v38;
                goto LABEL_3;
              }
              v37 = v83;
            }
          }
          else
          {
            v37 = !v82;
          }
          if ( s2 )
          {
            if ( v37 )
            {
              v53 = *s2;
              if ( *s2 )
              {
                v54 = &s2[-v16];
                do
                {
                  if ( v10 > v16 )
                    v9[v16] = v53;
                  v53 = v54[++v16];
                }
                while ( v53 );
              }
            }
          }
          if ( v10 > v16 )
            v9[v16] = 0;
          return v16;
        }
        v20 = &s[v18];
        v57 = v56 & (v19 != 2);
        if ( !(v56 & (v19 != 2)) )
          break;
        if ( n )
        {
          if ( v17 == -1LL && n > 1 )
          {
            v71 = v19;
            v66 = v15;
            v21 = strlen(s);
            v19 = v71;
            v15 = v66;
            v20 = &s[v18];
            v17 = v21;
          }
          if ( v18 + n <= v17 )
          {
            v76 = v19;
            v72 = v17;
            v67 = v15;
            v62 = v20;
            v22 = memcmp(v20, s2, n);
            v20 = v62;
            v15 = v67;
            v17 = v72;
            v19 = v76;
            if ( !v22 )
            {
              if ( !v82 )
              {
                LOBYTE(v23) = *v62;
                switch ( *v62 )
                {
                  case 0:
                    goto LABEL_83;
                  case 7:
                    LOBYTE(v23) = 97;
                    goto LABEL_79;
                  case 8:
                    LODWORD(v13) = 0;
                    v11 = 0;
                    LOBYTE(v23) = 98;
                    goto LABEL_29;
                  case 9:
                    goto LABEL_72;
                  case 10:
                    goto LABEL_68;
                  case 11:
                    goto LABEL_80;
                  case 12:
                    goto LABEL_77;
                  case 13:
                    goto LABEL_76;
                  case 32:
                    v33 = v57;
                    goto LABEL_128;
                  case 33:
                  case 34:
                  case 36:
                  case 38:
                  case 40:
                  case 41:
                  case 42:
                  case 59:
                  case 60:
                  case 61:
                  case 62:
                  case 91:
                  case 94:
                  case 96:
                  case 124:
                    goto LABEL_74;
                  case 35:
                  case 126:
                    v34 = v57;
                    goto LABEL_125;
                  case 37:
                  case 43:
                  case 44:
                  case 45:
                  case 46:
                  case 47:
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                  case 58:
                  case 65:
                  case 66:
                  case 67:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                  case 78:
                  case 79:
                  case 80:
                  case 81:
                  case 82:
                  case 83:
                  case 84:
                  case 85:
                  case 86:
                  case 87:
                  case 88:
                  case 89:
                  case 90:
                  case 93:
                  case 95:
                  case 97:
                  case 98:
                  case 99:
                  case 100:
                  case 101:
                  case 102:
                  case 103:
                  case 104:
                  case 105:
                  case 106:
                  case 107:
                  case 108:
                  case 109:
                  case 110:
                  case 111:
                  case 112:
                  case 113:
                  case 114:
                  case 115:
                  case 116:
                  case 117:
                  case 118:
                  case 119:
                  case 120:
                  case 121:
                  case 122:
                    v33 = v57;
                    goto LABEL_123;
                  case 39:
                    goto LABEL_62;
                  case 63:
                    goto LABEL_58;
                  case 92:
                    goto LABEL_65;
                  case 123:
                  case 125:
                    goto LABEL_17;
                  default:
                    goto LABEL_98;
                }
              }
              return sub_407CE0((__int64)v9, v10, s);
            }
          }
        }
        LOBYTE(v23) = *v20;
        switch ( *v20 )
        {
          case 0:
            goto LABEL_81;
          case 7:
            LOBYTE(v23) = 97;
            goto LABEL_78;
          case 8:
            LOBYTE(v23) = 98;
            goto LABEL_69;
          case 9:
LABEL_72:
            LOBYTE(v23) = 116;
            goto LABEL_69;
          case 10:
LABEL_68:
            LOBYTE(v23) = 110;
LABEL_69:
            LODWORD(v13) = 0;
            v11 = 0;
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            goto LABEL_29;
          case 11:
LABEL_80:
            LOBYTE(v23) = 118;
            goto LABEL_78;
          case 12:
LABEL_77:
            LOBYTE(v23) = 102;
LABEL_78:
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
LABEL_79:
            v11 = 0;
            goto LABEL_37;
          case 13:
            v57 = 0;
LABEL_76:
            LOBYTE(v23) = 13;
            v29 = 114;
            LOBYTE(v13) = v19 == 2;
            goto LABEL_66;
          case 32:
            v33 = 0;
LABEL_128:
            LOBYTE(v23) = 32;
            goto LABEL_123;
          case 33:
          case 34:
          case 36:
          case 38:
          case 40:
          case 41:
          case 42:
          case 59:
          case 60:
          case 61:
          case 62:
          case 91:
          case 94:
          case 96:
          case 124:
            v57 = 0;
LABEL_74:
            LODWORD(v13) = 0;
            goto LABEL_67;
          case 35:
          case 126:
            v34 = 0;
LABEL_125:
            if ( !v18 )
            {
              v11 = v57;
              LODWORD(v13) = 0;
              v57 = v34;
              goto LABEL_23;
            }
            v57 = v34;
            v11 = 0;
            break;
          case 37:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 93:
          case 95:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            v33 = 0;
LABEL_123:
            v11 = v57;
            v57 = v33;
            v25 = 0;
            goto LABEL_25;
          case 39:
            v57 = 0;
            goto LABEL_62;
          case 63:
            v57 = 0;
            goto LABEL_58;
          case 92:
            v57 = 0;
            goto LABEL_65;
          case 123:
          case 125:
            v57 = 0;
            goto LABEL_17;
          default:
            v57 = 0;
            goto LABEL_98;
        }
LABEL_24:
        v25 = 0;
LABEL_25:
        if ( a7 )
        {
          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;
          if ( (_DWORD)v13 )
          {
            LOBYTE(v13) = v19 == 2;
LABEL_28:
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
LABEL_29:
            v26 = v15 ^ 1;
            LOBYTE(v26) = v13 & (v15 ^ 1);
            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )
            {
              if ( v10 > v16 )
                v9[v16] = 39;
              if ( v16 + 1 < v10 )
                v9[v16 + 1] = 36;
              LODWORD(v13) = v16 + 2;
              if ( v16 + 2 < v10 )
                v9[v16 + 2] = 39;
              v16 += 3LL;
              v15 = v26;
            }
LABEL_37:
            if ( v10 > v16 )
              v9[v16] = 92;
            ++v16;
            ++v18;
            goto LABEL_40;
          }
        }
LABEL_49:
        LOBYTE(v13) = v19 == 2;
        if ( v57 )
          goto LABEL_28;
        ++v18;
        LODWORD(v28) = v15 & (v25 ^ 1);
LABEL_51:
        if ( (_BYTE)v28 )
        {
          if ( v10 > v16 )
            v9[v16] = 39;
          if ( v10 > v16 + 1 )
            v9[v16 + 1] = 39;
          v16 += 2LL;
          v15 = 0;
        }
LABEL_40:
        if ( v16 < v10 )
          v9[v16] = v23;
        v27 = v59;
        ++v16;
        if ( !(_BYTE)v11 )
          v27 = 0;
        v59 = v27;
      }
      LOBYTE(v23) = *v20;
      switch ( *v20 )
      {
        case 0:
          if ( !v56 )
          {
            if ( !(v81 & 1) )
            {
              v57 = 0;
              LOBYTE(v13) = v19 == 2;
              v11 = 0;
              LOBYTE(v23) = 0;
              goto LABEL_23;
            }
            ++v18;
            goto LABEL_4;
          }
LABEL_81:
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          v57 = 0;
LABEL_83:
          LOBYTE(v13) = v19 == 2;
          v25 = v15 ^ 1;
          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);
          if ( (_BYTE)v25 )
          {
            if ( v10 > v16 )
              v9[v16] = 39;
            if ( v10 > v16 + 1 )
              v9[v16 + 1] = 36;
            if ( v10 > v16 + 2 )
              v9[v16 + 2] = 39;
            v31 = v16 + 3;
            if ( v10 <= v16 + 3 )
            {
              v16 += 4LL;
              v15 = v25;
              v11 = 0;
              LOBYTE(v23) = 48;
              goto LABEL_49;
            }
            goto LABEL_91;
          }
          v31 = v16;
          if ( v10 > v16 )
          {
            v25 = v15;
LABEL_91:
            v9[v31] = 92;
            v15 = v25;
          }
          v16 = v31 + 1;
          if ( v19 == 2 )
          {
            v25 = v11;
            LOBYTE(v23) = 48;
            v11 = 0;
            goto LABEL_49;
          }
          LOBYTE(v23) = 48;
          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )
          {
            if ( v10 > v16 )
              v9[v16] = 48;
            if ( v10 > v31 + 2 )
              v9[v31 + 2] = 48;
            v16 = v31 + 3;
            LOBYTE(v23) = 48;
          }
LABEL_95:
          v25 = v11;
          v11 = 0;
          if ( (unsigned __int8)v13 | v56 ^ 1 )
            goto LABEL_49;
          goto LABEL_25;
        case 7:
          LOBYTE(v23) = 7;
          v29 = 97;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 8:
          LOBYTE(v23) = 8;
          v29 = 98;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 9:
          LOBYTE(v23) = 9;
          v29 = 116;
          goto LABEL_104;
        case 10:
          LOBYTE(v23) = 10;
          v29 = 110;
          goto LABEL_104;
        case 11:
          LOBYTE(v23) = 11;
          v29 = 118;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 12:
          LOBYTE(v23) = 12;
          v29 = 102;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 13:
          LOBYTE(v23) = 13;
          v29 = 114;
LABEL_104:
          LOBYTE(v13) = v19 == 2;
          v57 = v19 == 2 && v82;
          if ( v57 )
            return sub_407CE0((__int64)v9, v10, s);
          goto LABEL_66;
        case 32:
          LOBYTE(v23) = 32;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_21;
        case 33:
        case 34:
        case 36:
        case 38:
        case 40:
        case 41:
        case 42:
        case 59:
        case 60:
        case 61:
        case 62:
        case 91:
        case 94:
        case 96:
        case 124:
          LOBYTE(v13) = v19 == 2;
          v11 = 0;
          goto LABEL_21;
        case 35:
        case 126:
          LOBYTE(v13) = v19 == 2;
          goto LABEL_20;
        case 37:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 93:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          goto LABEL_101;
        case 39:
LABEL_62:
          if ( v19 != 2 )
          {
            v83 = v11;
            LODWORD(v13) = 0;
            LOBYTE(v23) = 39;
            goto LABEL_23;
          }
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          if ( !v10 || (v13 = 0LL, v79) )
          {
            if ( v10 > v16 )
              v9[v16] = 39;
            if ( v10 > v16 + 1 )
              v9[v16 + 1] = 92;
            v13 = v10;
            if ( v10 > v16 + 2 )
              v9[v16 + 2] = 39;
            v10 = v79;
          }
          v83 = v11;
          v16 += 3LL;
          v25 = 0;
          v15 = 0;
          v79 = v10;
          LOBYTE(v23) = 39;
          v10 = v13;
          goto LABEL_49;
        case 63:
LABEL_58:
          if ( v19 == 2 )
          {
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            v11 = 0;
            v25 = 0;
            LOBYTE(v23) = 63;
            goto LABEL_49;
          }
          if ( v19 != 5 )
          {
            LOBYTE(v23) = 63;
            LOBYTE(v13) = v19 == 2;
            v11 = 0;
            goto LABEL_23;
          }
          if ( !(v81 & 4)
            || v18 + 2 >= v17
            || s[v18 + 1] != 63
            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)
            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )
          {
            LODWORD(v13) = 0;
            v11 = 0;
            LOBYTE(v23) = 63;
            goto LABEL_23;
          }
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          if ( v10 > v16 )
            v9[v16] = 63;
          if ( v10 > v16 + 1 )
            v9[v16 + 1] = 34;
          if ( v10 > v16 + 2 )
            v9[v16 + 2] = 34;
          if ( v10 > v16 + 3 )
            v9[v16 + 3] = 63;
          v16 += 4LL;
          LODWORD(v13) = 0;
          v11 = 0;
          v18 += 2LL;
          goto LABEL_95;
        case 92:
          if ( v19 == 2 )
          {
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            ++v18;
            LOBYTE(v28) = v15;
            v11 = 0;
            LOBYTE(v23) = 92;
            goto LABEL_51;
          }
LABEL_65:
          LODWORD(v13) = v56;
          LOBYTE(v23) = 92;
          v29 = 92;
          LOBYTE(v13) = (n != 0) & v82 & v56;
          if ( (_BYTE)v13 )
          {
            ++v18;
            LOBYTE(v28) = v15;
            v11 = 0;
            goto LABEL_51;
          }
LABEL_66:
          if ( !v56 )
          {
LABEL_67:
            v11 = 0;
            goto LABEL_23;
          }
          LOBYTE(v23) = v29;
          v11 = 0;
          goto LABEL_28;
        case 123:
        case 125:
LABEL_17:
          v24 = v17 != 1;
          if ( v17 == -1LL )
            v24 = s[1] != 0;
          LOBYTE(v13) = v19 == 2;
          if ( v24 )
            goto LABEL_67;
LABEL_20:
          if ( v18 )
            goto LABEL_67;
LABEL_21:
          if ( !v82 || !(_BYTE)v13 )
            goto LABEL_23;
          return sub_407CE0((__int64)v9, v10, s);
        default:
LABEL_98:
          if ( v80 == 1 )
          {
            v73 = v19;
            v68 = v17;
            v63 = v15;
            v28 = __ctype_b_loc();
            LODWORD(v13) = (unsigned __int8)v23;
            v15 = v63;
            v17 = v68;
            v19 = v73;
            v32 = 1LL;
            LODWORD(v28) = (*v28)[(unsigned __int8)v23];
            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;
            LOBYTE(v11) = (_WORD)v28 != 0;
            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);
            goto LABEL_100;
          }
          ps = 0LL;
          if ( v17 == -1LL )
          {
            v74 = v19;
            v69 = v15;
            v64 = v20;
            v39 = strlen(s);
            v19 = v74;
            LOBYTE(v15) = v69;
            v20 = v64;
            v17 = v39;
          }
          v85 = v16;
          v86 = v20;
          v40 = 0LL;
          v84 = v15;
          v75 = v9;
          v77 = v10;
          v65 = v17;
          v70 = v19;
          break;
      }
      while ( 2 )
      {
        v41 = v18 + v40;
        v28 = (const unsigned __int16 **)sub_40B6B0((wchar_t *)&wc, &s[v18 + v40]);
        v42 = v28;
        if ( !v28 )
        {
LABEL_241:
          v32 = v40;
          v16 = v85;
          v15 = v84;
          v9 = v75;
          LODWORD(v13) = v11 ^ 1;
          v10 = v77;
          v17 = v65;
          v19 = v70;
          LOBYTE(v13) = v56 & (v11 ^ 1);
          goto LABEL_242;
        }
        if ( v28 == (const unsigned __int16 **)-1LL )
        {
          v32 = v40;
          v16 = v85;
          v11 = 0;
          v15 = v84;
          v9 = v75;
          v10 = v77;
          v17 = v65;
          v19 = v70;
          LODWORD(v13) = v56;
          goto LABEL_242;
        }
        if ( v28 == (const unsigned __int16 **)-2LL )
        {
          v17 = v65;
          v50 = v18 + v40;
          v51 = &s[v18 + v40];
          v28 = (const unsigned __int16 **)v40;
          v32 = v40;
          v15 = v84;
          v16 = v85;
          v9 = v75;
          v10 = v77;
          v19 = v70;
          if ( v50 < v65 && *v51 )
          {
            do
              v28 = (const unsigned __int16 **)((char *)v28 + 1);
            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );
            v32 = (unsigned __int64)v28;
          }
          LODWORD(v13) = v56;
          v11 = 0;
LABEL_242:
          if ( v32 > 1 )
            goto LABEL_174;
LABEL_100:
          if ( (_BYTE)v13 )
          {
            LODWORD(v13) = v56;
            LOBYTE(v11) = 0;
LABEL_174:
            v44 = 0;
            v45 = v18 + v32;
            v46 = v57;
            while ( 1 )
            {
              if ( (_BYTE)v13 )
              {
                if ( v82 )
                  return sub_407CE0((__int64)v9, v10, s);
                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);
                if ( (_BYTE)v28 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 39;
                  if ( v10 > v16 + 1 )
                    v9[v16 + 1] = 36;
                  if ( v10 > v16 + 2 )
                    v9[v16 + 2] = 39;
                  v16 += 3LL;
                  v15 = (int)v28;
                }
                if ( v10 > v16 )
                  v9[v16] = 92;
                if ( v10 > v16 + 1 )
                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;
                LODWORD(v28) = v16 + 2;
                if ( v10 > v16 + 2 )
                {
                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;
                  v9[v16 + 2] = (_BYTE)v28;
                }
                ++v18;
                v16 += 3LL;
                LOBYTE(v23) = (v23 & 7) + 48;
                if ( v18 >= v45 )
                {
                  v11 = (unsigned __int8)v11;
                  goto LABEL_40;
                }
                v44 = v13;
              }
              else
              {
                LODWORD(v28) = v15 & (v44 ^ 1);
                if ( v46 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 92;
                  ++v16;
                }
                if ( ++v18 >= v45 )
                {
                  v11 = (unsigned __int8)v11;
                  goto LABEL_51;
                }
                if ( (_BYTE)v28 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 39;
                  LODWORD(v28) = v16 + 1;
                  if ( v10 > v16 + 1 )
                    v9[v16 + 1] = 39;
                  v16 += 2LL;
                  v46 = 0;
                  v15 = 0;
                }
                else
                {
                  v46 = 0;
                }
              }
              if ( v10 > v16 )
                v9[v16] = v23;
              LOBYTE(v23) = s[v18];
              ++v16;
            }
          }
LABEL_101:
          LOBYTE(v13) = v19 == 2;
LABEL_23:
          v25 = (v13 | v56 ^ 1) ^ 1;
          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;
          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )
            goto LABEL_49;
          goto LABEL_24;
        }
        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )
        {
LABEL_148:
          if ( !iswprint(wc) )
            v11 = 0;
          v40 += (unsigned __int64)v42;
          LODWORD(v28) = mbsinit(&ps);
          if ( (_DWORD)v28 )
            goto LABEL_241;
          continue;
        }
        break;
      }
      v43 = &s[v41 + 1];
      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )
      {
        if ( &s[(_QWORD)v42 + v41] == ++v43 )
          goto LABEL_148;
      }
      v9 = v75;
      v10 = v77;
      return sub_407CE0((__int64)v9, v10, s);
    case 5:
      if ( v12 )
      {
        v59 = 1;
        v15 = 0;
        v16 = 0LL;
        v83 = 0;
        v79 = 0LL;
        v82 = 1;
        v56 = 1;
        n = 1LL;
        s2 = "\"";
      }
      else
      {
        if ( a2 )
        {
          *a1 = 34;
          v15 = 0;
          v59 = 1;
          v83 = 0;
          v79 = 0LL;
        }
        else
        {
          v79 = 0LL;
          v15 = 0;
          v59 = 1;
          v83 = 0;
        }
        v82 = 0;
        v16 = 1LL;
        v56 = 1;
        n = 1LL;
        s2 = "\"";
      }
      goto LABEL_3;
    case 6:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v11 = 5;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 1;
      n = 1LL;
      s2 = "\"";
      goto LABEL_3;
    case 7:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 0;
      v56 = 1;
      n = 0LL;
      s2 = 0LL;
      goto LABEL_3;
    case 8:
    case 9:
    case 10:
      if ( v12 )
      {
        a8 = sub_407BE0("`", v11);
        v47 = sub_407BE0("'", v11);
        v14 = v55;
        a9 = v47;
      }
      v16 = 0LL;
      if ( !v12 )
      {
        for ( i = *a8; i; i = a8[v16] )
        {
          if ( a2 > v16 )
            a1[v16] = i;
          ++v16;
        }
      }
      v58 = v14;
      v48 = strlen(a9);
      v59 = 1;
      v15 = 0;
      v14 = v58;
      n = v48;
      v83 = 0;
      s2 = a9;
      v79 = 0LL;
      v56 = 1;
      goto LABEL_3;
    default:
      abort();
      return result;
  }
}

unsigned __int64 __fastcall sub_407CE0(_BYTE *a1, unsigned __int64 a2, char *a3, unsigned __int64 a4, int a5, char a6, __int64 a7, char *a8, char *a9)
{
  _BYTE *v9; // r15
  unsigned __int64 v10; // r14
  int v11; // er13
  int v12; // ebp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r11
  int v15; // er10
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // r12
  int v19; // er11
  char *v20; // r8
  size_t v21; // rax
  int v22; // eax
  unsigned __int64 v23; // rbp
  bool v24; // al
  int v25; // eax
  int v26; // eax
  char v27; // di
  const unsigned __int16 **v28; // rax
  char v29; // cl
  unsigned __int64 result; // rax
  __int64 v31; // rcx
  unsigned __int64 v32; // rdi
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  int v35; // er13
  bool v36; // dl
  bool v37; // dl
  bool v38; // al
  size_t v39; // rax
  unsigned __int64 v40; // rbx
  unsigned __int64 v41; // r15
  const unsigned __int16 **v42; // r14
  char *v43; // rax
  int v44; // esi
  unsigned __int64 v45; // rcx
  unsigned __int8 v46; // di
  char *v47; // rax
  size_t v48; // rax
  __int64 v49; // rsi
  unsigned __int64 v50; // rsi
  char *v51; // rcx
  char i; // al
  char v53; // dl
  char *v54; // rax
  unsigned __int64 v55; // [rsp+8h] [rbp-C0h]
  unsigned __int8 v56; // [rsp+8h] [rbp-C0h]
  unsigned __int8 v57; // [rsp+10h] [rbp-B8h]
  unsigned __int64 v58; // [rsp+10h] [rbp-B8h]
  char v59; // [rsp+1Fh] [rbp-A9h]
  char *s; // [rsp+20h] [rbp-A8h]
  size_t n; // [rsp+28h] [rbp-A0h]
  char *v62; // [rsp+30h] [rbp-98h]
  unsigned __int8 v63; // [rsp+30h] [rbp-98h]
  char *v64; // [rsp+30h] [rbp-98h]
  unsigned __int64 v65; // [rsp+30h] [rbp-98h]
  unsigned __int8 v66; // [rsp+38h] [rbp-90h]
  unsigned __int8 v67; // [rsp+38h] [rbp-90h]
  unsigned __int64 v68; // [rsp+38h] [rbp-90h]
  char v69; // [rsp+38h] [rbp-90h]
  int v70; // [rsp+38h] [rbp-90h]
  int v71; // [rsp+40h] [rbp-88h]
  unsigned __int64 v72; // [rsp+40h] [rbp-88h]
  int v73; // [rsp+40h] [rbp-88h]
  int v74; // [rsp+40h] [rbp-88h]
  _BYTE *v75; // [rsp+40h] [rbp-88h]
  int v76; // [rsp+48h] [rbp-80h]
  unsigned __int64 v77; // [rsp+48h] [rbp-80h]
  char *s2; // [rsp+50h] [rbp-78h]
  __int64 v79; // [rsp+58h] [rbp-70h]
  size_t v80; // [rsp+60h] [rbp-68h]
  char v81; // [rsp+68h] [rbp-60h]
  bool v82; // [rsp+6Ch] [rbp-5Ch]
  char v83; // [rsp+6Dh] [rbp-5Bh]
  unsigned __int8 v84; // [rsp+6Eh] [rbp-5Ah]
  unsigned __int64 v85; // [rsp+70h] [rbp-58h]
  char *v86; // [rsp+78h] [rbp-50h]
  wint_t wc; // [rsp+84h] [rbp-44h]
  mbstate_t ps; // [rsp+88h] [rbp-40h]

  v9 = a1;
  v10 = a2;
  v11 = a5;
  s = a3;
  v55 = a4;
  v81 = a6;
  v12 = a6 & 2;
  v80 = __ctype_get_mb_cur_max();
  v82 = v12 != 0;
  v14 = v55;
  switch ( v11 )
  {
    case 0:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 0;
      v56 = 0;
      n = 0LL;
      s2 = 0LL;
      goto LABEL_3;
    case 1:
      goto LABEL_2;
    case 2:
      if ( !v12 )
      {
        v56 = 0;
        goto LABEL_212;
      }
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 0;
      n = 1LL;
      s2 = "'";
      goto LABEL_3;
    case 3:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v11 = 2;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 1;
      n = 1LL;
      s2 = "'";
      goto LABEL_3;
    case 4:
      if ( v12 )
      {
LABEL_2:
        v59 = 1;
        v15 = 0;
        v16 = 0LL;
        v11 = 2;
        v83 = 0;
        v79 = 0LL;
        v82 = 1;
        v56 = 0;
        n = 1LL;
        s2 = "'";
        goto LABEL_3;
      }
      v56 = 1;
LABEL_212:
      if ( a2 )
      {
        v15 = 0;
        v38 = 0;
        v59 = 1;
        v79 = 0LL;
        goto LABEL_138;
      }
      v59 = 1;
      v15 = 0;
      v16 = 1LL;
      v11 = 2;
      v79 = 0LL;
      v83 = 0;
      v82 = 0;
      n = 1LL;
      s2 = "'";
LABEL_3:
      v17 = v14;
      v18 = 0LL;
      v19 = v11;
      while ( 1 )
      {
LABEL_4:
        LOBYTE(v11) = v17 != v18;
        if ( v17 == -1LL )
          LOBYTE(v11) = s[v18] != 0;
        if ( !(_BYTE)v11 )
        {
          v35 = v19;
          v14 = v17;
          v36 = v35 == 2;
          if ( !v16 && v36 && v82 )
            return sub_407CE0((__int64)v9, v10, s);
          v37 = !v82 && v36;
          if ( v37 )
          {
            if ( v83 )
            {
              if ( v59 )
                return sub_407CE0((__int64)v9, v79, s);
              v38 = v79 != 0 && v10 == 0;
              if ( v38 )
              {
                v10 = v79;
LABEL_138:
                *v9 = 39;
                v11 = 2;
                v16 = 1LL;
                s2 = "'";
                n = 1LL;
                v82 = 0;
                v83 = v38;
                goto LABEL_3;
              }
              v37 = v83;
            }
          }
          else
          {
            v37 = !v82;
          }
          if ( s2 )
          {
            if ( v37 )
            {
              v53 = *s2;
              if ( *s2 )
              {
                v54 = &s2[-v16];
                do
                {
                  if ( v10 > v16 )
                    v9[v16] = v53;
                  v53 = v54[++v16];
                }
                while ( v53 );
              }
            }
          }
          if ( v10 > v16 )
            v9[v16] = 0;
          return v16;
        }
        v20 = &s[v18];
        v57 = v56 & (v19 != 2);
        if ( !(v56 & (v19 != 2)) )
          break;
        if ( n )
        {
          if ( v17 == -1LL && n > 1 )
          {
            v71 = v19;
            v66 = v15;
            v21 = strlen(s);
            v19 = v71;
            v15 = v66;
            v20 = &s[v18];
            v17 = v21;
          }
          if ( v18 + n <= v17 )
          {
            v76 = v19;
            v72 = v17;
            v67 = v15;
            v62 = v20;
            v22 = memcmp(v20, s2, n);
            v20 = v62;
            v15 = v67;
            v17 = v72;
            v19 = v76;
            if ( !v22 )
            {
              if ( !v82 )
              {
                LOBYTE(v23) = *v62;
                switch ( *v62 )
                {
                  case 0:
                    goto LABEL_83;
                  case 7:
                    LOBYTE(v23) = 97;
                    goto LABEL_79;
                  case 8:
                    LODWORD(v13) = 0;
                    v11 = 0;
                    LOBYTE(v23) = 98;
                    goto LABEL_29;
                  case 9:
                    goto LABEL_72;
                  case 10:
                    goto LABEL_68;
                  case 11:
                    goto LABEL_80;
                  case 12:
                    goto LABEL_77;
                  case 13:
                    goto LABEL_76;
                  case 32:
                    v33 = v57;
                    goto LABEL_128;
                  case 33:
                  case 34:
                  case 36:
                  case 38:
                  case 40:
                  case 41:
                  case 42:
                  case 59:
                  case 60:
                  case 61:
                  case 62:
                  case 91:
                  case 94:
                  case 96:
                  case 124:
                    goto LABEL_74;
                  case 35:
                  case 126:
                    v34 = v57;
                    goto LABEL_125;
                  case 37:
                  case 43:
                  case 44:
                  case 45:
                  case 46:
                  case 47:
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                  case 58:
                  case 65:
                  case 66:
                  case 67:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                  case 78:
                  case 79:
                  case 80:
                  case 81:
                  case 82:
                  case 83:
                  case 84:
                  case 85:
                  case 86:
                  case 87:
                  case 88:
                  case 89:
                  case 90:
                  case 93:
                  case 95:
                  case 97:
                  case 98:
                  case 99:
                  case 100:
                  case 101:
                  case 102:
                  case 103:
                  case 104:
                  case 105:
                  case 106:
                  case 107:
                  case 108:
                  case 109:
                  case 110:
                  case 111:
                  case 112:
                  case 113:
                  case 114:
                  case 115:
                  case 116:
                  case 117:
                  case 118:
                  case 119:
                  case 120:
                  case 121:
                  case 122:
                    v33 = v57;
                    goto LABEL_123;
                  case 39:
                    goto LABEL_62;
                  case 63:
                    goto LABEL_58;
                  case 92:
                    goto LABEL_65;
                  case 123:
                  case 125:
                    goto LABEL_17;
                  default:
                    goto LABEL_98;
                }
              }
              return sub_407CE0((__int64)v9, v10, s);
            }
          }
        }
        LOBYTE(v23) = *v20;
        switch ( *v20 )
        {
          case 0:
            goto LABEL_81;
          case 7:
            LOBYTE(v23) = 97;
            goto LABEL_78;
          case 8:
            LOBYTE(v23) = 98;
            goto LABEL_69;
          case 9:
LABEL_72:
            LOBYTE(v23) = 116;
            goto LABEL_69;
          case 10:
LABEL_68:
            LOBYTE(v23) = 110;
LABEL_69:
            LODWORD(v13) = 0;
            v11 = 0;
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            goto LABEL_29;
          case 11:
LABEL_80:
            LOBYTE(v23) = 118;
            goto LABEL_78;
          case 12:
LABEL_77:
            LOBYTE(v23) = 102;
LABEL_78:
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
LABEL_79:
            v11 = 0;
            goto LABEL_37;
          case 13:
            v57 = 0;
LABEL_76:
            LOBYTE(v23) = 13;
            v29 = 114;
            LOBYTE(v13) = v19 == 2;
            goto LABEL_66;
          case 32:
            v33 = 0;
LABEL_128:
            LOBYTE(v23) = 32;
            goto LABEL_123;
          case 33:
          case 34:
          case 36:
          case 38:
          case 40:
          case 41:
          case 42:
          case 59:
          case 60:
          case 61:
          case 62:
          case 91:
          case 94:
          case 96:
          case 124:
            v57 = 0;
LABEL_74:
            LODWORD(v13) = 0;
            goto LABEL_67;
          case 35:
          case 126:
            v34 = 0;
LABEL_125:
            if ( !v18 )
            {
              v11 = v57;
              LODWORD(v13) = 0;
              v57 = v34;
              goto LABEL_23;
            }
            v57 = v34;
            v11 = 0;
            break;
          case 37:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 93:
          case 95:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            v33 = 0;
LABEL_123:
            v11 = v57;
            v57 = v33;
            v25 = 0;
            goto LABEL_25;
          case 39:
            v57 = 0;
            goto LABEL_62;
          case 63:
            v57 = 0;
            goto LABEL_58;
          case 92:
            v57 = 0;
            goto LABEL_65;
          case 123:
          case 125:
            v57 = 0;
            goto LABEL_17;
          default:
            v57 = 0;
            goto LABEL_98;
        }
LABEL_24:
        v25 = 0;
LABEL_25:
        if ( a7 )
        {
          LODWORD(v13) = (*(_DWORD *)(a7 + 4LL * ((unsigned __int8)v23 >> 5)) >> v23) & 1;
          if ( (_DWORD)v13 )
          {
            LOBYTE(v13) = v19 == 2;
LABEL_28:
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
LABEL_29:
            v26 = v15 ^ 1;
            LOBYTE(v26) = v13 & (v15 ^ 1);
            if ( (unsigned __int8)v13 & ((unsigned __int8)v15 ^ 1) )
            {
              if ( v10 > v16 )
                v9[v16] = 39;
              if ( v16 + 1 < v10 )
                v9[v16 + 1] = 36;
              LODWORD(v13) = v16 + 2;
              if ( v16 + 2 < v10 )
                v9[v16 + 2] = 39;
              v16 += 3LL;
              v15 = v26;
            }
LABEL_37:
            if ( v10 > v16 )
              v9[v16] = 92;
            ++v16;
            ++v18;
            goto LABEL_40;
          }
        }
LABEL_49:
        LOBYTE(v13) = v19 == 2;
        if ( v57 )
          goto LABEL_28;
        ++v18;
        LODWORD(v28) = v15 & (v25 ^ 1);
LABEL_51:
        if ( (_BYTE)v28 )
        {
          if ( v10 > v16 )
            v9[v16] = 39;
          if ( v10 > v16 + 1 )
            v9[v16 + 1] = 39;
          v16 += 2LL;
          v15 = 0;
        }
LABEL_40:
        if ( v16 < v10 )
          v9[v16] = v23;
        v27 = v59;
        ++v16;
        if ( !(_BYTE)v11 )
          v27 = 0;
        v59 = v27;
      }
      LOBYTE(v23) = *v20;
      switch ( *v20 )
      {
        case 0:
          if ( !v56 )
          {
            if ( !(v81 & 1) )
            {
              v57 = 0;
              LOBYTE(v13) = v19 == 2;
              v11 = 0;
              LOBYTE(v23) = 0;
              goto LABEL_23;
            }
            ++v18;
            goto LABEL_4;
          }
LABEL_81:
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          v57 = 0;
LABEL_83:
          LOBYTE(v13) = v19 == 2;
          v25 = v15 ^ 1;
          LOBYTE(v25) = (v19 == 2) & (v15 ^ 1);
          if ( (_BYTE)v25 )
          {
            if ( v10 > v16 )
              v9[v16] = 39;
            if ( v10 > v16 + 1 )
              v9[v16 + 1] = 36;
            if ( v10 > v16 + 2 )
              v9[v16 + 2] = 39;
            v31 = v16 + 3;
            if ( v10 <= v16 + 3 )
            {
              v16 += 4LL;
              v15 = v25;
              v11 = 0;
              LOBYTE(v23) = 48;
              goto LABEL_49;
            }
            goto LABEL_91;
          }
          v31 = v16;
          if ( v10 > v16 )
          {
            v25 = v15;
LABEL_91:
            v9[v31] = 92;
            v15 = v25;
          }
          v16 = v31 + 1;
          if ( v19 == 2 )
          {
            v25 = v11;
            LOBYTE(v23) = 48;
            v11 = 0;
            goto LABEL_49;
          }
          LOBYTE(v23) = 48;
          if ( v18 + 1 < v17 && (unsigned __int8)(s[v18 + 1] - 48) <= 9u )
          {
            if ( v10 > v16 )
              v9[v16] = 48;
            if ( v10 > v31 + 2 )
              v9[v31 + 2] = 48;
            v16 = v31 + 3;
            LOBYTE(v23) = 48;
          }
LABEL_95:
          v25 = v11;
          v11 = 0;
          if ( (unsigned __int8)v13 | v56 ^ 1 )
            goto LABEL_49;
          goto LABEL_25;
        case 7:
          LOBYTE(v23) = 7;
          v29 = 97;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 8:
          LOBYTE(v23) = 8;
          v29 = 98;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 9:
          LOBYTE(v23) = 9;
          v29 = 116;
          goto LABEL_104;
        case 10:
          LOBYTE(v23) = 10;
          v29 = 110;
          goto LABEL_104;
        case 11:
          LOBYTE(v23) = 11;
          v29 = 118;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 12:
          LOBYTE(v23) = 12;
          v29 = 102;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_66;
        case 13:
          LOBYTE(v23) = 13;
          v29 = 114;
LABEL_104:
          LOBYTE(v13) = v19 == 2;
          v57 = v19 == 2 && v82;
          if ( v57 )
            return sub_407CE0((__int64)v9, v10, s);
          goto LABEL_66;
        case 32:
          LOBYTE(v23) = 32;
          LOBYTE(v13) = v19 == 2;
          goto LABEL_21;
        case 33:
        case 34:
        case 36:
        case 38:
        case 40:
        case 41:
        case 42:
        case 59:
        case 60:
        case 61:
        case 62:
        case 91:
        case 94:
        case 96:
        case 124:
          LOBYTE(v13) = v19 == 2;
          v11 = 0;
          goto LABEL_21;
        case 35:
        case 126:
          LOBYTE(v13) = v19 == 2;
          goto LABEL_20;
        case 37:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 93:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          goto LABEL_101;
        case 39:
LABEL_62:
          if ( v19 != 2 )
          {
            v83 = v11;
            LODWORD(v13) = 0;
            LOBYTE(v23) = 39;
            goto LABEL_23;
          }
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          if ( !v10 || (v13 = 0LL, v79) )
          {
            if ( v10 > v16 )
              v9[v16] = 39;
            if ( v10 > v16 + 1 )
              v9[v16 + 1] = 92;
            v13 = v10;
            if ( v10 > v16 + 2 )
              v9[v16 + 2] = 39;
            v10 = v79;
          }
          v83 = v11;
          v16 += 3LL;
          v25 = 0;
          v15 = 0;
          v79 = v10;
          LOBYTE(v23) = 39;
          v10 = v13;
          goto LABEL_49;
        case 63:
LABEL_58:
          if ( v19 == 2 )
          {
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            v11 = 0;
            v25 = 0;
            LOBYTE(v23) = 63;
            goto LABEL_49;
          }
          if ( v19 != 5 )
          {
            LOBYTE(v23) = 63;
            LOBYTE(v13) = v19 == 2;
            v11 = 0;
            goto LABEL_23;
          }
          if ( !(v81 & 4)
            || v18 + 2 >= v17
            || s[v18 + 1] != 63
            || (v23 = (unsigned __int8)s[v18 + 2], (unsigned __int8)v23 > 0x3Eu)
            || (v49 = 8070630310989004800LL, !_bittest64(&v49, v23)) )
          {
            LODWORD(v13) = 0;
            v11 = 0;
            LOBYTE(v23) = 63;
            goto LABEL_23;
          }
          if ( v82 )
            return sub_407CE0((__int64)v9, v10, s);
          if ( v10 > v16 )
            v9[v16] = 63;
          if ( v10 > v16 + 1 )
            v9[v16 + 1] = 34;
          if ( v10 > v16 + 2 )
            v9[v16 + 2] = 34;
          if ( v10 > v16 + 3 )
            v9[v16 + 3] = 63;
          v16 += 4LL;
          LODWORD(v13) = 0;
          v11 = 0;
          v18 += 2LL;
          goto LABEL_95;
        case 92:
          if ( v19 == 2 )
          {
            if ( v82 )
              return sub_407CE0((__int64)v9, v10, s);
            ++v18;
            LOBYTE(v28) = v15;
            v11 = 0;
            LOBYTE(v23) = 92;
            goto LABEL_51;
          }
LABEL_65:
          LODWORD(v13) = v56;
          LOBYTE(v23) = 92;
          v29 = 92;
          LOBYTE(v13) = (n != 0) & v82 & v56;
          if ( (_BYTE)v13 )
          {
            ++v18;
            LOBYTE(v28) = v15;
            v11 = 0;
            goto LABEL_51;
          }
LABEL_66:
          if ( !v56 )
          {
LABEL_67:
            v11 = 0;
            goto LABEL_23;
          }
          LOBYTE(v23) = v29;
          v11 = 0;
          goto LABEL_28;
        case 123:
        case 125:
LABEL_17:
          v24 = v17 != 1;
          if ( v17 == -1LL )
            v24 = s[1] != 0;
          LOBYTE(v13) = v19 == 2;
          if ( v24 )
            goto LABEL_67;
LABEL_20:
          if ( v18 )
            goto LABEL_67;
LABEL_21:
          if ( !v82 || !(_BYTE)v13 )
            goto LABEL_23;
          return sub_407CE0((__int64)v9, v10, s);
        default:
LABEL_98:
          if ( v80 == 1 )
          {
            v73 = v19;
            v68 = v17;
            v63 = v15;
            v28 = __ctype_b_loc();
            LODWORD(v13) = (unsigned __int8)v23;
            v15 = v63;
            v17 = v68;
            v19 = v73;
            v32 = 1LL;
            LODWORD(v28) = (*v28)[(unsigned __int8)v23];
            LOWORD(v28) = (unsigned __int16)v28 & 0x4000;
            LOBYTE(v11) = (_WORD)v28 != 0;
            LOBYTE(v13) = v56 & ((_WORD)v28 == 0);
            goto LABEL_100;
          }
          ps = 0LL;
          if ( v17 == -1LL )
          {
            v74 = v19;
            v69 = v15;
            v64 = v20;
            v39 = strlen(s);
            v19 = v74;
            LOBYTE(v15) = v69;
            v20 = v64;
            v17 = v39;
          }
          v85 = v16;
          v86 = v20;
          v40 = 0LL;
          v84 = v15;
          v75 = v9;
          v77 = v10;
          v65 = v17;
          v70 = v19;
          break;
      }
      while ( 2 )
      {
        v41 = v18 + v40;
        v28 = (const unsigned __int16 **)sub_40B6B0((wchar_t *)&wc, &s[v18 + v40]);
        v42 = v28;
        if ( !v28 )
        {
LABEL_241:
          v32 = v40;
          v16 = v85;
          v15 = v84;
          v9 = v75;
          LODWORD(v13) = v11 ^ 1;
          v10 = v77;
          v17 = v65;
          v19 = v70;
          LOBYTE(v13) = v56 & (v11 ^ 1);
          goto LABEL_242;
        }
        if ( v28 == (const unsigned __int16 **)-1LL )
        {
          v32 = v40;
          v16 = v85;
          v11 = 0;
          v15 = v84;
          v9 = v75;
          v10 = v77;
          v17 = v65;
          v19 = v70;
          LODWORD(v13) = v56;
          goto LABEL_242;
        }
        if ( v28 == (const unsigned __int16 **)-2LL )
        {
          v17 = v65;
          v50 = v18 + v40;
          v51 = &s[v18 + v40];
          v28 = (const unsigned __int16 **)v40;
          v32 = v40;
          v15 = v84;
          v16 = v85;
          v9 = v75;
          v10 = v77;
          v19 = v70;
          if ( v50 < v65 && *v51 )
          {
            do
              v28 = (const unsigned __int16 **)((char *)v28 + 1);
            while ( (unsigned __int64)v28 + v18 < v65 && *((_BYTE *)v28 + (_QWORD)v86) );
            v32 = (unsigned __int64)v28;
          }
          LODWORD(v13) = v56;
          v11 = 0;
LABEL_242:
          if ( v32 > 1 )
            goto LABEL_174;
LABEL_100:
          if ( (_BYTE)v13 )
          {
            LODWORD(v13) = v56;
            LOBYTE(v11) = 0;
LABEL_174:
            v44 = 0;
            v45 = v18 + v32;
            v46 = v57;
            while ( 1 )
            {
              if ( (_BYTE)v13 )
              {
                if ( v82 )
                  return sub_407CE0((__int64)v9, v10, s);
                LOBYTE(v28) = (v15 ^ 1) & (v19 == 2);
                if ( (_BYTE)v28 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 39;
                  if ( v10 > v16 + 1 )
                    v9[v16 + 1] = 36;
                  if ( v10 > v16 + 2 )
                    v9[v16 + 2] = 39;
                  v16 += 3LL;
                  v15 = (int)v28;
                }
                if ( v10 > v16 )
                  v9[v16] = 92;
                if ( v10 > v16 + 1 )
                  v9[v16 + 1] = ((unsigned __int8)v23 >> 6) + 48;
                LODWORD(v28) = v16 + 2;
                if ( v10 > v16 + 2 )
                {
                  LODWORD(v28) = (((unsigned __int8)v23 >> 3) & 7) + 48;
                  v9[v16 + 2] = (_BYTE)v28;
                }
                ++v18;
                v16 += 3LL;
                LOBYTE(v23) = (v23 & 7) + 48;
                if ( v18 >= v45 )
                {
                  v11 = (unsigned __int8)v11;
                  goto LABEL_40;
                }
                v44 = v13;
              }
              else
              {
                LODWORD(v28) = v15 & (v44 ^ 1);
                if ( v46 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 92;
                  ++v16;
                }
                if ( ++v18 >= v45 )
                {
                  v11 = (unsigned __int8)v11;
                  goto LABEL_51;
                }
                if ( (_BYTE)v28 )
                {
                  if ( v10 > v16 )
                    v9[v16] = 39;
                  LODWORD(v28) = v16 + 1;
                  if ( v10 > v16 + 1 )
                    v9[v16 + 1] = 39;
                  v16 += 2LL;
                  v46 = 0;
                  v15 = 0;
                }
                else
                {
                  v46 = 0;
                }
              }
              if ( v10 > v16 )
                v9[v16] = v23;
              LOBYTE(v23) = s[v18];
              ++v16;
            }
          }
LABEL_101:
          LOBYTE(v13) = v19 == 2;
LABEL_23:
          v25 = (v13 | v56 ^ 1) ^ 1;
          LOBYTE(v25) = v82 | (v13 | v56 ^ 1) ^ 1;
          if ( !(v82 | (unsigned __int8)(v13 | v56 ^ 1) ^ 1) )
            goto LABEL_49;
          goto LABEL_24;
        }
        if ( v70 != 2 || !v82 || v28 == (const unsigned __int16 **)1 )
        {
LABEL_148:
          if ( !iswprint(wc) )
            v11 = 0;
          v40 += (unsigned __int64)v42;
          LODWORD(v28) = mbsinit(&ps);
          if ( (_DWORD)v28 )
            goto LABEL_241;
          continue;
        }
        break;
      }
      v43 = &s[v41 + 1];
      while ( (unsigned __int8)(*v43 - 91) > 0x21u || !((1LL << (*v43 - 91)) & 0x20000002BLL) )
      {
        if ( &s[(_QWORD)v42 + v41] == ++v43 )
          goto LABEL_148;
      }
      v9 = v75;
      v10 = v77;
      return sub_407CE0((__int64)v9, v10, s);
    case 5:
      if ( v12 )
      {
        v59 = 1;
        v15 = 0;
        v16 = 0LL;
        v83 = 0;
        v79 = 0LL;
        v82 = 1;
        v56 = 1;
        n = 1LL;
        s2 = "\"";
      }
      else
      {
        if ( a2 )
        {
          *a1 = 34;
          v15 = 0;
          v59 = 1;
          v83 = 0;
          v79 = 0LL;
        }
        else
        {
          v79 = 0LL;
          v15 = 0;
          v59 = 1;
          v83 = 0;
        }
        v82 = 0;
        v16 = 1LL;
        v56 = 1;
        n = 1LL;
        s2 = "\"";
      }
      goto LABEL_3;
    case 6:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v11 = 5;
      v83 = 0;
      v79 = 0LL;
      v82 = 1;
      v56 = 1;
      n = 1LL;
      s2 = "\"";
      goto LABEL_3;
    case 7:
      v59 = 1;
      v15 = 0;
      v16 = 0LL;
      v83 = 0;
      v79 = 0LL;
      v82 = 0;
      v56 = 1;
      n = 0LL;
      s2 = 0LL;
      goto LABEL_3;
    case 8:
    case 9:
    case 10:
      if ( v12 )
      {
        a8 = sub_407BE0("`", v11);
        v47 = sub_407BE0("'", v11);
        v14 = v55;
        a9 = v47;
      }
      v16 = 0LL;
      if ( !v12 )
      {
        for ( i = *a8; i; i = a8[v16] )
        {
          if ( a2 > v16 )
            a1[v16] = i;
          ++v16;
        }
      }
      v58 = v14;
      v48 = strlen(a9);
      v59 = 1;
      v15 = 0;
      v14 = v58;
      n = v48;
      v83 = 0;
      s2 = a9;
      v79 = 0LL;
      v56 = 1;
      goto LABEL_3;
    default:
      abort();
      return result;
  }
}

_BYTE *__fastcall sub_408F10(int a1, char *a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  int *v6; // rax
  __int128 *v7; // rbx
  int *v8; // r13
  __int64 v9; // rsi
  unsigned __int64 *v10; // rbx
  _BYTE *v11; // r12
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned __int64 v17; // rsi
  _BYTE *v18; // rax
  int v19; // er8
  char *v21; // [rsp+8h] [rbp-50h]
  unsigned __int64 v22; // [rsp+10h] [rbp-48h]
  __int64 v23; // [rsp+10h] [rbp-48h]
  int v24; // [rsp+18h] [rbp-40h]
  int v25; // [rsp+1Ch] [rbp-3Ch]

  v4 = a3;
  v5 = a4;
  v21 = a2;
  v6 = __errno_location();
  v7 = off_612318;
  v8 = v6;
  v24 = *v6;
  if ( a1 < 0 )
    abort();
  if ( dword_612330 <= a1 )
  {
    if ( a1 == 0x7FFFFFFF )
      sub_40A020();
    v9 = 16LL * (a1 + 1);
    if ( off_612318 == &xmmword_612320 )
    {
      v7 = (__int128 *)sub_409E30(0LL, v9);
      off_612318 = v7;
      *v7 = (__int128)_mm_load_si128((const __m128i *)&xmmword_612320);
    }
    else
    {
      off_612318 = (__int128 *)sub_409E30(off_612318, v9);
      v7 = off_612318;
    }
    memset(&v7[dword_612330], 0, 16LL * (a1 + 1 - dword_612330));
    dword_612330 = a1 + 1;
  }
  v10 = (unsigned __int64 *)&v7[a1];
  v11 = (_BYTE *)v10[1];
  v25 = *(_DWORD *)(v5 + 4) | 1;
  v22 = *v10;
  v12 = sub_407CE0(v11, *v10, v21, v4, *(_DWORD *)v5, v25, v5 + 8, *(char **)(v5 + 40), *(char **)(v5 + 48));
  if ( v22 <= v12 )
  {
    v17 = v12 + 1;
    *v10 = v12 + 1;
    if ( v11 != (_BYTE *)&unk_6123C0 )
    {
      v23 = v12 + 1;
      free(v11);
      v17 = v23;
    }
    v18 = (_BYTE *)sub_409DD0(v17, v17, v13, v14, v15, v16);
    v19 = *(_DWORD *)v5;
    v10[1] = (unsigned __int64)v18;
    v11 = v18;
    sub_407CE0(v18, v17, v21, v4, v19, v25, v5 + 8, *(char **)(v5 + 40), *(char **)(v5 + 48));
  }
  *v8 = v24;
  return v11;
}

_BYTE *__fastcall sub_408F10(int a1, char *a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbp
  int *v6; // rax
  __int128 *v7; // rbx
  int *v8; // r13
  __int64 v9; // rsi
  unsigned __int64 *v10; // rbx
  _BYTE *v11; // r12
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned __int64 v17; // rsi
  _BYTE *v18; // rax
  int v19; // er8
  char *v21; // [rsp+8h] [rbp-50h]
  unsigned __int64 v22; // [rsp+10h] [rbp-48h]
  __int64 v23; // [rsp+10h] [rbp-48h]
  int v24; // [rsp+18h] [rbp-40h]
  int v25; // [rsp+1Ch] [rbp-3Ch]

  v4 = a3;
  v5 = a4;
  v21 = a2;
  v6 = __errno_location();
  v7 = off_612318;
  v8 = v6;
  v24 = *v6;
  if ( a1 < 0 )
    abort();
  if ( dword_612330 <= a1 )
  {
    if ( a1 == 0x7FFFFFFF )
      sub_40A020();
    v9 = 16LL * (a1 + 1);
    if ( off_612318 == &xmmword_612320 )
    {
      v7 = (__int128 *)sub_409E30(0LL, v9);
      off_612318 = v7;
      *v7 = (__int128)_mm_load_si128((const __m128i *)&xmmword_612320);
    }
    else
    {
      off_612318 = (__int128 *)sub_409E30(off_612318, v9);
      v7 = off_612318;
    }
    memset(&v7[dword_612330], 0, 16LL * (a1 + 1 - dword_612330));
    dword_612330 = a1 + 1;
  }
  v10 = (unsigned __int64 *)&v7[a1];
  v11 = (_BYTE *)v10[1];
  v25 = *(_DWORD *)(v5 + 4) | 1;
  v22 = *v10;
  v12 = sub_407CE0(v11, *v10, v21, v4, *(_DWORD *)v5, v25, v5 + 8, *(char **)(v5 + 40), *(char **)(v5 + 48));
  if ( v22 <= v12 )
  {
    v17 = v12 + 1;
    *v10 = v12 + 1;
    if ( v11 != (_BYTE *)&unk_6123C0 )
    {
      v23 = v12 + 1;
      free(v11);
      v17 = v23;
    }
    v18 = (_BYTE *)sub_409DD0(v17, v17, v13, v14, v15, v16);
    v19 = *(_DWORD *)v5;
    v10[1] = (unsigned __int64)v18;
    v11 = v18;
    sub_407CE0(v18, v17, v21, v4, v19, v25, v5 + 8, *(char **)(v5 + 40), *(char **)(v5 + 48));
  }
  *v8 = v24;
  return v11;
}

_BYTE *__fastcall sub_409430(int a1, int a2, char *a3)
{
  int v4; // [rsp+0h] [rbp-48h]
  int v5; // [rsp+4h] [rbp-44h]
  __int64 v6; // [rsp+8h] [rbp-40h]
  __int64 v7; // [rsp+10h] [rbp-38h]
  __int64 v8; // [rsp+18h] [rbp-30h]
  __int64 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v4 = a2;
  v5 = 0;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  return sub_408F10(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);
}

_BYTE *__fastcall sub_409430(int a1, int a2, char *a3)
{
  int v4; // [rsp+0h] [rbp-48h]
  int v5; // [rsp+4h] [rbp-44h]
  __int64 v6; // [rsp+8h] [rbp-40h]
  __int64 v7; // [rsp+10h] [rbp-38h]
  __int64 v8; // [rsp+18h] [rbp-30h]
  __int64 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v4 = a2;
  v5 = 0;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  return sub_408F10(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);
}

_BYTE *__fastcall sub_4094A0(int a1, int a2, char *a3, unsigned __int64 a4)
{
  int v5; // [rsp+0h] [rbp-48h]
  int v6; // [rsp+4h] [rbp-44h]
  __int64 v7; // [rsp+8h] [rbp-40h]
  __int64 v8; // [rsp+10h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-30h]
  __int64 v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+28h] [rbp-20h]
  __int64 v12; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v5 = a2;
  v6 = 0;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  return sub_408F10(a1, a3, a4, (__int64)&v5);
}

_BYTE *__fastcall sub_4094A0(int a1, int a2, char *a3, unsigned __int64 a4)
{
  int v5; // [rsp+0h] [rbp-48h]
  int v6; // [rsp+4h] [rbp-44h]
  __int64 v7; // [rsp+8h] [rbp-40h]
  __int64 v8; // [rsp+10h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-30h]
  __int64 v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+28h] [rbp-20h]
  __int64 v12; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v5 = a2;
  v6 = 0;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  return sub_408F10(a1, a3, a4, (__int64)&v5);
}

_BYTE *__fastcall sub_409510(int a1, char *a2)
{
  return sub_409430(0, a1, a2);
}

_BYTE *__fastcall sub_409530(char *a1, unsigned __int64 a2, unsigned __int8 a3)
{
  char v3; // cl
  int *v4; // r8
  unsigned __int32 v5; // edx
  __m128i v7; // [rsp+0h] [rbp-48h]
  __m128i v8; // [rsp+10h] [rbp-38h]
  __m128i v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+30h] [rbp-18h]

  v3 = a3 & 0x1F;
  v10 = qword_6124F0;
  v7 = _mm_load_si128((const __m128i *)&xmmword_6124C0);
  v8 = _mm_load_si128((const __m128i *)&xmmword_6124D0);
  v4 = &v7.m128i_i32[(a3 >> 5) + 2];
  v9 = _mm_load_si128((const __m128i *)&xmmword_6124E0);
  v5 = v7.m128i_u32[(a3 >> 5) + 2];
  *v4 = v5 ^ ((~(unsigned __int8)(v5 >> v3) & 1) << v3);
  return sub_408F10(0, a1, a2, (__int64)&v7);
}

_BYTE *__fastcall sub_4095B0(char *a1)
{
  return sub_409530(a1, 0xFFFFFFFFFFFFFFFFLL, 0x3Au);
}

_BYTE *__fastcall sub_4095E0(int a1, int a2, char *a3)
{
  int v4; // [rsp+0h] [rbp-48h]
  int v5; // [rsp+4h] [rbp-44h]
  __int64 v6; // [rsp+8h] [rbp-40h]
  __int64 v7; // [rsp+10h] [rbp-38h]
  __int64 v8; // [rsp+18h] [rbp-30h]
  __int64 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v4 = a2;
  v6 = 0x400000000000000LL;
  v5 = 0;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  return sub_408F10(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);
}

_BYTE *__fastcall sub_4095E0(int a1, int a2, char *a3)
{
  int v4; // [rsp+0h] [rbp-48h]
  int v5; // [rsp+4h] [rbp-44h]
  __int64 v6; // [rsp+8h] [rbp-40h]
  __int64 v7; // [rsp+10h] [rbp-38h]
  __int64 v8; // [rsp+18h] [rbp-30h]
  __int64 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+28h] [rbp-20h]
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a2 == 10 )
    abort();
  v4 = a2;
  v6 = 0x400000000000000LL;
  v5 = 0;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  return sub_408F10(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)&v4);
}

_BYTE *__fastcall sub_409650(int a1, __int64 a2, __int64 a3, char *a4, unsigned __int64 a5)
{
  __m128i v6; // [rsp+0h] [rbp-48h]
  __m128i v7; // [rsp+10h] [rbp-38h]
  __m128i v8; // [rsp+20h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-18h]

  v6 = _mm_load_si128((const __m128i *)&xmmword_6124C0);
  v7 = _mm_load_si128((const __m128i *)&xmmword_6124D0);
  v8 = _mm_load_si128((const __m128i *)&xmmword_6124E0);
  v9 = qword_6124F0;
  v6.m128i_i32[0] = 10;
  if ( !a2 || !a3 )
    abort();
  v8.m128i_i64[1] = a2;
  v9 = a3;
  return sub_408F10(a1, a4, a5, (__int64)&v6);
}

_BYTE *__fastcall sub_409740(int a1, char *a2)
{
  return sub_408F10(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_6122E0);
}

_BYTE *__fastcall sub_409760(char *a1)
{
  return sub_408F10(0, a1, 0xFFFFFFFFFFFFFFFFLL, (__int64)&unk_6122E0);
}

ssize_t __fastcall sub_409780(int fd, void *buf, size_t nbytes)
{
  size_t v3; // rbx
  ssize_t v4; // rbp
  int v5; // eax

  v3 = nbytes;
  while ( 1 )
  {
    v4 = read(fd, buf, v3);
    if ( v4 >= 0 )
      break;
    v5 = *__errno_location();
    if ( v5 != 4 )
    {
      if ( v3 <= 0x7FFFE000 || v5 != 22 )
        return v4;
      v3 = 2147475456LL;
    }
  }
  return v4;
}

__int64 __fastcall sub_4097E0(int fd)
{
  __int64 result; // rax
  unsigned int v2; // er12
  int *v3; // rax
  int v4; // er13
  int *v5; // rbp

  if ( (unsigned int)fd > 2 )
    return (unsigned int)fd;
  v2 = sub_40BFE0();
  v3 = __errno_location();
  v4 = *v3;
  v5 = v3;
  close(fd);
  result = v2;
  *v5 = v4;
  return result;
}

__int64 __fastcall sub_409830(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)
{
  __int64 v6; // r12
  __int64 *v7; // rbx
  char *v8; // rax
  char *v9; // rax
  __int64 v10; // rbx
  char *v11; // rax
  __int64 result; // rax
  const char *v13; // rsi
  __int64 v14; // rbx
  char *v15; // rax
  __int64 v16; // rbx
  char *v17; // rax
  __int64 v18; // rbx
  char *v19; // rax
  __int64 v20; // r14
  __int64 v21; // rbx
  char *v22; // rax
  __int64 v23; // rbx
  char *v24; // rax

  v6 = a6;
  v7 = a5;
  if ( a2 )
    __fprintf_chk(stream, 1LL, "%s (%s) %s\n", a2);
  else
    __fprintf_chk(stream, 1LL, "%s %s\n", a3);
  v8 = dcgettext(0LL, "(C)", 5);
  __fprintf_chk(stream, 1LL, "Copyright %s %d Free Software Foundation, Inc.", v8);
  v9 = dcgettext(
         0LL,
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n",
         5);
  fputs_unlocked(v9, stream);
  switch ( v6 )
  {
    case 0LL:
      abort();
      return result;
    case 1LL:
      v14 = *v7;
      v15 = dcgettext(0LL, "Written by %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v15, v14);
    case 2LL:
      v16 = *v7;
      v17 = dcgettext(0LL, "Written by %s and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v17, v16);
    case 3LL:
      v18 = *v7;
      v19 = dcgettext(0LL, "Written by %s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v19, v18);
    case 4LL:
      v20 = v7[3];
      v21 = *v7;
      v22 = dcgettext(0LL, "Written by %s, %s, %s,\nand %s.\n", 5);
      goto LABEL_13;
    case 5LL:
      v20 = v7[3];
      v21 = *v7;
      v22 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, and %s.\n", 5);
LABEL_13:
      __fprintf_chk(stream, 1LL, v22, v21);
      return v20;
    case 6LL:
      v23 = *v7;
      v24 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v24, v23);
    case 7LL:
      v23 = *v7;
      v24 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v24, v23);
    case 8LL:
      v10 = *v7;
      v11 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v11, v10);
    case 9LL:
      v13 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
      v10 = *v7;
      goto LABEL_8;
    default:
      v13 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
      v10 = *v7;
LABEL_8:
      v11 = dcgettext(0LL, v13, 5);
      return __fprintf_chk(stream, 1LL, v11, v10);
  }
}

__int64 __fastcall sub_409830(FILE *stream, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)
{
  __int64 v6; // r12
  __int64 *v7; // rbx
  char *v8; // rax
  char *v9; // rax
  __int64 v10; // rbx
  char *v11; // rax
  __int64 result; // rax
  const char *v13; // rsi
  __int64 v14; // rbx
  char *v15; // rax
  __int64 v16; // rbx
  char *v17; // rax
  __int64 v18; // rbx
  char *v19; // rax
  __int64 v20; // r14
  __int64 v21; // rbx
  char *v22; // rax
  __int64 v23; // rbx
  char *v24; // rax

  v6 = a6;
  v7 = a5;
  if ( a2 )
    __fprintf_chk(stream, 1LL, "%s (%s) %s\n", a2);
  else
    __fprintf_chk(stream, 1LL, "%s %s\n", a3);
  v8 = dcgettext(0LL, "(C)", 5);
  __fprintf_chk(stream, 1LL, "Copyright %s %d Free Software Foundation, Inc.", v8);
  v9 = dcgettext(
         0LL,
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n",
         5);
  fputs_unlocked(v9, stream);
  switch ( v6 )
  {
    case 0LL:
      abort();
      return result;
    case 1LL:
      v14 = *v7;
      v15 = dcgettext(0LL, "Written by %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v15, v14);
    case 2LL:
      v16 = *v7;
      v17 = dcgettext(0LL, "Written by %s and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v17, v16);
    case 3LL:
      v18 = *v7;
      v19 = dcgettext(0LL, "Written by %s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v19, v18);
    case 4LL:
      v20 = v7[3];
      v21 = *v7;
      v22 = dcgettext(0LL, "Written by %s, %s, %s,\nand %s.\n", 5);
      goto LABEL_13;
    case 5LL:
      v20 = v7[3];
      v21 = *v7;
      v22 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, and %s.\n", 5);
LABEL_13:
      __fprintf_chk(stream, 1LL, v22, v21);
      return v20;
    case 6LL:
      v23 = *v7;
      v24 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v24, v23);
    case 7LL:
      v23 = *v7;
      v24 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v24, v23);
    case 8LL:
      v10 = *v7;
      v11 = dcgettext(0LL, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", 5);
      return __fprintf_chk(stream, 1LL, v11, v10);
    case 9LL:
      v13 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
      v10 = *v7;
      goto LABEL_8;
    default:
      v13 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
      v10 = *v7;
LABEL_8:
      v11 = dcgettext(0LL, v13, 5);
      return __fprintf_chk(stream, 1LL, v11, v10);
  }
}

__int64 __fastcall sub_409C30(FILE *a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  __int64 i; // r9
  __int64 *v6; // r10
  __int64 v7; // rax
  unsigned int v8; // eax
  __int64 *v9; // r10
  __int64 v10; // rax
  __int64 v12[11]; // [rsp+0h] [rbp-58h]

  for ( i = 0LL; i != 10; ++i )
  {
    v8 = *a5;
    if ( (unsigned int)*a5 <= 0x2F )
    {
      v6 = (__int64 *)(*((_QWORD *)a5 + 2) + v8);
      *a5 = v8 + 8;
      v7 = *v6;
      v12[i] = *v6;
      if ( !v7 )
        return sub_409830(a1, a2, a3, a4, v12, i);
      continue;
    }
    v9 = (__int64 *)*((_QWORD *)a5 + 1);
    *((_QWORD *)a5 + 1) = v9 + 1;
    v10 = *v9;
    v12[i] = *v9;
    if ( !v10 )
      break;
  }
  return sub_409830(a1, a2, a3, a4, v12, i);
}

__int64 __fastcall sub_409C90(FILE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  char *v7; // r10
  unsigned int v8; // er8
  __int64 i; // r9
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 *v12; // rax
  __int64 v13; // rax
  __int64 v15[10]; // [rsp+20h] [rbp-88h]
  char v16[32]; // [rsp+70h] [rbp-38h]
  __int64 v17; // [rsp+90h] [rbp-18h]
  __int64 v18; // [rsp+98h] [rbp-10h]

  v17 = a5;
  v7 = &a7;
  v8 = 32;
  v18 = a6;
  for ( i = 0LL; i != 10; ++i )
  {
    if ( v8 <= 0x2F )
    {
      v10 = v8;
      v8 += 8;
      v11 = *(_QWORD *)&v16[v10];
      v15[i] = v11;
      if ( !v11 )
        return sub_409830(a1, a2, a3, a4, v15, i);
      continue;
    }
    v12 = (__int64 *)v7;
    v7 += 8;
    v13 = *v12;
    v15[i] = v13;
    if ( !v13 )
      break;
  }
  return sub_409830(a1, a2, a3, a4, v15, i);
}

int sub_409D50()
{
  char *v0; // rax
  __int64 v1; // rcx
  char *v2; // rax
  FILE *v3; // rbx
  char *v4; // rax

  v0 = dcgettext(0LL, "\nReport bugs to: %s\n", 5);
  __printf_chk(1LL, v0, "bug-coreutils@gnu.org", v1);
  v2 = dcgettext(0LL, "%s home page: <%s>\n", 5);
  __printf_chk(1LL, v2, &unk_40C375, "https://www.gnu.org/software/coreutils/");
  v3 = stdout;
  v4 = dcgettext(0LL, "General help using GNU software: <https://www.gnu.org/gethelp/>\n", 5);
  return fputs_unlocked(v4, v3);
}

void *__fastcall sub_409DD0(size_t a1)
{
  void *result; // rax

  result = malloc(a1);
  if ( !result )
  {
    if ( a1 )
      sub_40A020();
  }
  return result;
}

void *__fastcall sub_409E30(void *a1, size_t a2)
{
  void *result; // rax

  if ( !a2 && a1 )
  {
    free(a1);
    result = 0LL;
  }
  else
  {
    result = realloc(a1, a2);
    if ( !result )
    {
      if ( a2 )
        sub_40A020();
    }
  }
  return result;
}

void *__fastcall sub_409FD0(void *src, size_t n)
{
  void *v2; // rax

  v2 = sub_409DD0(n);
  return memcpy(v2, src, n);
}

void __noreturn sub_40A020()
{
  char *v0; // rax

  v0 = dcgettext(0LL, "memory exhausted", 5);
  error(status, 0, "%s", v0);
  abort();
}

unsigned __int64 __fastcall sub_40A060(char *a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, int a7)
{
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r14
  __int64 v9; // r13
  int v10; // ebx
  int v11; // eax
  unsigned __int64 v12; // rbp
  int *v13; // r14
  _BYTE *v14; // rax
  int v15; // esi
  int v17; // ebp
  int *v18; // rax
  unsigned __int64 v19; // [rsp+8h] [rbp-40h]

  v7 = a4;
  v8 = a3;
  v9 = a6;
  v10 = a7;
  v11 = sub_40A260(a1);
  if ( v11 )
  {
    v17 = v11;
    v18 = __errno_location();
    v13 = v18;
    if ( v17 == 1 )
    {
      *v18 = 75;
    }
    else if ( v17 == 3 )
    {
      *v18 = 0;
    }
  }
  else
  {
    v12 = v19;
    if ( v19 >= v8 && v19 <= v7 )
      return v12;
    v13 = __errno_location();
    *v13 = v19 < 0x40000000 ? 34 : 75;
  }
  v14 = sub_409760(a1);
  v15 = *v13;
  if ( *v13 == 22 )
    v15 = 0;
  if ( !a7 )
    v10 = 1;
  error(v10, v15, "%s: %s", v9, v14);
  return v19;
}

unsigned __int64 __fastcall sub_40A130(char *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, int a6)
{
  return sub_40A060(a1, 10LL, a2, a3, a4, a5, a6);
}

__int64 sub_40A160()
{
  __int64 v0; // rdx
  int *v1; // rbx
  __int64 result; // rax
  __int64 v3; // [rsp+0h] [rbp-18h]
  __int64 v4; // [rsp+8h] [rbp-10h]

  v3 = sub_40B950();
  v4 = v0;
  v1 = __errno_location();
  while ( 1 )
  {
    *v1 = 0;
    result = sub_40B840(&v3, 0LL);
    if ( !(_DWORD)result )
      break;
    if ( *v1 & 0xFFFFFFFB )
      return 0xFFFFFFFFLL;
  }
  return result;
}

bool __fastcall sub_40A1C0(_BYTE *a1, _QWORD *a2, double *a3, void (__fastcall *a4)(_BYTE *, _BYTE **), double a5)
{
  void (__fastcall *v5)(_BYTE *, _BYTE **); // r14
  double *v6; // r13
  int *v7; // r12
  bool result; // al
  _BYTE *v9; // [rsp+8h] [rbp-30h]

  v5 = a4;
  v6 = a3;
  v7 = __errno_location();
  *v7 = 0;
  v5(a1, &v9);
  if ( v9 == a1 )
  {
    result = 0;
  }
  else
  {
    if ( a2 )
    {
      result = 1;
      if ( a5 == 0.0 )
      {
LABEL_6:
        *a2 = v9;
        goto LABEL_7;
      }
    }
    else
    {
      result = 0;
      if ( *v9 )
        goto LABEL_7;
      if ( a5 == 0.0 )
      {
        result = 1;
        goto LABEL_7;
      }
    }
    result = *v7 != 34;
  }
  if ( a2 )
    goto LABEL_6;
LABEL_7:
  *v6 = a5;
  return result;
}

__int64 __fastcall sub_40A260(char *nptr, char **a2, unsigned int a3, unsigned __int64 *a4, const char *a5)
{
  char **v5; // r15
  unsigned __int64 *v6; // r14
  const char *v7; // r13
  int *v8; // rax
  int *v9; // r12
  unsigned __int8 v10; // bl
  const unsigned __int16 *v11; // rsi
  char *v12; // rax
  unsigned __int64 v13; // rbx
  unsigned int v14; // ebp
  int v15; // er12
  char *v17; // rax
  char *v18; // r8
  __int64 v19; // rax
  char *v20; // rax
  char v21; // al
  int v22; // esi
  unsigned __int64 v23; // rdx
  char *v24; // r8
  unsigned __int64 v25; // kr30_8
  char *v26; // rax
  int v27; // edi
  int v28; // er9
  bool v29; // of
  int v30; // edi
  int v31; // edi
  int v32; // edi
  int v33; // edi
  int base; // [rsp+0h] [rbp-58h]
  char *basea; // [rsp+0h] [rbp-58h]
  char *baseb; // [rsp+0h] [rbp-58h]
  char *v37; // [rsp+8h] [rbp-50h]
  char *endptr; // [rsp+18h] [rbp-40h]

  if ( a3 > 0x24 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "lib/xstrtol.c", 0x60u, "xstrtoumax");
  v5 = a2;
  base = a3;
  v6 = a4;
  v7 = a5;
  if ( !a2 )
    v5 = &endptr;
  v8 = __errno_location();
  *v8 = 0;
  v9 = v8;
  v10 = *nptr;
  v11 = *__ctype_b_loc();
  v12 = nptr;
  while ( v11[v10] & 0x2000 )
    v10 = *++v12;
  if ( v10 == 45 )
    return 4;
  v13 = __strtoul_internal(nptr, v5, base, 0);
  if ( *v5 == nptr )
  {
    basea = *v5;
    if ( v7 )
    {
      v15 = (unsigned __int8)*nptr;
      if ( (_BYTE)v15 )
      {
        v14 = 0;
        v13 = 1LL;
        v17 = strchr(v7, (char)v15);
        v18 = basea;
        if ( v17 )
          goto LABEL_20;
      }
    }
    return 4;
  }
  if ( *v9 )
  {
    v14 = 1;
    if ( *v9 == 34 )
      goto LABEL_11;
    return 4;
  }
  v14 = 0;
LABEL_11:
  if ( v7 )
  {
    v15 = (unsigned __int8)**v5;
    if ( (_BYTE)v15 )
    {
      baseb = *v5;
      v26 = strchr(v7, (char)v15);
      v18 = baseb;
      if ( !v26 )
      {
LABEL_39:
        *v6 = v13;
        v14 |= 2u;
        return v14;
      }
LABEL_20:
      v19 = 142129060940101LL;
      if ( !_bittest64(&v19, (unsigned int)(v15 - 69)) || (v37 = v18, v20 = strchr(v7, 48), v18 = v37, !v20) )
      {
LABEL_26:
        v22 = 1;
        v23 = 1024LL;
        goto LABEL_27;
      }
      v21 = v37[1];
      if ( v21 != 68 )
      {
        if ( v21 == 105 )
        {
          v23 = 1024LL;
          v22 = 2 * (v37[2] == 66) + 1;
LABEL_27:
          switch ( (_BYTE)v15 )
          {
            case 0x42:
              if ( v13 >> 54 )
                goto LABEL_37;
              v13 <<= 10;
              break;
            case 0x45:
              goto LABEL_70;
            case 0x47:
            case 0x67:
              goto LABEL_76;
            case 0x4B:
            case 0x6B:
              goto LABEL_36;
            case 0x4D:
            case 0x6D:
              goto LABEL_29;
            case 0x50:
              goto LABEL_64;
            case 0x54:
            case 0x74:
              goto LABEL_58;
            case 0x59:
              goto LABEL_52;
            case 0x5A:
              goto LABEL_46;
            case 0x62:
              goto LABEL_43;
            case 0x63:
              break;
            case 0x77:
              if ( (v13 & 0x8000000000000000LL) != 0LL )
                goto LABEL_37;
              v13 *= 2LL;
              break;
            default:
              goto LABEL_39;
          }
LABEL_32:
          v24 = &v18[v22];
          *v5 = v24;
          if ( *v24 )
            v14 |= 2u;
          goto LABEL_13;
        }
        if ( v21 != 66 )
        {
          switch ( (_BYTE)v15 )
          {
            case 0x45:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_70:
              v33 = 6;
              v28 = 0;
              do
              {
                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;
                v13 *= (int)v23;
                if ( v29 )
                {
                  v28 = 1;
                  v13 = -1LL;
                }
                --v33;
              }
              while ( v33 );
              goto LABEL_50;
            case 0x46:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4C:
            case 0x4E:
            case 0x4F:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6C:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
              goto LABEL_39;
            case 0x47:
            case 0x67:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_76:
              if ( is_mul_ok((int)v23, v13)
                && is_mul_ok((int)v23, (int)v23 * v13)
                && is_mul_ok((int)v23, (int)v23 * (int)v23 * v13) )
              {
                v13 *= (int)v23 * (int)v23 * (__int64)(int)v23;
              }
              else
              {
                v13 = -1LL;
                v14 |= 1u;
              }
              goto LABEL_32;
            case 0x4B:
            case 0x6B:
              v22 = 1;
              v23 = 1024LL;
LABEL_36:
              v25 = v13;
              v13 *= v23;
              if ( is_mul_ok(v23, v25) )
                goto LABEL_32;
              goto LABEL_37;
            case 0x4D:
            case 0x6D:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_29:
              if ( !is_mul_ok((int)v23, v13) || !is_mul_ok((int)v23, (int)v23 * v13) )
                goto LABEL_37;
              v13 *= (int)v23 * (__int64)(int)v23;
              break;
            case 0x50:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_64:
              v32 = 5;
              v28 = 0;
              do
              {
                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;
                v13 *= (int)v23;
                if ( v29 )
                {
                  v28 = 1;
                  v13 = -1LL;
                }
                --v32;
              }
              while ( v32 );
              goto LABEL_50;
            case 0x54:
            case 0x74:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_58:
              v31 = 4;
              v28 = 0;
              do
              {
                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;
                v13 *= (int)v23;
                if ( v29 )
                {
                  v28 = 1;
                  v13 = -1LL;
                }
                --v31;
              }
              while ( v31 );
              goto LABEL_50;
            case 0x59:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_52:
              v30 = 8;
              v28 = 0;
              do
              {
                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;
                v13 *= (int)v23;
                if ( v29 )
                {
                  v28 = 1;
                  v13 = -1LL;
                }
                --v30;
              }
              while ( v30 );
              goto LABEL_50;
            case 0x5A:
              v22 = 1;
              LODWORD(v23) = 1024;
LABEL_46:
              v27 = 7;
              v28 = 0;
              do
              {
                v29 = ((unsigned __int64)(int)v23 * (unsigned __int128)v13) >> 64 != 0;
                v13 *= (int)v23;
                if ( v29 )
                {
                  v28 = 1;
                  v13 = -1LL;
                }
                --v27;
              }
              while ( v27 );
LABEL_50:
              v14 |= v28;
              break;
            case 0x62:
              v22 = 1;
LABEL_43:
              if ( v13 >> 55 )
              {
LABEL_37:
                v14 = 1;
                v13 = -1LL;
              }
              else
              {
                v13 <<= 9;
              }
              break;
            case 0x63:
              v22 = 1;
              goto LABEL_32;
            default:
              goto LABEL_26;
          }
          goto LABEL_32;
        }
      }
      v22 = 2;
      v23 = 1000LL;
      goto LABEL_27;
    }
  }
LABEL_13:
  *v6 = v13;
  return v14;
}

__int64 __fastcall sub_40A6A0(char a1, int a2, __int64 a3)
{
  int v3; // ebx
  int v5; // eax
  int *v6; // rax
  int v7; // edi
  int v8; // er12
  int *v9; // rbp

  if ( a2 == 1030 )
  {
    if ( dword_6124F8 < 0 )
    {
      v3 = sub_40A6A0(a1);
      if ( v3 >= 0 && dword_6124F8 == -1 )
      {
LABEL_8:
        v5 = fcntl((unsigned __int8)v3, 1);
        if ( v5 < 0 || fcntl((unsigned __int8)v3, 2, v5 | 1u) == -1 )
        {
          v6 = __errno_location();
          v7 = v3;
          v3 = -1;
          v8 = *v6;
          v9 = v6;
          close(v7);
          *v9 = v8;
        }
        return (unsigned int)v3;
      }
    }
    else
    {
      v3 = fcntl(a1, 1030, (unsigned int)a3);
      if ( v3 >= 0 || *__errno_location() != 22 )
      {
        dword_6124F8 = 1;
      }
      else
      {
        v3 = sub_40A6A0(a1);
        if ( v3 >= 0 )
        {
          dword_6124F8 = -1;
          goto LABEL_8;
        }
      }
    }
    return (unsigned int)v3;
  }
  return (unsigned int)fcntl(a1, a2, a3);
}

__int64 __fastcall sub_40A7E0(__int64 a1, int *a2)
{
  __int64 v2; // r11
  int v3; // er12
  int v4; // ebp
  __int64 v5; // rbx
  int v6; // er9
  int v7; // er10
  int v8; // er8
  int v9; // er14
  int v10; // edx
  __int64 *v11; // rax
  unsigned __int64 v12; // r13
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 result; // rax
  __int64 *v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx

  v2 = a1 + 8;
  v3 = a2[11];
  v4 = *a2;
  v5 = a2[12];
  v6 = a2[11];
  v7 = *a2;
  v8 = a2[12];
LABEL_2:
  if ( v7 > v8 )
  {
    while ( v6 < v8 )
    {
      v9 = v7 - v8;
      v10 = v8 - v6;
      if ( v7 - v8 <= v8 - v6 )
      {
        v16 = (__int64 *)(a1 + 8LL * v6);
        v17 = v5 - v6;
        do
        {
          v18 = *v16;
          *v16 = v16[v17];
          v16[v17] = v18;
          ++v16;
        }
        while ( v16 != (__int64 *)(v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v9 - 1))) );
        v6 += v9;
        goto LABEL_2;
      }
      v7 -= v10;
      v11 = (__int64 *)(a1 + 8LL * v6);
      v12 = v2 + 8 * (v6 + (unsigned __int64)(unsigned int)(v10 - 1));
      v13 = v7 - (__int64)v6;
      do
      {
        v14 = *v11;
        *v11 = v11[v13];
        v11[v13] = v14;
        ++v11;
      }
      while ( (__int64 *)v12 != v11 );
      if ( v7 <= v8 )
        break;
    }
  }
  a2[12] = v4;
  result = (unsigned int)(v4 - v8);
  a2[11] = result + v3;
  return result;
}

__int64 __fastcall sub_40A8C0(int a1, __int64 *a2, char *a3, char **a4, _DWORD *a5, int a6, int *a7, int a8, __int64 a9)
{
  const char *v9; // r14
  char *v10; // rbp
  size_t v11; // r13
  char **v12; // rbx
  __int64 v13; // r12
  const char *v14; // r15
  const char *v15; // rdi
  __int64 v16; // r15
  char **v17; // rbp
  char *v18; // rdx
  __int64 result; // rax
  int v20; // edx
  int v21; // eax
  int v22; // ecx
  char *v23; // rdx
  __int64 v24; // rbx
  char *v25; // rax
  __int64 v26; // rbx
  char *v27; // rax
  __int64 v28; // rbp
  char *v29; // rax
  __int64 v30; // rbp
  char *v31; // rax
  FILE *v32; // rdi
  char **v33; // rbx
  _BYTE *v34; // rbp
  __int64 v35; // r12
  __int64 v36; // rbp
  char *v37; // rax
  char **v38; // [rsp+0h] [rbp-88h]
  int v39; // [rsp+Ch] [rbp-7Ch]
  char *s1; // [rsp+10h] [rbp-78h]
  char *s1a; // [rsp+10h] [rbp-78h]
  _BYTE *ptr; // [rsp+18h] [rbp-70h]
  _DWORD *v43; // [rsp+20h] [rbp-68h]
  char *s; // [rsp+30h] [rbp-58h]
  int v45; // [rsp+38h] [rbp-50h]
  char v46; // [rsp+3Fh] [rbp-49h]
  int v47; // [rsp+40h] [rbp-48h]
  int v48; // [rsp+44h] [rbp-44h]
  int v49; // [rsp+48h] [rbp-40h]

  v47 = a1;
  v9 = (const char *)*((_QWORD *)a7 + 4);
  s = a3;
  v38 = a4;
  v43 = a5;
  v10 = (char *)*((_QWORD *)a7 + 4);
  v39 = a6;
  v46 = *v9;
  if ( *v9 != 61 && *v9 )
  {
    do
      ++v10;
    while ( *v10 && *v10 != 61 );
    v11 = v10 - v9;
  }
  else
  {
    v11 = 0LL;
  }
  v12 = a4;
  v13 = 0LL;
  s1 = *a4;
  v14 = *a4;
  if ( !*a4 )
  {
LABEL_24:
    if ( !v39 || *(_BYTE *)(a2[*a7] + 1) == 45 || (v18 = strchr(s, v46), result = 0xFFFFFFFFLL, !v18) )
    {
      if ( a8 )
      {
        v24 = *a2;
        v25 = dcgettext(0LL, "%s: unrecognized option '%s%s'\n", 5);
        __fprintf_chk(stderr, 1LL, v25, v24);
      }
      *((_QWORD *)a7 + 4) = 0LL;
      ++*a7;
      a7[2] = 0;
      result = 63LL;
    }
    return result;
  }
  while ( 1 )
  {
    if ( !strncmp(v14, v9, v11) && strlen(v14) == v11 )
      goto LABEL_31;
    v12 += 4;
    v14 = *v12;
    if ( !*v12 )
      break;
    v13 = (int)v13 + 1;
  }
  v12 = 0LL;
  v48 = -1;
  v15 = s1;
  v16 = 0LL;
  v45 = 0;
  v49 = 0;
  ptr = 0LL;
  s1a = v10;
  v17 = v38;
  do
  {
    if ( strncmp(v15, v9, v11) )
      goto LABEL_20;
    if ( v12 )
    {
      if ( (v39
         || *((_DWORD *)v12 + 2) != *((_DWORD *)v17 + 2)
         || v12[2] != v17[2]
         || *((_DWORD *)v12 + 6) != *((_DWORD *)v17 + 6))
        && !v45 )
      {
        if ( a8 )
        {
          if ( ptr )
            goto LABEL_19;
          ptr = calloc((int)v13 + 1, 1uLL);
          if ( ptr )
          {
            v49 = 1;
            ptr[v48] = 1;
LABEL_19:
            ptr[v16] = 1;
            goto LABEL_20;
          }
          v45 = 1;
        }
        else
        {
          v45 = 1;
          if ( ptr )
            goto LABEL_19;
        }
      }
    }
    else
    {
      v48 = v16;
      v12 = v17;
    }
LABEL_20:
    v17 += 4;
    v15 = *v17;
    ++v16;
  }
  while ( *v17 );
  v10 = s1a;
  if ( ptr || v45 )
  {
    if ( a8 )
    {
      if ( v45 )
      {
        v26 = *a2;
        v27 = dcgettext(0LL, "%s: option '%s%s' is ambiguous\n", 5);
        __fprintf_chk(stderr, 1LL, v27, v26);
        v9 = (const char *)*((_QWORD *)a7 + 4);
      }
      else
      {
        flockfile(stderr);
        v30 = *a2;
        v31 = dcgettext(0LL, "%s: option '%s%s' is ambiguous; possibilities:", 5);
        __fprintf_chk(stderr, 1LL, v31, v30);
        v32 = stderr;
        v33 = v38;
        v34 = ptr;
        v35 = (__int64)&ptr[v13 + 1];
        do
        {
          if ( *v34 )
          {
            __fprintf_chk(v32, 1LL, " '%s%s'", a9);
            v32 = stderr;
          }
          ++v34;
          v33 += 4;
        }
        while ( (_BYTE *)v35 != v34 );
        fputc(10, v32);
        funlockfile(stderr);
        v9 = (const char *)*((_QWORD *)a7 + 4);
      }
    }
    if ( v49 )
      free(ptr);
    *((_QWORD *)a7 + 4) = &v9[strlen(v9)];
    ++*a7;
    a7[2] = 0;
    result = 63LL;
  }
  else
  {
    if ( !v12 )
      goto LABEL_24;
    LODWORD(v13) = v48;
LABEL_31:
    v20 = *a7;
    *((_QWORD *)a7 + 4) = 0LL;
    v21 = v20 + 1;
    *a7 = v20 + 1;
    v22 = *((_DWORD *)v12 + 2);
    if ( *v10 )
    {
      if ( v22 )
      {
        *((_QWORD *)a7 + 2) = v10 + 1;
        goto LABEL_33;
      }
      if ( a8 )
      {
        v28 = *a2;
        v29 = dcgettext(0LL, "%s: option '%s%s' doesn't allow an argument\n", 5);
        __fprintf_chk(stderr, 1LL, v29, v28);
      }
      a7[2] = *((_DWORD *)v12 + 6);
      result = 63LL;
    }
    else
    {
      if ( v22 != 1 )
        goto LABEL_33;
      if ( v21 >= v47 )
      {
        if ( a8 )
        {
          v36 = *a2;
          v37 = dcgettext(0LL, "%s: option '%s%s' requires an argument\n", 5);
          __fprintf_chk(stderr, 1LL, v37, v36);
        }
        a7[2] = *((_DWORD *)v12 + 6);
        result = 5 * (unsigned int)(*s != 58) + 58;
      }
      else
      {
        *a7 = v20 + 2;
        *((_QWORD *)a7 + 2) = a2[v21];
LABEL_33:
        if ( v43 )
          *v43 = v13;
        v23 = v12[2];
        result = *((unsigned int *)v12 + 6);
        if ( v23 )
        {
          *(_DWORD *)v23 = result;
          result = 0LL;
        }
      }
    }
  }
  return result;
}

__int64 __fastcall sub_40AEE0(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int a6, int *a7, int a8)
{
  int v8; // er13
  int v9; // eax
  int v10; // ebp
  __int64 *v11; // r12
  char *v12; // r15
  _BYTE *v13; // rdx
  char v14; // al
  char v15; // al
  int v16; // eax
  _BYTE *v17; // r14
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // er14
  char *v22; // rax
  __int64 v23; // r8
  char v24; // cl
  int v26; // edx
  __int64 v27; // rax
  _BYTE *v28; // rcx
  int v29; // esi
  char v30; // cl
  char *v31; // rax
  __int64 v32; // rax
  char *v34; // rax
  char v35; // dl
  __int64 v36; // rax
  int v37; // edx
  __int64 v38; // rax
  __int64 v39; // rbp
  char *v40; // rax
  __int64 v41; // rbp
  char *v42; // rax
  __int64 v43; // rbp
  char *v44; // rax
  char **v45; // [rsp+8h] [rbp-60h]
  _DWORD *v46; // [rsp+10h] [rbp-58h]
  char v47; // [rsp+1Ch] [rbp-4Ch]
  int v48; // [rsp+1Ch] [rbp-4Ch]
  int v49; // [rsp+1Ch] [rbp-4Ch]
  int v50; // [rsp+1Ch] [rbp-4Ch]
  _BYTE *v51; // [rsp+20h] [rbp-48h]
  __int64 v52; // [rsp+28h] [rbp-40h]

  v45 = a4;
  v46 = a5;
  v8 = a7[1];
  if ( a1 <= 0 )
    return (unsigned int)-1;
  v9 = *a7;
  v10 = a1;
  v11 = (__int64 *)a2;
  v12 = a3;
  *((_QWORD *)a7 + 2) = 0LL;
  if ( !v9 )
  {
    *a7 = 1;
    v9 = 1;
LABEL_4:
    a7[12] = v9;
    a7[11] = v9;
    *((_QWORD *)a7 + 4) = 0LL;
    if ( *a3 == 45 )
    {
      a7[10] = 2;
      v12 = a3 + 1;
      v13 = 0LL;
    }
    else if ( *a3 == 43 )
    {
      a7[10] = 0;
      v12 = a3 + 1;
      v13 = 0LL;
    }
    else
    {
      v13 = 0LL;
      if ( !a8 )
      {
        v50 = a6;
        v34 = getenv("POSIXLY_CORRECT");
        a6 = v50;
        if ( !v34 )
        {
          a7[10] = 1;
          v13 = (_BYTE *)*((_QWORD *)a7 + 4);
          goto LABEL_24;
        }
        v13 = (_BYTE *)*((_QWORD *)a7 + 4);
      }
      a7[10] = 0;
    }
LABEL_24:
    a7[6] = 1;
    v14 = *v12;
    goto LABEL_25;
  }
  if ( !a7[6] )
    goto LABEL_4;
  v14 = *a3;
  v13 = (_BYTE *)*((_QWORD *)a7 + 4);
  if ( !((v14 - 43) & 0xFD) )
  {
    v15 = *++v12;
    if ( v15 == 58 )
      v8 = 0;
    if ( !v13 )
      goto LABEL_12;
    goto LABEL_28;
  }
LABEL_25:
  if ( v14 == 58 )
    v8 = 0;
  if ( !v13 )
    goto LABEL_12;
LABEL_28:
  if ( !*v13 )
  {
LABEL_12:
    v16 = *a7;
    if ( a7[12] > *a7 )
      a7[12] = v16;
    if ( v16 < a7[11] )
      a7[11] = v16;
    if ( a7[10] == 1 )
    {
      v26 = a7[12];
      if ( a7[11] == v26 )
      {
        if ( v16 != v26 )
        {
          a7[11] = v16;
          v26 = v16;
        }
      }
      else if ( v16 != v26 )
      {
        v48 = a6;
        sub_40A7E0(a2, a7);
        v26 = *a7;
        a6 = v48;
      }
      if ( a1 <= v26 )
      {
LABEL_79:
        v16 = v26;
      }
      else
      {
        v27 = v26;
        while ( 1 )
        {
          v28 = (_BYTE *)v11[v27];
          v29 = v27;
          v26 = v27;
          if ( *v28 == 45 )
          {
            if ( v28[1] )
              break;
          }
          v26 = ++v27;
          *a7 = v29 + 1;
          if ( a1 <= (int)v27 )
            goto LABEL_79;
        }
        v16 = *a7;
      }
      a7[12] = v26;
    }
    if ( a1 == v16 )
    {
      v10 = a7[12];
      v18 = a7[11];
LABEL_41:
      if ( v18 != v10 )
        *a7 = v18;
      return (unsigned int)-1;
    }
    v17 = (_BYTE *)v11[v16];
    if ( !strcmp((const char *)v11[v16], "--") )
    {
      v18 = a7[11];
      v19 = a7[12];
      v20 = v16 + 1;
      *a7 = v20;
      if ( v18 == v19 )
      {
        a7[11] = v20;
        v18 = v20;
      }
      else if ( v20 != v19 )
      {
        sub_40A7E0((__int64)v11, a7);
        v18 = a7[11];
      }
      a7[12] = a1;
      *a7 = a1;
      goto LABEL_41;
    }
    if ( *v17 == 45 )
    {
      v30 = v17[1];
      if ( v30 )
      {
        if ( v45 )
        {
          if ( v30 == 45 )
          {
            *((_QWORD *)a7 + 4) = v17 + 2;
            return (unsigned int)sub_40A8C0(a1, v11, v12, v45, v46, a6, a7, v8, (__int64)"--");
          }
          if ( a6 )
          {
            if ( v17[2] || (v49 = a6, v31 = strchr(v12, v30), a6 = v49, !v31) )
            {
              *((_QWORD *)a7 + 4) = v17 + 1;
              v21 = sub_40A8C0(a1, v11, v12, v45, v46, a6, a7, v8, (__int64)"-");
              if ( v21 != -1 )
                return v21;
              v17 = (_BYTE *)v11[*a7];
            }
          }
        }
        v13 = v17 + 1;
        goto LABEL_29;
      }
    }
    if ( a7[10] )
    {
      *((_QWORD *)a7 + 2) = v17;
      v21 = 1;
      *a7 = v16 + 1;
      return v21;
    }
    return (unsigned int)-1;
  }
LABEL_29:
  v51 = v13;
  *((_QWORD *)a7 + 4) = v13 + 1;
  v21 = (char)*v13;
  v52 = (__int64)(v13 + 1);
  v47 = *v13;
  v22 = strchr(v12, v21);
  v23 = v52;
  if ( !v51[1] )
    ++*a7;
  if ( (unsigned __int8)(v47 - 58) > 1u && v22 )
  {
    v24 = v22[1];
    if ( *v22 == 87 && v45 && v24 == 59 )
    {
      if ( v51[1] )
      {
LABEL_68:
        *((_QWORD *)a7 + 4) = v23;
        *((_QWORD *)a7 + 2) = 0LL;
        return (unsigned int)sub_40A8C0(a1, v11, v12, v45, v46, 0, a7, v8, (__int64)"-W ");
      }
      v32 = *a7;
      if ( (_DWORD)v32 != a1 )
      {
        v23 = v11[v32];
        goto LABEL_68;
      }
      if ( v8 )
      {
        v43 = *v11;
        v44 = dcgettext(0LL, "%s: option requires an argument -- '%c'\n", 5);
        __fprintf_chk(stderr, 1LL, v44, v43);
      }
      a7[2] = v21;
      v21 = 5 * (*v12 != 58) + 58;
    }
    else if ( v24 == 58 )
    {
      v35 = v51[1];
      if ( v22[2] == 58 )
      {
        if ( v35 )
        {
          *((_QWORD *)a7 + 2) = v52;
          ++*a7;
        }
        else
        {
          *((_QWORD *)a7 + 2) = 0LL;
        }
      }
      else
      {
        v36 = *a7;
        if ( v35 )
        {
          *((_QWORD *)a7 + 2) = v52;
          *a7 = v36 + 1;
        }
        else if ( a1 == (_DWORD)v36 )
        {
          if ( v8 )
          {
            v41 = *v11;
            v42 = dcgettext(0LL, "%s: option requires an argument -- '%c'\n", 5);
            __fprintf_chk(stderr, 1LL, v42, v41);
          }
          a7[2] = v21;
          v21 = 5 * (*v12 != 58) + 58;
        }
        else
        {
          v37 = v36 + 1;
          v38 = v11[v36];
          *a7 = v37;
          *((_QWORD *)a7 + 2) = v38;
        }
      }
      *((_QWORD *)a7 + 4) = 0LL;
    }
  }
  else
  {
    if ( v8 )
    {
      v39 = *v11;
      v40 = dcgettext(0LL, "%s: invalid option -- '%c'\n", 5);
      __fprintf_chk(stderr, 1LL, v40, v39);
    }
    a7[2] = v21;
    v21 = 63;
  }
  return v21;
}

__int64 __fastcall sub_40B4B0(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int a6, int a7)
{
  __int64 result; // rax

  dword_612500 = dword_61233C;
  dword_612504 = dword_612338;
  result = sub_40AEE0(a1, a2, a3, a4, a5, a6, &dword_612500, a7);
  dword_61233C = dword_612500;
  qword_612540 = qword_612510;
  dword_612334 = dword_612508;
  return result;
}

__int64 __fastcall sub_40B510(int a1, __int64 a2, char *a3)
{
  return sub_40B4B0(a1, a2, a3, 0LL, 0LL, 0, 1);
}

__int64 __fastcall sub_40B530(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5)
{
  return sub_40B4B0(a1, a2, a3, a4, a5, 0, 0);
}

__int64 __fastcall sub_40B550(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int *a6)
{
  return sub_40AEE0(a1, a2, a3, a4, a5, 0, a6, 0);
}

__int64 __fastcall sub_40B570(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5)
{
  return sub_40B4B0(a1, a2, a3, a4, a5, 1, 0);
}

__int64 __fastcall sub_40B590(int a1, __int64 a2, char *a3, char **a4, _DWORD *a5, int *a6)
{
  return sub_40AEE0(a1, a2, a3, a4, a5, 1, a6, 0);
}

__int64 __fastcall sub_40B5B0(int fildes)
{
  unsigned int v1; // ebx
  int *v3; // rbp
  int v4; // er12
  int v5; // edx
  int pipedes[2]; // [rsp+8h] [rbp-140h]
  struct stat stat_buf; // [rsp+10h] [rbp-138h]
  struct stat v8; // [rsp+A0h] [rbp-A8h]

  v1 = __fxstat(1, fildes, &stat_buf);
  if ( !v1 )
  {
    LOBYTE(v1) = (stat_buf.st_mode & 0xF000) == 49152 || (stat_buf.st_mode & 0xF000) == 4096;
    if ( !(_BYTE)v1 )
      return (unsigned __int8)v1;
    v1 = pipe(pipedes);
    if ( !v1 )
    {
      v1 = __fxstat(1, pipedes[0], &v8);
      v3 = __errno_location();
      v4 = *v3;
      close(pipedes[0]);
      close(pipedes[1]);
      if ( v1 )
      {
        *v3 = v4;
        return v1;
      }
      if ( stat_buf.st_nlink <= v8.st_nlink )
      {
        v5 = stat_buf.st_mode & 0xF000;
        v1 = v5 == 4096;
        if ( (v8.st_mode & 0xF000) != 4096 )
        {
          LOBYTE(v1) = v5 == 49152;
          return (unsigned __int8)v1;
        }
      }
    }
  }
  return v1;
}

size_t __fastcall sub_40B6B0(wchar_t *pwc, char *s, size_t a3, mbstate_t *a4)
{
  size_t v4; // rbx
  wchar_t *v5; // r12
  char *v6; // rbp
  char v8; // [rsp+Ch] [rbp-1Ch]

  if ( !s )
  {
    a3 = 1LL;
    v6 = "%s: invalid option -- '%c'\n" + 27;
LABEL_7:
    v5 = (wchar_t *)&v8;
    goto LABEL_4;
  }
  v4 = -2LL;
  if ( !a3 )
    return v4;
  v5 = pwc;
  v6 = s;
  if ( !pwc )
    goto LABEL_7;
LABEL_4:
  v4 = mbrtowc(v5, v6, a3, a4);
  if ( v4 > 0xFFFFFFFFFFFFFFFDLL && !(unsigned __int8)sub_40BA10(0LL) )
  {
    v4 = 1LL;
    *v5 = (unsigned __int8)*v6;
  }
  return v4;
}

_BYTE *__fastcall sub_40B730(_BYTE *a1, __int16 a2, unsigned __int64 a3)
{
  _BYTE *result; // rax
  __int64 v4; // r9
  __int64 v5; // rcx
  _BYTE *v6; // rdi

  if ( !a3 )
    return 0LL;
  if ( (unsigned __int8)a1 & 7 )
  {
    if ( (_BYTE)a2 == *a1 )
      return a1;
    while ( 1 )
    {
      ++a1;
      if ( !--a3 )
        return 0LL;
      if ( !((unsigned __int8)a1 & 7) )
        break;
      if ( *a1 == (_BYTE)a2 )
        return a1;
    }
  }
  v4 = ((((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 32) | ((__int64)((unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8)) << 16) | (unsigned __int8)a2 | (unsigned int)(unsigned __int16)(a2 << 8);
  if ( a3 > 7 && !(((v4 ^ *(_QWORD *)a1) - 72340172838076673LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL) )
  {
    while ( 1 )
    {
      a3 -= 8LL;
      a1 += 8;
      if ( a3 <= 7 )
        break;
      if ( ((v4 ^ *(_QWORD *)a1) - 72340172838076673LL) & ~(v4 ^ *(_QWORD *)a1) & 0x8080808080808080LL )
        goto LABEL_15;
    }
    if ( !a3 )
      return 0LL;
  }
LABEL_15:
  if ( (_BYTE)a2 != *a1 )
  {
    v5 = (__int64)(a1 + 1);
    v6 = &a1[a3];
    while ( 1 )
    {
      result = (_BYTE *)v5;
      if ( (_BYTE *)v5 == v6 )
        break;
      if ( *(_BYTE *)(++v5 - 1) == (_BYTE)a2 )
        return result;
    }
    return 0LL;
  }
  return a1;
}

int __fastcall sub_40B840(__int64 *a1, struct timespec *a2)
{
  __int64 v2; // rbx
  int result; // eax
  __int64 v4; // [rsp+0h] [rbp-28h]
  __int64 v5; // [rsp+8h] [rbp-20h]

  if ( (unsigned __int64)a1[1] > 0x3B9AC9FF )
  {
    *__errno_location() = 22;
    result = -1;
  }
  else
  {
    v2 = *a1;
    v5 = a1[1];
    if ( v2 > 2073600 )
    {
      while ( 1 )
      {
        v4 = 2073600LL;
        v2 -= 2073600LL;
        result = nanosleep((const struct timespec *)&v4, a2);
        if ( result )
          break;
        v5 = 0LL;
        if ( v2 <= 2073600 )
          goto LABEL_8;
      }
      if ( a2 )
        a2->tv_sec += v2;
    }
    else
    {
LABEL_8:
      v4 = v2;
      result = nanosleep((const struct timespec *)&v4, a2);
    }
  }
  return result;
}

__int64 __fastcall sub_40B8F0(FILE *stream)
{
  size_t v1; // r12
  int v2; // ebx
  __int64 result; // rax

  v1 = __fpending(stream);
  v2 = stream->_flags & 0x20;
  result = sub_40BFF0(stream);
  if ( v2 )
  {
    if ( !(_DWORD)result )
    {
      *__errno_location() = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( !(_DWORD)result )
      return result;
    if ( !v1 )
      return (unsigned int)-(*__errno_location() != 9);
  }
  return 0xFFFFFFFFLL;
}

__int64 __fastcall sub_40B950(double a1)
{
  __int64 result; // rax
  __int64 v2; // rsi
  signed __int64 v3; // rcx

  if ( a1 <= -9.223372036854776e18 )
    return 0x8000000000000000LL;
  if ( a1 >= 9.223372036854776e18 )
    return 0x7FFFFFFFFFFFFFFFLL;
  v2 = (unsigned int)(int)a1;
  v3 = (unsigned int)(int)((a1 - (double)(int)v2) * 1000000000.0)
     + (unsigned __int64)((a1 - (double)(int)v2) * 1000000000.0 > (double)(int)((a1 - (double)(int)v2) * 1000000000.0));
  result = v3 / 1000000000 + v2;
  if ( v3 % 1000000000 < 0 )
    --result;
  return result;
}

bool __fastcall sub_40BA10(int a1)
{
  char *v1; // rdx
  bool result; // al

  v1 = setlocale(a1, 0LL);
  result = 1;
  if ( v1 )
  {
    result = 0;
    if ( strcmp(v1, "C") )
      result = strcmp(v1, "POSIX") != 0;
  }
  return result;
}

const char *sub_40BA70()
{
  char *v0; // rax
  char *v1; // r15
  const char *v2; // rbx
  char v3; // bp
  size_t v4; // rax
  char *v6; // rax
  const char *v7; // r13
  size_t v8; // rax
  __int64 v9; // r12
  size_t v10; // r14
  size_t v11; // rdi
  char *v12; // rax
  char *v13; // rbp
  size_t v14; // rdi
  char *v15; // rax
  int v16; // eax
  int v17; // er12
  FILE *v18; // r13
  const char *v19; // rax
  FILE *v20; // rbx
  const char *v21; // r13
  char *v22; // rax
  int v23; // edi
  char *v24; // kr00_8
  char *v25; // rdx
  int v26; // esi
  unsigned int v27; // eax
  __int64 v28; // rdx
  signed __int64 v29; // rax
  char *v30; // rax
  signed __int64 v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rsi
  unsigned int v34; // ecx
  __int64 v35; // rdi
  char *v36; // rsi
  unsigned int v37; // edx
  char *v38; // rcx
  FILE *v39; // rdi
  int v40; // eax
  bool v41; // dl
  char *v42; // rax
  __int64 v43; // rax
  unsigned __int64 v44; // r9
  char *v45; // rsi
  char *v46; // r10
  unsigned int v47; // ecx
  unsigned int v48; // ecx
  unsigned int v49; // esi
  __int64 v50; // r8
  unsigned __int64 v51; // rdi
  char *v52; // rcx
  char *v53; // r9
  unsigned int v54; // edx
  unsigned int v55; // edx
  unsigned int v56; // ecx
  __int64 v57; // rsi
  const char *v58; // rax
  char *v59; // rdi
  FILE *v60; // r13
  __int64 v61; // [rsp+8h] [rbp-D0h]
  __int64 v62; // [rsp+18h] [rbp-C0h]
  char v63[64]; // [rsp+20h] [rbp-B8h]
  char v64[120]; // [rsp+60h] [rbp-78h]

  v0 = nl_langinfo(14);
  v1 = s;
  v2 = v0;
  if ( !v0 )
    v2 = "";
  if ( !s )
  {
    v6 = getenv("CHARSETALIASDIR");
    v7 = v6;
    if ( v6 && *v6 )
    {
      v8 = strlen(v6);
      v9 = v8;
      v10 = v8;
      if ( !v8 )
      {
        v11 = 14LL;
LABEL_18:
        v12 = (char *)malloc(v11);
        v13 = v12;
        if ( !v12 )
        {
LABEL_19:
          v1 = "%s: invalid option -- '%c'\n" + 27;
LABEL_20:
          s = v1;
          goto LABEL_4;
        }
        memcpy(v12, v7, v10);
LABEL_24:
        strcpy(&v13[v9], "charset.alias");
        v16 = open(v13, 0);
        v17 = v16;
        if ( v16 >= 0 )
        {
          v1 = 0LL;
          v61 = 0LL;
          v18 = fdopen(v16, "r");
          if ( v18 )
          {
            v19 = v2;
            v20 = v18;
            v21 = v19;
LABEL_30:
            v22 = v20->_IO_read_ptr;
            if ( v22 < v20->_IO_read_end )
            {
LABEL_31:
              v20->_IO_read_ptr = v22 + 1;
              v23 = (unsigned __int8)*v22;
              goto LABEL_32;
            }
            while ( 1 )
            {
              v23 = __uflow(v20);
              if ( v23 == -1 )
                break;
LABEL_32:
              if ( (unsigned int)(v23 - 9) <= 1 || v23 == 32 )
                goto LABEL_30;
              if ( v23 == 35 )
              {
                do
                {
                  v42 = v20->_IO_read_ptr;
                  if ( v42 < v20->_IO_read_end )
                  {
                    v20->_IO_read_ptr = v42 + 1;
                    v40 = (unsigned __int8)*v42;
                    v41 = 1;
                  }
                  else
                  {
                    v40 = __uflow(v20);
                    v41 = v40 != -1;
                  }
                }
                while ( v40 != 10 && v41 );
                if ( v40 == -1 )
                  break;
                goto LABEL_30;
              }
              ungetc(v23, v20);
              if ( fscanf(v20, "%50s %50s", v63, v64) <= 1 )
                break;
              v24 = &v63[strlen(v63)];
              v25 = v64;
              do
              {
                v26 = *(_DWORD *)v25;
                v25 += 4;
                v27 = ~v26 & (v26 - 16843009) & 0x80808080;
              }
              while ( !v27 );
              if ( !(~v26 & (v26 - 16843009) & 0x8080) )
                v27 >>= 16;
              if ( !(~v26 & (v26 - 16843009) & 0x8080) )
                v25 += 2;
              v28 = &v25[-__CFADD__((_BYTE)v27, (_BYTE)v27) - 3] - v64;
              v29 = v24 - v63 + v28;
              v62 = v28;
              if ( v61 )
              {
                v43 = v61 + v29;
                v61 = v43 + 2;
                v30 = (char *)realloc(v1, v43 + 3);
                v32 = v62;
                v31 = v24 - v63;
              }
              else
              {
                v61 = v29 + 2;
                v30 = (char *)malloc(v29 + 3);
                v31 = v24 - v63;
                v32 = v62;
              }
              if ( !v30 )
              {
                v58 = v21;
                v59 = v1;
                v60 = v20;
                v1 = "%s: invalid option -- '%c'\n" + 27;
                v2 = v58;
                free(v59);
                sub_40BFF0(v60);
                goto LABEL_26;
              }
              v33 = -2 - v31;
              v34 = v31 + 1;
              v35 = v61 - v32;
              v36 = &v30[v61 - v32 + v33];
              if ( v34 >= 8 )
              {
                *(_QWORD *)v36 = *(_QWORD *)v63;
                *(_QWORD *)&v36[v34 - 8] = *(_QWORD *)&v63[v34 - 8];
                v44 = (unsigned __int64)(v36 + 8) & 0xFFFFFFFFFFFFFFF8LL;
                v45 = &v36[-v44];
                v46 = (char *)(v63 - v45);
                v47 = ((_DWORD)v45 + v34) & 0xFFFFFFF8;
                if ( v47 >= 8 )
                {
                  v48 = v47 & 0xFFFFFFF8;
                  v49 = 0;
                  do
                  {
                    v50 = v49;
                    v49 += 8;
                    *(_QWORD *)(v44 + v50) = *(_QWORD *)&v46[v50];
                  }
                  while ( v49 < v48 );
                }
              }
              else if ( v34 & 4 )
              {
                *(_DWORD *)v36 = *(_DWORD *)v63;
                *(_DWORD *)&v36[v34 - 4] = *(_DWORD *)&v63[v34 - 4];
              }
              else if ( v34 )
              {
                *v36 = v63[0];
                if ( v34 & 2 )
                  *(_WORD *)&v36[v34 - 2] = *(_WORD *)&v63[v34 - 2];
              }
              v37 = v32 + 1;
              v38 = &v30[v35 - 1];
              if ( v37 >= 8 )
              {
                *(_QWORD *)v38 = *(_QWORD *)v64;
                *(_QWORD *)&v38[v37 - 8] = *(_QWORD *)&v64[v37 - 8];
                v51 = (unsigned __int64)(v38 + 8) & 0xFFFFFFFFFFFFFFF8LL;
                v52 = &v38[-v51];
                v53 = (char *)(v64 - v52);
                v54 = ((_DWORD)v52 + v37) & 0xFFFFFFF8;
                if ( v54 >= 8 )
                {
                  v55 = v54 & 0xFFFFFFF8;
                  v56 = 0;
                  do
                  {
                    v57 = v56;
                    v56 += 8;
                    *(_QWORD *)(v51 + v57) = *(_QWORD *)&v53[v57];
                  }
                  while ( v56 < v55 );
                }
              }
              else if ( v37 & 4 )
              {
                *(_DWORD *)v38 = *(_DWORD *)v64;
                *(_DWORD *)&v38[v37 - 4] = *(_DWORD *)&v64[v37 - 4];
              }
              else if ( v37 )
              {
                *v38 = v64[0];
                if ( v37 & 2 )
                  *(_WORD *)&v38[v37 - 2] = *(_WORD *)&v64[v37 - 2];
              }
              v1 = v30;
              v22 = v20->_IO_read_ptr;
              if ( v22 < v20->_IO_read_end )
                goto LABEL_31;
            }
            v39 = v20;
            v2 = v21;
            sub_40BFF0(v39);
            if ( !v61 )
              goto LABEL_25;
            v1[v61] = 0;
            goto LABEL_26;
          }
          close(v17);
        }
LABEL_25:
        v1 = "%s: invalid option -- '%c'\n" + 27;
LABEL_26:
        free(v13);
        goto LABEL_20;
      }
      if ( v7[v8 - 1] == 47 )
      {
        v11 = v8 + 14;
        goto LABEL_18;
      }
      v14 = v8 + 15;
      v9 = v8 + 1;
    }
    else
    {
      v14 = 115LL;
      v9 = 101LL;
      v10 = 100LL;
      v7 = "/home/dongkwan/data/scripts/gnu_packages/coreutils/coreutils-8.29_gcc-8.2.0_x86_64_O2_debug/gogo/lib";
    }
    v15 = (char *)malloc(v14);
    v13 = v15;
    if ( !v15 )
      goto LABEL_19;
    memcpy(v15, v7, v10);
    v13[v10] = 47;
    goto LABEL_24;
  }
LABEL_4:
  v3 = *v1;
  if ( *v1 )
  {
    while ( strcmp(v2, v1) && (v3 != 42 || v1[1]) )
    {
      v4 = strlen(v1);
      v1 += v4 + strlen(&v1[v4 + 1]) + 2;
      v3 = *v1;
      if ( !*v1 )
        goto LABEL_11;
    }
    v2 = &v1[strlen(v1) + 1];
  }
LABEL_11:
  if ( !*v2 )
    v2 = "ASCII";
  return v2;
}

__int64 __fastcall sub_40BFE0(char a1)
{
  return sub_40A6A0(a1, 0, 3LL);
}

int __fastcall sub_40BFF0(FILE *stream)
{
  int *v1; // rax
  int v2; // er12
  int *v3; // rbp
  int result; // eax
  int v5; // eax

  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( __freading(stream) )
  {
    v5 = fileno(stream);
    if ( lseek(v5, 0LL, 1) == -1 )
      return fclose(stream);
  }
  if ( !(unsigned int)sub_40C070(stream) )
    return fclose(stream);
  v1 = __errno_location();
  v2 = *v1;
  v3 = v1;
  result = fclose(stream);
  if ( v2 )
  {
    *v3 = v2;
    result = -1;
  }
  return result;
}

int __fastcall sub_40C070(FILE *stream)
{
  if ( !stream || !__freading(stream) || !(stream->_flags & 0x100) )
    return fflush(stream);
  sub_40C0B0(stream, 0LL, 1LL);
  return fflush(stream);
}

int __fastcall sub_40C0B0(FILE *a1, __off_t a2, int a3)
{
  __off_t v3; // rax
  int v4; // er12
  int v5; // eax

  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )
  {
    LODWORD(v3) = fseeko(a1, a2, a3);
  }
  else
  {
    v4 = a3;
    v5 = fileno(a1);
    v3 = lseek(v5, a2, v4);
    if ( v3 != -1 )
    {
      a1->_flags &= 0xFFFFFFEF;
      a1->_offset = v3;
      LODWORD(v3) = 0;
    }
  }
  return v3;
}

void init(void)
{
  init_proc();
}

void fini(void)
{
  ;
}

int __fastcall sub_40C180(void (__fastcall *a1)(void *))
{
  void *v1; // rdx

  v1 = 0LL;
  if ( &unk_612288 )
    v1 = (void *)unk_612288;
  return __cxa_atexit(a1, 0LL, v1);
}

__int64 __fastcall sub_40C198(__int64 a1, __int64 a2, __int64 a3)
{
  void (**v3)(void); // rbx
  __int64 v5; // [rsp-8h] [rbp-10h]

  v3 = (void (**)(void))&qword_611E30;
  v5 = a3;
  while ( *v3 != (void (*)(void))-1LL )
  {
    (*v3)();
    --v3;
  }
  return v5;
}
